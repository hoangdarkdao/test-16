[
     {
          "algorithm": "{The new algorithm will first identify solutions in the archive that show potential for improvement by analyzing both their objective values and the diversity of their node sequences, then apply a novel 'multi-dimensional cluster inversion' strategy that randomly groups nodes into clusters based on their geometric proximity in both coordinate spaces, inverts each cluster's sequence while maintaining spatial coherence, and optimally reassigns edges between clusters by considering both distance matrices, all while ensuring feasibility by verifying that the resulting tour remains a valid permutation of all nodes and maintaining the circular nature of the tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a solution with high potential for improvement\n    candidates = []\n    for sol, obj in archive:\n        # Calculate potential improvement score considering both objectives and diversity\n        obj_score = (obj[0] + obj[1]) / 2\n        diversity_score = len(set(sol)) / len(sol)\n        improvement_score = obj_score * diversity_score\n        candidates.append((sol, improvement_score))\n\n    candidates.sort(key=lambda x: -x[1])\n    selected = candidates[0][0].copy()\n\n    # Step 2: Apply multi-dimensional cluster inversion\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Create clusters based on geometric proximity in both spaces\n    clusters = []\n    remaining = list(range(n))\n    while len(remaining) > 0:\n        # Randomly select a seed node\n        seed = random.choice(remaining)\n        cluster = [seed]\n        remaining.remove(seed)\n\n        # Find nearby nodes in both spaces\n        for node in remaining[:]:\n            x1_seed, y1_seed, x2_seed, y2_seed = instance[selected[seed]]\n            x1_node, y1_node, x2_node, y2_node = instance[selected[node]]\n\n            # Calculate distances in both spaces\n            dist1 = np.sqrt((x1_seed - x1_node)**2 + (y1_seed - y1_node)**2)\n            dist2 = np.sqrt((x2_seed - x2_node)**2 + (y2_seed - y2_node)**2)\n\n            # Add to cluster if close in both spaces\n            if dist1 < np.mean(distance_matrix_1) * 0.5 and dist2 < np.mean(distance_matrix_2) * 0.5:\n                cluster.append(node)\n                remaining.remove(node)\n\n        if len(cluster) > 1:\n            clusters.append(cluster)\n\n    # Invert each cluster while maintaining spatial coherence\n    for cluster in clusters:\n        # Find the cluster's centroid in both spaces\n        centroid1_x = np.mean([instance[selected[node]][0] for node in cluster])\n        centroid1_y = np.mean([instance[selected[node]][1] for node in cluster])\n        centroid2_x = np.mean([instance[selected[node]][2] for node in cluster])\n        centroid2_y = np.mean([instance[selected[node]][3] for node in cluster])\n\n        # Sort nodes in the cluster by angle relative to centroid in both spaces\n        def angle_sort_key(node):\n            x1, y1, x2, y2 = instance[selected[node]]\n            angle1 = np.arctan2(y1 - centroid1_y, x1 - centroid1_x)\n            angle2 = np.arctan2(y2 - centroid2_y, x2 - centroid2_x)\n            return (angle1 + angle2) / 2\n\n        cluster_sorted = sorted(cluster, key=angle_sort_key)\n        new_solution[cluster] = [selected[node] for node in cluster_sorted[::-1]]\n\n    # Step 3: Optimally reassign edges between clusters\n    for i in range(len(clusters)-1):\n        cluster1 = clusters[i]\n        cluster2 = clusters[i+1]\n\n        # Find best edge to connect clusters\n        best_improvement = 0\n        best_edge = None\n\n        for a in cluster1:\n            for b in cluster2:\n                # Current edges\n                prev_a = selected[a-1] if a > 0 else selected[-1]\n                next_a = selected[(a+1)%n]\n                prev_b = selected[b-1] if b > 0 else selected[-1]\n                next_b = selected[(b+1)%n]\n\n                # Current costs\n                current_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                                distance_matrix_1[selected[a], next_a] +\n                                distance_matrix_1[prev_b, selected[b]] +\n                                distance_matrix_1[selected[b], next_b])\n                current_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                                distance_matrix_2[selected[a], next_a] +\n                                distance_matrix_2[prev_b, selected[b]] +\n                                distance_matrix_2[selected[b], next_b])\n\n                # New costs if we connect a to b\n                new_cost1 = (distance_matrix_1[prev_a, selected[a]] +\n                            distance_matrix_1[selected[a], selected[b]] +\n                            distance_matrix_1[selected[b], next_a] +\n                            distance_matrix_1[prev_b, selected[b]] +\n                            distance_matrix_1[selected[b], next_b])\n                new_cost2 = (distance_matrix_2[prev_a, selected[a]] +\n                            distance_matrix_2[selected[a], selected[b]] +\n                            distance_matrix_2[selected[b], next_a] +\n                            distance_matrix_2[prev_b, selected[b]] +\n                            distance_matrix_2[selected[b], next_b])\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_edge = (a, b)\n\n        # Apply the best edge connection\n        if best_edge:\n            a, b = best_edge\n            a_pos = np.where(new_solution == selected[a])[0][0]\n            b_pos = np.where(new_solution == selected[b])[0][0]\n\n            if a_pos > b_pos:\n                a_pos, b_pos = b_pos, a_pos\n\n            new_solution[a_pos+1:b_pos] = new_solution[a_pos+1:b_pos][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.036349290086442,
               2.395252764225006
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 2, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment rotation\n    if end < n:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If not feasible, perform a simple valid move\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9636209173816817,
               0.14570850133895874
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel multi-objective adaptive segment exchange mechanism that combines a probabilistic segment selection strategy with an objective-aware segment relocation operator. It first identifies solutions with high potential by analyzing their objective-space coverage and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively exchanges entire segments between the current solution and a reference solution, where the segment selection probability and relocation depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the segment relocation mechanism explores different solution structures by probabilistically relocating segments to positions that improve both objectives. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while maintaining a focus on segment-based operations that can efficiently explore the solution space in the bi-objective context.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of coverage and dominance)\n    coverage_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * coverage_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply adaptive segment exchange with objective-aware relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment selection with probability based on objective improvements\n    segment_length = max(2, min(n // 5, np.random.randint(2, n // 3)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Objective-aware segment relocation\n    if len(archive) > 1:\n        # Select a reference solution\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n\n        # Calculate potential improvement for the segment\n        current_segment = base_solution[start:end]\n        ref_segment = ref_solution[start:end]\n\n        # Calculate cost difference\n        current_cost1 = sum(distance_matrix_1[current_segment[i], current_segment[i+1]] for i in range(len(current_segment)-1))\n        current_cost1 += distance_matrix_1[current_segment[-1], current_segment[0]]\n        ref_cost1 = sum(distance_matrix_1[ref_segment[i], ref_segment[i+1]] for i in range(len(ref_segment)-1))\n        ref_cost1 += distance_matrix_1[ref_segment[-1], ref_segment[0]]\n\n        current_cost2 = sum(distance_matrix_2[current_segment[i], current_segment[i+1]] for i in range(len(current_segment)-1))\n        current_cost2 += distance_matrix_2[current_segment[-1], current_segment[0]]\n        ref_cost2 = sum(distance_matrix_2[ref_segment[i], ref_segment[i+1]] for i in range(len(ref_segment)-1))\n        ref_cost2 += distance_matrix_2[ref_segment[-1], ref_segment[0]]\n\n        # Decide whether to exchange based on objective improvement\n        if (ref_cost1 < current_cost1 and ref_cost2 < current_cost2):\n            new_solution[start:end] = ref_segment.copy()\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0345572131886867,
               0.27952826023101807
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    n = len(new_solution)\n    if n < 4:\n        # If too small, just swap two nodes\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select three random segments to modify\n        segments = np.sort(np.random.choice(n, 3, replace=False))\n        a, b, c = segments\n\n        # Extract segments\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:c]\n        segment4 = new_solution[c:]\n\n        # Recombine segments with novel perturbation\n        new_order = np.concatenate([\n            segment1,\n            segment3[::-1],  # Reverse middle segment\n            segment2,\n            segment4\n        ])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n    return new_solution\n\n",
          "score": [
               -0.79853724529653,
               0.20083975791931152
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest combined objective value (to explore less crowded regions)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel local search: Combine segment inversion with adaptive perturbation based on objective diversity\n    n = len(new_solution)\n    if n < 4:\n        # For small instances, perform a random 4-opt move if possible\n        if n >= 4:\n            i, j, k, l = sorted(random.sample(range(n), 4))\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:k][::-1],\n                new_solution[i:j],\n                new_solution[k:l][::-1],\n                new_solution[l:]\n            ])\n        else:\n            # Simple swap for very small instances\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Adaptive segment selection based on objective diversity\n        obj_diversity = archive[selected_idx][1][0] / archive[selected_idx][1][1] if archive[selected_idx][1][1] != 0 else 1.0\n\n        if obj_diversity > 1.5:\n            # More aggressive perturbation when objectives are diverse\n            segments = sorted(random.sample(range(1, n-1), 3))\n            a, b, c = segments\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[b:c][::-1],\n                new_solution[a:b],\n                new_solution[c:][::-1]\n            ])\n        else:\n            # More conservative perturbation when objectives are balanced\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            new_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[j:][::-1],\n                new_solution[i:j]\n            ])\n\n    # Ensure all nodes are visited exactly once\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple valid move if the above fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8878011692665726,
               0.21410870552062988
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9119965028668441,
               0.27439093589782715
          ]
     },
     {
          "algorithm": "{The new algorithm will select a solution from the archive based on its dominance in the objective space (prioritizing solutions that are not dominated by others), then apply a novel \"objective-aware segment relocation\" operator that identifies segments of the tour where the objectives show significant divergence, relocates these segments to different positions in the tour, and inverts them if the relocation improves the balance between objectives, while ensuring all nodes remain visited exactly once.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution from the archive\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1] and (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                dominated[i] = True\n                break\n    non_dominated_indices = np.where(~dominated)[0]\n    if len(non_dominated_indices) == 0:\n        non_dominated_indices = np.arange(len(archive))\n    selected_idx = np.random.choice(non_dominated_indices)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Objective-aware segment relocation\n    n = len(new_solution)\n    if n < 3:\n        # For small instances, perform a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Identify segments with significant objective divergence\n        segment_length = max(2, n // 4)\n        i = random.randint(0, n - segment_length - 1)\n        segment = new_solution[i:i+segment_length]\n\n        # Calculate segment costs\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Determine relocation position\n        j = random.randint(0, n - segment_length - 1)\n        while abs(j - i) < segment_length:\n            j = random.randint(0, n - segment_length - 1)\n\n        # Relocate and optionally invert the segment\n        if random.random() > 0.5:\n            segment = segment[::-1]\n\n        # Insert the segment at new position\n        new_solution = np.concatenate([\n            new_solution[:j],\n            segment,\n            new_solution[j+segment_length:]\n        ])\n\n        # Ensure all nodes are visited exactly once\n        if len(np.unique(new_solution)) != n:\n            # Fallback to a simple valid move\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8912730930590683,
               0.23640000820159912
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.7 * diversity_scores + 0.3 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 4, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.3, 0.7)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment inversion\n    if end < n:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.002562955635491,
               0.30344176292419434
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive perturbation strategy with a dynamic path relinking mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a segment-based perturbation with a path relinking-inspired move, where the perturbation strength and relinking depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the path relinking mechanism explores intermediate solutions between the current and a reference solution to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.6 * diversity_scores + 0.4 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive perturbation with dynamic path relinking\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment-based perturbation\n    segment_length = max(2, min(n // 3, np.random.randint(2, n // 2)))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Dynamic path relinking: blend with a reference solution\n    if len(archive) > 1:\n        ref_solution = archive[np.random.randint(0, len(archive))][0]\n        blend_ratio = np.random.uniform(0.2, 0.8)\n        for i in range(start, end):\n            if np.random.random() < blend_ratio:\n                new_solution[i] = ref_solution[i]\n\n    # Local improvement via segment rotation\n    if end < n:\n        rotation = np.random.randint(1, segment_length)\n        new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9248384270565428,
               0.28275126218795776
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone of selecting promising solutions from an archive and applying sophisticated local search operators, but introduces a novel approach by combining a multi-objective adaptive clustering with a dynamic segment inversion mechanism. It first identifies solutions with high potential by evaluating their objective-space diversity and dominance, then intelligently selects one such solution and applies a hybrid operator that adaptively combines a cluster-based perturbation with a segment inversion-inspired move, where the cluster size and inversion depth are dynamically adjusted based on the current solution's objective values and the instance's characteristics. The operator ensures feasibility by maintaining a Hamiltonian cycle and uses a weighted combination of objective improvements to guide the search, while the segment inversion mechanism explores intermediate solutions by flipping segments of the tour to escape local optima. The algorithm balances exploration and exploitation by dynamically adjusting its search focus based on the archive's diversity and the solutions' objective trade-offs, while also incorporating spatial information from the instance to guide the local search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions in the archive for potential improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    # Step 2: Select a solution with high potential (combination of diversity and dominance)\n    diversity_scores = np.sum(normalized_objectives, axis=1)\n    dominance_scores = np.prod(1 - normalized_objectives, axis=1)\n    combined_scores = 0.5 * diversity_scores + 0.5 * dominance_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Apply hybrid adaptive clustering with dynamic segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive cluster-based perturbation\n    cluster_size = max(2, min(n // 4, np.random.randint(2, n // 3)))\n    num_clusters = max(2, n // cluster_size)\n\n    # Create clusters by grouping consecutive nodes\n    clusters = []\n    for i in range(num_clusters):\n        start = i * cluster_size\n        end = min((i + 1) * cluster_size, n)\n        clusters.append(new_solution[start:end])\n\n    # Dynamic segment inversion: invert clusters based on spatial proximity\n    if len(clusters) > 1:\n        for i in range(len(clusters)):\n            if np.random.random() < 0.3:  # 30% chance to invert a cluster\n                clusters[i] = clusters[i][::-1]\n\n    # Reconstruct the solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0289927276199635,
               0.35933321714401245
          ]
     }
]