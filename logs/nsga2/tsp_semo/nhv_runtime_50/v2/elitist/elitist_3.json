[
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    # Calculate crowding distance\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Distance-aware segment reversal\n    if n > 5:\n        # Calculate segment costs\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        # Find segments to reverse\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.994337138149379,
            0.4075266718864441
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a novel \"cross-segment insertion\" operator that inserts a randomly selected segment from one part of the tour into another position, followed by a \"multi-segment reversal\" that reverses multiple non-overlapping segments to create a more diverse neighborhood.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 3:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert the segment at the new position\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Multi-segment reversal\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        # Reverse both segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8749075943578248,
            0.14364105463027954
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a novel \"cross-segment insertion\" operator that inserts a randomly selected segment from one part of the tour into another position, followed by a \"multi-segment reversal\" that reverses multiple non-overlapping segments to create a more diverse neighborhood.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 3:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert the segment at the new position\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Multi-segment reversal\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        # Reverse both segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8749075943578248,
            0.14364105463027954
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted sum of objectives, then applies a \"multi-point crossover\" operator that combines segments from two different solutions, followed by a \"guided segment reversal\" that reverses segments based on their contribution to improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])\n    base_solution = archive[0][0].copy()\n    if len(archive) > 1:\n        second_solution = archive[1][0].copy()\n    else:\n        second_solution = base_solution.copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-point crossover\n    if n > 3:\n        crossover_points = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        new_solution[crossover_points[0]:crossover_points[1]] = second_solution[crossover_points[0]:crossover_points[1]]\n\n    # Guided segment reversal\n    if n > 4:\n        # Calculate segment costs\n        segments = []\n        for i in range(1, n-1):\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n            segments.append((i, cost1 + cost2))\n\n        # Sort segments by cost\n        segments.sort(key=lambda x: x[1], reverse=True)\n\n        # Reverse top segments\n        for i in range(min(2, len(segments))):\n            pos = segments[i][0]\n            new_solution[pos], new_solution[pos+1] = new_solution[pos+1], new_solution[pos]\n\n    return new_solution\n\n",
        "score": [
            -0.9248201089352052,
            0.24753248691558838
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    # Calculate crowding distance\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Distance-aware segment reversal\n    if n > 5:\n        # Calculate segment costs\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        # Find segments to reverse\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.994337138149379,
            0.4075266718864441
        ]
    },
    {
        "algorithm": "{This algorithm selects the solution with the best Pareto dominance (non-dominated by others) from the archive, then applies a novel \"adaptive segment crossover\" operator that combines segments from the best solution with segments from a randomly selected archive solution, followed by a \"dynamic segment inversion\" that inverts segments based on their cost contribution to create a more balanced neighborhood.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if not non_dominated:\n        non_dominated = list(range(len(archive)))\n    best_idx = np.random.choice(non_dominated)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment crossover\n    if n > 3 and len(archive) > 1:\n        other_idx = np.random.choice([i for i in range(len(archive)) if i != best_idx])\n        other_solution = archive[other_idx][0].copy()\n\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        insert_pos = np.random.randint(1, n)\n\n        segment = new_solution[seg_start:seg_end]\n        other_segment = other_solution[seg_start:seg_end]\n\n        # Combine segments with probability based on their cost difference\n        cost_diff = (archive[best_idx][1][0] - archive[other_idx][1][0]) + (archive[best_idx][1][1] - archive[other_idx][1][1])\n        if cost_diff > 0 and np.random.rand() < 0.7:\n            segment = other_segment\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Dynamic segment inversion\n    if n > 4:\n        # Calculate segment costs\n        segment_costs = []\n        for i in range(1, n):\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n            segment_costs.append(cost1 + cost2)\n\n        # Identify segments with high cost\n        threshold = np.percentile(segment_costs, 75)\n        high_cost_segments = [i for i, c in enumerate(segment_costs) if c > threshold]\n\n        if high_cost_segments:\n            for i in range(len(high_cost_segments)-1):\n                seg1_start = high_cost_segments[i]\n                seg1_end = high_cost_segments[i+1]\n                if seg1_end - seg1_start > 1:\n                    new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.984610188034801,
            0.40414148569107056
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive with high variance in objective values, then applies a hybrid \"distance-aware segment exchange\" operator that exchanges segments between the base solution and a randomly generated solution, followed by a \"multi-objective segment insertion\" that inserts segments from either objective space into the tour, ensuring feasibility and potentially improving the solution in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Generate random solution for segment exchange\n    random_solution = np.random.permutation(new_solution)\n\n    # Distance-aware segment exchange\n    if n > 4:\n        seg_start = np.random.randint(1, n-3)\n        seg_end = np.random.randint(seg_start+1, n-2)\n\n        # Compare segments from both solutions\n        base_segment = new_solution[seg_start:seg_end]\n        random_segment = random_solution[seg_start:seg_end]\n\n        # Choose better segment based on distance matrices\n        base_cost = distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] + distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]]\n        random_cost = distance_matrix_1[random_solution[seg_start-1], random_solution[seg_start]] + distance_matrix_1[random_solution[seg_end-1], random_solution[seg_end]]\n\n        if random_cost < base_cost:\n            new_solution[seg_start:seg_end] = random_segment\n\n    # Multi-objective segment insertion\n    if n > 5:\n        # Select segment based on which objective it improves\n        obj1_segment = np.random.choice(range(1, n-2), size=2, replace=False)\n        obj2_segment = np.random.choice(range(1, n-2), size=2, replace=False)\n\n        # Insert segments from both objectives\n        insert_pos1 = np.random.randint(1, n-1)\n        insert_pos2 = np.random.randint(1, n-1)\n\n        # Insert segments while maintaining feasibility\n        new_solution = np.insert(new_solution, insert_pos1, new_solution[obj1_segment[0]])\n        new_solution = np.insert(new_solution, insert_pos2, new_solution[obj2_segment[1]])\n\n        # Remove duplicates if any\n        unique_nodes = np.unique(new_solution)\n        if len(unique_nodes) != n:\n            missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n            for node in missing_nodes:\n                new_solution = np.append(new_solution, node)\n\n    return new_solution[1:n+1]  # Ensure correct length\n\n",
        "score": [
            -0.9227536644693372,
            0.15186536312103271
        ]
    },
    {
        "algorithm": "{This algorithm selects the best solution from the archive based on the sum of objectives, then applies a novel \"cross-segment insertion\" operator that inserts a randomly selected segment from one part of the tour into another position, followed by a \"multi-segment reversal\" that reverses multiple non-overlapping segments to create a more diverse neighborhood.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cross-segment insertion\n    if n > 3:\n        seg_start = np.random.randint(1, n-2)\n        seg_end = np.random.randint(seg_start+1, n)\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        # Insert the segment at a new position\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n\n        # Reinsert the segment at the new position\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # Fallback to simple swap if insertion causes duplicates\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Multi-segment reversal\n    if n > 4:\n        # Select two non-overlapping segments\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        # Reverse both segments\n        new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n        new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8749075943578248,
            0.14364105463027954
        ]
    }
]