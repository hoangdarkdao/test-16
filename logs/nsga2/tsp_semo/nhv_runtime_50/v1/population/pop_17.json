[
    {
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective segment replacement with adaptive segment inversion, where a high-performing solution from the archive is modified by strategically replacing and inverting segments from a random solution, while evaluating the impact on both objectives and ensuring feasibility through a dynamic repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a high-performing solution from the archive\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    n = len(new_solution)\n    random_sol = np.random.permutation(new_solution)\n\n    # Multi-objective segment replacement with inversion\n    for _ in range(2):\n        # Select a random segment from random solution\n        a, b = sorted(random.sample(range(n), 2))\n        segment = random_sol[a:b]\n\n        # Optionally invert the segment\n        if random.random() < 0.5:\n            segment = segment[::-1]\n\n        # Find best insertion point in new_solution\n        best_pos = 0\n        best_cost = float('inf')\n\n        for i in range(n - len(segment)):\n            # Insert segment at position i\n            candidate = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            # Ensure no duplicates\n            if len(np.unique(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n+1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = i\n\n        # Insert the best segment\n        if best_pos != 0:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic repair mechanism\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If duplicates exist, repair by replacing with missing nodes\n        missing_nodes = [i for i in range(n) if i not in unique_nodes]\n        for i in range(n):\n            if new_solution[i] in unique_nodes:\n                continue\n            new_solution[i] = missing_nodes.pop(0)\n\n    return new_solution\n\n",
        "score": [
            -1.0315927370617872,
            4.081437826156616
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment swapping with dynamic edge selection to explore high-quality solutions in both objective spaces by intelligently selecting and rearranging segments of the tour while preserving feasibility and maintaining diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    archive_solutions = [sol for sol, _ in archive]\n    selected_sol = random.choice(archive_solutions)\n    new_solution = selected_sol.copy()\n\n    # Determine segment size based on problem size\n    n = len(new_solution)\n    segment_size = max(2, min(5, n // 4))\n\n    # Adaptive segment selection and swapping\n    for _ in range(2):  # Perform multiple swaps\n        # Select two non-overlapping segments\n        seg1_start = random.randint(0, n - segment_size)\n        seg1_end = seg1_start + segment_size\n\n        seg2_start = random.randint(0, n - segment_size)\n        seg2_end = seg2_start + segment_size\n\n        # Ensure segments don't overlap\n        while (seg1_start < seg2_end and seg1_end > seg2_start):\n            seg2_start = random.randint(0, n - segment_size)\n            seg2_end = seg2_start + segment_size\n\n        # Swap the segments\n        seg1 = new_solution[seg1_start:seg1_end]\n        seg2 = new_solution[seg2_start:seg2_end]\n\n        new_solution[seg1_start:seg1_end] = seg2\n        new_solution[seg2_start:seg2_end] = seg1\n\n    # Dynamic edge selection for further refinement\n    for _ in range(3):  # Perform multiple edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n        # Ensure the swap maintains feasibility\n        if (j - i) > 1:\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7639962521331065,
            0.04677629470825195
        ]
    }
]