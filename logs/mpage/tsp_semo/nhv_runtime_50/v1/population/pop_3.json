[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Step 2: Select a solution probabilistically based on non-domination rank and crowding distance\n    selected = random.choices(non_dominated, k=1)[0][0].copy()\n\n    # Step 3: Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Variable-length segment relocation\n    if n > 3:\n        seg_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Biased 3-opt move\n    if n > 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n\n        # Try all possible 3-opt configurations\n        options = [\n            (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n        ]\n\n        best_option = None\n        best_improvement = 0\n\n        for opt in options:\n            temp_sol = np.concatenate([new_solution[:i], opt[0], opt[1], opt[2]])\n            new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_option = opt\n\n        if best_option is not None:\n            new_solution = np.concatenate([new_solution[:i], best_option[0], best_option[1], best_option[2]])\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism: reorder nodes to form a valid tour\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9209101573486693,
               0.6316920518875122
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with the lowest combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + multi-objective edge exchange\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Segment inversion\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Multi-objective edge exchange\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.7895915616322705,
               0.45019596815109253
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by intelligently selecting a promising solution from the archive using a combined fitness criterion that balances the normalized objectives and the solution's current Pareto dominance status. It then applies a novel hybrid local search strategy: a two-phase approach where first a variable-length segment inversion is performed, followed by a guided edge exchange that prioritizes edges with high improvement potential in both objectives. The segment inversion length is dynamically determined based on the solution's current objective values, while the edge exchange phase uses a Pareto-dominance-aware selection mechanism to choose the most beneficial edge swaps. The function ensures feasibility by strictly maintaining a valid TSP tour throughout all operations, and includes a diversification mechanism that occasionally performs a random segment inversion when no improving moves are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (could be improved with more sophisticated selection)\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1, len(archive)) / np.sum(np.linspace(0.1, 1, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Variable-length segment inversion\n    segment_length = max(2, min(n // 4, int(np.random.normal(loc=n//3, scale=n//6))))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Phase 2: Guided edge exchange\n    for _ in range(10):  # Limit the number of attempts\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or abs(i - j) == 1 or (i == 0 and j == n-1) or (j == 0 and i == n-1):\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        # Calculate cost change for both objectives\n        cost_change_1 = sum(distance_matrix_1[e1] - distance_matrix_1[e2] for e1, e2 in zip(new_edges, current_edges))\n        cost_change_2 = sum(distance_matrix_2[e1] - distance_matrix_2[e2] for e1, e2 in zip(new_edges, current_edges))\n\n        # Accept if non-worsening in both objectives\n        if cost_change_1 <= 0 and cost_change_2 <= 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the solution is valid (this is redundant but safe)\n    if not np.array_equal(np.sort(new_solution), np.arange(n)):\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8690813752066894,
               0.609645664691925
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.7458745936860245,
               0.4126279354095459
          ]
     },
     {
          "algorithm": "{This new algorithm first identifies the most diverse solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most diverse solution based on both objectives\n    best_idx = 0\n    best_diversity = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        diversity = obj[0] * obj[1]  # Product of objectives to find diverse solutions\n        if diversity > best_diversity:\n            best_diversity = diversity\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover with objective-aware segment selection\n    if n > 3:\n        # Calculate objective weights\n        total_cost = archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10\n        weight1 = archive[best_idx][1][0] / total_cost\n        weight2 = archive[best_idx][1][1] / total_cost\n\n        # Determine segment lengths based on objective weights\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments with different strategies\n        if random.random() < 0.7:  # 70% chance for balanced approach\n            start1 = random.randint(0, n - seg_length1)\n            start2 = random.randint(0, n - seg_length2)\n            # Swap segments\n            new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n                new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n        else:  # 30% chance for aggressive approach\n            # Select segments based on high-cost edges\n            def get_high_cost_segment(sol, matrix):\n                max_cost = -1\n                best_start = 0\n                for i in range(n - seg_length1):\n                    segment_cost = sum(matrix[sol[i+j-1], sol[i+j]] for j in range(seg_length1))\n                    if segment_cost > max_cost:\n                        max_cost = segment_cost\n                        best_start = i\n                return best_start\n\n            start1 = get_high_cost_segment(new_solution, distance_matrix_1)\n            start2 = get_high_cost_segment(new_solution, distance_matrix_2)\n            # Swap segments\n            new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n                new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap with objective-aware acceptance\n    if n > 3:\n        # Select edges based on both objectives\n        def select_critical_edge(sol, matrix):\n            max_diff = -1\n            best_i, best_j = 0, 0\n            for i in range(n):\n                for j in range(i+1, n):\n                    diff = matrix[sol[i-1], sol[i]] + matrix[sol[j-1], sol[j]] - \\\n                          (matrix[sol[i-1], sol[j]] + matrix[sol[j-1], sol[i]])\n                    if diff > max_diff:\n                        max_diff = diff\n                        best_i, best_j = i, j\n            return best_i, best_j\n\n        i1, j1 = select_critical_edge(new_solution, distance_matrix_1)\n        i2, j2 = select_critical_edge(new_solution, distance_matrix_2)\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        # Calculate cost improvements\n        cost1_before = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        cost2_before = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n        cost1_after = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        cost2_after = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly with controlled degradation\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (cost1_after < cost1_before * 0.95 and cost2_after < cost1_before * 1.05) or \\\n           (cost2_after < cost2_before * 0.95 and cost1_after < cost2_before * 1.05):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair with objective-aware insertion\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.9307861622212523,
               4.820932924747467
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.6561629267549149,
               0.41754186153411865
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution (best balance between objectives)\n    def balance_score(obj):\n        obj1, obj2 = obj\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        norm_obj1 = obj1 / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj2 / max_obj2 if max_obj2 > 0 else 0\n        return abs(norm_obj1 - norm_obj2)  # Prefer solutions with balanced objectives\n\n    archive_sorted = sorted(archive, key=lambda x: balance_score(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n\n    # Select guiding template (most complementary solution)\n    def complement_score(obj):\n        obj1, obj2 = obj\n        max_obj1 = max(o[0] for _, o in archive)\n        max_obj2 = max(o[1] for _, o in archive)\n        norm_obj1 = obj1 / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj2 / max_obj2 if max_obj2 > 0 else 0\n        return -abs(norm_obj1 - norm_obj2)  # Prefer solutions with complementary objectives\n\n    archive_sorted = sorted(archive, key=lambda x: complement_score(x[1]))\n    template_solution = archive_sorted[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path relinking with objective-aware segment selection\n    for _ in range(5):  # Number of relinking iterations\n        # Find segments where template offers improvement\n        improvement_segments = []\n        for i in range(n):\n            for j in range(i+1, min(i+5, n)):  # Consider segments of length 2-4\n                # Calculate cost difference between base and template\n                base_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n                base_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i, j))\n                template_cost1 = sum(distance_matrix_1[template_solution[k], template_solution[(k+1)%n]] for k in range(i, j))\n                template_cost2 = sum(distance_matrix_2[template_solution[k], template_solution[(k+1)%n]] for k in range(i, j))\n\n                # Calculate improvement potential\n                imp1 = base_cost1 - template_cost1\n                imp2 = base_cost2 - template_cost2\n\n                # Segment is promising if it improves at least one objective significantly\n                if imp1 > 0.1 * base_cost1 or imp2 > 0.1 * base_cost2:\n                    improvement_segments.append((i, j, imp1, imp2))\n\n        if not improvement_segments:\n            continue\n\n        # Select segment with highest combined improvement\n        best_segment = max(improvement_segments, key=lambda x: x[2] + x[3])\n        i, j, _, _ = best_segment\n\n        # Replace segment with template's version\n        segment_length = j - i\n        new_solution[i:j] = template_solution[i:j]\n\n        # Cross-objective edge refinement\n        for k in range(i, j):\n            # Check edges before and after the segment\n            prev = (i - 1) % n\n            next = j % n\n\n            # Calculate current costs\n            cost1_prev = distance_matrix_1[new_solution[prev], new_solution[i]]\n            cost2_prev = distance_matrix_2[new_solution[prev], new_solution[i]]\n            cost1_next = distance_matrix_1[new_solution[j-1], new_solution[next]]\n            cost2_next = distance_matrix_2[new_solution[j-1], new_solution[next]]\n\n            # Try to swap with template's edges if they improve both objectives\n            if i > 0 and j < n:\n                template_prev = distance_matrix_1[template_solution[prev], template_solution[i]]\n                template_prev2 = distance_matrix_2[template_solution[prev], template_solution[i]]\n                template_next = distance_matrix_1[template_solution[j-1], template_solution[next]]\n                template_next2 = distance_matrix_2[template_solution[j-1], template_solution[next]]\n\n                if (template_prev + template_next < cost1_prev + cost1_next and\n                    template_prev2 + template_next2 < cost2_prev + cost2_next):\n                    # Perform the swap\n                    new_solution[i], new_solution[j-1] = new_solution[j-1], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8780509981704763,
               10.667819559574127
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate the variance of objectives in the archive to identify solutions with high potential\n    objectives = np.array([obj for (sol, obj) in archive])\n    variance = np.var(objectives, axis=0)\n    normalized_variance = variance / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n\n    # Select the solution with the highest normalized variance in objectives\n    selected_idx = np.argmax(np.sum(normalized_variance * (objectives - np.mean(objectives, axis=0)), axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Apply a hybrid local search: combine 3-opt with a biased edge insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three segments to perform 3-opt\n    i, j, k = sorted(np.random.choice(range(1, n-1), 3, replace=False))\n\n    # Perform 3-opt: reverse segments between i-j and j-k\n    new_solution[i:j] = new_solution[i:j][::-1]\n    new_solution[j:k] = new_solution[j:k][::-1]\n\n    # Insert a randomly selected node at a position that improves both objectives\n    if n > 3:\n        # Remove a random node and reinsert it at a position that minimizes the sum of distances in both spaces\n        node_to_insert = np.random.choice(new_solution)\n        mask = new_solution != node_to_insert\n        filtered_solution = new_solution[mask]\n\n        best_pos = 0\n        min_total_cost = float('inf')\n\n        for pos in range(len(filtered_solution)):\n            # Create a temporary solution with the node inserted at pos\n            temp_solution = np.insert(filtered_solution, pos, node_to_insert)\n\n            # Calculate the total cost in both spaces\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_total_cost:\n                min_total_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(filtered_solution, best_pos, node_to_insert)\n\n    return new_solution\n\n",
          "score": [
               -0.8767660732396109,
               3.445814549922943
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with good balance between objectives and diversity\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with multi-objective edge swapping\n    for _ in range(10):\n        # Determine segment length based on current solution's characteristics\n        segment_length = max(2, min(n // 2, random.randint(2, n // 2)))\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length - 1\n\n        # Reverse the segment\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Perform multi-objective edge swapping\n        for _ in range(3):\n            i, j = sorted(random.sample(range(n), 2))\n            # Calculate cost improvement for both objectives\n            cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            cost1_after = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            cost2_after = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            # Accept if both objectives improve or one improves significantly\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n               (cost1_after < 0.9 * cost1_before and cost2_after < 1.1 * cost2_before) or \\\n               (cost2_after < 0.9 * cost2_before and cost1_after < 1.1 * cost1_before):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.7822603911151339,
               0.4592154622077942
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first evaluates the archive of solutions to identify promising candidates by analyzing their objective values and potential for local improvement, using a combination of Pareto dominance and crowding distance metrics to prioritize solutions with high diversity and non-dominated status. It then intelligently selects one such solution, employs a novel hybrid local search strategy that combines a randomized edge insertion step with a guided segment relocation operator to explore the solution space, ensuring feasibility by always validating the generated tour structure. The edge insertion step randomly selects a subset of nodes and reinserts them into the tour at optimal positions based on both objective distances, while the segment relocation operator identifies and relocates contiguous segments of nodes to improve both objectives, with the relocation positions determined by a weighted combination of the two distance matrices. The function ensures the generated neighbor solution remains feasible by verifying that all nodes are visited exactly once and the tour forms a valid cycle, returning the improved solution for further exploration.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (non-dominated and diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: randomized edge insertion + guided segment relocation\n    n = len(base_solution)\n\n    # Random edge insertion (exploration)\n    if np.random.rand() < 0.7:  # 70% chance for edge insertion\n        # Randomly select a segment to remove\n        segment_size = np.random.randint(2, min(5, n-1))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n\n        # Find best insertion position for the segment\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting segment at position i\n            temp = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n            cost1 = sum(distance_matrix_1[temp[j-1], temp[j]] for j in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[j-1], temp[j]] for j in range(len(temp)))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Guided segment relocation (exploitation)\n    else:\n        # Select a segment to relocate\n        segment_size = np.random.randint(2, min(4, n-1))\n        start = np.random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n\n        # Find best relocation position based on both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for i in range(len(new_solution)):\n            # Try inserting segment at position i\n            temp = np.concatenate([new_solution[:i], segment, new_solution[i:]])\n\n            # Calculate cost for both objectives\n            cost1 = sum(distance_matrix_1[temp[j-1], temp[j]] for j in range(len(temp)))\n            cost2 = sum(distance_matrix_2[temp[j-1], temp[j]] for j in range(len(temp)))\n\n            # Weighted combination of both costs\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = i\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution  # Fallback to original if something went wrong\n\n    return new_solution\n\n",
          "score": [
               -0.8337590239034691,
               3.1341360211372375
          ]
     }
]