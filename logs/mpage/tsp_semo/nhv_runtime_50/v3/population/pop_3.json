[
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-objective adaptive local search strategy that intelligently selects a promising solution from the archive based on a combined objective score (normalized sum of both objectives), then applies a novel hybrid local search operator that combines edge insertion with a biased random walk to explore high-potential regions of the search space. The method first identifies the Pareto-frontier solutions in the archive, then selects a base solution probabilistically weighted by its dominance and diversity, followed by a two-stage perturbation: 1) a constrained segment inversion that preserves node connectivity, and 2) a multi-objective-aware edge swap that prioritizes improvements in both objectives while ensuring feasibility through a validation check. The generated neighbor solution is guaranteed to be a valid TSP tour through the use of a permutation repair mechanism that corrects any invalid sequences.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Stage 1: Constrained segment inversion\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n    # Stage 2: Multi-objective-aware edge swap\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        prev_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        prev_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if both objectives improve\n        if (new_cost1 < prev_cost1) and (new_cost2 < prev_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.9434502893378602,
               0.6291956901550293
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Sort solutions by the sum of their objectives (prioritize those with lower total cost)\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Apply a hybrid local search operator: a combination of segment reversal and node insertion\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse (to avoid getting stuck in local optima)\n    start = np.random.randint(0, n - 1)\n    end = np.random.randint(start + 1, n)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select a node to reinsert (to explore new neighborhoods)\n    node_to_move = np.random.choice(new_solution)\n    mask = new_solution != node_to_move\n    new_solution = np.concatenate([new_solution[mask], [node_to_move]])\n\n    return new_solution\n\n",
          "score": [
               -0.7095738278032713,
               0.4901522397994995
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = [obj for _, obj in archive]\n    if len(archive) > 1:\n        # Select a solution that is not dominated by others\n        selected_idx = 0\n        for i in range(1, len(archive)):\n            if (objectives[i][0] < objectives[selected_idx][0] and objectives[i][1] <= objectives[selected_idx][1]) or \\\n               (objectives[i][0] <= objectives[selected_idx][0] and objectives[i][1] < objectives[selected_idx][1]):\n                selected_idx = i\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose a segment to reverse (novel segment reversal)\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Apply 2-opt to improve the solution\n    i, j = np.random.randint(0, n, size=2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if not (np.array_equal(np.unique(new_solution), np.arange(n)) and len(new_solution) == n):\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               -0.8398412362557686,
               0.5397500395774841
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is the selection of promising solutions from an archive based on multi-objective criteria (Pareto dominance or combined objective scores) followed by the application of a local search operator that balances exploration and exploitation while maintaining solution feasibility. The new algorithm will employ a multi-stage local search strategy that combines a biased random walk with a constrained segment rotation, where the selection of segments is guided by the instance's coordinate data to identify high-potential regions for improvement. The method will first normalize the objectives to create a combined score, then select a base solution probabilistically, followed by a two-phase perturbation: 1) a biased random walk that prioritizes edges with high potential for cost reduction in both objectives, and 2) a constrained segment rotation that dynamically selects and rotates segments to explore the neighborhood while ensuring feasibility through a validation check and permutation repair mechanism if needed.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Biased random walk phase\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Select a random starting point\n        current_pos = np.random.randint(0, n)\n        steps = np.random.randint(2, min(5, n//2))\n\n        # Perform biased random walk\n        for _ in range(steps):\n            next_pos = (current_pos + 1) % n\n\n            # Calculate potential cost reduction\n            current_edges = [\n                (new_solution[current_pos-1], new_solution[current_pos]),\n                (new_solution[next_pos], new_solution[(next_pos+1)%n])\n            ]\n            swapped_edges = [\n                (new_solution[current_pos-1], new_solution[next_pos]),\n                (new_solution[current_pos], new_solution[(next_pos+1)%n])\n            ]\n\n            current_cost1 = sum(distance_matrix_1[u, v] for u, v in current_edges)\n            current_cost2 = sum(distance_matrix_2[u, v] for u, v in current_edges)\n            swapped_cost1 = sum(distance_matrix_1[u, v] for u, v in swapped_edges)\n            swapped_cost2 = sum(distance_matrix_2[u, v] for u, v in swapped_edges)\n\n            # Accept if both objectives improve\n            if (swapped_cost1 < current_cost1) and (swapped_cost2 < current_cost2):\n                new_solution[current_pos], new_solution[next_pos] = new_solution[next_pos], new_solution[current_pos]\n\n            current_pos = next_pos\n\n    # Step 3: Constrained segment rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Rotate the segment\n        rotation = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:end] = rotated_segment\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.8726024957466604,
               0.5535788536071777
          ]
     },
     {
          "algorithm": "{This algorithm implements a novel neighbor selection and generation strategy that combines multi-objective solution evaluation with a hybrid local search approach. It first identifies the most promising solutions in the archive by analyzing their dominance relationships and combined objective values, then employs a weighted random selection to choose a base solution with higher probability for better-performing solutions. The hybrid local search operator combines a novel adaptive segment reversal with a multi-objective-aware acceptance criterion, which evaluates the impact of the reversal on both objectives and accepts the change if it improves at least one objective or with a small probability if it doesn't. The algorithm also includes a fallback mechanism to ensure solution feasibility and a secondary segment reversal attempt if the initial reversal doesn't yield improvement. The approach goes beyond standard 2-opt by focusing on segment-based operations and incorporating multi-objective considerations throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions and select base solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        # If no non-dominated solutions, select the one with minimal combined cost\n        combined_costs = [obj[0] + obj[1] for _, obj in archive]\n        selected_idx = np.argmin(combined_costs)\n    else:\n        # Select from non-dominated solutions with probability proportional to their quality\n        qualities = [1.0 / (1.0 + archive[i][1][0] + archive[i][1][1]) for i in non_dominated]\n        selected_idx = random.choices(non_dominated, weights=qualities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search with multi-objective consideration\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Novel segment-based operation: adaptive segment rotation\n    segment_length = max(2, n // 4)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Calculate segment cost before rotation\n    def calculate_segment_cost(sol, start, end):\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(start, end):\n            cost1 += distance_matrix_1[sol[i], sol[(i+1)%n]]\n            cost2 += distance_matrix_2[sol[i], sol[(i+1)%n]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Perform rotation (shift elements to the right by one position)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Calculate segment cost after rotation\n    new_cost1, new_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Acceptance criterion: accept if at least one objective improves or with small probability\n    if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or random.random() < 0.2:\n        # If accepted, try another segment rotation\n        for _ in range(2):\n            new_start = random.randint(0, n - segment_length - 1)\n            new_end = new_start + segment_length\n            new_segment = new_solution[new_start:new_end]\n            new_rotated_segment = np.roll(new_segment, 1)\n            new_solution[new_start:new_end] = new_rotated_segment\n            new_new_cost1, new_new_cost2 = calculate_segment_cost(new_solution, new_start, new_end)\n            if (new_new_cost1 <= original_cost1 and new_new_cost2 <= original_cost2) or random.random() < 0.1:\n                break\n    else:\n        # If not accepted, revert to original\n        new_solution[start:end] = new_solution[start:end][::-1]  # Simple reversal as fallback\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9043114509275021,
               0.6162062883377075
          ]
     },
     {
          "algorithm": "{The common backbone idea in the provided algorithms is the selection of promising solutions from an archive based on multi-objective criteria (Pareto dominance or combined objective scores) followed by the application of a local search operator that balances exploration and exploitation while maintaining solution feasibility. The new algorithm will employ a multi-stage local search strategy that combines an objective-aware edge insertion with a geometric segment inversion, where the selection of edges and segments is guided by the instance's coordinate data to identify high-potential regions for improvement. The method will first normalize the objectives to create a combined score, then select a base solution probabilistically, followed by a two-phase perturbation: 1) an objective-aware edge insertion that identifies and inserts edges that improve both objectives, and 2) a geometric segment inversion that dynamically selects and inverts segments based on their spatial properties in both coordinate spaces to explore the neighborhood while ensuring feasibility through a validation check and permutation repair mechanism if needed.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Objective-aware edge insertion phase\n    if n > 3:\n        # Find edges with high potential for improvement\n        edge_improvement = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n\n            # Find alternative edges that could improve both objectives\n            for j in range(n):\n                if j == i or j == (i + 1) % n or (j + 1) % n == i or (j + 1) % n == (i + 1) % n:\n                    continue\n                x = new_solution[j]\n                y = new_solution[(j + 1) % n]\n\n                # Calculate potential cost improvement\n                new_cost1 = distance_matrix_1[u, x] + distance_matrix_1[y, v]\n                new_cost2 = distance_matrix_2[u, x] + distance_matrix_2[y, v]\n                improvement1 = cost1 - (distance_matrix_1[u, x] + distance_matrix_1[y, v])\n                improvement2 = cost2 - (distance_matrix_2[u, x] + distance_matrix_2[y, v])\n\n                if improvement1 > 0 and improvement2 > 0:\n                    edge_improvement.append((i, j, improvement1 + improvement2))\n\n        if edge_improvement:\n            # Select the edge with the highest potential improvement\n            edge_improvement.sort(key=lambda x: -x[2])\n            i, j, _ = edge_improvement[0]\n\n            # Perform the insertion\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            x = new_solution[j]\n            y = new_solution[(j + 1) % n]\n\n            # Create new path u -> x -> y -> v\n            new_segment = np.array([u, x, y, v])\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                new_segment,\n                new_solution[(i+2):]\n            ])\n            new_solution = np.unique(new_solution, return_index=False)\n\n    # Step 3: Geometric segment inversion phase\n    if n > 4:\n        # Calculate centroids of segments in both spaces\n        centroids1 = []\n        centroids2 = []\n        for i in range(n - 2):\n            segment = new_solution[i:i+3]\n            coords1 = instance[segment, :2]\n            coords2 = instance[segment, 2:]\n            centroid1 = np.mean(coords1, axis=0)\n            centroid2 = np.mean(coords2, axis=0)\n            centroids1.append(centroid1)\n            centroids2.append(centroid2)\n\n        # Select segment with the most \"spread\" in both spaces\n        spread1 = np.std(centroids1, axis=0).sum()\n        spread2 = np.std(centroids2, axis=0).sum()\n        total_spread = [spread1 + spread2 for spread1, spread2 in zip(centroids1, centroids2)]\n        selected_segment = np.argmax(total_spread)\n\n        # Invert the selected segment\n        start = selected_segment\n        end = start + 3\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.977654153406121,
               7.749007880687714
          ]
     },
     {
          "algorithm": "{The new algorithm will employ a hybrid approach combining a multi-objective aware edge insertion heuristic with a constrained geometric perturbation, where it first identifies critical edges in the Pareto frontier solutions using a geometric analysis of the instance coordinates, then probabilistically selects a base solution based on its geometric diversity, followed by a two-phase perturbation process: 1) a directed edge insertion that prioritizes edges connecting geometrically distant nodes while maintaining Pareto optimality, and 2) a constrained geometric rotation that dynamically selects and rotates segments based on the relative positions of nodes in both objective spaces, with feasibility maintained through a geometric validation check and a permutation repair mechanism that ensures the solution remains a valid tour by reconstructing the tour using a nearest-neighbor approach from the closest valid node if invalidity is detected.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify critical edges in Pareto frontier solutions\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol_i)\n\n    if not pareto_front:\n        pareto_front = [sol for sol, _ in archive]\n\n    # Step 2: Select base solution based on geometric diversity\n    def geometric_diversity(sol):\n        coords1 = instance[sol, :2]\n        coords2 = instance[sol, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n        diversity = np.sum(np.linalg.norm(coords1 - centroid1, axis=1)) + np.sum(np.linalg.norm(coords2 - centroid2, axis=1))\n        return diversity\n\n    base_solution = max(pareto_front, key=geometric_diversity).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Directed edge insertion\n    if n > 3:\n        # Find geometrically distant nodes\n        coords1 = instance[new_solution, :2]\n        coords2 = instance[new_solution, 2:]\n        distances1 = np.linalg.norm(coords1 - np.roll(coords1, 1, axis=0), axis=1)\n        distances2 = np.linalg.norm(coords2 - np.roll(coords2, 1, axis=0), axis=1)\n        total_distances = distances1 + distances2\n        critical_edges = np.argsort(total_distances)[-min(3, n//2):]\n\n        for edge in critical_edges:\n            # Try inserting a new edge\n            u, v = new_solution[edge], new_solution[(edge+1)%n]\n            # Find the best insertion point\n            best_insert = -1\n            best_gain = -np.inf\n            for i in range(n):\n                if i != edge and i != (edge+1)%n:\n                    # Calculate potential gain\n                    old_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                    new_cost = distance_matrix_1[u, new_solution[(i+1)%n]] + distance_matrix_2[u, new_solution[(i+1)%n]] + \\\n                               distance_matrix_1[new_solution[i], v] + distance_matrix_2[new_solution[i], v]\n                    gain = old_cost - new_cost\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_insert = i\n\n            if best_insert != -1 and best_gain > 0:\n                # Perform insertion\n                new_solution = np.concatenate([new_solution[:best_insert+1], [v], new_solution[best_insert+1:]])\n                new_solution = np.concatenate([new_solution[:edge+1], [u], new_solution[edge+1:]])\n\n    # Step 4: Constrained geometric rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Calculate geometric properties\n        segment_coords1 = instance[new_solution[start:end], :2]\n        segment_coords2 = instance[new_solution[start:end], 2:]\n        centroid1 = np.mean(segment_coords1, axis=0)\n        centroid2 = np.mean(segment_coords2, axis=0)\n\n        # Rotate segment based on geometric properties\n        angle1 = np.arctan2(segment_coords1[:,1] - centroid1[1], segment_coords1[:,0] - centroid1[0])\n        angle2 = np.arctan2(segment_coords2[:,1] - centroid2[1], segment_coords2[:,0] - centroid2[0])\n        avg_angle = np.mean(angle1 + angle2)\n\n        # Sort nodes by angle\n        angles = angle1 + angle2\n        sorted_indices = np.argsort(angles)\n        new_solution[start:end] = new_solution[start:end][sorted_indices]\n\n    # Step 5: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Nearest-neighbor repair\n        valid_tour = []\n        remaining_nodes = set(new_solution)\n        current_node = new_solution[0]\n        valid_tour.append(current_node)\n        remaining_nodes.remove(current_node)\n\n        while remaining_nodes:\n            min_dist = np.inf\n            next_node = None\n            for node in remaining_nodes:\n                dist = distance_matrix_1[current_node, node] + distance_matrix_2[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    next_node = node\n            valid_tour.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        new_solution = np.array(valid_tour)\n\n    return new_solution\n\n",
          "score": [
               -0.9502865232406194,
               0.8973692655563354
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' employs a novel hybrid local search strategy that combines adaptive selection pressure with a multi-phase perturbation mechanism. It first intelligently samples the archive to identify solutions with high potential for improvement by evaluating their dominance and crowding distance in the bi-objective space, then applies a dynamic 3-exchange operator followed by a targeted inversion of a subtour segment, guided by a weighted objective-aware fitness function that balances the trade-offs between the two objectives. The method ensures feasibility by strictly maintaining permutation properties and includes a validity check to revert to the original solution if the generated neighbor is invalid, guaranteeing the output is always a feasible TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a weighted selection based on dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance and crowding distance (simplified approach)\n    dominated = [False] * len(archive)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]:\n                if objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]:\n                    dominated[i] = True\n                    break\n\n    # Select non-dominated solutions if available, otherwise select all\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    selected_indices = non_dominated if non_dominated else list(range(len(archive)))\n\n    # Calculate crowding distance for selected solutions\n    if len(selected_indices) > 1:\n        # Sort by first objective\n        sorted_indices = sorted(selected_indices, key=lambda i: objectives[i][0])\n        crowding = [0.0] * len(archive)\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, len(sorted_indices)-1):\n            crowding[sorted_indices[i]] = abs(objectives[sorted_indices[i+1]][0] - objectives[sorted_indices[i-1]][0])\n\n        # Sort by second objective\n        sorted_indices = sorted(selected_indices, key=lambda i: objectives[i][1])\n        crowding[sorted_indices[0]] = float('inf')\n        crowding[sorted_indices[-1]] = float('inf')\n\n        for i in range(1, len(sorted_indices)-1):\n            crowding[sorted_indices[i]] += abs(objectives[sorted_indices[i+1]][1] - objectives[sorted_indices[i-1]][1])\n\n        # Select solution with highest crowding distance\n        best_idx = max(selected_indices, key=lambda i: crowding[i])\n    else:\n        best_idx = selected_indices[0]\n\n    base_solution = solutions[best_idx].copy()\n\n    # Step 2: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Phase 1: Adaptive 3-exchange\n    if n >= 3:\n        # Select three distinct positions\n        a, b, c = sorted(random.sample(range(n), 3))\n\n        # Perform 3-exchange\n        temp = new_solution[a]\n        new_solution[a] = new_solution[b]\n        new_solution[b] = new_solution[c]\n        new_solution[c] = temp\n\n    # Phase 2: Targeted inversion\n    if n >= 2:\n        # Select a segment to invert\n        start, end = sorted(random.sample(range(n), 2))\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Verify the solution is valid (permutation)\n    if not (np.array_equal(np.sort(new_solution), np.sort(base_solution)) and len(np.unique(new_solution)) == n):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.692138007707279,
               0.504461407661438
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-objective cluster-based local search strategy that first partitions the archive into clusters of solutions with similar objective profiles, then probabilistically selects a base solution from the cluster with the highest potential for improvement, followed by a two-stage perturbation: 1) a dynamic segment relocation that moves a variable-length segment to a new position while preserving connectivity, and 2) a multi-objective-aware node insertion that evaluates candidate insertions based on a weighted combination of both objectives, with acceptance criteria that balance improvement in both dimensions while ensuring feasibility through a comprehensive validation mechanism that repairs any invalid sequences through a combination of node swaps and segment reversals.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Cluster solutions based on objective similarity\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n\n    # Use K-means to cluster solutions (simplified for demonstration)\n    from sklearn.cluster import KMeans\n    n_clusters = min(3, len(archive))\n    kmeans = KMeans(n_clusters=n_clusters, random_state=42).fit(norm_obj)\n    cluster_labels = kmeans.labels_\n\n    # Step 2: Select cluster with highest potential for improvement\n    cluster_potentials = []\n    for cluster in range(n_clusters):\n        cluster_indices = np.where(cluster_labels == cluster)[0]\n        cluster_objectives = objectives[cluster_indices]\n        # Potential is based on average objective values (lower is better)\n        potential = np.mean(cluster_objectives, axis=0)\n        cluster_potentials.append(potential)\n\n    # Select cluster with lowest average objectives (most promising)\n    selected_cluster = np.argmin(np.sum(cluster_potentials, axis=1))\n    cluster_indices = np.where(cluster_labels == selected_cluster)[0]\n\n    # Select a base solution from this cluster\n    if len(cluster_indices) > 1:\n        # Select solution closest to the cluster centroid\n        cluster_centroid = kmeans.cluster_centers_[selected_cluster]\n        distances = np.linalg.norm(norm_obj[cluster_indices] - cluster_centroid, axis=1)\n        selected_idx = cluster_indices[np.argmin(distances)]\n    else:\n        selected_idx = cluster_indices[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Dynamic segment relocation\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Find new insertion point\n        insertion_point = np.random.randint(0, n - segment_length)\n        while insertion_point >= start and insertion_point < end:\n            insertion_point = np.random.randint(0, n - segment_length)\n\n        # Relocate segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:insertion_point],\n            segment,\n            new_solution[insertion_point:start],\n            new_solution[end:]\n        ])\n\n    # Step 4: Multi-objective-aware node insertion\n    for _ in range(3):\n        # Select a random node to move\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n\n        # Evaluate possible insertions\n        best_pos = node_idx\n        best_cost1 = 0\n        best_cost2 = 0\n\n        # Consider positions around current node\n        for pos in range(max(0, node_idx-3), min(n, node_idx+4)):\n            if pos == node_idx:\n                continue\n\n            # Calculate cost before and after insertion\n            if pos > 0:\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos]\n                current_node = new_solution[node_idx]\n\n                # Cost before insertion\n                prev_cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n                prev_cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n\n                # Cost after insertion\n                if node_idx > pos:\n                    # Node is moved forward\n                    new_cost1 = (distance_matrix_1[prev_node, node] +\n                                distance_matrix_1[node, next_node] +\n                                distance_matrix_1[new_solution[node_idx-1], current_node])\n                    new_cost2 = (distance_matrix_2[prev_node, node] +\n                                distance_matrix_2[node, next_node] +\n                                distance_matrix_2[new_solution[node_idx-1], current_node])\n                else:\n                    # Node is moved backward\n                    new_cost1 = (distance_matrix_1[prev_node, node] +\n                                distance_matrix_1[node, next_node] +\n                                distance_matrix_1[current_node, new_solution[node_idx+1]])\n                    new_cost2 = (distance_matrix_2[prev_node, node] +\n                                distance_matrix_2[node, next_node] +\n                                distance_matrix_2[current_node, new_solution[node_idx+1]])\n\n                # Weighted cost improvement\n                weight = 0.5  # Equal weighting between objectives\n                cost_improvement = (weight * (prev_cost1 - new_cost1) + (1-weight) * (prev_cost2 - new_cost2))\n\n                if cost_improvement > 0:\n                    if (best_pos == node_idx) or (cost_improvement > (weight * (prev_cost1 - best_cost1) + (1-weight) * (prev_cost2 - best_cost2))):\n                        best_pos = pos\n                        best_cost1 = new_cost1\n                        best_cost2 = new_cost2\n\n        # Perform the best insertion if found\n        if best_pos != node_idx:\n            # Remove node from current position\n            new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n            # Insert node at new position\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.9382842925863917,
               2.6549702882766724
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n\n    if n < 3:\n        return selected_solution\n\n    # Dynamic segment selection based on solution properties\n    segment_length = min(max(2, n // 3), n - 2)\n    start_idx = np.random.randint(0, n - segment_length)\n\n    # Adaptive segment shuffling\n    segment = selected_solution[start_idx:start_idx + segment_length]\n    np.random.shuffle(segment)\n\n    # Objective-aware reinsertion\n    remaining_nodes = [node for node in selected_solution if node not in segment]\n    new_segment = []\n\n    # Start with node that minimizes combined distance to neighbors\n    if remaining_nodes:\n        current_node = min(remaining_nodes, key=lambda x: distance_matrix_1[x, segment[0]] + distance_matrix_2[x, segment[0]])\n        new_segment.append(current_node)\n        remaining_nodes.remove(current_node)\n\n    for node in segment:\n        # Find best position to insert current node based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_segment) + 1):\n            if i == 0:\n                prev_node = new_segment[-1] if new_segment else selected_solution[-1]\n                next_node = new_segment[0] if new_segment else selected_solution[start_idx + segment_length]\n            elif i == len(new_segment):\n                prev_node = new_segment[-1]\n                next_node = selected_solution[start_idx + segment_length]\n            else:\n                prev_node = new_segment[i-1]\n                next_node = new_segment[i]\n\n            dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            score = 0.7 * dist1 + 0.3 * dist2  # Weighted by objective importance\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        new_segment.insert(best_pos, node)\n\n    # Construct new solution\n    new_solution = np.concatenate([\n        selected_solution[:start_idx],\n        np.array(new_segment),\n        selected_solution[start_idx + segment_length:]\n    ])\n\n    # Validate solution\n    if len(np.unique(new_solution)) == n and len(new_solution) == n:\n        return new_solution\n\n    return selected_solution\n\n",
          "score": [
               -0.9368335472606997,
               0.8721699118614197
          ]
     }
]