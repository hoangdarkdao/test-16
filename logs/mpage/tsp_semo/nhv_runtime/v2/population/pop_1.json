[
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify the most promising candidate for local improvement, prioritizing those with lower objective values or exhibiting characteristics of suboptimality (e.g., high edge crossings or non-dominated solutions). It then applies a hybrid local search strategy that combines a novel segment inversion operator with a biased 3-opt move, where the inversion is guided by the relative costs of edges in the two objective spaces, and the 3-opt is constrained to preserve feasibility by ensuring no nodes are skipped or revisited. The inversion operator selects two random segments of the tour and reverses their order, while the 3-opt operator identifies three non-adjacent edges and reconnects them to form a new cycle, with the selection of edges biased towards those with higher relative costs in either objective space. The function ensures feasibility by validating the generated neighbor solution before returning it, thus maintaining the integrity of the TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives as the base\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with biased 3-opt\n    if n >= 4:\n        # Segment inversion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Biased 3-opt: select edges with higher relative costs\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            edges.append((i, (i + 1) % n, max(cost1, cost2)))\n\n        # Sort edges by descending cost and select top 3\n        edges.sort(key=lambda x: -x[2])\n        selected_edges = [edge for edge in edges[:3]]\n\n        if len(selected_edges) == 3:\n            # Perform 3-opt swap\n            i1, j1, _ = selected_edges[0]\n            i2, j2, _ = selected_edges[1]\n            i3, j3, _ = selected_edges[2]\n\n            # Ensure edges are non-adjacent and can form a valid cycle\n            if not (abs(i1 - i2) == 1 or abs(i1 - i3) == 1 or abs(i2 - i3) == 1):\n                # Create a new segment by reconnecting the edges\n                segment = new_solution[i1:j1] + new_solution[i2:j2] + new_solution[i3:j3]\n                new_solution = np.concatenate([new_solution[:i1], segment[::-1], new_solution[j3:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8609101435913555,
               0.23056882619857788
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-phase approach to intelligently select a promising solution from the archive and generate a high-quality neighbor solution. First, it identifies candidate solutions by evaluating their objective values and structural diversity, using a weighted sum of normalized objectives to prioritize solutions with good trade-offs. Next, it selects the most promising candidate through tournament selection, favoring solutions with higher diversity and better objective values. For local search, it employs a hybrid strategy combining edge inversion and segment relocation, where segments of the tour are either inverted or relocated to different positions while maintaining feasibility. The algorithm ensures feasibility by strictly enforcing the TSP constraints (no node repetition or omission) and uses the provided distance matrices to evaluate the quality of generated neighbors. The process iteratively refines the solution by accepting improvements in either objective while maintaining Pareto dominance, and terminates when no further improvements are found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution (simplified for this example)\n    # In practice, implement a more sophisticated selection mechanism\n    selected_solution = archive[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Randomly choose between inversion and relocation\n    if np.random.rand() < 0.5:\n        # Segment inversion\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment relocation\n        i, j, k = sorted(np.random.choice(n, 3, replace=False))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique, counts = np.unique(new_solution, return_counts=True)\n    if len(unique) != n or np.any(counts != 1):\n        # If infeasible, revert to original\n        return selected_solution\n\n    return new_solution\n\n",
          "score": [
               -0.7012671140032183,
               0.2083536982536316
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the non-dominated solutions in the archive by comparing their objectives using Pareto dominance, then intelligently selects a base solution from these non-dominated solutions based on a combination of their objective values and the diversity of their neighborhood in the solution space. The selected solution undergoes a novel hybrid local search operator that combines a randomized edge insertion step with a restricted 3-opt move, where the 3-opt is constrained to operate only on edges that are within a certain distance threshold in both objective spaces. This ensures the generated neighbor solution remains feasible while exploring a broader search space than traditional 2-opt. The function then evaluates the new solution's objectives and ensures it is added to the archive if it is non-dominated, maintaining the archive's quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Identify non-dominated solutions in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive  # Fallback to all solutions if no non-dominated found\n\n    # Step 2: Select a base solution with a combination of objective and neighborhood diversity\n    selected_idx = 0\n    max_score = -1\n    for i, (sol, obj) in enumerate(non_dominated):\n        # Score based on objective values and neighborhood diversity\n        score = (1 / (obj[0] + obj[1] + 1e-6)) + np.random.uniform(0, 0.1)\n        if score > max_score:\n            max_score = score\n            selected_idx = i\n\n    base_solution = non_dominated[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 3: Apply hybrid local search operator\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small for meaningful local search\n\n    # Randomized edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n\n    # Restricted 3-opt\n    k = np.random.randint(0, n)\n    if k != i and k != j:\n        l = np.random.randint(0, n)\n        if l != i and l != j and l != k:\n            # Ensure the move is feasible and within distance thresholds\n            dist1 = distance_matrix_1[new_solution[k], new_solution[l]]\n            dist2 = distance_matrix_2[new_solution[k], new_solution[l]]\n            if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n                # Perform 3-opt move\n                new_solution = np.concatenate([\n                    new_solution[:i],\n                    new_solution[j:k],\n                    new_solution[i:j],\n                    new_solution[k:]\n                ])\n\n    return new_solution\n\n",
          "score": [
               -0.956737750399488,
               0.41641467809677124
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: Edge insertion with segment reversal\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # No meaningful operation possible\n\n    # Randomly select a segment to reverse\n    start = random.randint(0, n - 4)\n    end = random.randint(start + 2, n - 2)\n\n    # Reverse the selected segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly select two non-adjacent edges and perform edge insertion\n    edge1 = random.randint(0, n - 2)\n    edge2 = random.randint(0, n - 2)\n    while abs(edge1 - edge2) <= 1:\n        edge2 = random.randint(0, n - 2)\n\n    # Insert edge2 after edge1\n    node = new_solution[edge2]\n    new_solution = np.concatenate([new_solution[:edge1+1], [node], new_solution[edge1+1:]])\n    new_solution = np.delete(new_solution, edge2 + (1 if edge2 > edge1 else 0))\n\n    return new_solution\n\n",
          "score": [
               -0.7740271816421253,
               0.2292952537536621
          ]
     },
     {
          "algorithm": "{The proposed algorithm first evaluates the archive of solutions to identify the most promising candidates for local improvement by analyzing their objective values and diversity, prioritizing solutions with high potential for improvement in either objective while maintaining balance. It then applies a hybrid local search operator that combines a novel segment relocation strategy with a guided edge insertion mechanism, where segments of the tour are intelligently relocated to reduce both objectives, and edges are inserted based on a weighted combination of the two distance matrices to ensure progress toward the Pareto front. The algorithm ensures feasibility by maintaining the TSP tour constraints, and it dynamically adjusts the search parameters based on the current archive state to balance exploration and exploitation, ultimately generating high-quality neighbor solutions that advance the optimization process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a solution with high potential for improvement (e.g., highest objective values)\n    archive_solutions = [sol_obj[0] for sol_obj in archive]\n    objectives = [sol_obj[1] for sol_obj in archive]\n\n    # Calculate the sum of objectives for each solution\n    objective_sums = [sum(obj) for obj in objectives]\n\n    # Select the solution with the highest sum (most promising for improvement)\n    selected_idx = np.argmax(objective_sums)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Hybrid local search: Segment Relocation with Guided Edge Insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Segment Relocation (relocate a random segment)\n    if n > 3:\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n - 1)\n        segment = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment])\n\n    # Step 2: Guided Edge Insertion (insert the best edge based on a weighted distance)\n    if n > 2:\n        # Calculate weighted distance matrix (combining both objectives)\n        alpha = 0.5  # Weight for balancing the two objectives\n        weighted_distance = alpha * distance_matrix_1 + (1 - alpha) * distance_matrix_2\n\n        # Find the best edge to insert\n        best_insertion = None\n        best_improvement = 0\n\n        for i in range(n - 1):\n            u = new_solution[i]\n            v = new_solution[i + 1]\n            for j in range(n - 1):\n                if j != i and j != i + 1:\n                    x = new_solution[j]\n                    y = new_solution[j + 1]\n                    # Calculate potential improvement\n                    old_cost = weighted_distance[u, v] + weighted_distance[x, y]\n                    new_cost = weighted_distance[u, x] + weighted_distance[v, y]\n                    improvement = old_cost - new_cost\n                    if improvement > best_improvement:\n                        best_improvement = improvement\n                        best_insertion = (i, j)\n\n        # Perform the best insertion if found\n        if best_insertion is not None:\n            i, j = best_insertion\n            if i < j:\n                segment = new_solution[i + 1:j + 1]\n                new_solution = np.concatenate([new_solution[:i + 1], segment, new_solution[j + 1:]])\n            else:\n                segment = new_solution[j + 1:i + 1]\n                new_solution = np.concatenate([new_solution[:j + 1], segment, new_solution[i + 1:]])\n\n    return new_solution\n\n",
          "score": [
               -0.9189895277485969,
               0.7991083860397339
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the non-dominated solutions in the archive by filtering out those that are not Pareto-efficient, then intelligently selects a solution based on a combination of objective values and structural diversity (e.g., using a weighted random selection that favors solutions with lower total costs or higher structural variance). It then applies a novel hybrid local search operator that combines edge exchange (similar to 2-opt but with a broader scope) with a constrained segment inversion strategy, where it randomly selects a segment of the tour, reverses it, and ensures feasibility by carefully handling overlapping or adjacent segments, thus generating a neighbor solution that explores a larger neighborhood while maintaining tour validity and potentially improving both objectives. The function ensures the generated neighbor remains feasible by validating the tour structure after each modification.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Filter non-dominated solutions\n    def is_dominated(sol1, sol2):\n        return sol1[1][0] <= sol2[1][0] and sol1[1][1] <= sol2[1][1] and (sol1[1][0] < sol2[1][0] or sol1[1][1] < sol2[1][1])\n\n    non_dominated = []\n    for sol in archive:\n        dominated = False\n        for other in archive:\n            if is_dominated(sol, other):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with a combination of low cost and high diversity\n    weights = np.array([(sol[1][0] + sol[1][1]) / (1 + np.std(sol[0])) for sol in non_dominated])\n    weights = 1 / (weights + 1e-6)  # Inverse to prefer lower weights\n    weights = weights / np.sum(weights)\n    selected = np.random.choice(len(non_dominated), p=weights)\n    base_solution = non_dominated[selected][0].copy()\n\n    # Step 3: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    seg_start = np.random.randint(0, n)\n    seg_length = np.random.randint(2, min(5, n // 2))\n    seg_end = (seg_start + seg_length) % n\n\n    # Ensure the segment is valid and doesn't overlap with itself\n    if seg_start < seg_end:\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n    else:\n        # Handle circular segment\n        segment = np.concatenate([new_solution[seg_start:], new_solution[:seg_end]])\n        reversed_segment = segment[::-1]\n        new_solution[seg_start:] = reversed_segment[:n - seg_start]\n        new_solution[:seg_end] = reversed_segment[n - seg_start:]\n\n    # Step 4: Ensure feasibility by validating the tour\n    if len(np.unique(new_solution)) != n:\n        raise ValueError(\"Generated solution is invalid\")\n\n    return new_solution\n\n",
          "score": [
               -0.8083910447386892,
               0.6622113585472107
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating each solution's potential for improvement using a weighted sum of the normalized objectives, where weights are inversely proportional to the current objective values. It then applies a hybrid local search operator that combines a novel segment inversion strategy with a randomized edge swap, ensuring feasibility by checking for duplicate nodes and repairing invalid tours. The segment inversion strategy selects a random segment of the tour and reverses its order, while the randomized edge swap probabilistically swaps edges between non-adjacent nodes to escape local optima. The function prioritizes solutions with lower objective values but also considers those with high potential for improvement, balancing exploration and exploitation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives to prioritize solutions with lower costs\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_obj = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n\n    # Weighted sum of normalized objectives (inverse of objective values)\n    weights = 1.0 / (normalized_obj + 1e-8)\n    scores = np.sum(weights, axis=1)\n\n    # Select the solution with the highest score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment inversion + randomized edge swap\n    n = len(new_solution)\n\n    # Segment inversion\n    if n > 2:\n        start = np.random.randint(0, n - 1)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomized edge swap\n    if n > 3:\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        if abs(i - j) > 1:  # Ensure non-adjacent nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # Repair by restoring the original segment if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.7456226053075101,
               0.2586659789085388
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_combined = float('inf')\n    base_solution = None\n    for sol, obj in archive:\n        combined = obj[0] + obj[1]\n        if combined < best_combined:\n            best_combined = combined\n            base_solution = sol.copy()\n\n    new_solution = base_solution.copy()\n\n    # Apply a hybrid local search operator: combine 3-opt with a novel edge-swap strategy\n    n = len(new_solution)\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    k = np.random.randint(0, n)\n\n    # Ensure all indices are distinct\n    while i == j or i == k or j == k:\n        j = np.random.randint(0, n)\n        k = np.random.randint(0, n)\n\n    # Sort indices to apply 3-opt\n    i, j, k = sorted([i, j, k])\n\n    # Apply 3-opt: reverse segments between i to j, j to k, and k to i\n    segment1 = new_solution[i:j+1]\n    segment2 = new_solution[j+1:k+1]\n    segment3 = new_solution[k+1:] if k+1 < n else np.array([], dtype=int)\n\n    # Reconstruct the solution\n    new_solution = np.concatenate([new_solution[:i], segment1[::-1], segment2[::-1], segment3])\n\n    # Apply novel edge-swap: swap two edges that are not adjacent and improve both objectives\n    for _ in range(5):  # Limit attempts to avoid excessive computation\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        c = np.random.randint(0, n)\n        d = np.random.randint(0, n)\n\n        # Ensure all indices are distinct and valid\n        while a == b or a == c or a == d or b == c or b == d or c == d:\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            c = np.random.randint(0, n)\n            d = np.random.randint(0, n)\n\n        # Sort indices to maintain order\n        a, b, c, d = sorted([a, b, c, d], key=lambda x: new_solution[x])\n\n        # Check if swapping edges (a,b) and (c,d) improves both objectives\n        old_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n        new_cost1 = distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[b], new_solution[d]]\n\n        old_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n        new_cost2 = distance_matrix_2[new_solution[a], new_solution[c]] + distance_matrix_2[new_solution[b], new_solution[d]]\n\n        if new_cost1 < old_cost1 and new_cost2 < old_cost2:\n            # Perform the swap\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = new_solution[a], new_solution[c], new_solution[b], new_solution[d]\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.7640144294366105,
               0.29147499799728394
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective (sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    combined_scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel edge-swap based on objective diversity\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify edges with high potential for improvement in either objective\n    edge_scores = []\n    for i in range(n):\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[a, b]\n        cost2 = distance_matrix_2[a, b]\n        # Score based on both objectives and their relative improvement potential\n        score = (cost1 + cost2) * (1 + 0.5 * abs(cost1 - cost2) / (cost1 + cost2 + 1e-8))\n        edge_scores.append((score, i))\n\n    # Step 2: Select top 3 edges with highest scores for modification\n    edge_scores.sort(reverse=True)\n    selected_edges = [idx for _, idx in edge_scores[:3]]\n\n    # Step 3: For each selected edge, try to find a better replacement\n    for edge_idx in selected_edges:\n        i = edge_idx\n        j = (i + 1) % n\n\n        # Find a node to swap that improves both objectives\n        best_improvement = 0\n        best_swap = None\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Try swapping nodes at positions i and k\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n            # Calculate new costs\n            new_cost1 = (distance_matrix_1[temp_solution[i-1], temp_solution[i]] +\n                         distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] +\n                         distance_matrix_1[temp_solution[k-1], temp_solution[k]] +\n                         distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]])\n\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n            new_cost2 = (distance_matrix_2[temp_solution[i-1], temp_solution[i]] +\n                         distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] +\n                         distance_matrix_2[temp_solution[k-1], temp_solution[k]] +\n                         distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[k-1], new_solution[k]] +\n                         distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n            # Calculate improvement (negative means better)\n            improvement = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n\n            if improvement < best_improvement:\n                best_improvement = improvement\n                best_swap = k\n\n        if best_swap is not None:\n            new_solution[i], new_solution[best_swap] = new_solution[best_swap], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8829461644759529,
               4.299792051315308
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: multi-objective edge insertion with biased random walk\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify critical edges in both objective spaces\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Step 2: Find the most expensive edge in the first objective space\n    max_edge_idx = 0\n    max_edge_cost = -1\n    for i in range(n):\n        cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        if cost > max_edge_cost:\n            max_edge_cost = cost\n            max_edge_idx = i\n\n    # Step 3: Perform edge insertion between the selected edge's nodes\n    a, b = new_solution[max_edge_idx], new_solution[(max_edge_idx+1)%n]\n    insertion_candidates = [node for node in new_solution if node not in [a, b]]\n\n    if len(insertion_candidates) > 0:\n        # Select a node to insert based on both objectives\n        candidate_costs = []\n        for node in insertion_candidates:\n            cost1 = distance_matrix_1[a, node] + distance_matrix_1[node, b] - distance_matrix_1[a, b]\n            cost2 = distance_matrix_2[a, node] + distance_matrix_2[node, b] - distance_matrix_2[a, b]\n            candidate_costs.append((cost1 + cost2, node))\n\n        # Select node that improves both objectives most\n        best_node = min(candidate_costs, key=lambda x: x[0])[1]\n        best_idx = np.where(new_solution == best_node)[0][0]\n\n        # Perform insertion\n        if best_idx > max_edge_idx:\n            new_solution = np.concatenate([\n                new_solution[:max_edge_idx+1],\n                [best_node],\n                new_solution[max_edge_idx+1:best_idx],\n                new_solution[best_idx+1:]\n            ])\n        else:\n            new_solution = np.concatenate([\n                new_solution[:best_idx],\n                new_solution[best_idx+1:max_edge_idx+1],\n                [best_node],\n                new_solution[max_edge_idx+1:]\n            ])\n\n    # Step 4: Apply biased random walk to escape local optima\n    if np.random.random() < 0.3:  # 30% chance of perturbation\n        i, j = np.random.choice(n, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.7482033607159562,
               0.9626083970069885
          ]
     }
]