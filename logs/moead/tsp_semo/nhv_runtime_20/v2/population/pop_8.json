[
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ]
    },
    {
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ]
    }
]