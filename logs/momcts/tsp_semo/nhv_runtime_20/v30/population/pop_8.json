[
    {
        "algorithm": "The heuristic selects the highest-hypervolume solution from the archive, applies a 3-opt move to diversify the tour, and then uses simulated annealing to refine it by probabilistically accepting edge swaps that improve or slightly degrade the solution, cooling the temperature over iterations to balance exploration and exploitation. The algorithm prioritizes solutions with better hypervolume (product of objectives) and balances local search with randomness to escape local optima while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with highest hypervolume improvement potential\n    def hypervolume(obj):\n        return obj[0] * obj[1]\n\n    archive.sort(key=lambda x: hypervolume(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with simulated annealing edge swaps\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Perform 3-opt\n    i, j, k = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    new_segment = np.concatenate([segment2, segment1])\n    new_solution[i:k] = new_segment\n\n    # Simulated annealing-inspired edge swaps\n    temp = 1.0\n    cooling_rate = 0.99\n    for _ in range(10):\n        a, b = sorted(random.sample(range(1, n), 2))\n        current_obj = (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                       sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)))\n\n        # Try swapping edges\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        new_obj = (sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n                   sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)))\n\n        # Accept if better or with probability based on temperature\n        if (hypervolume(new_obj) > hypervolume(current_obj) or\n            random.random() < np.exp((hypervolume(new_obj) - hypervolume(current_obj)) / temp)):\n            new_solution = temp_solution\n\n        temp *= cooling_rate\n\n    return new_solution\n\n",
        "score": [
            -0.9159466759073818,
            2.6878561973571777
        ]
    },
    {
        "algorithm": "The algorithm selects a random solution from the archive and applies a hybrid local search combining edge exchange (reversing a segment) and node insertion (relocating a node), ensuring feasibility by validating solution length and uniqueness. It prioritizes improving solutions by leveraging randomness in segment selection and node relocation, with no explicit dominance/diversity checks.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (dominated or diverse)\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge exchange and node insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, size=2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Ensure the exchange creates a valid tour\n    if j - i > 1:\n        # Reverse the segment between i and j\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Step 2: Node insertion (move a node to a different position)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n, \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8999263182725653,
            1.5403056144714355
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest total cost) and applies a hybrid local search: 70% chance for an edge swap (reversing a segment) or 30% for a segment reversal (swapping two edges), ensuring feasibility by validating uniqueness. If invalid, it defaults to a simple edge swap. The selection prioritizes solutions with high potential for improvement, while the local search diversifies exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Hybrid local search: choose between edge swap or segment reversal based on current diversity\n    if random.random() < 0.7:  # 70% chance for edge swap\n        # Edge swap: select two random edges and swap their connections\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = selected_solution[j:i-1:-1]\n    else:\n        # Segment reversal: reverse a random segment of the tour\n        n = len(selected_solution)\n        i, j = sorted(random.sample(range(1, n-1), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i:j+1] = selected_solution[j:i-1:-1]\n\n    # Ensure the new solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != len(selected_solution):\n        # If invalid, revert to a simple edge swap\n        i, j = sorted(random.sample(range(1, len(selected_solution)-1), 2))\n        new_solution = selected_solution.copy()\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.695281572845684,
            1.1709911227226257
        ]
    },
    {
        "algorithm": "The algorithm intelligently selects the best solution from the archive (prioritizing lowest total cost) and applies a hybrid local search combining multi-segment reversal (with probabilistic segment selection) and node relocation (with limited randomness). It ensures feasibility through validation checks, reverting to the original solution if duplicates or length changes are detected. The approach balances exploration (via random segment selection and relocation) while maintaining feasibility, making it more creative than standard 2-opt methods.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (lowest total cost)\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_solution = archive_sorted[0][0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(selected_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful local search\n\n    # Hybrid local search: multi-segment reversal with probabilistic node relocation\n    # Multi-segment reversal (generalization of segment reversal)\n    num_segments = min(3, n // 3)  # Limit number of segments to avoid excessive changes\n    segment_indices = sorted(random.sample(range(1, n-1), num_segments * 2))\n    for i in range(0, len(segment_indices), 2):\n        start, end = segment_indices[i], segment_indices[i+1]\n        if start < end:\n            new_solution[start:end+1] = new_solution[end:start-1:-1]\n\n    # Probabilistic node relocation (inspired by Algorithm 2)\n    for _ in range(min(2, n // 2)):  # Limit number of relocations\n        if random.random() < 0.6:  # 60% chance to relocate\n            k = random.randint(0, n-1)\n            l = random.randint(0, n-1)\n            if k != l:\n                node = new_solution[k]\n                new_solution = np.delete(new_solution, k)\n                new_solution = np.insert(new_solution, l, node)\n\n    # Two-phase validation to ensure feasibility\n    # Phase 1: Check for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If duplicates found, revert to original solution\n        new_solution = selected_solution.copy()\n\n    # Phase 2: Check solution length\n    if len(new_solution) != n:\n        # If length changed, revert to original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.719801261221124,
            1.2372207641601562
        ]
    },
    {
        "algorithm": "This algorithm selects a promising solution from an archive using weighted objective scores, then applies a hybrid local search combining segment reversal, edge insertion, and node swapping, ensuring feasibility by validating solution length and node uniqueness. The selection prioritizes non-dominated solutions with random weights, while the local search adaptively adjusts segment sizes and uses distance matrices to guide improvements in both objective spaces.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted objective value (prioritize non-dominated solutions)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))  # Random weights for objectives\n    scores = np.sum(objectives * weights[:, np.newaxis], axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Hybrid local search with novel operators\n    # 1. Segment reversal with adaptive size\n    seg_size = min(3, max(2, np.random.randint(1, n//2)))\n    i = np.random.randint(0, n - seg_size)\n    new_solution[i:i+seg_size] = new_solution[i:i+seg_size][::-1]\n\n    # 2. Edge insertion with distance-based selection\n    if n > 4:\n        a, b = np.random.choice(n, size=2, replace=False)\n        if a > b:\n            a, b = b, a\n        if b - a > 1:\n            new_solution = np.concatenate([new_solution[:a+1], new_solution[b:], new_solution[a+1:b]])\n\n    # 3. Node swapping with objective-aware selection\n    if n > 3:\n        u, v = np.random.choice(n, size=2, replace=False)\n        obj1 = distance_matrix_1[new_solution[u-1], new_solution[v]] + distance_matrix_1[new_solution[v], new_solution[(u+1)%n]]\n        obj2 = distance_matrix_1[new_solution[u-1], new_solution[u]] + distance_matrix_1[new_solution[v], new_solution[(v+1)%n]]\n        if obj1 < obj2:\n            new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    # Ensure feasibility\n    assert len(new_solution) == n, \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.8309748862373612,
            1.5073076486587524
        ]
    },
    {
        "algorithm": "The algorithm selects the highest-hypervolume solution from the archive, applies a novel 4-opt move to diversify the tour, and refines it using Pareto-aware simulated annealing to probabilistically accept edge swaps based on dominance and cooling temperature. It prioritizes solutions with better hypervolume (product of objectives) and balances exploration/exploitation via temperature cooling, while ensuring feasibility through valid TSP tours.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    def hypervolume(obj):\n        return obj[0] * obj[1]\n\n    archive.sort(key=lambda x: hypervolume(x[1]), reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Novel 4-opt move\n    i, j, k, l = sorted(random.sample(range(1, n), 4))\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n    segment3 = new_solution[k:l]\n    new_segment = np.concatenate([segment2, segment3, segment1])\n    new_solution[i:l] = new_segment\n\n    # Pareto-aware simulated annealing\n    temp = 1.0\n    cooling_rate = 0.99\n    for _ in range(10):\n        a, b = sorted(random.sample(range(1, n), 2))\n        current_obj = (sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)),\n                       sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)))\n\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        new_obj = (sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)),\n                   sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)))\n\n        # Pareto dominance check\n        dominates = (new_obj[0] <= current_obj[0] and new_obj[1] < current_obj[1]) or \\\n                    (new_obj[0] < current_obj[0] and new_obj[1] <= current_obj[1])\n\n        if dominates or random.random() < np.exp((hypervolume(new_obj) - hypervolume(current_obj)) / temp):\n            new_solution = temp_solution\n\n        temp *= cooling_rate\n\n    return new_solution\n\n",
        "score": [
            -0.8418698365623543,
            2.814416468143463
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with the largest differences in their objective values, then applies a hybrid local search combining segment reversal and edge swaps to generate a neighbor while ensuring feasibility. It randomly selects a segment to reverse and swaps two edges, reverting to the original solution if the new one is infeasible. The approach emphasizes diversity in improvement potential and a creative combination of local search operators.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement\n    # Prioritize solutions with the largest differences in their objective values\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]), reverse=True)\n    selected_solution = archive_sorted[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse (segment reversal)\n    start = np.random.randint(0, n)\n    end = np.random.randint(start + 1, n + 1)\n    segment = new_solution[start:end]\n    new_solution[start:end] = segment[::-1]\n\n    # Randomly swap two edges (edge swap)\n    i, j = np.random.choice(n, size=2, replace=False)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        # If not feasible, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.4802288791772343,
            1.427356779575348
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a weighted objective-based scoring, then applies a hybrid local search combining 3-opt and node relocation, prioritizing improvements in both objectives while ensuring feasibility through validation checks. It biases the search toward solutions that improve the less-dominated objective and reverts changes if they don\u2019t benefit both objectives. The selection is randomized but weighted to favor high-potential solutions, and the local search ensures valid tours by validating node uniqueness and tour length.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=len(archive))\n    weighted_scores = np.sum(objectives * weights[:, np.newaxis], axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 5:\n        return new_solution  # Too small for meaningful local search\n\n    # Hybrid local search: combine 3-opt and node relocation\n    # Step 1: 3-opt (select three non-consecutive edges and reconnect)\n    i, j, k = np.random.choice(n, size=3, replace=False)\n    i, j, k = sorted([i, j, k])\n\n    # Ensure the 3-opt creates a valid tour\n    if j - i > 1 and k - j > 1:\n        # Reconnect the edges in a different order\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution[i:k] = np.concatenate([segment2, segment1])\n\n    # Step 2: Node relocation (move a node to a different position with bias toward improving the less-dominated objective)\n    k = np.random.randint(0, n)\n    l = np.random.randint(0, n)\n    if k != l:\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        new_solution = np.insert(new_solution, l, node)\n\n        # Additional step: if the relocation improves the less-dominated objective, keep it; otherwise, revert\n        original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        if original_cost1 > new_cost1 and original_cost2 > new_cost2:\n            pass  # Keep the change\n        elif original_cost1 > new_cost1 or original_cost2 > new_cost2:\n            # If only one objective improves, decide randomly\n            if np.random.rand() < 0.5:\n                new_solution = base_solution.copy()  # Revert if not both improve\n        else:\n            new_solution = base_solution.copy()  # Revert if no improvement\n\n    # Ensure the solution remains feasible\n    assert len(new_solution) == n, \"Solution length changed\"\n    assert len(np.unique(new_solution)) == n, \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.7611646425657238,
            3.665418863296509
        ]
    },
    {
        "algorithm": "The algorithm selects a non-dominated solution from the archive based on edge length variance (prioritizing solutions with higher variance in both objective spaces), then applies a hybrid local search combining a random 2-opt move and a novel segment reversal strategy targeting the most uneven edges. The selection favors solutions with potential for improvement, while the search operator balances standard and creative perturbation techniques to explore the solution space effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and\n                (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a solution with high variance in edge lengths (indicative of potential for improvement)\n    selected_sol = None\n    max_variance = -1\n    for sol, _ in non_dominated:\n        lengths1 = [distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)]\n        lengths1.append(distance_matrix_1[sol[-1], sol[0]])\n        lengths2 = [distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)]\n        lengths2.append(distance_matrix_2[sol[-1], sol[0]])\n        variance1 = np.var(lengths1)\n        variance2 = np.var(lengths2)\n        total_variance = variance1 + variance2\n        if total_variance > max_variance:\n            max_variance = total_variance\n            selected_sol = sol.copy()\n\n    if selected_sol is None:\n        selected_sol = archive[0][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel segment reversal strategy\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # First, perform a random 2-opt move\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Then, apply a novel segment reversal strategy based on distance matrix\n    # Find the most \"uneven\" segment and reverse it\n    max_diff = -1\n    best_k = -1\n    for k in range(1, n):\n        diff1 = distance_matrix_1[new_solution[k-1], new_solution[k]] - distance_matrix_1[new_solution[k], new_solution[k-1]]\n        diff2 = distance_matrix_2[new_solution[k-1], new_solution[k]] - distance_matrix_2[new_solution[k], new_solution[k-1]]\n        total_diff = abs(diff1) + abs(diff2)\n        if total_diff > max_diff:\n            max_diff = total_diff\n            best_k = k\n\n    if best_k != -1:\n        # Reverse the segment around the most uneven edge\n        segment_length = np.random.randint(2, min(5, n))\n        start = max(0, best_k - segment_length // 2)\n        end = min(n, start + segment_length)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6722772045240937,
            6.283906161785126
        ]
    }
]