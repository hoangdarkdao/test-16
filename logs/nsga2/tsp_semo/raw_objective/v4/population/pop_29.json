[
    {
        "algorithm": "{This algorithm implements a novel multi-objective segment relocation and inversion strategy that identifies segments based on their contribution to both objectives, relocates them to positions that optimize both objectives simultaneously while ensuring feasibility, and inverts segments to explore additional solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = random.randint(2, min(5, n // 2))\n    segments = []\n    for i in range(0, n, segment_length):\n        segments.append(new_solution[i:i+segment_length])\n\n    for i in range(len(segments)):\n        if random.random() < 0.5:\n            segments[i] = segments[i][::-1]\n\n    relocated = []\n    for segment in segments:\n        if not relocated:\n            relocated = segment.tolist()\n            continue\n\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(len(relocated) + 1):\n            candidate = relocated[:pos] + segment.tolist() + relocated[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            current_cost1, current_cost2 = calculate_cost(relocated)\n            weight = 0.5 + 0.5 * (current_cost1 + current_cost2) / (sum(distance_matrix_1[relocated[k-1], relocated[k]] for k in range(len(relocated))) + sum(distance_matrix_2[relocated[k-1], relocated[k]] for k in range(len(relocated))))\n\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            relocated = relocated[:best_pos] + segment.tolist() + relocated[best_pos:]\n\n    _, unique_indices = np.unique(relocated, return_index=True)\n    new_solution = np.array(relocated)[np.sort(unique_indices)]\n\n    missing_nodes = set(range(n)) - set(new_solution)\n    if missing_nodes:\n        for node in missing_nodes:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            4.3164086058753055,
            9.279739304052928
        ]
    },
    {
        "algorithm": "{This algorithm implements a multi-objective adaptive segment fusion and dynamic node rearrangement strategy that combines probabilistic segment merging with intelligent node repositioning, dynamically optimizing both objectives through adaptive weight adjustment and segment quality evaluation while ensuring feasibility through segment validation and repair.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    segment_length = max(2, min(5, int(n * 0.2)))\n    num_segments = random.randint(1, min(2, n // segment_length))\n\n    segments = []\n    for _ in range(num_segments):\n        start = random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        segments.append(segment)\n\n    fused_segments = []\n    for i in range(0, len(segments), 2):\n        if i + 1 < len(segments):\n            merged = np.concatenate((segments[i], segments[i+1]))\n            if random.random() < 0.5:\n                merged = merged[::-1]\n            fused_segments.append(merged)\n        else:\n            fused_segments.append(segments[i])\n\n    reassembled = []\n    for segment in fused_segments:\n        if not reassembled:\n            reassembled = segment.tolist()\n            continue\n\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + segment.tolist() + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.5 if pos == 0 or pos == len(reassembled) else 0.3\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled = reassembled[:best_pos] + segment.tolist() + reassembled[best_pos:]\n\n    remaining_nodes = list(set(range(n)) - set(reassembled))\n    for node in remaining_nodes:\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(reassembled) + 1):\n            candidate = reassembled[:pos] + [node] + reassembled[pos:]\n\n            def calculate_cost(sol):\n                cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(len(sol)))\n                cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(len(sol)))\n                return cost1, cost2\n\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n            weight = 0.7 if pos == 0 or pos == len(reassembled) else 0.1\n            score = weight * candidate_cost1 + (1 - weight) * candidate_cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        reassembled.insert(best_pos, node)\n\n    new_solution = np.array(reassembled)\n\n    _, unique_indices = np.unique(new_solution, return_index=True)\n    new_solution = new_solution[np.sort(unique_indices)]\n\n    if len(new_solution) != n:\n        missing = list(set(range(n)) - set(new_solution))\n        for node in missing:\n            insert_pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            9.315345863623348,
            4.089294891477414
        ]
    }
]