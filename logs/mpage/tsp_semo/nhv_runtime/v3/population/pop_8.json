[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in non_dominated])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1.0 / (normalized_obj + 1e-10)\n    probs = weights.sum(axis=1) / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search - edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to remove and reinsert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n - 1, 5))  # Segment length between 2 and 4\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find a new position to insert the segment\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    if insert_pos == 0:\n        new_solution = np.concatenate([segment, remaining])\n    elif insert_pos == len(remaining):\n        new_solution = np.concatenate([remaining, segment])\n    else:\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly relocate a node\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9880560877894095,
               0.30501770973205566
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            pareto_front.append((sol_i, obj_i))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Step 2: Select a solution based on objective values and diversity\n    objectives = np.array([obj for _, obj in pareto_front])\n    normalized_obj = objectives / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = []\n    for sol, _ in pareto_front:\n        unique_edges = set()\n        for i in range(len(sol)):\n            unique_edges.add((min(sol[i], sol[(i+1)%len(sol)]), max(sol[i], sol[(i+1)%len(sol)])))\n        diversity_scores.append(len(unique_edges))\n    diversity_scores = np.array(diversity_scores) / (np.max(diversity_scores) + 1e-10)\n\n    selection_scores = 0.7 * (1 - normalized_obj[:, 0]) + 0.3 * diversity_scores\n    selected_idx = np.argmax(selection_scores)\n    base_solution = pareto_front[selected_idx][0].copy()\n\n    # Step 3: Multi-segment crossover operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two random segments from the base solution\n    seg1_start = np.random.randint(0, n)\n    seg1_length = np.random.randint(2, min(4, n//2))\n    seg1_end = (seg1_start + seg1_length) % n\n\n    seg2_start = np.random.randint(0, n)\n    while abs(seg2_start - seg1_start) < 2 or abs(seg2_start - seg1_end) < 2:\n        seg2_start = np.random.randint(0, n)\n    seg2_length = np.random.randint(2, min(4, n//2))\n    seg2_end = (seg2_start + seg2_length) % n\n\n    # Extract segments\n    if seg1_start < seg1_end:\n        seg1 = new_solution[seg1_start:seg1_end]\n    else:\n        seg1 = np.concatenate([new_solution[seg1_start:], new_solution[:seg1_end]])\n\n    if seg2_start < seg2_end:\n        seg2 = new_solution[seg2_start:seg2_end]\n    else:\n        seg2 = np.concatenate([new_solution[seg2_start:], new_solution[:seg2_end]])\n\n    # Select a third segment from another solution in the archive\n    other_sol = random.choice([sol for sol, _ in archive if not np.array_equal(sol, base_solution)])\n    seg3_start = np.random.randint(0, n)\n    seg3_length = np.random.randint(2, min(4, n//2))\n    seg3_end = (seg3_start + seg3_length) % n\n\n    if seg3_start < seg3_end:\n        seg3 = other_sol[seg3_start:seg3_end]\n    else:\n        seg3 = np.concatenate([other_sol[seg3_start:], other_sol[:seg3_end]])\n\n    # Combine segments to form new solution\n    remaining_nodes = set(range(n)) - set(seg1) - set(seg2) - set(seg3)\n    new_solution = np.concatenate([seg1, seg2, seg3, np.array(list(remaining_nodes))])\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.0059111292081795,
               0.346810519695282
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first identifying the most promising segments of the tour in each objective space by analyzing the distance matrices, then applying a novel adaptive segment fusion strategy that dynamically combines these segments based on their relative performance in both objectives, while simultaneously performing a probabilistic edge swapping mechanism that prioritizes connections with high potential for reducing costs in either or both spaces, and finally validating the solution to ensure it remains feasible while exploring diverse regions of the search space by incorporating a dynamic segment reordering phase that adapts to the specific characteristics of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on combined objective performance\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    combined_scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Identify promising segments in each objective space\n    n = len(base_solution)\n    segment_length = max(2, n // 5)\n    segments = []\n    for i in range(0, n, segment_length):\n        segment = base_solution[i:i+segment_length]\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(len(segment)-1))\n        segments.append((segment, cost1, cost2))\n\n    # Adaptive segment fusion strategy\n    new_solution = []\n    remaining_nodes = set(range(n))\n    current_node = base_solution[0]\n    new_solution.append(current_node)\n    remaining_nodes.remove(current_node)\n\n    while remaining_nodes:\n        # Find best segment to connect to current node\n        best_segment = None\n        best_score = float('inf')\n\n        for seg, cost1, cost2 in segments:\n            if not remaining_nodes.intersection(seg):\n                continue\n\n            # Calculate connection cost\n            last_in_new = new_solution[-1]\n            first_in_seg = seg[0]\n\n            # Combine objective scores with segment quality\n            connection_cost = (distance_matrix_1[last_in_new, first_in_seg] + distance_matrix_2[last_in_new, first_in_seg])\n            segment_quality = (cost1 + cost2) / len(seg)\n            total_score = connection_cost + 0.3 * segment_quality\n\n            if total_score < best_score:\n                best_score = total_score\n                best_segment = seg\n\n        if best_segment is None:\n            # Fallback to nearest neighbor\n            candidates = list(remaining_nodes)\n            nearest = min(candidates, key=lambda x: distance_matrix_1[current_node, x] + distance_matrix_2[current_node, x])\n            new_solution.append(nearest)\n            remaining_nodes.remove(nearest)\n            current_node = nearest\n        else:\n            # Add the best segment\n            for node in best_segment:\n                if node in remaining_nodes:\n                    new_solution.append(node)\n                    remaining_nodes.remove(node)\n            current_node = best_segment[-1]\n\n    # Close the tour\n    new_solution.append(new_solution[0])\n\n    # Validate solution\n    assert len(new_solution) == n + 1 and len(np.unique(new_solution[:-1])) == n\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.931391441151007,
               0.14418554306030273
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge assembly with partial 3-opt\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge assembly: reconnect edges to form a new tour segment\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse another segment\n\n    # Partial 3-opt: attempt to improve the tour by reconnecting three edges\n    if np.random.rand() < 0.5:\n        # Randomly select three nodes and attempt to reconnect them\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Ensure feasibility: verify no duplicates and all nodes are included\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8337802753264643,
               0.16590946912765503
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Objective-aware path reconstruction strategy\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Phase 1: Identify critical nodes in each objective space\n    critical_nodes1 = np.argsort(np.sum(distance_matrix_1, axis=1))[:len(solutions)//2]\n    critical_nodes2 = np.argsort(np.sum(distance_matrix_2, axis=1))[:len(solutions)//2]\n    critical_nodes = np.unique(np.concatenate([critical_nodes1, critical_nodes2]))\n\n    # Phase 2: Select a solution with high diversity in objectives\n    obj_ranges = objectives.max(axis=0) - objectives.min(axis=0)\n    diversity_scores = np.prod(objectives / (obj_ranges + 1e-10), axis=1)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Phase 3: Construct new solution by inserting critical nodes\n    new_solution = []\n    remaining_nodes = set(range(len(instance)))\n    current_node = base_solution[0]\n\n    while remaining_nodes:\n        new_solution.append(current_node)\n        remaining_nodes.remove(current_node)\n\n        # Find next node with best combined objective improvement\n        candidates = list(remaining_nodes)\n        if not candidates:\n            break\n\n        # Evaluate potential next nodes\n        candidate_scores = []\n        for candidate in candidates:\n            # Calculate potential improvement in both objectives\n            cost1 = distance_matrix_1[current_node, candidate]\n            cost2 = distance_matrix_2[current_node, candidate]\n\n            # Combine with critical node preference\n            is_critical = candidate in critical_nodes\n            score = (cost1 + cost2) * (1.5 if is_critical else 1.0)\n            candidate_scores.append(score)\n\n        # Select node with best combined score\n        next_idx = np.argmin(candidate_scores)\n        current_node = candidates[next_idx]\n\n    # Ensure Hamiltonian cycle\n    new_solution.append(new_solution[0])\n\n    # Verify feasibility\n    if len(np.unique(new_solution)) != len(instance):\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return np.array(new_solution)\n\n",
          "score": [
               -0.9911737239425997,
               0.8463422656059265
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a base solution from the archive by evaluating the potential improvement areas in both objective spaces, then applying a novel segment inversion and dynamic edge reconnection strategy that adaptively selects and inverts segments of varying lengths based on their relative performance in each objective space, while simultaneously reconnecting edges in a way that maintains tour validity and potentially reduces costs in either or both objectives. The algorithm uses a probabilistic segment selection mechanism that favors longer segments when they show promise in one objective but not the other, and incorporates a dynamic edge reconnection phase that prioritizes edges with high cost savings in either space, ensuring the solution remains feasible while exploring diverse regions of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution based on potential improvement areas\n    base_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic segment selection and inversion\n    segment_length = np.random.randint(3, min(6, n//3))\n    start = np.random.randint(0, n - segment_length)\n\n    # Calculate segment costs and potential improvements\n    segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n\n    # Invert segment with probability based on cost improvement potential\n    cost_improvement_prob = min(1.0, (segment_cost1 + segment_cost2) / (np.median(distance_matrix_1) + np.median(distance_matrix_2)))\n    if np.random.rand() < cost_improvement_prob:\n        new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Step 3: Adaptive edge reconnection\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Reconnect edges with potential savings in either objective\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) or \\\n           (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 4: Node relocation based on objective space performance\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        # Calculate relocation potential in both objectives\n        current_cost1 = distance_matrix_1[new_solution[node_pos-1], node] + distance_matrix_1[node, new_solution[(node_pos+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[node_pos-1], node] + distance_matrix_2[node, new_solution[(node_pos+1)%n]]\n\n        best_pos = node_pos\n        best_cost1 = current_cost1\n        best_cost2 = current_cost2\n\n        # Search for better positions in both objectives\n        for pos in range(n):\n            if pos == node_pos:\n                continue\n            new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n            if (new_cost1 < best_cost1 and new_cost2 <= best_cost2) or (new_cost1 <= best_cost1 and new_cost2 < best_cost2):\n                best_pos = pos\n                best_cost1 = new_cost1\n                best_cost2 = new_cost2\n\n        if best_pos != node_pos:\n            new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n            new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n\n    # Ensure solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.9893037508178055,
               0.3928150534629822
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP first selects a base solution from the archive by analyzing the trade-off between the two objectives, then applies a novel adaptive segment relocation strategy that dynamically selects and relocates segments of varying lengths based on their performance in each objective space, while simultaneously performing a probabilistic edge swap operation that prioritizes edges with high cost savings in either space, ensuring the solution remains feasible while exploring diverse regions of the search space. The algorithm uses a hybrid approach that combines segment inversion with edge swapping, where the segment length is determined by the relative performance of the segments in each objective, and the edge swaps are performed with a probability that depends on the potential cost reduction in either objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on objective trade-off\n    base_solution, (cost1, cost2) = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = min(5, n//3)\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_length)\n        segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n        segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, start+segment_length-1))\n\n        # Relocate segment if it shows potential for improvement\n        if segment_cost1 > cost1 * 0.3 or segment_cost2 > cost2 * 0.3:\n            segment = new_solution[start:start+segment_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Probabilistic edge swap\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        elif (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n             (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.929804836027715,
               0.37801146507263184
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the hybrid approach seen in both provided solutions by combining a novel segment inversion strategy with a bi-objective-aware edge reconnection mechanism. It first selects a solution from the archive based on a weighted combination of its objectives, then applies a segment inversion that reverses a randomly selected segment while considering both distance matrices to maintain balance between objectives. Following this, it performs a targeted edge reconnection by swapping edges that show potential for improvement in both objective spaces, ensuring feasibility through careful validation. The method also incorporates a probabilistic element to occasionally perform a complete segment relocation when the current solution shows limited improvement, promoting exploration while preserving the tour's validity.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = [1/(obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = np.random.choice(len(archive), p=np.array(weights)/sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Bi-objective segment inversion\n    segment_start = np.random.randint(0, n)\n    segment_length = np.random.randint(2, min(6, n-1))\n    segment_end = (segment_start + segment_length) % n\n\n    if segment_start < segment_end:\n        new_solution[segment_start:segment_end] = base_solution[segment_start:segment_end][::-1]\n    else:\n        new_solution[:segment_end] = base_solution[:segment_end][::-1]\n        new_solution[segment_start:] = base_solution[segment_start:][::-1]\n\n    # Bi-objective edge reconnection\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        # Calculate potential improvement in both objectives\n        delta1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_1[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                 distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                 distance_matrix_2[new_solution[i-1], new_solution[i]] -\n                 distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if delta1 + delta2 < 0:  # If improvement in both objectives\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Probabilistic segment relocation\n    if np.random.rand() < 0.3 and len(archive) > 1:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        insert_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8571488457382084,
               0.2382320761680603
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves selecting a base solution from the archive by evaluating the potential improvement areas in both objective spaces, then applying a novel adaptive path interchange and objective-aware edge flipping strategy that dynamically identifies and flips critical edges based on their relative performance in each objective space, while simultaneously interchanging entire paths of varying lengths between different segments of the tour. The algorithm uses a probabilistic path selection mechanism that favors longer paths when they show promise in one objective but not the other, and incorporates an adaptive edge flipping phase that prioritizes edges with high cost savings in either space, while ensuring the solution remains feasible and explores diverse regions of the search space by maintaining the tour's connectivity and node visitation properties.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on potential improvement areas\n    base_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path interchange\n    if n > 3:\n        # Select two non-overlapping segments\n        split1 = np.random.randint(1, n-2)\n        split2 = np.random.randint(split1+1, n-1)\n\n        # Calculate segment costs\n        seg1_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(split1-1, split1+1))\n        seg1_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(split1-1, split1+1))\n        seg2_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(split2-1, split2+1))\n        seg2_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(split2-1, split2+1))\n\n        # Interchange segments if it shows potential for improvement in either objective\n        if (np.random.rand() < 0.6) or (seg1_cost1 + seg1_cost2 > seg2_cost1 + seg2_cost2):\n            new_solution[split1:split2] = new_solution[split1:split2][::-1]\n\n    # Objective-aware edge flipping\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(0, n-1)\n\n        # Calculate potential cost changes\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Flip edges if it improves either objective\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure solution remains valid\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.9132394028123072,
               0.2746849060058594
          ]
     }
]