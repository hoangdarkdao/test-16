[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm implements a multi-objective selection strategy that uses a hybrid \"objective-balance\" segment crossover with adaptive node relocation, leveraging a novel \"improvement-weighted\" node swapping mechanism to balance improvement across both objectives while maintaining feasibility through strict validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-balance selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        balance = (obj[0] / obj1_avg) * (obj[1] / obj2_avg)\n        score = (obj[0] / obj1_avg) * (0.5 + 0.5 * balance) + (obj[1] / obj2_avg) * (0.5 - 0.5 * balance)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-balance segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Improvement-weighted node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate weighted improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        original_cost = (0.6 * distance_matrix_1[prev_i, node_i] + 0.4 * distance_matrix_1[node_i, next_i] +\n                         0.4 * distance_matrix_1[prev_j, node_j] + 0.6 * distance_matrix_1[node_j, next_j] +\n                         0.6 * distance_matrix_2[prev_i, node_i] + 0.4 * distance_matrix_2[node_i, next_i] +\n                         0.4 * distance_matrix_2[prev_j, node_j] + 0.6 * distance_matrix_2[node_j, next_j])\n\n        new_cost = (0.6 * distance_matrix_1[prev_i, node_j] + 0.4 * distance_matrix_1[node_j, next_i] +\n                    0.4 * distance_matrix_1[prev_j, node_i] + 0.6 * distance_matrix_1[node_i, next_j] +\n                    0.6 * distance_matrix_2[prev_i, node_j] + 0.4 * distance_matrix_2[node_j, next_i] +\n                    0.4 * distance_matrix_2[prev_j, node_i] + 0.6 * distance_matrix_2[node_i, next_j])\n\n        if new_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This new algorithm implements a multi-objective selection strategy that uses a hybrid \"objective-weighted\" segment relocation with adaptive node insertion, leveraging a novel \"improvement-balanced\" edge swapping mechanism to optimize both objectives while maintaining feasibility through strict validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-weighted selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        score = (obj[0] / obj1_avg) * 0.7 + (obj[1] / obj2_avg) * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-weighted segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Improvement-balanced edge swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate balanced improvement\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (0.5 * distance_matrix_1[prev_i, node_i] + 0.5 * distance_matrix_1[node_i, next_i] +\n                             0.5 * distance_matrix_1[prev_j, node_j] + 0.5 * distance_matrix_1[node_j, next_j] +\n                             0.5 * distance_matrix_2[prev_i, node_i] + 0.5 * distance_matrix_2[node_i, next_i] +\n                             0.5 * distance_matrix_2[prev_j, node_j] + 0.5 * distance_matrix_2[node_j, next_j])\n\n            new_cost = (0.5 * distance_matrix_1[prev_i, node_j] + 0.5 * distance_matrix_1[node_j, next_i] +\n                        0.5 * distance_matrix_1[prev_j, node_i] + 0.5 * distance_matrix_1[node_i, next_j] +\n                        0.5 * distance_matrix_2[prev_i, node_j] + 0.5 * distance_matrix_2[node_j, next_i] +\n                        0.5 * distance_matrix_2[prev_j, node_i] + 0.5 * distance_matrix_2[node_i, next_j])\n\n            if new_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment relocation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n",
        "score": [
            4.457749133021455,
            8.5583149070602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-weighted selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        score = (obj[0] / obj1_avg) * 0.7 + (obj[1] / obj2_avg) * 0.3\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-weighted segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Improvement-balanced edge swapping\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if abs(i - j) > 1:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            # Calculate balanced improvement\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (0.5 * distance_matrix_1[prev_i, node_i] + 0.5 * distance_matrix_1[node_i, next_i] +\n                             0.5 * distance_matrix_1[prev_j, node_j] + 0.5 * distance_matrix_1[node_j, next_j] +\n                             0.5 * distance_matrix_2[prev_i, node_i] + 0.5 * distance_matrix_2[node_i, next_i] +\n                             0.5 * distance_matrix_2[prev_j, node_j] + 0.5 * distance_matrix_2[node_j, next_j])\n\n            new_cost = (0.5 * distance_matrix_1[prev_i, node_j] + 0.5 * distance_matrix_1[node_j, next_i] +\n                        0.5 * distance_matrix_1[prev_j, node_i] + 0.5 * distance_matrix_1[node_i, next_j] +\n                        0.5 * distance_matrix_2[prev_i, node_j] + 0.5 * distance_matrix_2[node_j, next_i] +\n                        0.5 * distance_matrix_2[prev_j, node_i] + 0.5 * distance_matrix_2[node_i, next_j])\n\n            if new_cost < original_cost:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment relocation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm implements a multi-objective selection strategy that uses a hybrid \"objective-balance\" segment crossover with adaptive node relocation, leveraging a novel \"improvement-weighted\" node swapping mechanism to balance improvement across both objectives while maintaining feasibility through strict validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-balance selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        balance = (obj[0] / obj1_avg) * (obj[1] / obj2_avg)\n        score = (obj[0] / obj1_avg) * (0.5 + 0.5 * balance) + (obj[1] / obj2_avg) * (0.5 - 0.5 * balance)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-balance segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Improvement-weighted node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate weighted improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        original_cost = (0.6 * distance_matrix_1[prev_i, node_i] + 0.4 * distance_matrix_1[node_i, next_i] +\n                         0.4 * distance_matrix_1[prev_j, node_j] + 0.6 * distance_matrix_1[node_j, next_j] +\n                         0.6 * distance_matrix_2[prev_i, node_i] + 0.4 * distance_matrix_2[node_i, next_i] +\n                         0.4 * distance_matrix_2[prev_j, node_j] + 0.6 * distance_matrix_2[node_j, next_j])\n\n        new_cost = (0.6 * distance_matrix_1[prev_i, node_j] + 0.4 * distance_matrix_1[node_j, next_i] +\n                    0.4 * distance_matrix_1[prev_j, node_i] + 0.6 * distance_matrix_1[node_i, next_j] +\n                    0.6 * distance_matrix_2[prev_i, node_j] + 0.4 * distance_matrix_2[node_j, next_i] +\n                    0.4 * distance_matrix_2[prev_j, node_i] + 0.6 * distance_matrix_2[node_i, next_j])\n\n        if new_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This new algorithm implements a multi-objective selection strategy that uses a hybrid \"objective-aware\" segment crossover with adaptive node relocation, leveraging a novel \"pareto-frontier\" guided node insertion mechanism to balance improvement across both objectives while maintaining feasibility through strict validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Pareto-frontier selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment crossover\n    if n > 5 and random.random() < 0.8:\n        obj_weights = [0.7, 0.3] if random.random() < 0.5 else [0.3, 0.7]\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n        total_cost = obj_weights[0] * segment_cost1 + obj_weights[1] * segment_cost2\n\n        # Evaluate alternatives\n        alternatives = [segment[::-1]]  # Reverse\n        for k in range(1, len(segment)-1):\n            alt = segment.copy()\n            alt[k], alt[k+1] = alt[k+1], alt[k]\n            alternatives.append(alt)\n\n        best_alt = segment\n        best_cost = total_cost\n\n        for alt in alternatives:\n            alt_cost1 = sum(distance_matrix_1[alt[k], alt[k+1]] for k in range(len(alt)-1)) + distance_matrix_1[alt[-1], alt[0]]\n            alt_cost2 = sum(distance_matrix_2[alt[k], alt[k+1]] for k in range(len(alt)-1)) + distance_matrix_2[alt[-1], alt[0]]\n            alt_total = obj_weights[0] * alt_cost1 + obj_weights[1] * alt_cost2\n\n            if alt_total < best_cost:\n                best_cost = alt_total\n                best_alt = alt\n\n        new_solution[i:j] = best_alt\n\n    # Pareto-guided node insertion\n    if random.random() < 0.6:\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        # Find best insertion position\n        best_pos = current_pos\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == current_pos:\n                continue\n\n            # Remove from current position\n            prev = new_solution[current_pos-1] if current_pos > 0 else new_solution[-1]\n            next_node = new_solution[(current_pos+1)%n]\n\n            # Insert at new position\n            new_prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            new_next = new_solution[pos]\n\n            # Calculate improvement\n            original_cost = (distance_matrix_1[prev, node_to_move] + distance_matrix_1[node_to_move, next_node] +\n                            distance_matrix_2[prev, node_to_move] + distance_matrix_2[node_to_move, next_node])\n\n            new_cost = (distance_matrix_1[new_prev, node_to_move] + distance_matrix_1[node_to_move, new_next] +\n                         distance_matrix_2[new_prev, node_to_move] + distance_matrix_2[node_to_move, new_next])\n\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != current_pos:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            7.266249558777172,
            6.04423928253062
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Pareto-frontier selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = random.choice(pareto_front)\n    else:\n        selected_idx = random.randint(0, len(archive)-1)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment crossover\n    if n > 5 and random.random() < 0.8:\n        obj_weights = [0.7, 0.3] if random.random() < 0.5 else [0.3, 0.7]\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n\n        # Evaluate segment in both objectives\n        segment_cost1 = sum(distance_matrix_1[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        segment_cost2 = sum(distance_matrix_2[segment[k], segment[k+1]] for k in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n        total_cost = obj_weights[0] * segment_cost1 + obj_weights[1] * segment_cost2\n\n        # Evaluate alternatives\n        alternatives = [segment[::-1]]  # Reverse\n        for k in range(1, len(segment)-1):\n            alt = segment.copy()\n            alt[k], alt[k+1] = alt[k+1], alt[k]\n            alternatives.append(alt)\n\n        best_alt = segment\n        best_cost = total_cost\n\n        for alt in alternatives:\n            alt_cost1 = sum(distance_matrix_1[alt[k], alt[k+1]] for k in range(len(alt)-1)) + distance_matrix_1[alt[-1], alt[0]]\n            alt_cost2 = sum(distance_matrix_2[alt[k], alt[k+1]] for k in range(len(alt)-1)) + distance_matrix_2[alt[-1], alt[0]]\n            alt_total = obj_weights[0] * alt_cost1 + obj_weights[1] * alt_cost2\n\n            if alt_total < best_cost:\n                best_cost = alt_total\n                best_alt = alt\n\n        new_solution[i:j] = best_alt\n\n    # Pareto-guided node insertion\n    if random.random() < 0.6:\n        node_to_move = random.choice(new_solution)\n        current_pos = np.where(new_solution == node_to_move)[0][0]\n\n        # Find best insertion position\n        best_pos = current_pos\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == current_pos:\n                continue\n\n            # Remove from current position\n            prev = new_solution[current_pos-1] if current_pos > 0 else new_solution[-1]\n            next_node = new_solution[(current_pos+1)%n]\n\n            # Insert at new position\n            new_prev = new_solution[pos-1] if pos > 0 else new_solution[-1]\n            new_next = new_solution[pos]\n\n            # Calculate improvement\n            original_cost = (distance_matrix_1[prev, node_to_move] + distance_matrix_1[node_to_move, next_node] +\n                            distance_matrix_2[prev, node_to_move] + distance_matrix_2[node_to_move, next_node])\n\n            new_cost = (distance_matrix_1[new_prev, node_to_move] + distance_matrix_1[node_to_move, new_next] +\n                         distance_matrix_2[new_prev, node_to_move] + distance_matrix_2[node_to_move, new_next])\n\n            improvement = original_cost - new_cost\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != current_pos:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm implements a multi-objective selection strategy that combines a novel \"objective-aware\" segment inversion with adaptive node insertion, using a hybrid local search operator that dynamically combines segment reversal with a \"proximity-based\" node relocation to balance improvement across both objectives while maintaining feasibility through strict validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-aware selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        weight = 0.4 if obj[0] > obj1_avg and obj[1] > obj2_avg else 0.2\n        score = (obj[0] / obj1_avg) * weight + (obj[1] / obj2_avg) * (1 - weight)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with objective preference\n    if n > 3 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j+1 if j+1 < n else 0]] -\n                           distance_matrix_1[new_solution[i-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[j+1 if j+1 < n else 0]])\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j+1 if j+1 < n else 0]] -\n                           distance_matrix_2[new_solution[i-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[j+1 if j+1 < n else 0]])\n\n        if (obj1_improvement < 0 and obj2_improvement < 0) or (random.random() < 0.5):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Proximity-based node relocation\n    if random.random() < 0.5:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        candidates = [j for j in range(n) if j != i and abs(j - i) > 1]\n\n        if candidates:\n            j = random.choice(candidates)\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (distance_matrix_1[prev_i, node] + distance_matrix_1[node, next_i] +\n                           distance_matrix_2[prev_i, node] + distance_matrix_2[node, next_i])\n\n            new_cost = (distance_matrix_1[prev_j, node] + distance_matrix_1[node, next_j] +\n                       distance_matrix_2[prev_j, node] + distance_matrix_2[node, next_j])\n\n            if new_cost < original_cost or random.random() < 0.3:\n                new_solution = np.delete(new_solution, i)\n                if i < j:\n                    new_solution = np.insert(new_solution, j-1, node)\n                else:\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm implements a multi-objective selection strategy that uses a hybrid \"objective-balance\" segment crossover with adaptive node relocation, leveraging a novel \"improvement-weighted\" node swapping mechanism to balance improvement across both objectives while maintaining feasibility through strict validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-balance selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        balance = (obj[0] / obj1_avg) * (obj[1] / obj2_avg)\n        score = (obj[0] / obj1_avg) * (0.5 + 0.5 * balance) + (obj[1] / obj2_avg) * (0.5 - 0.5 * balance)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-balance segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Improvement-weighted node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate weighted improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        original_cost = (0.6 * distance_matrix_1[prev_i, node_i] + 0.4 * distance_matrix_1[node_i, next_i] +\n                         0.4 * distance_matrix_1[prev_j, node_j] + 0.6 * distance_matrix_1[node_j, next_j] +\n                         0.6 * distance_matrix_2[prev_i, node_i] + 0.4 * distance_matrix_2[node_i, next_i] +\n                         0.4 * distance_matrix_2[prev_j, node_j] + 0.6 * distance_matrix_2[node_j, next_j])\n\n        new_cost = (0.6 * distance_matrix_1[prev_i, node_j] + 0.4 * distance_matrix_1[node_j, next_i] +\n                    0.4 * distance_matrix_1[prev_j, node_i] + 0.6 * distance_matrix_1[node_i, next_j] +\n                    0.6 * distance_matrix_2[prev_i, node_j] + 0.4 * distance_matrix_2[node_j, next_i] +\n                    0.4 * distance_matrix_2[prev_j, node_i] + 0.6 * distance_matrix_2[node_i, next_j])\n\n        if new_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This new algorithm implements a multi-objective selection strategy that combines a novel \"objective-aware\" segment inversion with adaptive node insertion, using a hybrid local search operator that dynamically combines segment reversal with a \"proximity-based\" node relocation to balance improvement across both objectives while maintaining feasibility through strict validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-aware selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        weight = 0.4 if obj[0] > obj1_avg and obj[1] > obj2_avg else 0.2\n        score = (obj[0] / obj1_avg) * weight + (obj[1] / obj2_avg) * (1 - weight)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with objective preference\n    if n > 3 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j+1 if j+1 < n else 0]] -\n                           distance_matrix_1[new_solution[i-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[j+1 if j+1 < n else 0]])\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j+1 if j+1 < n else 0]] -\n                           distance_matrix_2[new_solution[i-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[j+1 if j+1 < n else 0]])\n\n        if (obj1_improvement < 0 and obj2_improvement < 0) or (random.random() < 0.5):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Proximity-based node relocation\n    if random.random() < 0.5:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        candidates = [j for j in range(n) if j != i and abs(j - i) > 1]\n\n        if candidates:\n            j = random.choice(candidates)\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (distance_matrix_1[prev_i, node] + distance_matrix_1[node, next_i] +\n                           distance_matrix_2[prev_i, node] + distance_matrix_2[node, next_i])\n\n            new_cost = (distance_matrix_1[prev_j, node] + distance_matrix_1[node, next_j] +\n                       distance_matrix_2[prev_j, node] + distance_matrix_2[node, next_j])\n\n            if new_cost < original_cost or random.random() < 0.3:\n                new_solution = np.delete(new_solution, i)\n                if i < j:\n                    new_solution = np.insert(new_solution, j-1, node)\n                else:\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            9.11972357846324,
            4.148619365462119
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-aware selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        weight = 0.4 if obj[0] > obj1_avg and obj[1] > obj2_avg else 0.2\n        score = (obj[0] / obj1_avg) * weight + (obj[1] / obj2_avg) * (1 - weight)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with objective preference\n    if n > 3 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], segment[-1]] + distance_matrix_1[segment[0], new_solution[j+1 if j+1 < n else 0]] -\n                           distance_matrix_1[new_solution[i-1], segment[0]] - distance_matrix_1[segment[-1], new_solution[j+1 if j+1 < n else 0]])\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], segment[-1]] + distance_matrix_2[segment[0], new_solution[j+1 if j+1 < n else 0]] -\n                           distance_matrix_2[new_solution[i-1], segment[0]] - distance_matrix_2[segment[-1], new_solution[j+1 if j+1 < n else 0]])\n\n        if (obj1_improvement < 0 and obj2_improvement < 0) or (random.random() < 0.5):\n            new_solution[i:j+1] = segment[::-1]\n\n    # Proximity-based node relocation\n    if random.random() < 0.5:\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        candidates = [j for j in range(n) if j != i and abs(j - i) > 1]\n\n        if candidates:\n            j = random.choice(candidates)\n            prev_i = new_solution[i-1]\n            next_i = new_solution[(i+1)%n]\n            prev_j = new_solution[j-1]\n            next_j = new_solution[(j+1)%n]\n\n            original_cost = (distance_matrix_1[prev_i, node] + distance_matrix_1[node, next_i] +\n                           distance_matrix_2[prev_i, node] + distance_matrix_2[node, next_i])\n\n            new_cost = (distance_matrix_1[prev_j, node] + distance_matrix_1[node, next_j] +\n                       distance_matrix_2[prev_j, node] + distance_matrix_2[node, next_j])\n\n            if new_cost < original_cost or random.random() < 0.3:\n                new_solution = np.delete(new_solution, i)\n                if i < j:\n                    new_solution = np.insert(new_solution, j-1, node)\n                else:\n                    new_solution = np.insert(new_solution, j, node)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm implements a multi-objective selection strategy that uses a hybrid \"objective-balance\" segment crossover with adaptive node relocation, leveraging a novel \"improvement-weighted\" node swapping mechanism to balance improvement across both objectives while maintaining feasibility through strict validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-balance selection with dynamic weights\n    obj1_avg = np.mean([obj[0] for _, obj in archive])\n    obj2_avg = np.mean([obj[1] for _, obj in archive])\n\n    scores = []\n    for _, obj in archive:\n        balance = (obj[0] / obj1_avg) * (obj[1] / obj2_avg)\n        score = (obj[0] / obj1_avg) * (0.5 + 0.5 * balance) + (obj[1] / obj2_avg) * (0.5 - 0.5 * balance)\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-balance segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    # Improvement-weighted node swapping\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        # Calculate weighted improvement\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        original_cost = (0.6 * distance_matrix_1[prev_i, node_i] + 0.4 * distance_matrix_1[node_i, next_i] +\n                         0.4 * distance_matrix_1[prev_j, node_j] + 0.6 * distance_matrix_1[node_j, next_j] +\n                         0.6 * distance_matrix_2[prev_i, node_i] + 0.4 * distance_matrix_2[node_i, next_i] +\n                         0.4 * distance_matrix_2[prev_j, node_j] + 0.6 * distance_matrix_2[node_j, next_j])\n\n        new_cost = (0.6 * distance_matrix_1[prev_i, node_j] + 0.4 * distance_matrix_1[node_j, next_i] +\n                    0.4 * distance_matrix_1[prev_j, node_i] + 0.6 * distance_matrix_1[node_i, next_j] +\n                    0.6 * distance_matrix_2[prev_i, node_j] + 0.4 * distance_matrix_2[node_j, next_i] +\n                    0.4 * distance_matrix_2[prev_j, node_i] + 0.6 * distance_matrix_2[node_i, next_j])\n\n        if new_cost < original_cost:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This new algorithm implements a multi-objective selection strategy using a hybrid \"objective-dominance\" segment crossover with adaptive node relocation, leveraging a novel \"cost-difference\" node swapping mechanism to prioritize improvements in the more critical objective while maintaining feasibility through strict validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-dominance selection\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n\n    obj1_min, obj1_max = min(obj1_values), max(obj1_values)\n    obj2_min, obj2_max = min(obj2_values), max(obj2_values)\n\n    scores = []\n    for obj in archive[1]:\n        obj1_norm = (obj[0] - obj1_min) / (obj1_max - obj1_min) if obj1_max != obj1_min else 0.5\n        obj2_norm = (obj[1] - obj2_min) / (obj2_max - obj2_min) if obj2_max != obj2_min else 0.5\n        score = max(obj1_norm, obj2_norm) * (1 - 0.5 * min(obj1_norm, obj2_norm))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-dominance segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        if random.random() < 0.7:\n            segment = np.roll(segment, shift=1)\n        else:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Cost-difference node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        original_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i]\n        original_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i]\n        new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i]\n        new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            8.12961353477664,
            7.6832512012383845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Objective-dominance selection\n    obj1_values = [obj[0] for _, obj in archive]\n    obj2_values = [obj[1] for _, obj in archive]\n\n    obj1_min, obj1_max = min(obj1_values), max(obj1_values)\n    obj2_min, obj2_max = min(obj2_values), max(obj2_values)\n\n    scores = []\n    for obj in archive[1]:\n        obj1_norm = (obj[0] - obj1_min) / (obj1_max - obj1_min) if obj1_max != obj1_min else 0.5\n        obj2_norm = (obj[1] - obj2_min) / (obj2_max - obj2_min) if obj2_max != obj2_min else 0.5\n        score = max(obj1_norm, obj2_norm) * (1 - 0.5 * min(obj1_norm, obj2_norm))\n        scores.append(score)\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: objective-dominance segment crossover\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5 and random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j]\n        if random.random() < 0.7:\n            segment = np.roll(segment, shift=1)\n        else:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    # Cost-difference node swapping\n    if random.random() < 0.6:\n        i, j = random.sample(range(n), 2)\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n\n        prev_i = new_solution[i-1]\n        next_i = new_solution[(i+1)%n]\n        prev_j = new_solution[j-1]\n        next_j = new_solution[(j+1)%n]\n\n        original_cost1 = distance_matrix_1[prev_i, node_i] + distance_matrix_1[node_i, next_i]\n        original_cost2 = distance_matrix_2[prev_i, node_i] + distance_matrix_2[node_i, next_i]\n        new_cost1 = distance_matrix_1[prev_i, node_j] + distance_matrix_1[node_j, next_i]\n        new_cost2 = distance_matrix_2[prev_i, node_j] + distance_matrix_2[node_j, next_i]\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    }
]