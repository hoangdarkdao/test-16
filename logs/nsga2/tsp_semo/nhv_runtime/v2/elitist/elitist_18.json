[
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This new algorithm employs an objective-balanced segment relocation with dynamic segment size adaptation that prioritizes segments based on their normalized objective contributions, using a hybrid insertion-reversal mechanism with probabilistic segment contraction to explore the solution space while ensuring feasibility through strict validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on normalized objective contributions\n    num_segments = random.randint(1, min(2, n//3))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate normalized segment contributions\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n        norm_contrib = (obj1_contrib + obj2_contrib) / (1 + obj1_contrib * obj2_contrib)\n\n        # Adaptive segment modification\n        if norm_contrib > 0.6:  # High normalized contribution, prioritize relocation\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:\n            if random.random() < 0.6:  # 60% chance to reverse\n                new_solution[start:end] = segment[::-1]\n            else:  # 40% chance to contract segment\n                contract_size = min(1, end - start)\n                if contract_size > 0:\n                    new_solution[start:end-contract_size] = segment[:-contract_size]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7418749997822319,
            0.07770830392837524
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment insertion with objective-aware segment prioritization that dynamically selects segments based on their relative contributions to both objectives, using a hybrid relocation-reversal mechanism with probabilistic segment expansion to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product\n    selected = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective product\n    num_segments = random.randint(1, min(3, n//4))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(3, min(5, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib * obj2_contrib > (obj1_contrib + obj2_contrib) * 0.8:  # High product, prioritize relocation\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_solution[start:end] = segment[::-1]\n            else:  # 30% chance to expand segment\n                expand_size = min(2, n - end)\n                if expand_size > 0:\n                    new_solution[start:end+expand_size] = np.concatenate([segment, new_solution[end:end+expand_size]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8994950836774224,
            0.08968448638916016
        ]
    },
    {
        "algorithm": "{This new algorithm employs an objective-balanced segment relocation with dynamic segment size adaptation that prioritizes segments based on their normalized objective contributions, using a hybrid insertion-reversal mechanism with probabilistic segment contraction to explore the solution space while ensuring feasibility through strict validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective sum\n    selected = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (1 + x[1][0] * x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on normalized objective contributions\n    num_segments = random.randint(1, min(2, n//3))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate normalized segment contributions\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n        norm_contrib = (obj1_contrib + obj2_contrib) / (1 + obj1_contrib * obj2_contrib)\n\n        # Adaptive segment modification\n        if norm_contrib > 0.6:  # High normalized contribution, prioritize relocation\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:\n            if random.random() < 0.6:  # 60% chance to reverse\n                new_solution[start:end] = segment[::-1]\n            else:  # 40% chance to contract segment\n                contract_size = min(1, end - start)\n                if contract_size > 0:\n                    new_solution[start:end-contract_size] = segment[:-contract_size]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7418749997822319,
            0.07770830392837524
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment insertion with objective-aware segment prioritization that dynamically selects segments based on their relative contributions to both objectives, using a hybrid relocation-reversal mechanism with probabilistic segment expansion to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product\n    selected = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective product\n    num_segments = random.randint(1, min(3, n//4))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(3, min(5, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib * obj2_contrib > (obj1_contrib + obj2_contrib) * 0.8:  # High product, prioritize relocation\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_solution[start:end] = segment[::-1]\n            else:  # 30% chance to expand segment\n                expand_size = min(2, n - end)\n                if expand_size > 0:\n                    new_solution[start:end+expand_size] = np.concatenate([segment, new_solution[end:end+expand_size]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8994950836774224,
            0.08968448638916016
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment insertion with objective-aware segment prioritization that dynamically selects segments based on their relative contributions to both objectives, using a hybrid relocation-reversal mechanism with probabilistic segment expansion to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product\n    selected = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective product\n    num_segments = random.randint(1, min(3, n//4))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(3, min(5, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib * obj2_contrib > (obj1_contrib + obj2_contrib) * 0.8:  # High product, prioritize relocation\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_solution[start:end] = segment[::-1]\n            else:  # 30% chance to expand segment\n                expand_size = min(2, n - end)\n                if expand_size > 0:\n                    new_solution[start:end+expand_size] = np.concatenate([segment, new_solution[end:end+expand_size]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8994950836774224,
            0.08968448638916016
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment relocation with objective-aware segment prioritization that dynamically selects and relocates segments based on their relative contributions to both objectives, using a hybrid inversion-expansion mechanism with probabilistic segment merging to explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value\n    selected = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(5, n//2))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(2, min(6, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2 improvement\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1 improvement\n            if random.random() < 0.5:\n                new_solution[start:end] = segment[::-1]\n            else:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:  # Balanced, perform probabilistic operations\n            if random.random() < 0.4:\n                new_solution[start:end] = segment[::-1]\n            else:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n\n        # Probabilistic segment merging\n        if random.random() < 0.3 and len(segment) > 2:\n            merge_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:merge_pos], segment, np.delete(new_solution, range(start, end))])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9678444670778921,
            0.11772149801254272
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment insertion with objective-aware segment prioritization that dynamically selects segments based on their relative contributions to both objectives, using a hybrid relocation-reversal mechanism with probabilistic segment expansion to explore the solution space more effectively while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective product\n    selected = max(archive, key=lambda x: x[1][0] * x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective product\n    num_segments = random.randint(1, min(3, n//4))\n    segment_starts = sorted(random.sample(range(n), num_segments))\n    segment_sizes = [random.randint(3, min(5, n//num_segments)) for _ in range(num_segments)]\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib * obj2_contrib > (obj1_contrib + obj2_contrib) * 0.8:  # High product, prioritize relocation\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        else:\n            if random.random() < 0.7:  # 70% chance to reverse\n                new_solution[start:end] = segment[::-1]\n            else:  # 30% chance to expand segment\n                expand_size = min(2, n - end)\n                if expand_size > 0:\n                    new_solution[start:end+expand_size] = np.concatenate([segment, new_solution[end:end+expand_size]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8994950836774224,
            0.08968448638916016
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{This novel algorithm employs an adaptive multi-segment inversion with objective-aware segment selection that dynamically balances segment sizes and positions based on their relative contributions to both objectives, while using a probabilistic segment insertion mechanism to ensure diverse exploration of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined normalized objective value\n    total_obj1 = sum(x[1][0] for x in archive)\n    total_obj2 = sum(x[1][1] for x in archive)\n    selected = max(archive, key=lambda x: (x[1][0]/total_obj1 + x[1][1]/total_obj2 if total_obj1 > 0 and total_obj2 > 0 else x[1][0] + x[1][1]))[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Dynamic segment selection based on objective balance\n    num_segments = random.randint(2, min(4, n//3))\n    segment_sizes = [random.randint(2, min(4, n//num_segments)) for _ in range(num_segments)]\n    segment_starts = sorted(random.sample(range(n), num_segments))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Adaptive segment modification\n        if obj1_contrib > obj2_contrib * 1.1:  # More in obj1, prioritize obj2\n            # Insert segment in reverse order with probability based on imbalance\n            if random.random() < (obj1_contrib - obj2_contrib)/max(obj1_contrib, obj2_contrib):\n                new_solution[start:end] = segment[::-1]\n            else:\n                # Relocate segment to position that might improve obj2\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.1:  # More in obj2, prioritize obj1\n            # Relocate segment with probability based on imbalance\n            if random.random() < (obj2_contrib - obj1_contrib)/max(obj1_contrib, obj2_contrib):\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                # Insert segment in reverse order\n                new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform probabilistic both operations\n            if random.random() < 0.6:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -1.0565294703576642,
            0.14040547609329224
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{This algorithm employs a multi-objective-aware segment inversion and insertion strategy that dynamically adapts segment modifications based on their Pareto dominance in both objective spaces, using a novel dominance-based segment selection and insertion mechanism to explore non-dominated regions of the objective space while maintaining solution feasibility through a constrained perturbation framework.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate Pareto dominance for each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Determine Pareto dominance\n        dominates_obj1 = any(obj1_contrib < x[1][0] and obj2_contrib <= x[1][1] for x in archive)\n        dominates_obj2 = any(obj2_contrib < x[1][1] and obj1_contrib <= x[1][0] for x in archive)\n\n        if dominates_obj1 and dominates_obj2:\n            # Non-dominated segment - perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n        elif dominates_obj1:\n            # Dominates in obj1 - prioritize obj2 improvement\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif dominates_obj2:\n            # Dominates in obj2 - prioritize obj1 improvement\n            new_solution[start:end] = segment[::-1]\n        else:\n            # Neither dominates - perform random operation\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9457387830237538,
            0.10093605518341064
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    },
    {
        "algorithm": "{This new algorithm combines a dynamic segment relocation with an adaptive objective-biased edge insertion that selectively modifies segments based on their contribution to both objectives, while maintaining solution feasibility through a constrained perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective value (potential for improvement)\n    selected = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Calculate objective contributions of each segment\n    segment_sizes = [random.randint(2, min(5, n//2)) for _ in range(3)]\n    segment_starts = sorted(random.sample(range(n), 3))\n\n    for size, start in zip(segment_sizes, segment_starts):\n        end = min(start + size, n)\n        segment = new_solution[start:end]\n\n        # Calculate segment's contribution to both objectives\n        obj1_contrib = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_1[segment[-1], segment[0]]\n        obj2_contrib = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1)) + distance_matrix_2[segment[-1], segment[0]]\n\n        # Decide whether to modify this segment based on objective balance\n        if obj1_contrib > obj2_contrib * 1.2:  # More in obj1, prioritize obj2\n            # Relocate segment to position that might improve obj2\n            new_pos = random.randint(0, n-1)\n            new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n        elif obj2_contrib > obj1_contrib * 1.2:  # More in obj2, prioritize obj1\n            # Insert segment in reverse order to potentially improve obj1\n            new_solution[start:end] = segment[::-1]\n        else:  # Balanced, perform both operations\n            if random.random() < 0.5:\n                new_pos = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:new_pos], segment, np.delete(new_solution, range(start, end))])\n            else:\n                new_solution[start:end] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9377224748701751,
            0.0983656644821167
        ]
    }
]