[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.496002494185099,
            8.748965748650448
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.284836363990623,
            5.758579697138991
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.031024429137359,
            6.175923263307726
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity metrics, then applies a novel local search operator that combines multi-segment reversals with adaptive node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better combined objective and diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj, axis=1)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.argmin(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using multi-segment reversal with adaptive insertion\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Randomly select multiple segments to reverse\n        num_segments = np.random.randint(1, min(3, N//2))\n        segments = []\n        for _ in range(num_segments):\n            start = np.random.randint(0, N-1)\n            end = np.random.randint(start+1, min(start+3, N))\n            segments.append((start, end))\n\n        # Apply reversals\n        for start, end in segments:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Adaptive node insertion\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            while j == i:\n                j = np.random.randint(0, N)\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            insert_pos = np.random.randint(0, N-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.752625469931836,
            7.207532138370265
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted objective score, then applies a hybrid local search combining edge swapping with a probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.array([0.7, 0.3])  # Weight for first objective is higher\n    weighted_scores = np.sum(objectives * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: edge swapping with probabilistic node relocation\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Edge swapping\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        # Probabilistic node relocation\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            5.496002494185099,
            8.748965748650448
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy that prioritizes solutions with both good objective values and high structural diversity, then applies a hybrid local search operator that combines edge insertion with segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with good objectives and high diversity\n    objectives = np.array([obj for (_, obj) in archive])\n    solutions = [sol for (sol, _) in archive]\n    N = len(solutions[0])\n\n    # Calculate diversity scores (number of unique edges)\n    diversity_scores = []\n    for i in range(len(solutions)):\n        edges = set()\n        for j in range(N):\n            edges.add((solutions[i][j], solutions[i][(j+1)%N]))\n        diversity_scores.append(len(edges))\n\n    # Combine objective and diversity scores\n    weights = np.random.uniform(0.4, 0.6)\n    combined_scores = weights * (objectives[:, 0] + objectives[:, 1]) + (1 - weights) * (1 / np.array(diversity_scores))\n    selected_idx = np.argmin(combined_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Generate neighbor using hybrid local search: edge insertion with segment relocation\n    new_solution = base_solution.copy()\n\n    if N > 3:\n        # Randomly select a segment to relocate\n        seg_length = np.random.randint(2, min(5, N//2))\n        start = np.random.randint(0, N - seg_length)\n        segment = new_solution[start:start+seg_length]\n\n        # Remove the segment\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n\n        # Find insertion point that minimizes both objectives\n        best_pos = 0\n        min_cost = float('inf')\n\n        for pos in range(len(new_solution)):\n            # Insert segment at position pos\n            candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate total cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%N]] for i in range(N))\n            total_cost = cost1 + cost2\n\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        # Insert segment at best position\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.284836363990623,
            5.758579697138991
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining 3-opt with a probabilistic node insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution: prioritize solutions with better normalized objective\n    objectives = np.array([obj for (_, obj) in archive])\n    normalized_obj = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized_obj, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        # Hybrid local search: 3-opt with probabilistic node insertion\n        a, b, c = np.random.choice(N, 3, replace=False)\n        a, b, c = sorted([a, b, c])\n\n        # Apply 3-opt\n        new_solution[a:b] = new_solution[a:b][::-1]\n        new_solution[b:c] = new_solution[b:c][::-1]\n\n        # Probabilistic node insertion\n        if np.random.random() < 0.3:\n            i = np.random.randint(0, N)\n            j = np.random.randint(0, N)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.031024429137359,
            6.175923263307726
        ]
    }
]