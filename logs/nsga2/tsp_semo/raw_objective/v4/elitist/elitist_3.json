[
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility, using a different parameter setting for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.7:  # Increased probability\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping with increased iterations\n    for _ in range(3):  # Increased to 3 rounds\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check with relaxed conditions\n        if (candidate_cost1 <= current_cost1 * 1.05 and candidate_cost2 < current_cost2 * 1.05) or \\\n           (candidate_cost1 < current_cost1 * 1.05 and candidate_cost2 <= current_cost2 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.586758163817032,
            5.824724534941522
        ]
    },
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping\n    for _ in range(2):  # Apply 2 rounds of edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2) or \\\n           (candidate_cost1 < current_cost1 and candidate_cost2 <= current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            5.789702237493191,
            7.209759566731042
        ]
    },
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping\n    for _ in range(2):  # Apply 2 rounds of edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2) or \\\n           (candidate_cost1 < current_cost1 and candidate_cost2 <= current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            5.789702237493191,
            7.209759566731042
        ]
    },
    {
        "algorithm": "{This novel hybrid local search operator combines a dynamic segment relocation strategy with a probabilistic path smoothing heuristic, guided by a Pareto-compliant improvement criterion to balance improvements in both objectives while ensuring feasibility through a dynamic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply dynamic segment relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to relocate\n    segment_length = random.randint(2, min(5, n//2))\n    start_pos = random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos+segment_length]\n\n    # Create candidate by removing the segment\n    candidate = np.concatenate([new_solution[:start_pos], new_solution[start_pos+segment_length:]])\n\n    # Find best insertion point for the segment\n    best_pos = 0\n    best_score = float('inf')\n\n    for pos in range(n - segment_length + 1):\n        # Insert segment at position pos\n        temp_solution = np.concatenate([candidate[:pos], segment, candidate[pos:]])\n\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n))\n\n        # Weighted score (Pareto-compliant)\n        score = max(total_dist1, total_dist2)\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    # Insert segment at best position\n    new_solution = np.concatenate([candidate[:best_pos], segment, candidate[best_pos:]])\n\n    # Probabilistic path smoothing for further improvement\n    if random.random() < 0.4:  # 40% chance to apply path smoothing\n        # Select a random segment to smooth\n        smooth_start = random.randint(0, n - 3)\n        smooth_segment = new_solution[smooth_start:smooth_start+3]\n\n        # Create candidate by reversing the segment\n        candidate_smooth = new_solution.copy()\n        candidate_smooth[smooth_start:smooth_start+3] = smooth_segment[::-1]\n\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[candidate_smooth[i-1], candidate_smooth[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate_smooth[i-1], candidate_smooth[i]] for i in range(n))\n\n        # Accept if Pareto-compliant improvement\n        original_dist1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n        original_dist2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n        if (total_dist1 <= original_dist1 and total_dist2 <= original_dist2) and (total_dist1 < original_dist1 or total_dist2 < original_dist2):\n            new_solution = candidate_smooth\n\n    return new_solution\n\n",
        "score": [
            6.2102437502751275,
            5.966343043946731
        ]
    },
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility, using a different parameter setting for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.7:  # Increased probability\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping with increased iterations\n    for _ in range(3):  # Increased to 3 rounds\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check with relaxed conditions\n        if (candidate_cost1 <= current_cost1 * 1.05 and candidate_cost2 < current_cost2 * 1.05) or \\\n           (candidate_cost1 < current_cost1 * 1.05 and candidate_cost2 <= current_cost2 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.586758163817032,
            5.824724534941522
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search operator that combines a multi-objective segment inversion heuristic with a probabilistic node relocation strategy, guided by a Pareto-based evaluation criterion to balance improvements in both objectives while maintaining solution feasibility through a comprehensive validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    weights = np.array([1.0 / (obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective segment inversion heuristic\n    for _ in range(3):  # Apply 3 rounds of segment inversions\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto improvement check\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2) or \\\n           (candidate_cost1 < current_cost1 and candidate_cost2 <= current_cost2):\n            new_solution = candidate\n\n    # Probabilistic node relocation strategy\n    if random.random() < 0.4:  # 40% chance to apply relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Create candidate solution\n            candidate = np.delete(new_solution, node_idx)\n            candidate = np.insert(candidate, pos, node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.135236752345165,
            6.072703628148185
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt move with a probabilistic edge reversal heuristic, guided by a normalized Pareto dominance criterion to balance improvements in both objectives while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply dynamic 4-opt with probabilistic edge reversal\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select four random edges to modify\n    i, j, k, l = sorted(random.sample(range(1, n), 4))\n\n    # Create candidate solutions for 4-opt\n    candidates = []\n    # 4-opt move 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j] = candidate1[i:j][::-1]\n    candidates.append(candidate1)\n\n    # 4-opt move 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k] = candidate2[j:k][::-1]\n    candidates.append(candidate2)\n\n    # 4-opt move 3: Reverse segment between k and l\n    candidate3 = new_solution.copy()\n    candidate3[k:l] = candidate3[k:l][::-1]\n    candidates.append(candidate3)\n\n    # 4-opt move 4: Reverse entire segment between i and l\n    candidate4 = new_solution.copy()\n    candidate4[i:l] = candidate4[i:l][::-1]\n    candidates.append(candidate4)\n\n    # Evaluate candidates based on normalized improvement in both objectives\n    best_candidate = new_solution.copy()\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Normalized score (weighted sum with normalization)\n        norm_dist1 = total_dist1 / (distance_matrix_1.max() + 1e-6)\n        norm_dist2 = total_dist2 / (distance_matrix_2.max() + 1e-6)\n        score = 0.5 * norm_dist1 + 0.5 * norm_dist2\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    # Probabilistic edge reversal for further improvement\n    if random.random() < 0.4:  # 40% chance to apply edge reversal\n        # Select two random edges to potentially reverse\n        a, b = sorted(random.sample(range(n), 2))\n\n        # Create candidate by reversing the segment between a and b\n        candidate_reverse = best_candidate.copy()\n        candidate_reverse[a:b] = candidate_reverse[a:b][::-1]\n\n        # Validate the candidate is still a valid tour\n        if len(np.unique(candidate_reverse)) == n:\n            best_candidate = candidate_reverse\n\n    return best_candidate\n\n",
        "score": [
            5.959956004664356,
            6.683964373425297
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic segment rearrangement with a probabilistic node reinsertion heuristic, guided by a multi-objective improvement criterion that considers both objectives' improvements while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rearrangement\n    segment_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Create candidate by moving the segment to a new position\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    new_pos = random.randint(0, len(remaining))\n    candidate = np.concatenate([remaining[:new_pos], segment, remaining[new_pos:]])\n\n    # Evaluate the candidate\n    def calculate_score(solution):\n        total_dist1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n        return total_dist1 + total_dist2\n\n    current_score = calculate_score(new_solution)\n    candidate_score = calculate_score(candidate)\n\n    if candidate_score < current_score:\n        new_solution = candidate.copy()\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:  # 40% chance to apply node reinsertion\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node and find the best position to reinsert\n        temp_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate_reinsert = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n            score = calculate_score(candidate_reinsert)\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.0465091550003764,
            6.455644376518854
        ]
    },
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.5:\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping\n    for _ in range(2):  # Apply 2 rounds of edge swaps\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2) or \\\n           (candidate_cost1 < current_cost1 and candidate_cost2 <= current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            5.789702237493191,
            7.209759566731042
        ]
    }
]