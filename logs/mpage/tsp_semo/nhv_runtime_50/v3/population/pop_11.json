[
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a multi-objective adaptive local search strategy that intelligently selects a promising solution from the archive based on a combined objective score (normalized sum of both objectives), then applies a novel hybrid local search operator that combines edge insertion with a biased random walk to explore high-potential regions of the search space. The method first identifies the Pareto-frontier solutions in the archive, then selects a base solution probabilistically weighted by its dominance and diversity, followed by a two-stage perturbation: 1) a constrained segment inversion that preserves node connectivity, and 2) a multi-objective-aware edge swap that prioritizes improvements in both objectives while ensuring feasibility through a validation check. The generated neighbor solution is guaranteed to be a valid TSP tour through the use of a permutation repair mechanism that corrects any invalid sequences.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a base solution (weighted random selection)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = objectives / np.max(objectives, axis=0)\n    combined_scores = np.sum(norm_obj, axis=1)\n    probabilities = combined_scores / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Stage 1: Constrained segment inversion\n    if n > 3:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n    # Stage 2: Multi-objective-aware edge swap\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost before swap\n        prev_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        prev_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                      distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Calculate cost after swap\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Accept if both objectives improve\n        if (new_cost1 < prev_cost1) and (new_cost2 < prev_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism if invalid\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -0.9434502893378602,
               0.6291956901550293
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone idea of intelligent solution selection and hybrid local search from the provided algorithms, but introduces a novel approach by combining multi-objective solution evaluation with a dynamic segment insertion mechanism. It first identifies the most promising solutions in the archive by analyzing their dominance relationships and combined objective values, then employs a weighted random selection to choose a base solution with higher probability for better-performing solutions. The hybrid local search operator dynamically selects and inserts a segment from one part of the tour into another position, evaluating the impact on both objectives and accepting the change if it improves at least one objective or with a small probability if it doesn't. The algorithm incorporates a multi-objective-aware acceptance criterion, a fallback mechanism to ensure solution feasibility, and a secondary segment insertion attempt if the initial insertion doesn't yield improvement, while going beyond standard segment-based operations by considering dynamic segment selection and insertion points based on both objective spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions and select base solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        combined_costs = [obj[0] + obj[1] for _, obj in archive]\n        selected_idx = np.argmin(combined_costs)\n    else:\n        qualities = [1.0 / (1.0 + archive[i][1][0] + archive[i][1][1]) for i in non_dominated]\n        selected_idx = random.choices(non_dominated, weights=qualities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search with dynamic segment insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Select a random segment to insert elsewhere\n    segment_start = random.randint(0, n - 3)\n    segment_length = random.randint(2, min(4, n - segment_start - 1))\n    segment_end = segment_start + segment_length\n    segment = new_solution[segment_start:segment_end]\n\n    # Calculate segment cost\n    def calculate_segment_cost(sol, start, end):\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(start, end):\n            cost1 += distance_matrix_1[sol[i], sol[(i+1)%n]]\n            cost2 += distance_matrix_2[sol[i], sol[(i+1)%n]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_segment_cost(new_solution, segment_start, segment_end)\n\n    # Remove the segment from its current position\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end:]])\n\n    # Find a new position to insert the segment\n    insert_pos = random.randint(0, n - segment_length - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Calculate new segment cost\n    new_cost1, new_cost2 = calculate_segment_cost(new_solution, insert_pos, insert_pos + segment_length)\n\n    # Acceptance criterion\n    if not (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) and random.random() >= 0.3:\n        # If not accepted, try another insertion position\n        for _ in range(2):\n            new_insert_pos = random.randint(0, n - segment_length - 1)\n            temp_solution = np.concatenate([new_solution[:new_insert_pos], segment, new_solution[new_insert_pos:]])\n            temp_cost1, temp_cost2 = calculate_segment_cost(temp_solution, new_insert_pos, new_insert_pos + segment_length)\n            if (temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2) or random.random() < 0.2:\n                new_solution = temp_solution\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9076509273958202,
               0.41547876596450806
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions and select base solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        combined_costs = [obj[0] + obj[1] for _, obj in archive]\n        selected_idx = np.argmin(combined_costs)\n    else:\n        qualities = [1.0 / (1.0 + archive[i][1][0] + archive[i][1][1]) for i in non_dominated]\n        selected_idx = random.choices(non_dominated, weights=qualities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search with dynamic node swapping\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    def calculate_total_cost(sol):\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(n):\n            cost1 += distance_matrix_1[sol[i], sol[(i+1)%n]]\n            cost2 += distance_matrix_2[sol[i], sol[(i+1)%n]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_total_cost(new_solution)\n\n    # Select two nodes to swap based on their relative positions in both spaces\n    i, j = random.sample(range(n), 2)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n\n    # Calculate the contribution of each node to both objectives\n    def calculate_node_contribution(sol, idx):\n        node = sol[idx]\n        prev_node = sol[idx-1]\n        next_node = sol[(idx+1)%n]\n        cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n        return cost1, cost2\n\n    contrib_i1, contrib_i2 = calculate_node_contribution(new_solution, i)\n    contrib_j1, contrib_j2 = calculate_node_contribution(new_solution, j)\n\n    # Perform the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Calculate new costs\n    new_cost1, new_cost2 = calculate_total_cost(new_solution)\n\n    # Acceptance criterion\n    if not (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) and random.random() >= 0.2:\n        # If not accepted, try another swap\n        for _ in range(2):\n            i_new, j_new = random.sample(range(n), 2)\n            new_solution[i_new], new_solution[j_new] = new_solution[j_new], new_solution[i_new]\n            temp_cost1, temp_cost2 = calculate_total_cost(new_solution)\n            if (temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2) or random.random() < 0.15:\n                break\n            new_solution[i_new], new_solution[j_new] = new_solution[j_new], new_solution[i_new]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9729095779833985,
               0.7925425171852112
          ]
     },
     {
          "algorithm": "{The new algorithm will employ a hybrid Pareto-geometric selection and path reconstruction strategy that combines a probabilistic dominance-based solution selection with a novel objective-space alignment operator. First, it will use non-dominated sorting to identify promising solutions in the archive, then probabilistically select a base solution based on its Pareto rank. Next, it will analyze the geometric alignment of nodes in both objective spaces using a custom alignment metric, and reconstruct the tour by sequentially connecting nodes that show the highest alignment potential in both spaces, with a dynamic segment reordering mechanism that alternates between objective spaces to balance improvement in both dimensions. The method will ensure feasibility through a permutation validation step and a geometric repair mechanism if needed, while prioritizing edges that show the most promising alignment improvement in both spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Pareto-based probabilistic selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Objective-space alignment analysis\n    alignment_scores = []\n    for i in range(n):\n        u = new_solution[i]\n        v = new_solution[(i + 1) % n]\n\n        # Calculate alignment metric: cosine similarity of direction vectors\n        vec1 = instance[v, :2] - instance[u, :2]\n        vec2 = instance[v, 2:] - instance[u, 2:]\n        norm1 = np.linalg.norm(vec1)\n        norm2 = np.linalg.norm(vec2)\n\n        if norm1 > 0 and norm2 > 0:\n            cos_sim = np.dot(vec1, vec2) / (norm1 * norm2)\n            alignment_scores.append((i, cos_sim))\n        else:\n            alignment_scores.append((i, 0.0))\n\n    # Step 3: Dynamic segment reordering\n    if n > 3:\n        # Sort segments by alignment score (highest first)\n        alignment_scores.sort(key=lambda x: -x[1])\n        selected_segments = [x[0] for x in alignment_scores[:max(2, n//5)]]\n\n        # Reorder segments in alternating objective spaces\n        toggle = True\n        new_order = []\n        used_nodes = set()\n\n        for seg in selected_segments:\n            if toggle:\n                # Connect in first objective space\n                u = new_solution[seg]\n                v = new_solution[(seg + 1) % n]\n                new_order.extend([u, v])\n            else:\n                # Connect in second objective space\n                u = new_solution[seg]\n                v = new_solution[(seg + 1) % n]\n                new_order.extend([v, u])\n            toggle = not toggle\n\n        # Add remaining nodes\n        remaining_nodes = [node for node in base_solution if node not in new_order]\n        new_order.extend(remaining_nodes)\n\n        new_solution = np.array(new_order)\n\n    # Ensure solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism\n        missing = set(range(n)) - set(new_solution)\n        duplicates = [x for x in range(n) if list(new_solution).count(x) > 1]\n        for dup in duplicates:\n            pos = np.where(new_solution == dup)[0][1]\n            new_solution[pos] = missing.pop()\n\n    return new_solution\n\n",
          "score": [
               -1.027370962532713,
               2.509422779083252
          ]
     },
     {
          "algorithm": "{This algorithm introduces a novel multi-objective-aware local search strategy that combines Pareto dominance analysis with a hybrid segment exchange mechanism. It first identifies the most promising solutions by evaluating their dominance relationships and combined objective values, then employs a weighted random selection to choose a base solution with higher probability for better-performing solutions. The algorithm then performs a hybrid segment exchange operation where it selects two non-overlapping segments from different parts of the tour and exchanges them, evaluating the impact on both objectives. The acceptance criterion considers both objectives simultaneously, accepting the change if it improves at least one objective or with a small probability if it doesn't. The algorithm also includes a fallback mechanism to ensure solution feasibility and a dynamic adjustment of segment sizes based on the solution's quality. The approach goes beyond standard segment-based operations by incorporating multi-objective considerations throughout the process and dynamically adapting the segment sizes during the search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions and select base solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        # If no non-dominated solutions, select the one with minimal combined cost\n        combined_costs = [obj[0] + obj[1] for _, obj in archive]\n        selected_idx = np.argmin(combined_costs)\n    else:\n        # Select from non-dominated solutions with probability proportional to their quality\n        qualities = [1.0 / (1.0 + archive[i][1][0] + archive[i][1][1]) for i in non_dominated]\n        selected_idx = random.choices(non_dominated, weights=qualities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid segment exchange operation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate total cost before any changes\n    def calculate_total_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_total_cost(new_solution)\n\n    # Select two non-overlapping segments\n    segment1_length = random.randint(2, min(4, n // 2 - 1))\n    segment2_length = random.randint(2, min(4, n - segment1_length - 1))\n\n    segment1_start = random.randint(0, n - segment1_length - 1)\n    segment1_end = segment1_start + segment1_length\n\n    # Ensure segment2 doesn't overlap with segment1\n    possible_positions = list(range(0, segment1_start - segment2_length + 1)) + list(range(segment1_end, n - segment2_length + 1))\n    if not possible_positions:\n        return new_solution\n\n    segment2_start = random.choice(possible_positions)\n    segment2_end = segment2_start + segment2_length\n\n    # Extract segments\n    segment1 = new_solution[segment1_start:segment1_end]\n    segment2 = new_solution[segment2_start:segment2_end]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        new_solution[:segment1_start],\n        segment2,\n        new_solution[segment1_end:segment2_start],\n        segment1,\n        new_solution[segment2_end:]\n    ])\n\n    # Calculate new total cost\n    new_cost1, new_cost2 = calculate_total_cost(new_solution)\n\n    # Acceptance criterion\n    if not (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) and random.random() >= 0.3:\n        # If not accepted, try another segment exchange\n        for _ in range(2):\n            new_segment1_length = random.randint(2, min(4, n // 2 - 1))\n            new_segment2_length = random.randint(2, min(4, n - new_segment1_length - 1))\n\n            new_segment1_start = random.randint(0, n - new_segment1_length - 1)\n            new_segment1_end = new_segment1_start + new_segment1_length\n\n            new_possible_positions = list(range(0, new_segment1_start - new_segment2_length + 1)) + list(range(new_segment1_end, n - new_segment2_length + 1))\n            if not new_possible_positions:\n                continue\n\n            new_segment2_start = random.choice(new_possible_positions)\n            new_segment2_end = new_segment2_start + new_segment2_length\n\n            new_segment1 = new_solution[new_segment1_start:new_segment1_end]\n            new_segment2 = new_solution[new_segment2_start:new_segment2_end]\n\n            temp_solution = np.concatenate([\n                new_solution[:new_segment1_start],\n                new_segment2,\n                new_solution[new_segment1_end:new_segment2_start],\n                new_segment1,\n                new_solution[new_segment2_end:]\n            ])\n\n            temp_cost1, temp_cost2 = calculate_total_cost(temp_solution)\n            if (temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2) or random.random() < 0.2:\n                new_solution = temp_solution\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8039436784067358,
               0.4244197607040405
          ]
     },
     {
          "algorithm": "{The new algorithm will employ a two-phase neighborhood exploration strategy that combines a probabilistic Pareto-dominance-based selection with a novel geometric path reconstruction operator. First, it will probabilistically select a solution from the archive based on its Pareto dominance rank and non-dominated sorting, then analyze the instance's geometric properties to identify clusters of nodes in each objective space using DBSCAN clustering. The algorithm will then reconstruct the tour by sequentially connecting clusters in an alternating fashion between objective spaces, ensuring feasibility through a cluster-ordering validation step that guarantees no node is skipped or revisited. The geometric path reconstruction operator will dynamically adjust the sequence of cluster connections based on the relative improvement potential in each objective space, with the final solution validated through a permutation check to ensure it remains a valid TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Pareto-based selection\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Geometric clustering and path reconstruction\n    n = len(base_solution)\n    if n < 3:\n        return base_solution\n\n    # Cluster nodes in both spaces using DBSCAN\n    from sklearn.cluster import DBSCAN\n    coords1 = instance[:, :2]\n    coords2 = instance[:, 2:]\n\n    clusterer1 = DBSCAN(eps=0.3, min_samples=2)\n    labels1 = clusterer1.fit_predict(coords1)\n\n    clusterer2 = DBSCAN(eps=0.3, min_samples=2)\n    labels2 = clusterer2.fit_predict(coords2)\n\n    # Create cluster mappings\n    clusters1 = {}\n    clusters2 = {}\n    for i, (l1, l2) in enumerate(zip(labels1, labels2)):\n        clusters1.setdefault(l1, []).append(i)\n        clusters2.setdefault(l2, []).append(i)\n\n    # Sort clusters by size (largest first)\n    sorted_clusters1 = sorted(clusters1.values(), key=lambda x: -len(x))\n    sorted_clusters2 = sorted(clusters2.values(), key=lambda x: -len(x))\n\n    # Alternate between clusters from both spaces\n    new_solution = []\n    used_nodes = set()\n    i = 0\n    j = 0\n    toggle = True  # Alternate between spaces\n\n    while len(new_solution) < n:\n        if toggle:\n            if i < len(sorted_clusters1):\n                cluster = sorted_clusters1[i]\n                i += 1\n            else:\n                cluster = sorted_clusters2[j]\n                j += 1\n        else:\n            if j < len(sorted_clusters2):\n                cluster = sorted_clusters2[j]\n                j += 1\n            else:\n                cluster = sorted_clusters1[i]\n                i += 1\n\n        toggle = not toggle\n\n        for node in cluster:\n            if node not in used_nodes:\n                new_solution.append(node)\n                used_nodes.add(node)\n\n    # Ensure all nodes are included\n    remaining_nodes = [node for node in base_solution if node not in new_solution]\n    new_solution.extend(remaining_nodes)\n\n    # Convert to numpy array and validate\n    new_solution = np.array(new_solution)\n    if len(np.unique(new_solution)) != n or len(new_solution) != n:\n        # Fallback to simple swap if invalid\n        new_solution = base_solution.copy()\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n",
          "score": [
               -1.0065441045515167,
               4.810353696346283
          ]
     },
     {
          "algorithm": "{The new algorithm will employ a hybrid approach combining a multi-objective aware edge insertion heuristic with a constrained geometric perturbation, where it first identifies critical edges in the Pareto frontier solutions using a geometric analysis of the instance coordinates, then probabilistically selects a base solution based on its geometric diversity, followed by a two-phase perturbation process: 1) a directed edge insertion that prioritizes edges connecting geometrically distant nodes while maintaining Pareto optimality, and 2) a constrained geometric rotation that dynamically selects and rotates segments based on the relative positions of nodes in both objective spaces, with feasibility maintained through a geometric validation check and a permutation repair mechanism that ensures the solution remains a valid tour by reconstructing the tour using a nearest-neighbor approach from the closest valid node if invalidity is detected.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify critical edges in Pareto frontier solutions\n    pareto_front = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(sol_i)\n\n    if not pareto_front:\n        pareto_front = [sol for sol, _ in archive]\n\n    # Step 2: Select base solution based on geometric diversity\n    def geometric_diversity(sol):\n        coords1 = instance[sol, :2]\n        coords2 = instance[sol, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n        diversity = np.sum(np.linalg.norm(coords1 - centroid1, axis=1)) + np.sum(np.linalg.norm(coords2 - centroid2, axis=1))\n        return diversity\n\n    base_solution = max(pareto_front, key=geometric_diversity).copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Directed edge insertion\n    if n > 3:\n        # Find geometrically distant nodes\n        coords1 = instance[new_solution, :2]\n        coords2 = instance[new_solution, 2:]\n        distances1 = np.linalg.norm(coords1 - np.roll(coords1, 1, axis=0), axis=1)\n        distances2 = np.linalg.norm(coords2 - np.roll(coords2, 1, axis=0), axis=1)\n        total_distances = distances1 + distances2\n        critical_edges = np.argsort(total_distances)[-min(3, n//2):]\n\n        for edge in critical_edges:\n            # Try inserting a new edge\n            u, v = new_solution[edge], new_solution[(edge+1)%n]\n            # Find the best insertion point\n            best_insert = -1\n            best_gain = -np.inf\n            for i in range(n):\n                if i != edge and i != (edge+1)%n:\n                    # Calculate potential gain\n                    old_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n                    new_cost = distance_matrix_1[u, new_solution[(i+1)%n]] + distance_matrix_2[u, new_solution[(i+1)%n]] + \\\n                               distance_matrix_1[new_solution[i], v] + distance_matrix_2[new_solution[i], v]\n                    gain = old_cost - new_cost\n                    if gain > best_gain:\n                        best_gain = gain\n                        best_insert = i\n\n            if best_insert != -1 and best_gain > 0:\n                # Perform insertion\n                new_solution = np.concatenate([new_solution[:best_insert+1], [v], new_solution[best_insert+1:]])\n                new_solution = np.concatenate([new_solution[:edge+1], [u], new_solution[edge+1:]])\n\n    # Step 4: Constrained geometric rotation\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Calculate geometric properties\n        segment_coords1 = instance[new_solution[start:end], :2]\n        segment_coords2 = instance[new_solution[start:end], 2:]\n        centroid1 = np.mean(segment_coords1, axis=0)\n        centroid2 = np.mean(segment_coords2, axis=0)\n\n        # Rotate segment based on geometric properties\n        angle1 = np.arctan2(segment_coords1[:,1] - centroid1[1], segment_coords1[:,0] - centroid1[0])\n        angle2 = np.arctan2(segment_coords2[:,1] - centroid2[1], segment_coords2[:,0] - centroid2[0])\n        avg_angle = np.mean(angle1 + angle2)\n\n        # Sort nodes by angle\n        angles = angle1 + angle2\n        sorted_indices = np.argsort(angles)\n        new_solution[start:end] = new_solution[start:end][sorted_indices]\n\n    # Step 5: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        # Nearest-neighbor repair\n        valid_tour = []\n        remaining_nodes = set(new_solution)\n        current_node = new_solution[0]\n        valid_tour.append(current_node)\n        remaining_nodes.remove(current_node)\n\n        while remaining_nodes:\n            min_dist = np.inf\n            next_node = None\n            for node in remaining_nodes:\n                dist = distance_matrix_1[current_node, node] + distance_matrix_2[current_node, node]\n                if dist < min_dist:\n                    min_dist = dist\n                    next_node = node\n            valid_tour.append(next_node)\n            remaining_nodes.remove(next_node)\n            current_node = next_node\n\n        new_solution = np.array(valid_tour)\n\n    return new_solution\n\n",
          "score": [
               -0.9502865232406194,
               0.8973692655563354
          ]
     },
     {
          "algorithm": "{This algorithm introduces a novel multi-objective-aware local search strategy that combines Pareto dominance analysis with a hybrid segment exchange mechanism. It first identifies the most promising solutions by evaluating their dominance relationships and combined objective values, then employs a weighted random selection to choose a base solution with higher probability for better-performing solutions. The algorithm then performs a hybrid segment exchange operation where it selects two non-overlapping segments from different parts of the tour and exchanges them, evaluating the impact on both objectives. The acceptance criterion considers both objectives simultaneously, accepting the change if it improves at least one objective or with a small probability if it doesn't. The algorithm also includes a fallback mechanism to ensure solution feasibility and a dynamic adjustment of segment sizes based on the solution's quality. The approach goes beyond standard segment-based operations by incorporating multi-objective considerations throughout the process and dynamically adapting the segment sizes during the search.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select base solution based on Pareto dominance and objective values\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        # If no non-dominated solutions, select the one with minimal combined cost\n        combined_costs = [obj[0] + obj[1] for _, obj in archive]\n        selected_idx = np.argmin(combined_costs)\n    else:\n        # Select from non-dominated solutions with probability proportional to their quality\n        qualities = [1.0 / (1.0 + archive[i][1][0] + archive[i][1][1]) for i in non_dominated]\n        selected_idx = random.choices(non_dominated, weights=qualities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Adaptive segment exchange with multi-objective evaluation\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    def calculate_total_cost(sol):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_total_cost(new_solution)\n\n    # Dynamic segment size based on solution quality\n    solution_quality = 1.0 / (1.0 + original_cost1 + original_cost2)\n    segment_size = max(2, int(3 * solution_quality))\n\n    # Select non-overlapping segments\n    segment1_start = random.randint(0, n - segment_size - 1)\n    segment1_end = segment1_start + segment_size\n\n    possible_positions = list(range(0, segment1_start - segment_size + 1)) + list(range(segment1_end, n - segment_size + 1))\n    if not possible_positions:\n        return new_solution\n\n    segment2_start = random.choice(possible_positions)\n    segment2_end = segment2_start + segment_size\n\n    # Extract segments\n    segment1 = new_solution[segment1_start:segment1_end]\n    segment2 = new_solution[segment2_start:segment2_end]\n\n    # Create new solution by exchanging segments\n    new_solution = np.concatenate([\n        new_solution[:segment1_start],\n        segment2,\n        new_solution[segment1_end:segment2_start],\n        segment1,\n        new_solution[segment2_end:]\n    ])\n\n    # Calculate new total cost\n    new_cost1, new_cost2 = calculate_total_cost(new_solution)\n\n    # Multi-objective acceptance criterion\n    if not ((new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or\n            (new_cost1 < original_cost1 or new_cost2 < original_cost2) or\n            random.random() < 0.2 * solution_quality):\n        # If not accepted, try another segment exchange\n        for _ in range(2):\n            new_segment_size = max(2, int(3 * solution_quality))\n\n            new_segment1_start = random.randint(0, n - new_segment_size - 1)\n            new_segment1_end = new_segment1_start + new_segment_size\n\n            new_possible_positions = list(range(0, new_segment1_start - new_segment_size + 1)) + list(range(new_segment1_end, n - new_segment_size + 1))\n            if not new_possible_positions:\n                continue\n\n            new_segment2_start = random.choice(new_possible_positions)\n            new_segment2_end = new_segment2_start + new_segment_size\n\n            new_segment1 = new_solution[new_segment1_start:new_segment1_end]\n            new_segment2 = new_solution[new_segment2_start:new_segment2_end]\n\n            temp_solution = np.concatenate([\n                new_solution[:new_segment1_start],\n                new_segment2,\n                new_solution[new_segment1_end:new_segment2_start],\n                new_segment1,\n                new_solution[new_segment2_end:]\n            ])\n\n            temp_cost1, temp_cost2 = calculate_total_cost(temp_solution)\n            if ((temp_cost1 <= original_cost1 and temp_cost2 <= original_cost2) or\n                (temp_cost1 < original_cost1 or temp_cost2 < original_cost2) or\n                random.random() < 0.2 * solution_quality):\n                new_solution = temp_solution\n                break\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.869459339195008,
               0.46490246057510376
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (highest sum of objectives)\n    selected_solution = max(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    n = len(selected_solution)\n\n    if n < 3:\n        return selected_solution\n\n    # Dynamic segment selection based on solution properties\n    segment_length = min(max(2, n // 3), n - 2)\n    start_idx = np.random.randint(0, n - segment_length)\n\n    # Adaptive segment shuffling\n    segment = selected_solution[start_idx:start_idx + segment_length]\n    np.random.shuffle(segment)\n\n    # Objective-aware reinsertion\n    remaining_nodes = [node for node in selected_solution if node not in segment]\n    new_segment = []\n\n    # Start with node that minimizes combined distance to neighbors\n    if remaining_nodes:\n        current_node = min(remaining_nodes, key=lambda x: distance_matrix_1[x, segment[0]] + distance_matrix_2[x, segment[0]])\n        new_segment.append(current_node)\n        remaining_nodes.remove(current_node)\n\n    for node in segment:\n        # Find best position to insert current node based on both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for i in range(len(new_segment) + 1):\n            if i == 0:\n                prev_node = new_segment[-1] if new_segment else selected_solution[-1]\n                next_node = new_segment[0] if new_segment else selected_solution[start_idx + segment_length]\n            elif i == len(new_segment):\n                prev_node = new_segment[-1]\n                next_node = selected_solution[start_idx + segment_length]\n            else:\n                prev_node = new_segment[i-1]\n                next_node = new_segment[i]\n\n            dist1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            dist2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            score = 0.7 * dist1 + 0.3 * dist2  # Weighted by objective importance\n\n            if score < best_score:\n                best_score = score\n                best_pos = i\n\n        new_segment.insert(best_pos, node)\n\n    # Construct new solution\n    new_solution = np.concatenate([\n        selected_solution[:start_idx],\n        np.array(new_segment),\n        selected_solution[start_idx + segment_length:]\n    ])\n\n    # Validate solution\n    if len(np.unique(new_solution)) == n and len(new_solution) == n:\n        return new_solution\n\n    return selected_solution\n\n",
          "score": [
               -0.9368335472606997,
               0.8721699118614197
          ]
     },
     {
          "algorithm": "{This algorithm implements a novel neighbor selection and generation strategy that combines multi-objective solution evaluation with a hybrid local search approach. It first identifies the most promising solutions in the archive by analyzing their dominance relationships and combined objective values, then employs a weighted random selection to choose a base solution with higher probability for better-performing solutions. The hybrid local search operator combines a novel adaptive segment reversal with a multi-objective-aware acceptance criterion, which evaluates the impact of the reversal on both objectives and accepts the change if it improves at least one objective or with a small probability if it doesn't. The algorithm also includes a fallback mechanism to ensure solution feasibility and a secondary segment reversal attempt if the initial reversal doesn't yield improvement. The approach goes beyond standard 2-opt by focusing on segment-based operations and incorporating multi-objective considerations throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Evaluate solutions and select base solution\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        # If no non-dominated solutions, select the one with minimal combined cost\n        combined_costs = [obj[0] + obj[1] for _, obj in archive]\n        selected_idx = np.argmin(combined_costs)\n    else:\n        # Select from non-dominated solutions with probability proportional to their quality\n        qualities = [1.0 / (1.0 + archive[i][1][0] + archive[i][1][1]) for i in non_dominated]\n        selected_idx = random.choices(non_dominated, weights=qualities, k=1)[0]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Hybrid local search with multi-objective consideration\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Novel segment-based operation: adaptive segment rotation\n    segment_length = max(2, n // 4)\n    start = random.randint(0, n - segment_length - 1)\n    end = start + segment_length\n\n    # Calculate segment cost before rotation\n    def calculate_segment_cost(sol, start, end):\n        cost1 = 0.0\n        cost2 = 0.0\n        for i in range(start, end):\n            cost1 += distance_matrix_1[sol[i], sol[(i+1)%n]]\n            cost2 += distance_matrix_2[sol[i], sol[(i+1)%n]]\n        return cost1, cost2\n\n    original_cost1, original_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Perform rotation (shift elements to the right by one position)\n    segment = new_solution[start:end]\n    rotated_segment = np.roll(segment, 1)\n    new_solution[start:end] = rotated_segment\n\n    # Calculate segment cost after rotation\n    new_cost1, new_cost2 = calculate_segment_cost(new_solution, start, end)\n\n    # Acceptance criterion: accept if at least one objective improves or with small probability\n    if (new_cost1 <= original_cost1 and new_cost2 <= original_cost2) or random.random() < 0.2:\n        # If accepted, try another segment rotation\n        for _ in range(2):\n            new_start = random.randint(0, n - segment_length - 1)\n            new_end = new_start + segment_length\n            new_segment = new_solution[new_start:new_end]\n            new_rotated_segment = np.roll(new_segment, 1)\n            new_solution[new_start:new_end] = new_rotated_segment\n            new_new_cost1, new_new_cost2 = calculate_segment_cost(new_solution, new_start, new_end)\n            if (new_new_cost1 <= original_cost1 and new_new_cost2 <= original_cost2) or random.random() < 0.1:\n                break\n    else:\n        # If not accepted, revert to original\n        new_solution[start:end] = new_solution[start:end][::-1]  # Simple reversal as fallback\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9043114509275021,
               0.6162062883377075
          ]
     }
]