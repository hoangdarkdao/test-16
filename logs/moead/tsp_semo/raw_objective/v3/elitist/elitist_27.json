[
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 3-opt with biased random selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three edges to modify\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3])\n    else:\n        new_order = np.concatenate([segment1, segment3, segment2[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.765381223706096,
            6.829708949278469
        ]
    },
    {
        "algorithm": "{A new algorithm that selects a solution from the archive based on a weighted combination of objectives, then applies a hybrid local search combining 2-opt with a biased random segment reversal to explore diverse neighborhoods while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.6*x[1][0] + 0.4*x[1][1])[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search: 2-opt with biased segment reversal\n    if np.random.rand() < 0.7:\n        # 2-opt move\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        i, j = min(i, j), max(i, j)\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        # Biased segment reversal\n        a, b = np.random.choice(range(n), size=2, replace=False)\n        a, b = min(a, b), max(a, b)\n        segment = new_solution[a:b]\n        if np.random.rand() < 0.5:\n            new_solution[a:b] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            5.198963866943478,
            6.7284177082263
        ]
    },
    {
        "algorithm": "{\"A novel algorithm that intelligently selects a solution from the archive based on both objectives, then applies a hybrid local search combining 4-opt with a biased segment reversal and insertion strategy to create high-quality neighbors while ensuring feasibility.\"}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Apply hybrid 4-opt with biased segment operations\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Calculate potential improvements for each segment configuration\n    configs = [\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment3, segment2[::-1], segment4]),\n        np.concatenate([segment1, segment4, segment3, segment2[::-1]]),\n        np.concatenate([segment2, segment1[::-1], segment3, segment4]),\n        np.concatenate([segment2, segment3, segment1[::-1], segment4])\n    ]\n\n    # Select configuration with best estimated improvement\n    best_config = min(configs, key=lambda x: sum(distance_matrix_1[x[:-1], x[1:]] + distance_matrix_2[x[:-1], x[1:]]))\n\n    # Apply the best configuration if valid\n    if len(np.unique(best_config)) == n:\n        new_solution[a:d] = best_config\n    else:\n        # Fallback to inserting a random segment between two random positions\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            5.229933770139944,
            6.583000928456719
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid objective score (weighted sum of both objectives) and applies a novel \"segment inversion and reinsertion\" operator that randomly inverts segments and reinserts them at different positions, biased towards reducing the total cost in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: 0.7 * x[1][0] + 0.3 * x[1][1])[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert and reinsert\n    start, end = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Invert the segment with 50% probability\n    if np.random.rand() < 0.5:\n        segment = segment[::-1]\n\n    # Find the best insertion point for the segment based on distance reduction\n    best_cost = float('inf')\n    best_pos = 0\n\n    for i in range(1, len(remaining)):\n        # Try inserting segment before and after each node\n        for pos in [i, i+1]:\n            if pos > len(remaining):\n                continue\n\n            temp = np.insert(remaining, pos, segment)\n            cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(len(temp)-1)) + distance_matrix_1[temp[-1], temp[0]]\n            cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(len(temp)-1)) + distance_matrix_2[temp[-1], temp[0]]\n            total_cost = 0.7 * cost1 + 0.3 * cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to swapping two nodes if invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            4.507658137222527,
            7.703495368741801
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Apply a novel local search operator: path inversion with segment merging\n    n = len(new_solution)\n    a, b, c = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n    # Invert segments and merge them in a non-trivial way\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:]\n\n    # Create a new path by inverting and merging segments with a probability bias\n    if np.random.rand() < 0.7:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n    else:\n        new_order = np.concatenate([segment3, segment2[::-1], segment1])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_order)) == n:\n        new_solution[a:c] = new_order\n    else:\n        # Fallback to a different transformation if invalid\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.088193651445383,
            5.653808432338506
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and insert elsewhere\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b]\n\n    # Remove the segment and insert it in a new position with bias toward reducing costs\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n    insert_pos = np.random.choice(range(len(remaining)))\n\n    # Calculate the cost of inserting the segment at different positions\n    costs = []\n    for pos in range(len(remaining)):\n        temp_sol = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n        cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n        cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n        costs.append(cost1 + cost2)\n\n    # Select the position with the lowest cost\n    best_pos = np.argmin(costs)\n    new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) == n:\n        return new_solution\n    else:\n        # Fallback to swapping two random nodes if the above fails\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            5.550207265240134,
            5.911976680121037
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n    weights = np.array([0.6, 0.4])  # Weight for first objective higher\n    scores = np.dot(normalized, weights)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment-based local search\n    if n > 4:\n        # Randomly select 3 segments to rearrange\n        split_points = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        a, b = split_points\n        segment1 = new_solution[:a]\n        segment2 = new_solution[a:b]\n        segment3 = new_solution[b:]\n\n        # Reconnect with probability based on objective improvement\n        obj1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        obj2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try different segment permutations\n        candidates = [\n            np.concatenate([segment1, segment2[::-1], segment3]),\n            np.concatenate([segment1, segment3, segment2[::-1]]),\n            np.concatenate([segment2, segment1, segment3]),\n            np.concatenate([segment2, segment3, segment1])\n        ]\n\n        best_candidate = None\n        best_score = float('inf')\n\n        for candidate in candidates:\n            temp_obj1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            temp_obj2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            temp_score = weights[0] * (temp_obj1 - obj1) + weights[1] * (temp_obj2 - obj2)\n\n            if temp_score < best_score and len(np.unique(candidate)) == n:\n                best_candidate = candidate\n                best_score = temp_score\n\n        if best_candidate is not None:\n            new_solution = best_candidate\n        else:\n            # Fallback to biased 2-opt\n            i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n            if np.random.rand() < 0.7:  # Higher probability for better objective\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Simple swap for small instances\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            4.826562467169547,
            7.380901208042275
        ]
    },
    {
        "algorithm": "{Select a solution from the archive with the lowest total cost and apply a novel \"4-segment inversion\" local search that randomly selects four segments, reverses them with a bias towards cost reduction, and ensures feasibility through validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four points to divide the tour into segments\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Reconnect the segments in a new order with bias towards cost reduction\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3[::-1]])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_order)) == n - (d - c) + len(segment2):\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.415615773951718,
            5.416200972064772
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: (x[1][0], x[1][1]))[0].copy()\n\n    # Apply a novel local search operator: 4-opt with adaptive segment selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n    segment4 = new_solution[d:]\n\n    # Reconnect the segments in a new order with bias towards reducing both objectives\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment3, segment2, segment4[::-1]])\n    else:\n        new_order = np.concatenate([segment2, segment4, segment1[::-1], segment3])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        start, end = np.random.choice(range(n), size=2, replace=False)\n        start, end = min(start, end), max(start, end)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            4.162399297697791,
            10.50098979468539
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a novel \"segment inversion with objective-biased reinsertion\" operator that intelligently inverts and reinserts segments of the tour based on the relative improvement in both objectives, ensuring feasibility through careful validation and fallback to a random swap if the operation fails.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to invert and reinsert\n    start, end = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n\n    # Calculate potential insertion points and evaluate their impact on both objectives\n    best_insert_pos = -1\n    best_improvement = 0\n    for i in range(len(remaining)):\n        # Try inserting the inverted segment at position i\n        candidate = np.concatenate([remaining[:i], segment[::-1], remaining[i:]])\n        # Calculate the change in both objectives\n        old_cost1 = distance_matrix_1[selected_solution[start-1], selected_solution[start]] + distance_matrix_1[selected_solution[end-1], selected_solution[end]]\n        old_cost2 = distance_matrix_2[selected_solution[start-1], selected_solution[start]] + distance_matrix_2[selected_solution[end-1], selected_solution[end]]\n        new_cost1 = distance_matrix_1[candidate[i-1], candidate[i]] + distance_matrix_1[candidate[i+len(segment)-1], candidate[i+len(segment)]]\n        new_cost2 = distance_matrix_2[candidate[i-1], candidate[i]] + distance_matrix_2[candidate[i+len(segment)-1], candidate[i+len(segment)]]\n        improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_insert_pos = i\n\n    # Apply the best insertion if it improves the solution\n    if best_insert_pos != -1:\n        candidate = np.concatenate([remaining[:best_insert_pos], segment[::-1], remaining[best_insert_pos:]])\n        if len(np.unique(candidate)) == n:\n            new_solution = candidate\n        else:\n            # Fallback to random swap if the operation fails\n            i, j = np.random.choice(range(n), size=2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Fallback to random swap if no improvement found\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.956907168424829,
            5.804027952379856
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search operator: 4-opt with biased segment reversal\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select four edges to modify\n    a, b, c, d = sorted(np.random.choice(range(1, n-1), size=4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[b:c]\n    segment3 = new_solution[c:d]\n\n    # Reconnect the segments in a new order with bias towards reducing total cost\n    if np.random.rand() < 0.5:\n        new_order = np.concatenate([segment1, segment2[::-1], segment3[::-1]])\n    else:\n        new_order = np.concatenate([segment1[::-1], segment2, segment3[::-1]])\n\n    # Ensure the solution remains valid (no duplicates or missing nodes)\n    if len(np.unique(new_order)) == n:\n        new_solution[a:d] = new_order\n    else:\n        # Fallback to reversing a random segment if the above fails\n        i, j = sorted(np.random.choice(range(n), size=2, replace=False))\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            6.217571056967836,
            5.6318697616168905
        ]
    },
    {
        "algorithm": "{The new algorithm selects a solution with high potential for improvement by considering both objective costs and applies a novel \"segmented inversion with objective-aware insertion\" operator that reverses segments and strategically reinserts them based on the combined cost reduction in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select a segment to reverse and reinsert\n    a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n    segment = new_solution[a:b]\n    remaining = np.concatenate([new_solution[:a], new_solution[b:]])\n\n    # Evaluate potential insertion points based on combined cost reduction\n    best_insertion = None\n    min_cost = float('inf')\n\n    for i in range(len(remaining)):\n        # Try inserting the reversed segment at position i\n        candidate = np.concatenate([remaining[:i], segment[::-1], remaining[i:]])\n        cost1 = sum(distance_matrix_1[candidate[j-1], candidate[j]] for j in range(1, n))\n        cost2 = sum(distance_matrix_2[candidate[j-1], candidate[j]] for j in range(1, n))\n        total_cost = cost1 + cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insertion = candidate\n\n    if best_insertion is not None:\n        new_solution = best_insertion\n    else:\n        # Fallback to random swap if no improvement found\n        i, j = np.random.choice(range(n), size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            5.524100728355354,
            6.100611625385507
        ]
    }
]