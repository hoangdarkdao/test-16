[
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of objective values and dominance relationships, then applies a hybrid local search operator combining edge insertion and node relocation to generate a neighbor solution, ensuring feasibility through careful validation of moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with a bias towards those with better objective values\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert to prefer lower values\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n    else:\n        # Node relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.553650942482376,
            6.418199704082414
        ]
    },
    {
        "algorithm": "{A hybrid local search algorithm that intelligently selects a solution from the archive based on both objective values and applies a novel 3-opt-like operator with randomized edge swaps and segment reversals to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] + 1e-6))[0].copy()\n\n    # Hybrid local search operator: 3-opt-like with randomized edge swaps and segment reversals\n    n = len(selected_solution)\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create a new solution with randomized 3-opt moves\n    new_solution = selected_solution.copy()\n    new_solution[a:b+1] = selected_solution[a:b+1][::-1]  # Reverse segment\n    new_solution[b:c+1] = selected_solution[b:c+1][::-1]  # Reverse another segment\n\n    # Randomly swap edges to explore more neighborhood\n    if random.random() < 0.5:\n        d, e = sorted(random.sample(range(n), 2))\n        new_solution[d], new_solution[e] = new_solution[e], new_solution[d]\n\n    return new_solution\n\n",
        "score": [
            10.374135631059367,
            10.637128667818267
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a weighted combination of objective values and dominance relationships, then applies a hybrid local search operator combining edge insertion and node relocation to generate a neighbor solution, ensuring feasibility through careful validation of moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive cannot be empty\")\n\n    # Select a solution with a bias towards those with better objective values\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert to prefer lower values\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between two operators\n    if random.random() < 0.5:\n        # Edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:j+1], new_solution[i:j], new_solution[j+1:]])\n    else:\n        # Node relocation\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            6.553650942482376,
            6.418199704082414
        ]
    }
]