[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    scores = []\n    for sol, _ in archive:\n        # Calculate diversity score (number of unique edges not in other solutions)\n        diversity = 0\n        edges = set(zip(sol, np.roll(sol, -1)))\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges - other_edges)\n        scores.append(diversity)\n\n    if all(s == 0 for s in scores):\n        # If all solutions are identical, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Normalize scores and select with probability\n        total = sum(scores)\n        probs = [s / total for s in scores]\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for segment relocation\n        # Select segment length based on instance size\n        max_segment = min(5, n // 4)\n        segment_length = random.randint(2, max_segment)\n\n        # Select random segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position that improves both objectives\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue  # Skip current position\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and best_cost < float('inf'):\n            # Apply the best move\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n    else:  # Edge insertion\n        # Select random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select random node to insert between\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i-1)%n:\n            k = random.randint(0, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]  # Reverse the edge\n        candidate = np.roll(candidate, -i)  # Make i the first element\n        candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n        candidate = np.roll(candidate, i)  # Restore original order\n\n        # Check if the move is valid (visits all nodes exactly once)\n        if len(set(candidate)) == n:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.602584769458544,
               5.827298074802924
          ]
     },
     {
          "algorithm": "{The new algorithm begins by selecting a base solution from the archive using a multi-criteria approach that combines objective values, diversity, and structural features, then employs a novel hybrid local search strategy that integrates adaptive segment swapping with probabilistic edge reversal, followed by a constrained node reinsertion phase to ensure feasibility while exploring the solution space more effectively than standard methods, ultimately generating a high-quality neighbor solution that balances exploration and exploitation through dynamic parameter adaptation and objective-aware move selection.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective and structural diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate combined objective score (normalized)\n        obj_score = (obj1 + obj2) / (sum(x[1][0] + x[1][1] for x in archive) / len(archive))\n\n        # Calculate structural diversity\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity = 0\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges.symmetric_difference(other_edges))\n\n        # Combine scores with adaptive weights\n        alpha = 0.7 if len(archive) > 10 else 0.5\n        scores.append(alpha * obj_score + (1 - alpha) * diversity)\n\n    # Select solution with highest combined score\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Phase 1: Adaptive segment swapping\n    segment_length = max(3, min(7, n // 5))\n    for _ in range(2):\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        # Swap segments with probability based on objective improvement\n        seg1 = new_solution[start1:start1+segment_length]\n        seg2 = new_solution[start2:start2+segment_length]\n\n        # Calculate potential improvement\n        old_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        candidate = new_solution.copy()\n        candidate[start1:start1+segment_length] = seg2\n        candidate[start2:start2+segment_length] = seg1\n\n        new_cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[candidate[-1], candidate[0]] +\n                    sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[candidate[-1], candidate[0]])\n\n        if new_cost < old_cost or np.random.random() < 0.3:\n            new_solution = candidate\n\n    # Phase 2: Probabilistic edge reversal with objective awareness\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        if new_cost < old_cost or np.random.random() < 0.2:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Phase 3: Constrained node reinsertion\n    for _ in range(2):\n        # Select a random node to remove\n        idx = np.random.randint(1, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        candidate = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find best insertion position that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            if pos == idx or pos == idx-1:\n                continue\n\n            # Insert node at position pos\n            temp = np.insert(candidate, pos, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[temp[-1], temp[0]]\n\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[temp[-1], temp[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.982530730904809,
               6.4238842089255845
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a novel adaptive path decomposition and recombination strategy that dynamically partitions the tour into segments based on both objective spaces' characteristics, then reconstructs the tour by interleaving these segments in a way that maximizes the trade-off between the two objectives. The selection process prioritizes solutions that exhibit non-dominated segments in the Pareto front, while the local search operator uses a probabilistic segment recombination mechanism guided by a multi-objective utility function that considers the segment's contribution to both objectives. The function ensures feasibility by maintaining the permutation property through a series of carefully designed segment swaps and rotations, with the segment length and recombination pattern determined by an adaptive probability model that learns from the current solution's structure and the distance matrices.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using adaptive segment analysis\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive path decomposition based on both objectives\n    segment_length = np.random.randint(3, min(7, n // 2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Extract segment and analyze its contribution to both objectives\n    segment = new_solution[start_pos:start_pos + segment_length]\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n\n    # Determine segment's Pareto dominance relative to the rest of the tour\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Probabilistic recombination based on segment's characteristics\n    if segment_cost1 / total_cost1 < 0.3 or segment_cost2 / total_cost2 < 0.3:\n        # If segment is significantly worse in one objective, consider removing it\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        # Insert the segment in a different position\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        # If segment is balanced, consider rotating it\n        rotation = np.random.randint(1, segment_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start_pos:start_pos + segment_length] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to restore feasibility\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.4586950415254565,
               5.903120343468656
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone idea of selecting a promising solution from the archive and applying a hybrid local search strategy, but it introduces a novel approach by combining adaptive segment relocation with a guided path inversion mechanism. The algorithm first evaluates solutions based on their objective diversity and local search potential, then selects a base solution with high potential for improvement. The selected solution undergoes a multi-stage local search process: first, it adaptively identifies and relocates promising segments of varying lengths based on their contribution to reducing both objectives, while dynamically adjusting segment lengths based on the solution's structure and the distance matrices. Next, it applies a guided path inversion where paths between critical nodes are inverted based on their weighted contribution to both objectives, with inversion length determined by a probabilistic model that considers the current solution's structure and the distance matrices. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    num_segments = np.random.randint(1, min(3, n // 3))\n    segment_lengths = []\n\n    for _ in range(num_segments):\n        # Determine segment length based on local structure\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate edge weights in both objectives\n        w1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[k]]\n        w2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[k]]\n\n        # Use weighted combination to determine segment length\n        length = max(2, min(5, int(3 * (w1 + w2) / (distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[i], base_solution[k]]))))\n        segment_lengths.append(length)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    # Relocate segments\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        # Find best insertion position\n        best_pos = current_pos\n        best_cost = float('inf')\n\n        for pos in range(n - length + 1):\n            if pos >= current_pos and pos < current_pos + length:\n                continue\n\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:current_pos],\n                new_solution[current_pos + length:]\n            ])\n\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != current_pos:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:current_pos],\n                new_solution[current_pos + length:]\n            ])\n\n        current_pos += length\n\n    # Guided path inversion\n    for _ in range(min(2, n // 3)):\n        # Select critical nodes based on both objectives\n        critical_nodes = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n                critical_nodes.append(i)\n\n        if len(critical_nodes) >= 2:\n            i, j = np.random.choice(critical_nodes, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate inversion length based on node distances\n            inversion_length = max(2, min(5, int(3 * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                                   distance_matrix_2[new_solution[i], new_solution[j]]) /\n                                                   (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))))\n\n            # Perform inversion\n            if j - i + 1 <= inversion_length:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                mid = i + inversion_length // 2\n                new_solution[i:mid] = new_solution[i:mid][::-1]\n                new_solution[mid:j+1] = new_solution[mid:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               6.455092419352846,
               6.242420963522866
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-phase approach that combines probabilistic node selection, geometric transformation-based local search, and adaptive objective-weighted edge swapping to generate high-quality neighbors. It first identifies critical nodes based on their geometric properties and objective contributions, then applies a series of geometric transformations (scaling, rotation, and translation) to the solution's node coordinates in both objective spaces, followed by a targeted edge swapping phase that prioritizes edges with high potential for improving both objectives, with the swap probability dynamically adjusted based on the current solution's structure and the relative weights of the two objectives. The algorithm ensures feasibility by maintaining the permutation property and using a validation step to confirm the generated solution remains a valid TSP tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution with probability based on objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.sum(np.abs(objectives[:, None] - objectives), axis=2)\n    probs = np.sum(diversity, axis=1)\n    probs = probs / np.sum(probs) if np.sum(probs) > 0 else np.ones(len(archive)) / len(archive)\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Geometric transformation phase\n    coords1 = instance[base_solution, :2]  # First objective coordinates\n    coords2 = instance[base_solution, 2:]  # Second objective coordinates\n\n    # Calculate centroids\n    centroid1 = np.mean(coords1, axis=0)\n    centroid2 = np.mean(coords2, axis=0)\n\n    # Apply random geometric transformations\n    if np.random.random() < 0.5:\n        # Scale transformation\n        scale_factor = np.random.uniform(0.9, 1.1)\n        coords1 = centroid1 + (coords1 - centroid1) * scale_factor\n        coords2 = centroid2 + (coords2 - centroid2) * scale_factor\n    else:\n        # Rotation transformation\n        angle = np.random.uniform(-np.pi/6, np.pi/6)\n        rotation_matrix = np.array([[np.cos(angle), -np.sin(angle)],\n                                   [np.sin(angle), np.cos(angle)]])\n        coords1 = centroid1 + (coords1 - centroid1) @ rotation_matrix\n        coords2 = centroid2 + (coords2 - centroid2) @ rotation_matrix\n\n    # Find nearest nodes in transformed spaces\n    transformed_instance1 = np.hstack([coords1, instance[:, 2:]])\n    transformed_instance2 = np.hstack([instance[:, :2], coords2])\n\n    # Create distance matrices for transformed spaces\n    def create_distance_matrix(coords):\n        n = len(coords)\n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                dist_matrix[i, j] = np.linalg.norm(coords[i] - coords[j])\n        return dist_matrix\n\n    transformed_dist1 = create_distance_matrix(transformed_instance1[base_solution, :2])\n    transformed_dist2 = create_distance_matrix(transformed_instance2[base_solution, 2:])\n\n    # Adaptive edge swapping phase\n    for _ in range(min(5, n // 2)):\n        # Calculate edge weights in both original and transformed spaces\n        edge_weights = []\n        for i in range(n):\n            j = (i + 1) % n\n            original_cost = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[i], base_solution[j]]\n            transformed_cost = transformed_dist1[i, j] + transformed_dist2[i, j]\n            edge_weights.append(original_cost + transformed_cost)\n\n        edge_weights = np.array(edge_weights)\n        edge_weights = edge_weights / np.sum(edge_weights)\n\n        # Select edges to swap with probability based on weights\n        if np.random.random() < 0.7:  # 70% chance for weighted selection\n            i = np.random.choice(n, p=edge_weights)\n        else:\n            i = np.random.randint(0, n)\n        j = (i + 1) % n\n\n        # Find best swap candidate\n        best_cost = float('inf')\n        best_k = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Create candidate solution\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate = np.roll(candidate, -i)\n            candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n            candidate = np.roll(candidate, i)\n\n            # Check validity\n            if len(set(candidate)) != n:\n                continue\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[l], candidate[l+1]] for l in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_k = k\n\n        if best_k != -1:\n            # Apply the best swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution = np.roll(new_solution, -i)\n            new_solution = np.concatenate([new_solution[:1], new_solution[2:best_k+1], new_solution[1:2], new_solution[best_k+1:]])\n            new_solution = np.roll(new_solution, i)\n\n    return new_solution\n\n",
          "score": [
               6.96520938589318,
               5.376564571653562
          ]
     },
     {
          "algorithm": "{The new algorithm introduces a novel approach by combining hierarchical clustering with multi-objective aware edge contraction and expansion. It first partitions the solution into hierarchical clusters based on spatial proximity in both objective spaces, then selectively contracts and expands edges between clusters to balance the trade-off between the two objectives, followed by a guided node reinsertion process that prioritizes nodes with complementary improvement potential in both objectives, while dynamically adjusting the reinsertion depth based on the current solution's structure and the relative improvement potential in both objectives. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Hierarchical clustering based on spatial proximity in both objectives\n    from scipy.cluster.hierarchy import linkage, fcluster\n\n    # Calculate pairwise distances in both objective spaces\n    coords1 = instance[base_solution, :2]\n    coords2 = instance[base_solution, 2:]\n    dist1 = np.sqrt(np.sum((coords1[:, np.newaxis, :] - coords1[np.newaxis, :, :])**2, axis=2))\n    dist2 = np.sqrt(np.sum((coords2[:, np.newaxis, :] - coords2[np.newaxis, :, :])**2, axis=2))\n    combined_dist = 0.5 * dist1 + 0.5 * dist2\n\n    # Perform hierarchical clustering\n    Z = linkage(combined_dist[np.triu_indices(n, k=1)], method='average')\n    clusters = fcluster(Z, t=0.5 * np.max(Z[:, 2]), criterion='distance')\n\n    # Identify cluster boundaries\n    cluster_boundaries = []\n    current_cluster = clusters[0]\n    for i in range(1, n):\n        if clusters[i] != current_cluster:\n            cluster_boundaries.append(i)\n            current_cluster = clusters[i]\n\n    # Edge contraction and expansion\n    for _ in range(min(3, len(cluster_boundaries))):\n        if not cluster_boundaries:\n            break\n\n        # Select a random boundary\n        boundary_idx = np.random.choice(cluster_boundaries)\n        i = boundary_idx - 1\n        j = boundary_idx\n\n        # Calculate current costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Try contracting the edge (remove it)\n        candidate = np.delete(new_solution, j)\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(len(candidate)-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n\n        # Try expanding the edge (add a new node)\n        if len(candidate) < n:\n            # Find the node that would best improve the solution\n            best_node = None\n            best_cost = float('inf')\n\n            for node in range(n):\n                if node not in candidate:\n                    # Try inserting the node between i and j\n                    temp = np.insert(candidate, i+1, node)\n                    temp_cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(len(temp)-1)) + distance_matrix_1[temp[-1], temp[0]]\n                    temp_cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(len(temp)-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n                    if temp_cost1 + temp_cost2 < best_cost:\n                        best_cost = temp_cost1 + temp_cost2\n                        best_node = node\n\n            if best_node is not None:\n                candidate = np.insert(candidate, i+1, best_node)\n\n        # Choose the better option\n        if cost1 + cost2 < best_cost:\n            new_solution = candidate\n        else:\n            new_solution = np.insert(candidate, i+1, best_node)\n\n    # Guided node reinsertion\n    for _ in range(min(5, n//2)):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Remove the node\n        candidate = np.delete(new_solution, i)\n\n        # Find the best position to reinsert the node\n        best_pos = None\n        best_cost = float('inf')\n\n        for j in range(len(candidate)):\n            temp = np.insert(candidate, j, node)\n            temp_cost1 = (distance_matrix_1[temp[j-1], temp[j]] +\n                         distance_matrix_1[temp[j], temp[(j+1)%len(temp)]])\n            temp_cost2 = (distance_matrix_2[temp[j-1], temp[j]] +\n                         distance_matrix_2[temp[j], temp[(j+1)%len(temp)]])\n\n            # Dynamic reinsertion depth based on improvement potential\n            improvement_ratio = (current_cost1 - temp_cost1) / current_cost1 + (current_cost2 - temp_cost2) / current_cost2\n            depth = max(1, min(3, int(2 * improvement_ratio)))\n\n            # Consider positions within the depth range\n            for k in range(max(0, j-depth), min(len(temp), j+depth+1)):\n                if k != j:\n                    temp2 = np.insert(candidate, k, node)\n                    temp2_cost1 = (distance_matrix_1[temp2[k-1], temp2[k]] +\n                                  distance_matrix_1[temp2[k], temp2[(k+1)%len(temp2)]])\n                    temp2_cost2 = (distance_matrix_2[temp2[k-1], temp2[k]] +\n                                  distance_matrix_2[temp2[k], temp2[(k+1)%len(temp2)]])\n\n                    if temp2_cost1 + temp2_cost2 < best_cost:\n                        best_cost = temp2_cost1 + temp2_cost2\n                        best_pos = k\n\n        if best_pos is not None:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.064051003022471,
               6.274244567844251
          ]
     },
     {
          "algorithm": "{The new algorithm combines a multi-objective aware cluster-based decomposition with a probabilistic edge contraction-expansion technique, where the solution is first partitioned into clusters based on spatial proximity in both objective spaces, then edges between clusters are probabilistically contracted or expanded to form new segments, followed by a guided node insertion operation that prioritizes nodes with balanced improvement potential in both objectives while maintaining tour feasibility, and finally refines the solution with a dynamic segment merging heuristic that adaptively combines segments based on their current contribution to both objectives and the relative improvement potential of their neighbors in the combined objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Cluster-based decomposition\n    clusters = []\n    current_cluster = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate spatial proximity in both objective spaces\n        pos1 = instance[new_solution[i], :2]\n        pos2 = instance[new_solution[i], 2:]\n        prev_pos1 = instance[new_solution[i-1], :2]\n        prev_pos2 = instance[new_solution[i-1], 2:]\n\n        dist1 = np.linalg.norm(pos1 - prev_pos1)\n        dist2 = np.linalg.norm(pos2 - prev_pos2)\n\n        # Cluster formation criteria\n        if (dist1 > 1.5 * np.mean(distance_matrix_1) or dist2 > 1.5 * np.mean(distance_matrix_2)) or np.random.random() < 0.05:\n            clusters.append(current_cluster)\n            current_cluster = [new_solution[i]]\n        else:\n            current_cluster.append(new_solution[i])\n    if current_cluster:\n        clusters.append(current_cluster)\n\n    # Edge contraction-expansion\n    if len(clusters) > 1:\n        # Calculate cluster scores\n        cluster_scores = []\n        for cluster in clusters:\n            # Calculate centroids\n            centroid1 = np.mean(instance[cluster, :2], axis=0)\n            centroid2 = np.mean(instance[cluster, 2:], axis=0)\n\n            # Calculate average distance to other clusters\n            avg_dist1 = np.mean([np.linalg.norm(centroid1 - np.mean(instance[other_cluster, :2], axis=0))\n                               for other_cluster in clusters if other_cluster != cluster])\n            avg_dist2 = np.mean([np.linalg.norm(centroid2 - np.mean(instance[other_cluster, 2:], axis=0))\n                               for other_cluster in clusters if other_cluster != cluster])\n\n            # Combined score\n            score = 0.6 * avg_dist1 + 0.4 * avg_dist2\n            cluster_scores.append(score)\n\n        # Probabilistically contract or expand edges between clusters\n        for i in range(len(clusters)):\n            for j in range(i+1, len(clusters)):\n                if np.random.random() < 0.3:\n                    # Contract: merge clusters\n                    if len(clusters[i]) < len(clusters[j]):\n                        clusters[i].extend(clusters[j])\n                        clusters.pop(j)\n                    else:\n                        clusters[j].extend(clusters[i])\n                        clusters.pop(i)\n                    break\n                elif np.random.random() < 0.4:\n                    # Expand: split clusters\n                    if len(clusters[i]) > 2:\n                        split_point = np.random.randint(1, len(clusters[i])-1)\n                        new_cluster = clusters[i][split_point:]\n                        clusters[i] = clusters[i][:split_point]\n                        clusters.append(new_cluster)\n                    break\n\n        # Reconstruct solution from clusters\n        new_solution = np.concatenate([np.array(cluster) for cluster in clusters])\n\n    # Guided node insertion\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try inserting node i after node j\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:j+1], [candidate[i]], candidate[j+1:i], candidate[i+1:]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Decision based on balanced improvement\n        if ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or\n            (new_cost1 < current_cost1 * 0.95 and new_cost2 <= current_cost2 * 1.05) or\n            (new_cost1 <= current_cost1 * 1.05 and new_cost2 < current_cost2 * 0.95)):\n            new_solution = candidate\n\n    # Dynamic segment merging\n    if len(new_solution) > 3:\n        # Identify segments with high improvement potential\n        segments = []\n        current_segment = [new_solution[0]]\n        for i in range(1, n):\n            cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n            cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n            if (cost1 > 1.3 * np.mean(distance_matrix_1) or cost2 > 1.3 * np.mean(distance_matrix_2)) or np.random.random() < 0.1:\n                segments.append(current_segment)\n                current_segment = [new_solution[i]]\n            else:\n                current_segment.append(new_solution[i])\n        if current_segment:\n            segments.append(current_segment)\n\n        # Merge segments with complementary improvement potential\n        if len(segments) > 1:\n            for i in range(len(segments)-1):\n                seg1 = segments[i]\n                seg2 = segments[i+1]\n                # Calculate segment costs\n                seg1_cost1 = sum(distance_matrix_1[seg1[j-1], seg1[j]] for j in range(1, len(seg1)))\n                seg1_cost2 = sum(distance_matrix_2[seg1[j-1], seg1[j]] for j in range(1, len(seg1)))\n                seg2_cost1 = sum(distance_matrix_1[seg2[j-1], seg2[j]] for j in range(1, len(seg2)))\n                seg2_cost2 = sum(distance_matrix_2[seg2[j-1], seg2[j]] for j in range(1, len(seg2)))\n\n                # Check merge potential\n                if ((seg1_cost1 + seg2_cost1 < 1.1 * (seg1_cost1 + seg2_cost1)) and\n                    (seg1_cost2 + seg2_cost2 < 1.1 * (seg1_cost2 + seg2_cost2))):\n                    segments[i] = seg1 + seg2\n                    segments.pop(i+1)\n                    break\n\n            new_solution = np.concatenate(segments)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.824222550593927,
               6.09863895272094
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    normalized_objectives = [(obj[0] / (obj[0] + obj[1] + 1e-10), obj[1] / (obj[0] + obj[1] + 1e-10)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to modify\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k = np.random.randint(1, n-1)\n\n    # Novel move: reverse segment between i and j, then insert segment between k and k+1\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen due to segment insertion)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.343084386472292,
               6.398679333078661
          ]
     },
     {
          "algorithm": "{The new algorithm combines a multi-objective aware path decomposition strategy with a probabilistic segment reassembly technique. It first decomposes the current solution into variable-length paths by identifying segments with balanced contributions to both objectives, then probabilistically reassembles these segments by considering their spatial proximity in both objective spaces, followed by a guided edge swapping operation that prioritizes edges with complementary improvements in both objectives while maintaining tour feasibility, and finally refines the solution with a novel node relocation heuristic that dynamically adjusts the relocation probability based on the current solution's structure and the relative improvement potential in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Multi-objective path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        prev_cost1 = distance_matrix_1[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n        prev_cost2 = distance_matrix_2[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n\n        # Check if segment should be split\n        if (current_cost1 > 1.2 * prev_cost1 and current_cost2 > 1.2 * prev_cost2) or np.random.random() < 0.1:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic segment reassembly\n    if len(segments) > 1:\n        # Calculate segment scores based on spatial proximity in both objectives\n        segment_scores = []\n        for seg in segments:\n            # Calculate centroids in both objective spaces\n            centroid1 = np.mean(instance[seg, :2], axis=0)\n            centroid2 = np.mean(instance[seg, 2:], axis=0)\n\n            # Calculate average distance to other segments\n            avg_dist1 = np.mean([np.linalg.norm(centroid1 - np.mean(instance[other_seg, :2], axis=0))\n                                for other_seg in segments if other_seg != seg])\n            avg_dist2 = np.mean([np.linalg.norm(centroid2 - np.mean(instance[other_seg, 2:], axis=0))\n                               for other_seg in segments if other_seg != seg])\n\n            # Combined score (weighted average)\n            score = 0.5 * avg_dist1 + 0.5 * avg_dist2\n            segment_scores.append(score)\n\n        # Reassemble segments in order of decreasing score\n        sorted_indices = np.argsort(segment_scores)[::-1]\n        new_solution = np.concatenate([segments[i] for i in sorted_indices])\n\n    # Guided edge swapping\n    for _ in range(min(5, n//2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try swapping edges\n        candidate = new_solution.copy()\n        if i < j:\n            candidate[i:j+1] = np.concatenate([candidate[j:j+1], candidate[i+1:j], candidate[i:i+1]])\n        else:\n            candidate[j:i+1] = np.concatenate([candidate[i:i+1], candidate[j+1:i], candidate[j:j+1]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly while the other doesn't worsen too much\n        if ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or\n            (new_cost1 < current_cost1 * 0.9 and new_cost2 <= current_cost2 * 1.1) or\n            (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9)):\n            new_solution = candidate\n\n    # Node relocation heuristic\n    for _ in range(min(3, n//3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try relocating node i after node j\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:j+1], [candidate[i]], candidate[j+1:i], candidate[i+1:]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Dynamic relocation probability based on improvement potential\n        improvement_ratio = (current_cost1 - new_cost1) / current_cost1 + (current_cost2 - new_cost2) / current_cost2\n        prob = min(1.0, 0.5 + 0.5 * improvement_ratio)\n        if np.random.random() < prob:\n            new_solution = candidate\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.2572821231179985,
               6.7334989692074805
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' introduces a novel adaptive tour partitioning and multi-objective guided crossover strategy that dynamically decomposes the TSP tour into segments based on their relative importance in both objective spaces, then reconstructs the solution by probabilistically selecting segments from the archive's most diverse solutions and recombining them in a way that balances the trade-off between the two objectives, guided by a multi-objective utility function that considers both the segment's contribution to each objective and its potential for synergy with other segments from different solutions. The selection process prioritizes solutions with high diversity in their edge sets, while the local search operator uses a probabilistic segment exchange mechanism that allows for both inter-solution and intra-solution segment transfers, with the segment selection and recombination pattern determined by an adaptive probability model that learns from the archive's current Pareto front structure and the distance matrices. The function ensures feasibility by maintaining the permutation property through a series of carefully designed segment transfers and rotations, with the transfer probability and segment length determined by the current solution's objective values and their relative dominance in the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution with high potential for improvement\n    diversity_scores = []\n    objective_scores = []\n    for sol, obj in archive:\n        # Calculate diversity score\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity = 0\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges.symmetric_difference(other_edges))\n        diversity_scores.append(diversity)\n\n        # Calculate objective score (normalized)\n        normalized_obj = (obj[0]/sum(o[0] for _, o in archive),\n                         obj[1]/sum(o[1] for _, o in archive))\n        objective_scores.append(normalized_obj)\n\n    # Combine scores for selection\n    combined_scores = []\n    for d, o in zip(diversity_scores, objective_scores):\n        combined_scores.append(d * (1 - (o[0] + o[1])/2))\n\n    if all(s == 0 for s in combined_scores):\n        base_solution = archive[0][0].copy()\n    else:\n        probs = np.array(combined_scores) / sum(combined_scores)\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment transfer strategy\n    if random.random() < 0.6:  # 60% chance for segment transfer\n        # Select segment from another solution\n        other_idx = random.choice([i for i in range(len(archive)) if i != idx])\n        other_sol = archive[other_idx][0]\n\n        # Find common segments between solutions\n        common_segments = []\n        for i in range(n):\n            for j in range(i+2, min(i+6, n)):\n                segment = tuple(base_solution[i:j])\n                if tuple(segment) in [tuple(other_sol[k:k+(j-i)]) for k in range(n)]:\n                    common_segments.append((i, j))\n\n        if common_segments:\n            # Select a random common segment\n            start, end = random.choice(common_segments)\n            segment = new_solution[start:end]\n\n            # Find best position to insert in other solution\n            best_cost = float('inf')\n            best_pos = -1\n\n            for pos in range(n - (end-start) + 1):\n                if pos >= start and pos < end:\n                    continue\n\n                # Create candidate solution\n                candidate = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:start],\n                    new_solution[end:]\n                ])\n\n                # Calculate cost\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n                cost1 += distance_matrix_1[candidate[-1], candidate[0]]\n\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n                cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[best_pos:start],\n                    new_solution[end:]\n                ])\n        else:\n            # If no common segments, perform a simple edge swap\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-based local search with multi-objective consideration\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Find best edge to swap with considering both objectives\n        best_gain = -float('inf')\n        best_k = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Calculate gain for both objectives\n            gain1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                    distance_matrix_1[new_solution[j], new_solution[(k+1)%n]] -\n                    distance_matrix_1[new_solution[i], new_solution[j]] -\n                    distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n            gain2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_2[new_solution[j], new_solution[(k+1)%n]] -\n                    distance_matrix_2[new_solution[i], new_solution[j]] -\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n            # Combine gains with weights based on current objectives\n            current_obj = archive[idx][1]\n            total_obj = sum(o[0] + o[1] for _, o in archive)\n            weight1 = current_obj[0] / total_obj\n            weight2 = current_obj[1] / total_obj\n\n            combined_gain = weight1 * gain1 + weight2 * gain2\n\n            if combined_gain > best_gain:\n                best_gain = combined_gain\n                best_k = k\n\n        if best_k != -1:\n            # Apply the best edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution = np.roll(new_solution, -i)\n            new_solution = np.concatenate([\n                new_solution[:1],\n                new_solution[2:best_k+1],\n                new_solution[1:2],\n                new_solution[best_k+1:]\n            ])\n            new_solution = np.roll(new_solution, i)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, perform a simple repair\n        missing = [i for i in range(n) if i not in new_solution]\n        extra = [i for i in range(n) if list(new_solution).count(i) > 1]\n        if missing and extra:\n            pos = np.where(new_solution == extra[0])[0][0]\n            new_solution[pos] = missing[0]\n\n    return new_solution\n\n",
          "score": [
               6.915718444634539,
               6.31270271370532
          ]
     }
]