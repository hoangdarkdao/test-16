[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel \"objective-aware segment fusion\" strategy that dynamically combines segments from different solutions while prioritizing regions with high potential for improvement in either objective, followed by a \"multi-objective segment inversion\" that flips segments considering both distance matrices to balance the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        obj1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        obj2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        total_obj = obj1 + obj2\n\n        if obj1 > obj2:\n            primary_matrix = distance_matrix_1\n            secondary_matrix = distance_matrix_2\n        else:\n            primary_matrix = distance_matrix_2\n            secondary_matrix = distance_matrix_1\n\n        seg_size = max(2, int(n * 0.2))\n        seg_start = np.random.randint(1, n-seg_size)\n        segment = new_solution[seg_start:seg_start+seg_size]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_start+seg_size:],\n            segment\n        ])\n\n        insert_pos = np.random.randint(1, n-seg_size+1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n\n        def segment_cost(start, end):\n            cost1 = primary_matrix[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = secondary_matrix[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        cost_before = segment_cost(seg1_start, seg1_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.0443797091017066,
            0.1111900806427002
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            new_solution[start:end] = new_solution[end-1:start-1:-1]\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8460879456176522,
            0.07456672191619873
        ]
    }
]