[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.898815676902424,
            0.09545725584030151
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601362894719456,
            0.18925809860229492
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9227092135739206,
            0.18014776706695557
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel \"node swapping\" with a \"multi-segment reordering\" strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 4 and random.random() < 0.6:\n        c, d = sorted(random.sample(range(n), 2))\n        segment1 = new_solution[c:d+1]\n        segment2 = new_solution[d+1:c+1] if c < d else new_solution[d+1:c]\n        new_solution = np.concatenate([new_solution[:c], segment2, segment1, new_solution[d+1:]])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9108755755114819,
            0.18737345933914185
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a hybrid local search operator that combines a novel segment reversal with a dynamic reordering strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b = sorted(random.sample(range(n), 2))\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.7:\n        c, d = sorted(random.sample(range(n), 2))\n        segment = new_solution[c:d+1]\n        new_solution = np.concatenate([new_solution[:c], new_solution[d+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.959617718588408,
            0.19279181957244873
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining adaptive segment reversal and objective-aware edge insertion to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        a, b = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    if n >= 4:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        if cost1_change >= 0 and cost2_change >= 0:\n            new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j+1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8154070991681677,
            0.11828166246414185
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.898815676902424,
            0.09545725584030151
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601362894719456,
            0.18925809860229492
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9227092135739206,
            0.18014776706695557
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9227092135739206,
            0.18014776706695557
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.898815676902424,
            0.09545725584030151
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive by prioritizing those with high potential for improvement, then applies a novel segment inversion and dynamic reordering strategy that combines local and global perturbations to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    if random.random() < 0.5:\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601362894719456,
            0.18925809860229492
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9227092135739206,
            0.18014776706695557
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.898815676902424,
            0.09545725584030151
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and diversity, then applies a hybrid local search combining a novel \"multi-segment inversion\" with a \"cross-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Multi-segment inversion + cross-segment rotation\n    if n > 4:\n        # Multi-segment inversion: Select 2-3 segments and invert each\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(n-3), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(4, n//num_segments), num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = segment[::-1]\n\n        # Cross-segment rotation: Select two non-overlapping segments and rotate them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            rotation_point = np.random.randint(1, min(first_length, second_length))\n            new_solution[first_start:first_start+first_length] = np.concatenate([second_segment[rotation_point:], second_segment[:rotation_point]])\n            new_solution[second_start:second_start+second_length] = np.concatenate([first_segment[rotation_point:], first_segment[:rotation_point]])\n\n    return new_solution\n\n",
        "score": [
            -0.898815676902424,
            0.09545725584030151
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.9227092135739206,
            0.18014776706695557
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score that considers both objectives equally, then applies a hybrid local search operator combining random segment rotation and adaptive edge swapping to generate a feasible neighbor solution while prioritizing improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_scores = (objectives[:, 0] / np.max(objectives[:, 0])) + (objectives[:, 1] / np.max(objectives[:, 1]))\n    selected_idx = np.argmin(normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Random segment rotation\n    if n >= 4:\n        a, b, c = sorted(np.random.choice(n, size=3, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:c+1] = np.concatenate([segment, new_solution[b+1:c+1]])\n\n    # Adaptive edge swapping\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        if cost1_change < 0 and cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9825132786060556,
            2.4285667538642883
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search strategy combining node insertion with adaptive edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best normalized objective score\n    min_obj1 = min(obj[0] for _, obj in archive)\n    min_obj2 = min(obj[1] for _, obj in archive)\n    max_obj1 = max(obj[0] for _, obj in archive)\n    max_obj2 = max(obj[1] for _, obj in archive)\n\n    if max_obj1 == min_obj1 or max_obj2 == min_obj2:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        normalized_scores = [(obj[0] - min_obj1)/(max_obj1 - min_obj1) + (obj[1] - min_obj2)/(max_obj2 - min_obj2) for _, obj in archive]\n        selected_idx = np.argmin(normalized_scores)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node insertion\n    if n >= 3:\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        while j == i or j == i+1 or j == i-1:\n            j = np.random.randint(1, n-1)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Edge swapping with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        if abs(i-j) > 1:\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]] -\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] -\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if cost1_change < 0 or cost2_change < 0:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9013681893931123,
            0.14917200803756714
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node segment shuffle\" with a \"cross-segment swap\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node segment shuffle + cross-segment swap\n    if n > 4:\n        # Node segment shuffle: Select a segment of 2-4 nodes and shuffle them\n        segment_length = np.random.randint(2, min(5, n))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        np.random.shuffle(segment)\n        new_solution[start:start+segment_length] = segment\n\n        # Cross-segment swap: Select two non-overlapping segments and swap them\n        if n > 8:\n            first_start = np.random.randint(0, n//2 - 2)\n            first_length = np.random.randint(2, min(5, n//2 - first_start))\n            second_start = np.random.randint(n//2, n - first_length)\n            second_length = first_length\n\n            first_segment = new_solution[first_start:first_start+first_length]\n            second_segment = new_solution[second_start:second_start+second_length]\n\n            new_solution[first_start:first_start+first_length] = second_segment\n            new_solution[second_start:second_start+second_length] = first_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8771784617919713,
            0.07099348306655884
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined objective score, then applies a novel local search strategy that combines adaptive segment reversal and edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined objective score\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n >= 4:\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution[a:b+1] = segment[::-1]  # Reverse the segment\n\n    # Edge inversion with objective-aware selection\n    if n >= 4:\n        i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n        # Calculate potential cost change\n        cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_1[new_solution[i-1], new_solution[i]] - distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] -\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] - distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Apply inversion if it improves at least one objective\n        if cost1_change < 0 or cost2_change < 0:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9716571767219704,
            0.2193671464920044
        ]
    }
]