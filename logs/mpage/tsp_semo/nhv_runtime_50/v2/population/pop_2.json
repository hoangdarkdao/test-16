[
     {
          "algorithm": "{The proposed algorithm, named \"Adaptive Multi-Objective Tour Fragmentation and Reconstruction,\" builds upon the common backbone of solution selection and local improvement from the provided algorithms but introduces a fundamentally different approach. It first identifies promising solutions by analyzing the archive's Pareto front, then adaptively selects and fragments the tour into multiple segments based on their contribution to each objective. These segments are then reconstructed using a novel \"objective-aware segment merging\" heuristic that prioritizes the most beneficial segments for each objective while maintaining tour feasibility. The method dynamically adjusts the fragmentation size and merging strategy based on the current solution's performance in both objective spaces, allowing for both fine-grained local improvements and more disruptive global explorations. The algorithm ensures feasibility by maintaining a valid tour structure throughout the process and includes a \"segment quality assessment\" mechanism that evaluates each segment's impact on both objectives before merging.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Step 2: Select base solution with probability based on solution quality\n    base_solution = random.choices(\n        non_dominated,\n        weights=[1/(i+1) for i in range(len(non_dominated))],\n        k=1\n    )[0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Adaptive tour fragmentation and reconstruction\n    if n > 3:\n        # Determine fragmentation size based on solution quality\n        fragment_size = min(3, max(1, n // 10))\n        num_fragments = max(2, n // fragment_size)\n\n        # Randomly select fragments to reconstruct\n        fragment_indices = sorted(random.sample(range(1, n-1), num_fragments-1))\n        fragments = []\n        start = 0\n        for idx in fragment_indices:\n            fragments.append(new_solution[start:idx])\n            start = idx\n        fragments.append(new_solution[start:])\n\n        # Shuffle fragments with probability based on objective performance\n        if random.random() < 0.7:\n            random.shuffle(fragments)\n\n        # Reconstruct solution with objective-aware merging\n        merged_solution = []\n        for i in range(len(fragments)):\n            # Calculate fragment quality for each objective\n            frag = fragments[i]\n            if len(frag) < 2:\n                merged_solution.extend(frag)\n                continue\n\n            # Calculate objective contributions\n            obj1_contrib = sum(distance_matrix_1[frag[j], frag[j+1]] for j in range(len(frag)-1))\n            obj2_contrib = sum(distance_matrix_2[frag[j], frag[j+1]] for j in range(len(frag)-1))\n\n            # Decide whether to reverse the fragment based on objective performance\n            if i > 0 and i < len(fragments)-1:\n                prev_node = merged_solution[-1] if merged_solution else fragments[i-1][-1]\n                next_node = fragments[i+1][0] if i < len(fragments)-1 else frag[-1]\n\n                # Calculate potential improvement if reversed\n                rev_obj1 = sum(distance_matrix_1[frag[j], frag[j+1]] for j in range(len(frag)-1))\n                rev_obj2 = sum(distance_matrix_2[frag[j], frag[j+1]] for j in range(len(frag)-1))\n\n                if (rev_obj1 < obj1_contrib and rev_obj2 < obj2_contrib) or \\\n                   (random.random() < 0.3 and (rev_obj1 < obj1_contrib or rev_obj2 < obj2_contrib)):\n                    frag = frag[::-1]\n\n            merged_solution.extend(frag)\n\n        # Ensure the tour is circular\n        if merged_solution[0] != merged_solution[-1]:\n            merged_solution.append(merged_solution[0])\n\n        new_solution = np.array(merged_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9578128800630137,
               0.3399670124053955
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or all if fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 3-opt with a novel segment reversal strategy\n    # First, perform a random 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    if i == 0 and k == n-1:  # Avoid full reversal which is equivalent to a swap\n        i, j, k = 0, 1, 2\n\n    # Create three segments and reverse the middle one\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j+1][::-1]\n    segment3 = new_solution[j+1:k+1][::-1]\n    segment4 = new_solution[k+1:]\n\n    # Combine segments with a novel crossover pattern\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Ensure the solution remains feasible\n    # Verify all nodes are present and unique\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.5515284065342554,
               0.4913042187690735
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive  # Fallback to all solutions if none are non-dominated\n\n    # Step 2: Select a solution with high diversity (sum of distances in both objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in non_dominated])\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Segmented inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment lengths dynamically based on instance size\n    segment_length = max(2, n // 10)  # At least 2 nodes per segment\n\n    for i in range(0, n, segment_length):\n        segment_start = i\n        segment_end = min(i + segment_length, n)\n\n        # Calculate segment cost in both objectives\n        segment_cost_1 = 0\n        segment_cost_2 = 0\n        for j in range(segment_start, segment_end - 1):\n            node_a = base_solution[j]\n            node_b = base_solution[j + 1]\n            segment_cost_1 += distance_matrix_1[node_a, node_b]\n            segment_cost_2 += distance_matrix_2[node_a, node_b]\n\n        # Probability of inversion is inversely proportional to segment cost\n        total_cost = segment_cost_1 + segment_cost_2\n        if total_cost > 0:\n            inversion_prob = 1.0 / (1.0 + total_cost / (distance_matrix_1.sum() + distance_matrix_2.sum()))\n        else:\n            inversion_prob = 0.5\n\n        if np.random.rand() < inversion_prob:\n            # Invert the segment\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
          "score": [
               -0.9562401881074726,
               0.8160168528556824
          ]
     },
     {
          "algorithm": "{The proposed local search strategy, named \"Adaptive Multi-Objective Edge Insertion with Dynamic Neighborhood Exploration,\" combines adaptive edge selection based on Pareto dominance and objective-specific distance matrices with dynamic neighborhood exploration to balance exploration and exploitation. It first identifies promising edges by analyzing the Pareto front of the archive, then adaptively selects edges with high potential for improvement by considering both objective-specific distances and their contribution to the overall solution quality. The dynamic neighborhood exploration phase employs a hybrid approach that alternates between edge-based and segment-based operations, guided by the current solution's performance in each objective space. The method ensures feasibility by maintaining a valid tour structure and includes a novel \"objective-aware edge insertion\" operator that selectively inserts edges based on their impact on both objectives, while a \"segment reordering\" heuristic reorders segments of the tour to optimize both spaces simultaneously. The adaptive selection of operations and the dynamic adjustment of neighborhood size based on the solution's convergence properties enhance the method's ability to escape local optima and explore diverse regions of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by non-dominated rank and crowding distance\n        sorted_archive = sorted(archive, key=lambda x: (sum(x[1]), -len(x[0])))\n        # Select a solution with probability proportional to its rank\n        selected_idx = random.choices(range(len(sorted_archive)), weights=[1/(i+1) for i in range(len(sorted_archive))])[0]\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for edge-based operation\n        # Objective-aware edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential improvement in both objectives\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly\n        if obj1_improvement < 0 and obj2_improvement < 0:\n            # Insert edge (i,j) between i and j\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n        elif (obj1_improvement < 0 and obj2_improvement < 10) or (obj2_improvement < 0 and obj1_improvement < 10):\n            # Insert edge (i,j) between i and j\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n    else:\n        # Segment reordering operation\n        if n > 3:\n            # Select two random segments and reverse one of them\n            k1, k2 = sorted(random.sample(range(1, n-1), 2))\n            if random.random() < 0.5:\n                # Reverse segment between k1 and k2\n                new_solution[k1:k2+1] = new_solution[k1:k2+1][::-1]\n            else:\n                # Swap segments\n                segment1 = new_solution[k1:k2+1]\n                k3 = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:k3], segment1, new_solution[k3:k1], new_solution[k2+1:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8044547072753083,
               0.5334844589233398
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify those with the highest potential for improvement, prioritizing solutions with lower objective values and higher diversity in their tour structures. It then intelligently selects a base solution using a tournament selection mechanism that balances exploration and exploitation, favoring solutions that are not only Pareto-optimal but also exhibit structural diversity. The selected base solution undergoes a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge insertion mechanism. This operator first partitions the tour into multiple segments, inverts a randomly selected segment to disrupt the current structure, and then intelligently reinserts edges from the inverted segment back into the tour using a guided approach that minimizes the increase in both objective costs. The operator ensures feasibility by maintaining a valid TSP tour throughout the process, and it employs a dynamic acceptance criterion to accept non-improving solutions with a small probability, preventing premature convergence. The generated neighbor solution is then returned, representing a high-quality candidate for further exploration in the optimization process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on objective values and diversity\n    def select_base(archive):\n        # Rank solutions based on objective values (lower is better)\n        objectives = np.array([obj for _, obj in archive])\n        ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n        # Select top 10% of solutions for tournament\n        tournament_size = max(1, len(archive) // 10)\n        candidates = [archive[i] for i in ranks[:tournament_size]]\n\n        # Select the solution with the highest diversity (most different from others)\n        def diversity(sol):\n            total_dist = 0\n            for other_sol, _ in candidates:\n                if not np.array_equal(sol, other_sol):\n                    total_dist += np.sum(sol != other_sol)\n            return total_dist\n\n        base_sol, _ = max(candidates, key=lambda x: diversity(x[0]))\n        return base_sol.copy()\n\n    base_solution = select_base(archive)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select a segment to invert\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge insertion\n    def calculate_cost(sol, distance_matrix_1, distance_matrix_2):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i + 1) % n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i + 1) % n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n\n    for _ in range(10):  # Limit the number of insertion attempts\n        # Randomly select two edges to reconnect\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create a new candidate solution by reconnecting edges\n        candidate = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j+1:],\n            new_solution[i+1:j+1]\n        ])\n\n        # Ensure the candidate is a valid tour\n        if len(np.unique(candidate)) == n:\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate, distance_matrix_1, distance_matrix_2)\n\n            # Accept the candidate if it improves both objectives\n            if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) or \\\n               (np.random.rand() < 0.1):  # Small probability to accept non-improving solutions\n                new_solution = candidate\n                current_cost1, current_cost2 = candidate_cost1, candidate_cost2\n\n    return new_solution\n\n",
          "score": [
               -0.9394132083738742,
               1.2528079152107239
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select base solution with probabilistic approach\n    weights = []\n    for _, obj in non_dominated:\n        # Calculate solution quality metric (harmonic mean of objectives)\n        if obj[0] + obj[1] == 0:\n            quality = 0\n        else:\n            quality = 2 / ((1/obj[0]) + (1/obj[1]))\n        weights.append(quality)\n\n    # Normalize weights\n    total_weight = sum(weights)\n    if total_weight > 0:\n        weights = [w/total_weight for w in weights]\n    else:\n        weights = [1/len(weights)] * len(weights)\n\n    base_solution = random.choices([sol for sol, _ in non_dominated], weights=weights, k=1)[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 3: Hybrid local search with multi-segment inversion and dynamic exchange\n    # Select multiple non-overlapping segments\n    num_segments = random.randint(1, min(3, n//4))\n    segment_lengths = random.sample(range(2, min(5, n//2)), num_segments)\n    segment_lengths = sorted(segment_lengths, reverse=True)\n\n    # Generate non-overlapping segments\n    segments = []\n    remaining_positions = list(range(n))\n    for length in segment_lengths:\n        if len(remaining_positions) < length:\n            break\n        start = random.choice(remaining_positions)\n        segment = []\n        for i in range(length):\n            pos = (start + i) % n\n            if pos in remaining_positions:\n                segment.append(pos)\n                remaining_positions.remove(pos)\n        if len(segment) == length:\n            segments.append(segment)\n\n    # Invert each segment\n    for seg in segments:\n        seg_start = seg[0]\n        seg_end = seg[-1]\n        new_solution[seg_start:seg_end+1] = new_solution[seg_start:seg_end+1][::-1]\n\n    # Dynamic node exchange between segments\n    for _ in range(min(3, len(segments))):\n        if len(segments) < 2:\n            break\n        seg1, seg2 = random.sample(segments, 2)\n        if len(seg1) > 1 and len(seg2) > 1:\n            pos1 = random.choice(seg1)\n            pos2 = random.choice(seg2)\n            new_solution[pos1], new_solution[pos2] = new_solution[pos2], new_solution[pos1]\n\n    # Step 4: Acceptance criterion with objective diversity\n    # Calculate current and new objective values\n    def calculate_objectives(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_1[solution[-1], solution[0]]\n        cost2 = sum(distance_matrix_2[solution[i], solution[i+1]] for i in range(n-1)) + distance_matrix_2[solution[-1], solution[0]]\n        return cost1, cost2\n\n    current_obj = archive[[sol.tolist() for sol, _ in archive].index(base_solution.tolist())][1]\n    new_obj = calculate_objectives(new_solution)\n\n    # Accept if either objective improves or if both are within 10% of the current values\n    accept = (new_obj[0] < current_obj[0] or new_obj[1] < current_obj[1] or\n              (new_obj[0] <= 1.1 * current_obj[0] and new_obj[1] <= 1.1 * current_obj[1]))\n\n    if not accept:\n        # Revert to base solution if not accepted\n        new_solution = base_solution.copy()\n\n    # Step 5: Fine-tuning with restricted variable neighborhood descent\n    neighborhoods = [\n        lambda sol: sol[::-1],  # Complete reversal\n        lambda sol: np.roll(sol, random.randint(1, n-1)),  # Circular shift\n        lambda sol: np.concatenate([sol[:n//2][::-1], sol[n//2:][::-1]])  # Double reversal\n    ]\n\n    for _ in range(3):\n        for neighborhood in neighborhoods:\n            candidate = neighborhood(new_solution.copy())\n            candidate_obj = calculate_objectives(candidate)\n            if (candidate_obj[0] < new_obj[0] or candidate_obj[1] < new_obj[1] or\n                (candidate_obj[0] <= 1.05 * new_obj[0] and candidate_obj[1] <= 1.05 * new_obj[1])):\n                new_solution = candidate.copy()\n                new_obj = candidate_obj\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.7234902892166956,
               0.8977619409561157
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Hybrid Segment Recombination with Adaptive Perturbation,\" intelligently selects a solution from the archive by prioritizing those with high crowding distance in the Pareto front or low dominance counts, then applies a hybrid local search operator that combines a variable-length segment exchange mechanism with adaptive perturbation. This operator selectively recombines non-overlapping segments from the selected solution with segments from other archive solutions, while dynamically adjusting the segment length based on the solution's quality and the diversity of the archive. Additionally, it incorporates a controlled perturbation step that introduces small, localized changes to the tour to escape local optima, with the perturbation intensity proportional to the solution's current objective values and the diversity of the archive. The algorithm ensures feasibility by validating all generated solutions for valid TSP tours and reverting to the original solution if any infeasibility is detected.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high crowding distance or low dominance count\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        # Find neighbors in the objective space\n        left = None\n        right = None\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and not (objectives[j][0] == objectives[i][0] and objectives[j][1] == objectives[i][1]):\n                # Dominated by j\n                if left is None or (objectives[j][0] >= objectives[left][0] and objectives[j][1] >= objectives[left][1]):\n                    left = j\n            elif (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and not (objectives[i][0] == objectives[j][0] and objectives[i][1] == objectives[j][1]):\n                # Dominates j\n                if right is None or (objectives[j][0] <= objectives[right][0] and objectives[j][1] <= objectives[right][1]):\n                    right = j\n        if left is not None and right is not None:\n            crowding_distances[i] = (objectives[right][0] - objectives[left][0]) + (objectives[right][1] - objectives[left][1])\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment recombination with adaptive perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment length adaptively\n    segment_length = max(2, int(np.random.uniform(0.1, 0.3) * n))\n\n    # Select two non-overlapping segments\n    a_start = np.random.randint(0, n - segment_length)\n    a_end = a_start + segment_length\n    b_start = np.random.randint(0, n - segment_length)\n    b_end = b_start + segment_length\n\n    # Ensure segments are non-overlapping\n    while not (a_end <= b_start or b_end <= a_start):\n        b_start = np.random.randint(0, n - segment_length)\n        b_end = b_start + segment_length\n\n    # Extract segments\n    segment_a = base_solution[a_start:a_end]\n    segment_b = base_solution[b_start:b_end]\n\n    # Create a new solution by swapping segments\n    new_solution[a_start:a_end] = segment_b\n    new_solution[b_start:b_end] = segment_a\n\n    # Ensure the new solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    # Step 3: Apply adaptive perturbation\n    perturbation_intensity = 0.1 * (1 - crowding_distances[selected_idx] / np.max(crowding_distances + 1e-6))\n    if np.random.rand() < perturbation_intensity:\n        # Randomly select two positions and swap them\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9221275616184177,
               1.2943867444992065
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of 3-opt and path relinking with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to modify (3-opt style)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = [segment1, segment3, segment2, segment4]\n    new_solution = np.concatenate(new_order)\n\n    # Path relinking: blend with another solution from archive\n    if len(archive) > 1:\n        other_solution = random.choice([s for s, _ in archive if not np.array_equal(s, base_solution)])\n        # Find common nodes and align segments\n        common_nodes = set(base_solution).intersection(set(other_solution))\n        if common_nodes:\n            # Create a new solution by combining segments from both solutions\n            # This is a simplified version of path relinking\n            new_solution = np.concatenate([base_solution[:len(base_solution)//2], other_solution[len(other_solution)//2:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If invalid, revert to base solution with a small random modification\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.7122305368764223,
               1.100231647491455
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Identify segments with high potential for improvement\n    segment_length = max(2, n // 5)\n    segment_scores = []\n\n    for i in range(n - segment_length + 1):\n        segment = new_solution[i:i+segment_length]\n        # Calculate segment cost in both objectives\n        cost1 = sum(distance_matrix_1[segment[j], segment[j+1]] for j in range(segment_length-1))\n        cost2 = sum(distance_matrix_2[segment[j], segment[j+1]] for j in range(segment_length-1))\n        # Score based on imbalance and potential for improvement\n        score = abs(cost1 - cost2) * (1 / (cost1 + cost2 + 1e-6))\n        segment_scores.append((i, score))\n\n    if not segment_scores:\n        segment_scores = [(0, 0)]\n\n    # Select top segments for evolution\n    segment_scores.sort(key=lambda x: x[1], reverse=True)\n    selected_segments = [x[0] for x in segment_scores[:2]]\n\n    # Step 3: Evolve selected segments\n    for start_idx in selected_segments:\n        segment = new_solution[start_idx:start_idx+segment_length]\n\n        # Random perturbation\n        if random.random() < 0.7:\n            segment = np.random.permutation(segment)\n\n        # Local search within segment\n        best_segment = segment.copy()\n        best_cost = float('inf')\n\n        for _ in range(5):  # Limited iterations for efficiency\n            candidate = np.random.permutation(segment)\n            cost1 = sum(distance_matrix_1[candidate[j], candidate[j+1]] for j in range(len(candidate)-1))\n            cost2 = sum(distance_matrix_2[candidate[j], candidate[j+1]] for j in range(len(candidate)-1))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_segment = candidate\n\n        # Cross-dimensional alignment\n        if random.random() < 0.5:\n            # Swap nodes between objectives\n            for i in range(len(best_segment)):\n                if random.random() < 0.3:\n                    # Find node with better alignment in the other objective\n                    current_node = best_segment[i]\n                    best_node = current_node\n                    best_diff = float('inf')\n\n                    for candidate_node in range(n):\n                        if candidate_node not in best_segment:\n                            diff = abs(distance_matrix_1[current_node, best_segment[(i+1)%len(best_segment)]] -\n                                     distance_matrix_2[candidate_node, best_segment[(i+1)%len(best_segment)]])\n                            if diff < best_diff:\n                                best_diff = diff\n                                best_node = candidate_node\n\n                    if best_node != current_node:\n                        best_segment[i] = best_node\n\n        # Reinsert evolved segment\n        new_solution = np.concatenate([new_solution[:start_idx], best_segment, new_solution[start_idx+segment_length:]])\n\n    # Step 4: Validate solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If invalid, revert to base solution with a small modification\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.763943173422974,
               1.6525200605392456
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-objective clustering-based selection strategy that first partitions the archive into k clusters using a k-means approach on the normalized objective values, then selects the cluster with the highest average improvement potential based on both objectives, and finally applies a novel \"objective-aware node insertion\" operator that probabilistically inserts nodes into the tour while considering their relative contributions to both objectives, ensuring feasibility by maintaining a valid tour structure throughout the operation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Cluster-based selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n\n    from sklearn.cluster import KMeans\n    k = min(3, len(archive))\n    kmeans = KMeans(n_clusters=k, random_state=42).fit(normalized_obj)\n    cluster_sizes = np.bincount(kmeans.labels_)\n\n    # Select cluster with largest size (most representative)\n    selected_cluster = np.argmax(cluster_sizes)\n    cluster_indices = np.where(kmeans.labels_ == selected_cluster)[0]\n\n    # Select best solution in the selected cluster\n    cluster_objectives = objectives[cluster_indices]\n    best_in_cluster = cluster_indices[np.argmin(np.sum(cluster_objectives, axis=1))]\n    base_solution = archive[best_in_cluster][0].copy()\n\n    # Step 2: Objective-aware node insertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Calculate node contributions in both objectives\n        node_contributions = np.zeros(n)\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            node_contributions[i] = (distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node] +\n                                    distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node])\n\n        # Select nodes with highest contribution for potential removal\n        sorted_nodes = np.argsort(node_contributions)[::-1]\n        selected_nodes = sorted_nodes[:min(3, n//2)]\n\n        for node in selected_nodes:\n            # Find best insertion position considering both objectives\n            best_pos = -1\n            best_cost = float('inf')\n\n            for pos in range(n):\n                if pos == node or pos == (node-1)%n:\n                    continue\n\n                # Calculate insertion cost\n                prev = new_solution[pos-1]\n                curr = new_solution[pos]\n                removed_node = new_solution[node]\n\n                cost1 = (distance_matrix_1[prev, removed_node] + distance_matrix_1[removed_node, curr] -\n                        distance_matrix_1[prev, curr])\n                cost2 = (distance_matrix_2[prev, removed_node] + distance_matrix_2[removed_node, curr] -\n                        distance_matrix_2[prev, curr])\n\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                # Perform insertion\n                removed_node = new_solution[node]\n                new_solution = np.concatenate([new_solution[:node], new_solution[node+1:]])\n                new_solution = np.insert(new_solution, best_pos, removed_node)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.8464608979104745,
               4.435267090797424
          ]
     }
]