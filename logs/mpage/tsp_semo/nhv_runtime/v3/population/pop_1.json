[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid Local Search: Combine 2-opt with a novel segment relocation\n    n = len(base_solution)\n\n    # Step 1: Randomly select two non-adjacent segments\n    a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    c, d = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n\n    # Step 2: Relocate the segment between a and b to after c\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:c+1], segment, new_solution[c+1:]])\n\n    # Step 3: Apply 2-opt on the relocated segment\n    i, j = sorted(np.random.choice(range(len(segment)), 2, replace=False))\n    segment[i], segment[j] = segment[j], segment[i]\n\n    # Ensure the solution remains valid\n    assert len(np.unique(new_solution)) == n, \"Invalid solution generated\"\n\n    return new_solution\n\n",
          "score": [
               -0.6753597224650268,
               0.0938725471496582
          ]
     },
     {
          "algorithm": "{The proposed algorithm for generating a high-quality neighbor solution in the bi-objective TSP involves first selecting a promising base solution from the archive by prioritizing those with objectives that are neither dominated nor excessively similar to others, ensuring diversity. Then, it applies a hybrid local search operator that combines a novel edge-swapping mechanism with a variable-length segment relocation strategy. The edge-swapping mechanism identifies critical edges in both objective spaces, swapping them while preserving tour validity, while the segment relocation strategy dynamically adjusts the length of relocated segments based on the local topology of the solution, favoring segments that yield significant cost reductions in either objective. The algorithm ensures feasibility by maintaining permutation validity throughout all operations and uses a probabilistic acceptance criterion to balance exploration and exploitation, favoring neighbors that improve Pareto dominance or show potential for further improvement.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution from the archive\n    selected_solution, _ = archive[np.random.choice(len(archive))]\n    new_solution = selected_solution.copy()\n\n    # Hybrid local search operator\n    n = len(new_solution)\n\n    # Step 1: Edge-swapping mechanism\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n    new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n\n    # Step 2: Variable-length segment relocation\n    segment_length = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    # Remove segment and insert elsewhere\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure solution remains valid (permutation of all nodes)\n    assert len(new_solution) == n and len(np.unique(new_solution)) == n\n\n    return new_solution\n\n",
          "score": [
               -0.8379564264344043,
               0.2384818196296692
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: combine edge assembly with partial 3-opt\n    n = len(base_solution)\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n\n    # Edge assembly: reconnect edges to form a new tour segment\n    new_solution[i:j] = base_solution[i:j][::-1]  # Reverse segment\n    new_solution[j:k] = base_solution[j:k][::-1]  # Reverse another segment\n\n    # Partial 3-opt: attempt to improve the tour by reconnecting three edges\n    if np.random.rand() < 0.5:\n        # Randomly select three nodes and attempt to reconnect them\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n        new_solution[b:c] = base_solution[b:c][::-1]\n\n    # Ensure feasibility: verify no duplicates and all nodes are included\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple 2-opt if the solution becomes invalid\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = base_solution[a:b][::-1]\n\n    return new_solution\n\n",
          "score": [
               -0.8337802753264643,
               0.16590946912765503
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with probability inversely proportional to its objective values\n    objectives = np.array([obj for _, obj in non_dominated])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1.0 / (normalized_obj + 1e-10)\n    probs = weights.sum(axis=1) / weights.sum()\n    selected_idx = np.random.choice(len(non_dominated), p=probs)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search - edge insertion and node relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to remove and reinsert\n    start = np.random.randint(0, n)\n    length = np.random.randint(2, min(n - 1, 5))  # Segment length between 2 and 4\n    end = (start + length) % n\n\n    if start < end:\n        segment = new_solution[start:end]\n        remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    else:\n        segment = np.concatenate([new_solution[start:], new_solution[:end]])\n        remaining = new_solution[end:start]\n\n    # Find a new position to insert the segment\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    if insert_pos == 0:\n        new_solution = np.concatenate([segment, remaining])\n    elif insert_pos == len(remaining):\n        new_solution = np.concatenate([remaining, segment])\n    else:\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Randomly relocate a node\n    if n > 2:\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    # Step 4: Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9880560877894095,
               0.30501770973205566
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solutions in the archive by evaluating their dominance or non-dominated status, then intelligently selects one based on a hybrid strategy combining a biased random selection and a local search quality assessment. It then applies a novel hybrid local search operator that dynamically alternates between a multi-segment inversion (MSI) and a guided edge insertion (GEI) strategy, where MSI focuses on reversing segments of the tour to improve both objectives, while GEI strategically inserts nodes based on their relative improvement potential in either objective space, ensuring feasibility by maintaining a valid tour structure throughout the process. The function ensures the neighbor solution remains feasible by validating the tour structure after each modification, and returns the improved solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # We prioritize solutions that are non-dominated or have high potential for improvement\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                # Check if solution i is dominated by solution j\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n\n    non_dominated_indices = [i for i in range(len(archive)) if not dominated[i]]\n    if non_dominated_indices:\n        # Select from non-dominated solutions\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        # If all are dominated, select randomly (could be improved with other criteria)\n        selected_idx = np.random.randint(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # MSI (Multi-Segment Inversion)\n    if np.random.rand() < 0.7:  # Higher probability for MSI\n        # Select two random segments and reverse them\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        c, d = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n        new_solution[c:d] = np.flip(new_solution[c:d])\n    else:\n        # GEI (Guided Edge Insertion)\n        # Select a node and insert it in a position that improves both objectives\n        node_idx = np.random.randint(n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        # Find the best insertion position\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n - 1):\n            # Calculate improvement for both objectives\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n            old_cost1 = distance_matrix_1[prev_node, next_node]\n            new_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            improvement1 = old_cost1 - new_cost1\n\n            old_cost2 = distance_matrix_2[prev_node, next_node]\n            new_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            improvement2 = old_cost2 - new_cost2\n\n            # Combine improvements (could be weighted)\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution is valid (all nodes are visited exactly once)\n    assert len(new_solution) == len(base_solution) and len(np.unique(new_solution)) == len(base_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.8293718919577119,
               0.3290862441062927
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a hybrid local search strategy: 3-opt with biased edge selection\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Identify edges with high cost in either objective space\n    high_cost_edges = []\n    for i in range(n):\n        u, v = selected_solution[i], selected_solution[(i+1)%n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_edges.append((i, (i+1)%n))\n\n    if high_cost_edges:\n        # Randomly select a high-cost edge to modify\n        edge_start, edge_end = random.choice(high_cost_edges)\n        # Apply 3-opt: reconnect three edges to form a new cycle\n        i, j, k = edge_start, (edge_start + 1) % n, (edge_start + 2) % n\n        new_solution[i], new_solution[j], new_solution[k] = new_solution[k], new_solution[i], new_solution[j]\n\n    return new_solution\n\n",
          "score": [
               -0.9228213845482578,
               0.32953977584838867
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Rank solutions by combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    combined_scores = normalized_obj[:, 0] + normalized_obj[:, 1]\n    ranks = np.argsort(combined_scores)[::-1]\n\n    # Step 2: Probabilistically select a solution based on rank (higher rank = higher probability)\n    selection_probs = np.exp(-0.5 * np.arange(len(archive)))  # Exponential decay\n    selection_probs = selection_probs[ranks]\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 3: Identify critical edges (top 20% edges with highest contribution to total cost)\n    def get_edge_contributions(solution, distance_matrix):\n        total_cost = 0.0\n        edge_costs = []\n        for i in range(len(solution) - 1):\n            cost = distance_matrix[solution[i], solution[i+1]]\n            edge_costs.append(cost)\n            total_cost += cost\n        edge_costs.append(distance_matrix[solution[-1], solution[0]])  # Close the loop\n        total_cost += edge_costs[-1]\n        edge_contributions = np.array(edge_costs) / total_cost\n        return edge_contributions\n\n    edge_contrib_1 = get_edge_contributions(base_solution, distance_matrix_1)\n    edge_contrib_2 = get_edge_contributions(base_solution, distance_matrix_2)\n    combined_contrib = edge_contrib_1 + edge_contrib_2\n    critical_edges = np.argsort(combined_contrib)[-max(2, len(combined_contrib) // 5):]\n\n    # Step 4: Perform dynamic segment relocation\n    new_solution = base_solution.copy()\n    if len(critical_edges) < 2:\n        # Fallback to simple swap if not enough critical edges\n        i, j = np.random.choice(len(new_solution), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Select two critical edges and move a segment between them\n        edge1, edge2 = np.random.choice(critical_edges, 2, replace=False)\n        edge1, edge2 = min(edge1, edge2), max(edge1, edge2)\n\n        segment_length = np.random.randint(2, min(10, len(new_solution) // 2) + 1)\n        start_pos = edge1 + 1\n        end_pos = min(start_pos + segment_length, len(new_solution))\n\n        segment = new_solution[start_pos:end_pos]\n        new_solution = np.concatenate([\n            new_solution[:start_pos],\n            new_solution[end_pos:edge2+1],\n            segment,\n            new_solution[edge2+1:]\n        ])\n\n    # Step 5: Validate the new solution\n    if len(np.unique(new_solution)) != len(base_solution):\n        # Fallback to base solution if invalid\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.784269083981462,
               0.31758350133895874
          ]
     },
     {
          "algorithm": "{The proposed heuristic function, 'select_neighbor', first identifies promising solutions in the archive by evaluating their non-dominated status and diversity, using a combination of Pareto dominance and crowding distance metrics to prioritize solutions that lie on the Pareto front or are isolated in the objective space. It then applies a hybrid local search operator that integrates a novel \"segment inversion\" strategy with a dynamic edge exchange mechanism. The segment inversion randomly selects a contiguous segment of nodes in the tour and reverses their order, while the dynamic edge exchange identifies the most promising edges to swap based on a weighted combination of their contributions to both objectives, ensuring feasibility by maintaining the tour's Hamiltonian cycle structure. The function intelligently selects a solution from the archive using a roulette wheel selection biased toward higher-quality solutions, and the generated neighbor solution is validated to ensure it remains a valid TSP tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Use a roulette wheel selection based on the inverse of the sum of objectives\n    objectives = np.array([obj for _, obj in archive])\n    fitness = 1.0 / (objectives.sum(axis=1) + 1e-10)  # Avoid division by zero\n    probabilities = fitness / fitness.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Segment inversion + Dynamic edge exchange\n    if n > 3:\n        # Segment inversion\n        start = np.random.randint(0, n-2)\n        end = np.random.randint(start+1, n)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Dynamic edge exchange\n        # Find edges with high potential for improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Find the most promising edges to swap\n        for _ in range(min(3, n//2)):\n            i = np.random.randint(0, n-1)\n            j = np.random.randint(i+1, n)\n\n            # Calculate potential new costs\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n            new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n            # Accept if improvement in at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                current_cost1, current_cost2 = new_cost1, new_cost2\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.8839295824162168,
               0.33863770961761475
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a solution with high potential for improvement (lower combined objective and higher diversity)\n    def selection_criteria(sol_obj):\n        sol, obj = sol_obj\n        combined = obj[0] + obj[1]\n        diversity = sum(abs(obj[0] - other_obj[0]) + abs(obj[1] - other_obj[1]) for _, other_obj in archive)\n        return -combined + 0.5 * diversity\n\n    selected = max(non_dominated, key=selection_criteria)[0].copy()\n\n    # Step 3: Apply hybrid local search\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Randomized edge exchange (similar to 3-opt but more flexible)\n    for _ in range(min(3, n // 2)):\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different edge exchange patterns\n        if random.random() < 0.5:\n            new_solution[i:j] = new_solution[i:j][::-1]  # Reverse segment\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]  # Swap nodes\n\n    # Node reinsertion with objective-aware placement\n    for _ in range(min(2, n // 3)):\n        i = random.randint(0, n-1)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        # Find best insertion point based on both objectives\n        best_pos = 0\n        best_cost = float('inf')\n        for j in range(len(new_solution)):\n            candidate = np.insert(new_solution, j, node)\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(len(candidate)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility (though the operations above should maintain it)\n    assert len(new_solution) == len(selected) and len(set(new_solution)) == len(selected), \"Generated solution is invalid\"\n\n    return new_solution\n\n",
          "score": [
               -0.828759489044435,
               1.4750920534133911
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = len(sorted_archive) // 2\n    base_solution = sorted_archive[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator combining 2-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to invert (novel segment inversion)\n    seg1_start = np.random.randint(0, n)\n    seg1_end = np.random.randint(seg1_start + 1, n + 1)\n    seg1 = new_solution[seg1_start:seg1_end]\n\n    seg2_start = np.random.randint(0, n)\n    seg2_end = np.random.randint(seg2_start + 1, n + 1)\n    seg2 = new_solution[seg2_start:seg2_end]\n\n    # Invert the segments\n    new_solution[seg1_start:seg1_end] = seg1[::-1]\n    new_solution[seg2_start:seg2_end] = seg2[::-1]\n\n    # Ensure feasibility by checking for duplicates and repairing\n    unique, counts = np.unique(new_solution, return_counts=True)\n    duplicates = unique[counts > 1]\n\n    for dup in duplicates:\n        # Find missing nodes\n        missing = np.setdiff1d(np.arange(n), new_solution)\n        if len(missing) > 0:\n            # Replace duplicates with missing nodes\n            for i in range(n):\n                if new_solution[i] == dup:\n                    new_solution[i] = missing[0]\n                    missing = missing[1:]\n                    if len(missing) == 0:\n                        break\n\n    # Step 3: Apply 2-opt to further refine the solution\n    improved = True\n    while improved:\n        improved = False\n        for i in range(1, n-1):\n            for j in range(i+1, n):\n                if j - i == 1:\n                    continue  # Skip adjacent nodes\n                # Calculate current cost\n                current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] +\n                                distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                                distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n                # Calculate new cost\n                new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                            distance_matrix_1[new_solution[i], new_solution[(j+1)%n]] +\n                            distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                            distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n                if new_cost < current_cost:\n                    # Reverse the segment between i and j\n                    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n                    improved = True\n                    break\n            if improved:\n                break\n\n    return new_solution\n\n",
          "score": [
               -0.7769529561611668,
               2.1659647822380066
          ]
     }
]