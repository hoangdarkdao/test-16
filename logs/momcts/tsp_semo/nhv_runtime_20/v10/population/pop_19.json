[
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted probability favoring solutions with lower average normalized objective values, then applies either a standard 2-opt operation or a novel segment inversion/reinsertion strategy to generate a neighbor solution while ensuring feasibility. The segment operation specifically inverts a random segment of the tour and reinserts it at the best position to minimize the combined cost of both objectives, providing a more exploratory local search compared to pure 2-opt.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = objectives - objectives.min(axis=0)\n    normalized = normalized / (normalized.max(axis=0) + 1e-10)\n    weights = 1 - normalized.mean(axis=1)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combination of 2-opt and segment inversion/reinsertion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between 2-opt or segment operation\n    if random.random() < 0.5:\n        # 2-opt operation\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Segment inversion and reinsertion\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        remaining = np.delete(new_solution, range(start, start+segment_length))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n\n        # Find best insertion point for inverted segment\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            temp_solution = np.insert(remaining, pos, inverted_segment)\n            cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    return new_solution\n\n",
        "score": [
            -0.9353011851346344,
            1.5762245655059814
        ]
    },
    {
        "algorithm": "The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n",
        "score": [
            -0.8179669842566333,
            0.3183813691139221
        ]
    },
    {
        "algorithm": "The heuristic algorithm selects a promising solution from the archive by prioritizing balanced objectives (40% weight for the first cost, 60% for the second) and randomly applies either a node swap or a path reversal to generate a neighbor, ensuring feasibility by verifying no nodes are duplicated or missing. The method balances exploration and exploitation by favoring more balanced solutions and using a hybrid local search strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower weighted objectives (prioritize balanced solutions)\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)  # Select from top 5 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or path reversal\n    if random.random() < 0.6:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path reversal between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n",
        "score": [
            -0.9229999080145157,
            1.1371864676475525
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using Pareto-dominance-based selection, prioritizing non-dominated solutions, then applies a hybrid local search operator that combines segment rotation and edge insertion to generate a neighbor solution while ensuring feasibility by validating the tour and reverting to the original if invalid. The segment size and rotation are randomized to balance diversification and intensification, with the solution's objective values implicitly guiding the search.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj[0] and obj_j[1] <= obj[1] and (obj_j[0] < obj[0] or obj_j[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation and edge insertion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    best_pos = random.randint(0, len(remaining))\n\n    # Insert the rotated segment at the best position\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9319700699839684,
            1.4907165169715881
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the Pareto front of the archive, then applies a hybrid local search that probabilistically rotates variable-length segments and performs edge flips to improve the tour while maintaining feasibility. It prioritizes segments with higher combined costs and uses a weighted selection to focus on non-dominated solutions, balancing exploration and exploitation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    pareto_front = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    weights = np.ones(len(pareto_front)) / len(pareto_front)\n    selected_idx = np.random.choice(pareto_front, p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(3, min(10, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    total_seg_cost = seg_cost1 + seg_cost2\n\n    swap_prob = min(0.9, 0.3 + (total_seg_cost / (seg_cost1 + seg_cost2 + 1e-10)) * 0.6)\n\n    if random.random() < swap_prob:\n        segment = np.roll(segment, random.randint(1, segment_length-1))\n\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 3:\n            temp = new_solution[i:j].copy()\n            new_solution[i:j] = temp[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9738251753841195,
            6.755994498729706
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing those with lower combined objective costs (weighted 60% for the first objective and 40% for the second), then applies a hybrid local search that randomly chooses between segment reversal (reversing a random segment of the tour) or edge swapping (swapping two non-adjacent edges) to generate a neighbor solution, ensuring feasibility by checking for duplicate nodes. The selection process biases toward high-potential solutions, while the local search diversifies exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective (exponential weighting)\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    selected_idx = min(15, len(archive_sorted) - 1)\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment reversal or edge swapping\n    if random.random() < 0.6:\n        # Segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # Edge swapping\n        if n >= 4:\n            i, j = sorted(random.sample(range(1, n-1), 2))\n            if i != j:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Verify solution validity\n    assert len(new_solution) == len(selected_solution), \"Solution length mismatch\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes detected\"\n\n    return new_solution\n\n",
        "score": [
            -0.9076585486137072,
            1.1378300786018372
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using a dynamic objective-weighted selection mechanism, then applies a hybrid local search that probabilistically inverts and reinserts variable-length segments while also performing a novel probabilistic edge rotation operator to balance exploration and exploitation while ensuring tour feasibility. It prioritizes segments with higher combined objective costs for inversion and uses a weighted random selection to focus on lower-normalized objective solutions.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (sol, obj) in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = 1 / (scores + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = random.randint(2, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    total_seg_cost = seg_cost1 + seg_cost2\n\n    inversion_prob = min(0.8, 0.4 + (total_seg_cost / (seg_cost1 + seg_cost2 + 1e-10)) * 0.4)\n\n    if random.random() < inversion_prob:\n        segment = segment[::-1]\n\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            direction = 1 if random.random() < 0.5 else -1\n            sub_segment = new_solution[i:j]\n            rotated = np.roll(sub_segment, direction)\n            new_solution[i:j] = rotated\n\n    return new_solution\n\n",
        "score": [
            -0.9176521353189986,
            3.844283163547516
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive by prioritizing Pareto-efficient solutions (non-dominated by others) and falling back to the lowest-sum objective if none exist. It then applies a hybrid local search combining segment reversal (randomly reversing a segment of the tour) and adaptive node relocation (probabilistically relocating nodes based on combined cost improvements in both objectives), ensuring feasibility by maintaining valid TSP tours throughout. The method balances exploration and exploitation through randomness and dynamic trade-off considerations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using Pareto-efficient front and objective trade-offs\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.zeros(len(archive), dtype=bool)\n\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        pareto_front[i] = not dominated\n\n    if np.any(pareto_front):\n        candidates = [i for i, is_pareto in enumerate(pareto_front) if is_pareto]\n        selected_idx = np.random.choice(candidates)\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment reversal + adaptive node relocation\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment reversal\n    start = np.random.randint(0, n-2)\n    end = np.random.randint(start+2, min(start+10, n))\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive node relocation\n    for _ in range(2):\n        node = np.random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n\n        # Calculate potential insertion positions based on both objectives\n        costs = []\n        for pos in range(n):\n            if pos == current_pos:\n                costs.append(np.inf)\n                continue\n\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            costs.append((cost1 + cost2) * (1 + np.random.uniform(-0.1, 0.1)))\n\n        best_pos = np.argmin(costs)\n        if costs[best_pos] < np.inf:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9538456537192214,
            10.783259153366089
        ]
    },
    {
        "algorithm": "The algorithm selects a Pareto-optimal solution from the archive and applies a hybrid local search combining segment inversion, adaptive edge swapping, and dynamic node relocation to generate a neighbor solution while ensuring feasibility through validation checks. It prioritizes solutions on the Pareto front and uses a combination of segment-based and node-based operations to explore the solution space effectively. The algorithm maintains feasibility by validating the solution and reverting to the base solution if necessary.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj[0] and obj_j[1] <= obj[1] and (obj_j[0] < obj[0] or obj_j[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + adaptive edge swapping + dynamic node relocation\n    if n < 4:\n        return new_solution\n\n    # Segment inversion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n    inverted_segment = segment[::-1]\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n\n    # Find best insertion point for inverted segment\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, inverted_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, inverted_segment)\n\n    # Adaptive edge swapping\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            new_solution = temp_solution.copy()\n            best_cost = total_cost\n\n    # Dynamic node relocation\n    for _ in range(2):\n        node = random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n\n        # Calculate potential insertion positions\n        costs = []\n        for pos in range(n):\n            if pos == current_pos:\n                costs.append(np.inf)\n                continue\n\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            costs.append(cost1 + cost2)\n\n        best_pos = np.argmin(costs)\n        if costs[best_pos] < np.inf:\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9259748438819304,
            10.202461063861847
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive using probabilistic Pareto-dominance based on normalized objective values, then applies a hybrid local search combining segment rotation and adaptive node relocation to generate a neighbor while ensuring feasibility through permutation validation. It prioritizes solutions with better objective values and uses randomized segment manipulation followed by cost-based node relocation to explore the solution space efficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution using probabilistic Pareto-dominance\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-10)\n    scores = 1 - normalized.mean(axis=1)\n    weights = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment rotation + adaptive node relocation\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    best_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Adaptive node relocation\n    for _ in range(2):\n        node = random.choice(new_solution)\n        current_pos = np.where(new_solution == node)[0][0]\n        costs = []\n\n        for pos in range(n):\n            if pos == current_pos:\n                costs.append(float('inf'))\n                continue\n\n            temp_sol = np.delete(new_solution, current_pos)\n            temp_sol = np.insert(temp_sol, pos, node)\n\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            costs.append(cost1 + cost2)\n\n        best_pos = np.argmin(costs)\n        if costs[best_pos] < float('inf'):\n            new_solution = np.delete(new_solution, current_pos)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9179978189366076,
            7.949755668640137
        ]
    }
]