[
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.301326944231567,
            7.222015579617734
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.318964386223638,
            6.297667744348535
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.910882867546672,
            6.797800312801045
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance (non-dominated solutions are prioritized), then applies a novel local search operator that combines node insertion with partial path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize non-dominated solutions\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (archive[i][1][0] >= archive[j][1][0] and archive[i][1][1] >= archive[j][1][1]) and \\\n                   (archive[i][1][0] > archive[j][1][0] or archive[i][1][1] > archive[j][1][1]):\n                    dominated[i] = True\n                    break\n    non_dominated_indices = np.where(~dominated)[0]\n\n    if len(non_dominated_indices) > 0:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node insertion with partial reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select a node to insert elsewhere\n        node_pos = np.random.randint(0, N)\n        node = new_solution[node_pos]\n\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_pos)\n\n        # Insert the node at a new random position\n        insert_pos = np.random.randint(0, N-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Reverse a random segment between the original and new positions\n        if node_pos < insert_pos:\n            start, end = node_pos, insert_pos\n        else:\n            start, end = insert_pos, node_pos\n\n        if start != end and end - start > 1:\n            segment = np.random.randint(start, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            7.318964386223638,
            6.297667744348535
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a non-dominated sorting approach, then applies a novel local search operator that combines segment relocations with adaptive edge insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to select a promising solution\n    fronts = []\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] <= obj_j[1]) and (obj_i[0] < obj_j[0] or obj_i[1] < obj_j[1]):\n                dominating_sets[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        # If no non-dominated solutions, select randomly\n        selected_idx = np.random.randint(len(archive))\n    else:\n        selected_idx = fronts[np.random.randint(len(fronts))]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive segment relocation\n    k = np.random.randint(2, min(5, N//2))\n    start = np.random.randint(0, N - k)\n    segment = new_solution[start:start+k]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+k:]])\n\n    # Insert segment at a different position\n    insert_pos = np.random.randint(0, N - k + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.301326944231567,
            7.222015579617734
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel segment-based local search strategy that combines edge insertions and segment rotations to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection considering both objectives and diversity\n    objectives = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    diversity = np.array([np.std([distance_matrix_1[sol[i], sol[i+1]] + distance_matrix_2[sol[i], sol[i+1]] for i in range(len(sol)-1)]) for sol, _ in archive])\n    weights = objectives + diversity\n    weights = np.max(weights) - weights + 1e-6\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel segment-based local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to rotate\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Randomly insert a node at a different position\n    if N > 3:\n        i = np.random.randint(N)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        j = np.random.randint(N-1)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.978528763413378,
            6.6055048283466755
        ]
    },
    {
        "algorithm": "{The algorithm selects a promising solution from the archive based on a weighted sum of objectives, then applies a hybrid local search combining edge swaps and segment reversals to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with a weighted random selection\n    weights = np.array([(obj[0] + obj[1]) for _, obj in archive])\n    weights = np.max(weights) - weights + 1e-6  # Invert and add small value to avoid zero weights\n    selected_idx = np.random.choice(len(archive), p=weights/np.sum(weights))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a, b = sorted(np.random.choice(N, size=2, replace=False))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Randomly swap two edges\n    if N > 3:\n        i, j = np.random.choice(N, size=2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        # If not feasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.910882867546672,
            6.797800312801045
        ]
    }
]