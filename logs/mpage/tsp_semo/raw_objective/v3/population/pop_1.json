[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    normalized_objectives = [(obj[0] / (obj[0] + obj[1] + 1e-10), obj[1] / (obj[0] + obj[1] + 1e-10)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to modify\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k = np.random.randint(1, n-1)\n\n    # Novel move: reverse segment between i and j, then insert segment between k and k+1\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen due to segment insertion)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.343084386472292,
               6.398679333078661
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    scores = []\n    for sol, _ in archive:\n        # Calculate diversity score (number of unique edges not in other solutions)\n        diversity = 0\n        edges = set(zip(sol, np.roll(sol, -1)))\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges - other_edges)\n        scores.append(diversity)\n\n    if all(s == 0 for s in scores):\n        # If all solutions are identical, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Normalize scores and select with probability\n        total = sum(scores)\n        probs = [s / total for s in scores]\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for segment relocation\n        # Select segment length based on instance size\n        max_segment = min(5, n // 4)\n        segment_length = random.randint(2, max_segment)\n\n        # Select random segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position that improves both objectives\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue  # Skip current position\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and best_cost < float('inf'):\n            # Apply the best move\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n    else:  # Edge insertion\n        # Select random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select random node to insert between\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i-1)%n:\n            k = random.randint(0, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]  # Reverse the edge\n        candidate = np.roll(candidate, -i)  # Make i the first element\n        candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n        candidate = np.roll(candidate, i)  # Restore original order\n\n        # Check if the move is valid (visits all nodes exactly once)\n        if len(set(candidate)) == n:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.602584769458544,
               5.827298074802924
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first evaluates the archive of solutions by computing their Pareto dominance relationships, then selects a promising solution with high potential for improvement using a custom selection criterion that balances objective diversity and local search potential. The selected solution undergoes a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge exchange mechanism, where segments of varying lengths are inverted and edges are exchanged based on their contribution to reducing the total tour length in both objective spaces. The inversion length is dynamically determined using a probabilistic model that considers both the distance matrices and the current solution's structure, while the edge exchange is guided by a weighted combination of the two objectives. The function ensures feasibility by maintaining the permutation property of TSP tours throughout the local search process, and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n // 2))\n    segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        new_solution[current_pos:current_pos + length] = segment[::-1]\n        current_pos += length\n\n    # Guided edge exchange\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Weighted decision based on both objectives\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               6.372959628179613,
               6.543599011883715
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (higher probability for non-dominated or less crowded solutions)\n    ranks = np.array([i for i in range(len(archive))])  # Simplified rank (in practice, use proper non-dominated sorting)\n    probabilities = 1 / (1 + ranks)\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost = archive[selected_idx][1]\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with objective-aware acceptance\n    if n > 2:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        candidate = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n        # Calculate new cost\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        new_cost = (cost1, cost2)\n\n        # Accept if weighted sum improves (weighted by inverse costs to balance objectives)\n        if (cost1 / current_cost[0] + cost2 / current_cost[1]) < 2:  # Simplified acceptance criterion\n            new_solution = candidate\n\n    # Edge exchange with objective-aware acceptance\n    if n > 3:\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate[k], candidate[l] = candidate[l], candidate[k]\n\n            # Calculate new cost\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            new_cost = (cost1, cost2)\n\n            # Accept if weighted sum improves\n            if (cost1 / current_cost[0] + cost2 / current_cost[1]) < 2:\n                new_solution = candidate\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               6.459716852001758,
               7.052657272676352
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for improvement using a combination of objective values and diversity metrics. It then intelligently selects one solution based on a weighted random selection that favors solutions with lower costs and higher diversity. For local search, it employs a novel hybrid approach: it first applies a randomized version of the Lin-Kernighan algorithm to escape local optima, followed by a biased random walk to explore the solution space while maintaining feasibility. The walk is guided by a weighted combination of the two objective spaces, ensuring progress toward both objectives. The function always checks the feasibility of the generated neighbor solution, ensuring it remains a valid TSP tour with no skipped or revisited nodes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate diversity and objective scores\n    objectives = np.array([obj for (sol, obj) in archive])\n    costs = objectives.sum(axis=1)\n    norm_costs = (costs - costs.min()) / (costs.max() - costs.min() + 1e-10)\n\n    # Calculate diversity (average distance to other solutions)\n    diversity = []\n    for i, (sol, _) in enumerate(archive):\n        dists = [np.sum(sol != other_sol) for j, (other_sol, _) in enumerate(archive) if i != j]\n        diversity.append(np.mean(dists) if dists else 0)\n    diversity = np.array(diversity)\n    norm_diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n\n    # Combine scores (weighted sum of normalized cost and diversity)\n    scores = 0.7 * norm_costs + 0.3 * norm_diversity\n    probs = np.exp(-scores) / np.exp(-scores).sum()  # Softmax-like selection\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Randomized Lin-Kernighan + Biased Random Walk\n    # First phase: Randomized Lin-Kernighan (k=3)\n    for _ in range(10):\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different segment reversals\n        for seg in [(i, j), (j, k), (i, k)]:\n            a, b = seg\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n            candidate = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n            # Calculate cost change\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]]\n            delta2 = new_cost2 - old_cost2\n\n            # Accept if both objectives improve\n            if delta1 < 0 and delta2 < 0:\n                new_solution = candidate\n                break\n\n    # Second phase: Biased Random Walk\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        delta2 = new_cost2 - old_cost2\n\n        # Accept with probability based on cost improvement\n        prob = min(1.0, np.exp(-(0.5 * delta1 + 0.5 * delta2) / 1000))  # Temperature-like parameter\n        if random.random() < prob:\n            new_solution = candidate\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               7.083802600128497,
               7.273785255666639
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator (3-opt with objective-aware edge selection)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create three possible new tours by reconnecting the edges\n    candidates = [\n        np.concatenate([new_solution[:a+1], new_solution[b+1:c+1], new_solution[a+1:b+1], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[c+1:b+1], new_solution[a+1:c+1], new_solution[b+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[a+1:c+1], new_solution[b+1:a+1], new_solution[c+1:]])\n    ]\n\n    # Evaluate each candidate based on both objectives\n    def evaluate(tour):\n        cost1 = sum(distance_matrix_1[tour[i], tour[i+1]] for i in range(n-1)) + distance_matrix_1[tour[-1], tour[0]]\n        cost2 = sum(distance_matrix_2[tour[i], tour[i+1]] for i in range(n-1)) + distance_matrix_2[tour[-1], tour[0]]\n        return cost1, cost2\n\n    # Select the candidate that improves the worst objective\n    current_costs = evaluate(selected_solution)\n    best_candidate = None\n    best_improvement = -float('inf')\n\n    for candidate in candidates:\n        candidate_costs = evaluate(candidate)\n        improvement = min(candidate_costs[i] - current_costs[i] for i in range(2))\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
          "score": [
               7.520170723852601,
               7.309382578806057
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify those with the highest potential for local improvement, prioritizing solutions with low objective values and high diversity in their node sequences. It then intelligently selects one such solution as the base for generating a neighbor. The novel local search operator, inspired by the 'path relinking' and 'large neighborhood search' paradigms, combines elements of both: it first identifies a critical segment in the base solution where significant improvements could be made, then explores a large neighborhood around this segment by considering multiple node insertions and deletions, while ensuring feasibility. The operator also incorporates a biased random walk to escape local optima, allowing it to explore diverse regions of the search space. The generated neighbor solution is validated to ensure it remains a feasible TSP tour, with all nodes visited exactly once. The function returns this new solution, which is expected to outperform the base solution in terms of both objectives, leveraging the hybrid approach to balance exploration and exploitation effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify a critical segment for improvement\n    segment_length = max(3, n // 4)\n    segment_start = np.random.randint(0, n - segment_length)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Explore large neighborhood around the segment\n    # Shuffle the segment and reinsert it\n    np.random.shuffle(segment)\n    new_solution[segment_start:segment_start + segment_length] = segment\n\n    # Step 3: Apply biased random walk to escape local optima\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for missing in missing_nodes:\n            idx = np.where(new_solution == new_solution[-1])[0][0]\n            new_solution[idx] = missing\n\n    return new_solution\n\n",
          "score": [
               7.716272384556294,
               7.58112182765195
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    for sol, _ in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if sol is not other_sol:\n                if (other_obj[0] <= sol[0] and other_obj[1] <= sol[1] and\n                    (other_obj[0] < sol[0] or other_obj[1] < sol[1])):\n                    dominated = True\n                    break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Step 2: Select a solution with high crowding distance\n    if len(non_dominated) > 1:\n        # Calculate crowding distances\n        objectives = [(sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))),\n                      sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))))\n                     for sol in non_dominated]\n\n        # Sort by first objective\n        sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][0])\n        crowding_distances = [0.0] * len(non_dominated)\n\n        # Crowding distance calculation\n        for obj_idx in range(2):\n            sorted_idx = sorted(range(len(objectives)), key=lambda i: objectives[i][obj_idx])\n            crowding_distances[sorted_idx[0]] = float('inf')\n            crowding_distances[sorted_idx[-1]] = float('inf')\n            if objectives[sorted_idx[-1]][obj_idx] == objectives[sorted_idx[0]][obj_idx]:\n                continue\n            norm = objectives[sorted_idx[-1]][obj_idx] - objectives[sorted_idx[0]][obj_idx]\n            for i in range(1, len(non_dominated)-1):\n                crowding_distances[sorted_idx[i]] += (objectives[sorted_idx[i+1]][obj_idx] - objectives[sorted_idx[i-1]][obj_idx]) / norm\n\n        # Select solution with highest crowding distance\n        selected_idx = max(range(len(non_dominated)), key=lambda i: crowding_distances[i])\n        base_solution = non_dominated[selected_idx].copy()\n    else:\n        base_solution = non_dominated[0].copy()\n\n    # Step 3: Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between segment inversion and edge insertion\n    if np.random.rand() < 0.7:  # Higher probability for segment inversion\n        # Segment inversion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Edge insertion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(len(new_solution) + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Verify feasibility\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               8.88553421128087,
               8.925474924110244
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies the most promising solution in the archive by evaluating the trade-off between the two objectives using a normalized Pareto-dominance criterion, then applies a novel hybrid local search operator that combines a biased random-walk segment reversal (BRSR) with a multi-objective edge insertion heuristic. The BRSR randomly selects a segment of the tour and reverses it with a bias towards improving the objective with the higher normalized dominance, while the edge insertion heuristic evaluates all possible insertions of non-adjacent edges into the tour, prioritizing those that improve the other objective. The function ensures feasibility by validating each move and only accepting changes that maintain a valid TSP tour, guaranteeing no node is skipped or revisited.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on normalized Pareto dominance\n    def normalized_dominance(obj1, obj2):\n        norm1 = (obj1[0] - min(o[0] for o in [s[1] for s in archive])) / (max(o[0] for o in [s[1] for s in archive]) - min(o[0] for o in [s[1] for s in archive]) + 1e-10)\n        norm2 = (obj1[1] - min(o[1] for o in [s[1] for s in archive])) / (max(o[1] for o in [s[1] for s in archive]) - min(o[1] for o in [s[1] for s in archive]) + 1e-10)\n        return norm1 + norm2\n\n    archive_sorted = sorted(archive, key=lambda x: normalized_dominance(x[1], None))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Novel hybrid local search operator: Biased Random-Walk Segment Reversal (BRSR) + Multi-objective Edge Insertion\n    n = len(base_solution)\n    if n < 4:\n        return new_solution  # Too small to apply meaningful operators\n\n    # BRSR: Randomly select a segment and reverse it with bias towards the objective with higher normalized dominance\n    obj = archive_sorted[0][1]\n    norm1 = (obj[0] - min(o[0] for o in [s[1] for s in archive])) / (max(o[0] for o in [s[1] for s in archive]) - min(o[0] for o in [s[1] for s in archive]) + 1e-10)\n    norm2 = (obj[1] - min(o[1] for o in [s[1] for s in archive])) / (max(o[1] for o in [s[1] for s in archive]) - min(o[1] for o in [s[1] for s in archive]) + 1e-10)\n\n    if norm1 > norm2:\n        # Focus on improving objective 1\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n    else:\n        # Focus on improving objective 2\n        a, b = np.random.choice(n, 2, replace=False)\n        a, b = min(a, b), max(a, b)\n        if b - a > 1:\n            new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Multi-objective Edge Insertion: Try to insert non-adjacent edges to improve the other objective\n    for i in range(n):\n        for j in range(i+2, n):\n            if j+1 < n:\n                # Try inserting edge (i, j) between (i, i+1) and (j, j+1)\n                candidate = new_solution.copy()\n                candidate[i+1:j+1] = np.concatenate([candidate[j:j+1], candidate[i+1:j]])\n                # Check if the move is valid (no duplicates)\n                if len(np.unique(candidate)) == n:\n                    new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               9.131114472441187,
               8.9513703888391
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by identifying promising solutions in the archive using a multi-objective ranking criterion that prioritizes solutions with high crowding distance or low dominance count, ensuring diversity and potential for improvement. It then applies a hybrid local search operator that combines a novel 'k-swap' perturbation (randomly swapping k nodes) with a greedy 'path relinking' step, where segments of the perturbed solution are replaced by the best matching segments from the original solution to maintain feasibility and improve solution quality. The operator also incorporates a probabilistic acceptance criterion based on the Pareto dominance relationship between the original and neighbor solutions to escape local optima. The function ensures feasibility by always validating the generated neighbor solution, rejecting invalid tours, and iterating until a feasible neighbor is found.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select promising solution based on crowding distance and dominance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distances for all solutions\n    crowding_distances = []\n    for i in range(len(objectives)):\n        obj1, obj2 = objectives[i]\n        left = (obj1, obj2)\n        right = (obj1, obj2)\n        for j in range(len(objectives)):\n            if i != j:\n                obj1_j, obj2_j = objectives[j]\n                if obj1_j <= left[0] and obj2_j <= left[1]:\n                    left = (obj1_j, obj2_j)\n                if obj1_j >= right[0] and obj2_j >= right[1]:\n                    right = (obj1_j, obj2_j)\n        crowding_distances.append((right[0] - left[0]) + (right[1] - left[1]))\n\n    # Select solution with highest crowding distance (most promising for improvement)\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: k-swap perturbation (k=3)\n    k = min(3, n // 2)\n    swap_indices = np.random.choice(n, size=2*k, replace=False)\n    for i in range(k):\n        idx1, idx2 = swap_indices[2*i], swap_indices[2*i+1]\n        new_solution[idx1], new_solution[idx2] = new_solution[idx2], new_solution[idx1]\n\n    # Step 2: Greedy path relinking\n    for _ in range(10):  # Limit iterations to prevent excessive computation\n        # Randomly select a segment to replace\n        seg_start = np.random.randint(0, n - 2)\n        seg_end = np.random.randint(seg_start + 1, n - 1)\n        segment = new_solution[seg_start:seg_end+1]\n\n        # Find best matching segment in original solution\n        best_cost = float('inf')\n        best_seg = None\n        for i in range(n - len(segment)):\n            candidate_seg = base_solution[i:i+len(segment)]\n            # Calculate cost difference in both objectives\n            cost1 = (distance_matrix_1[new_solution[seg_start-1], candidate_seg[0]] +\n                    distance_matrix_1[candidate_seg[-1], new_solution[seg_end+1]] -\n                    distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] -\n                    distance_matrix_1[new_solution[seg_end], new_solution[seg_end+1]])\n            cost2 = (distance_matrix_2[new_solution[seg_start-1], candidate_seg[0]] +\n                    distance_matrix_2[candidate_seg[-1], new_solution[seg_end+1]] -\n                    distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] -\n                    distance_matrix_2[new_solution[seg_end], new_solution[seg_end+1]])\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_seg = candidate_seg\n\n        if best_seg is not None and best_cost < 0:\n            # Replace the segment if it improves the solution\n            new_solution[seg_start:seg_end+1] = best_seg\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If solution is invalid, revert to original\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               10.555976725995068,
               10.617126277351593
          ]
     }
]