[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the highest combined improvement potential in both objectives, then applies a novel segment rotation and edge swap operation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    selected_solution = archive[0][0].copy()\n    max_potential = -float('inf')\n    for sol, (cost1, cost2) in archive:\n        potential = -cost1 - cost2  # Higher negative costs indicate better potential\n        if potential > max_potential:\n            max_potential = potential\n            selected_solution = sol.copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Segment rotation operation\n    a, b = sorted(np.random.choice(n, size=2, replace=False))\n    segment = new_solution[a:b+1]\n    rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n    new_solution[a:b+1] = rotated_segment\n\n    # Edge swap operation\n    i, j = sorted(np.random.choice(n, size=2, replace=False))\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7222753164251589,
            0.19529563188552856
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a combined quality-diversity metric, then applies a hybrid local search combining segment relocation and edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best combined quality-diversity trade-off\n    selected_idx = 0\n    best_score = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        quality = obj[0] + obj[1]\n        diversity = np.sum(sol != archive[0][0])\n        score = quality * (1 + 0.1 * diversity)  # Balance quality and diversity\n        if score < best_score:\n            best_score = score\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment relocation + edge swapping\n    if n >= 4:\n        # Randomly select a segment to relocate\n        a, b = sorted(np.random.choice(n, size=2, replace=False))\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        insert_pos = np.random.randint(0, len(new_solution)+1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Randomly swap two non-adjacent edges\n        if n >= 4:\n            i, j = sorted(np.random.choice(range(1, n-1), size=2, replace=False))\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.893841244784518,
            0.46345454454421997
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective dominance and solution diversity, then applies a hybrid local search combining a novel \"node chain inversion\" with a \"multi-segment rotation\" to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection: Combine objective dominance and diversity\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Node chain inversion + multi-segment rotation\n    if n > 5:\n        # Node chain inversion: Select a random chain of 3-5 nodes and invert them\n        chain_length = np.random.randint(3, min(6, n))\n        start = np.random.randint(0, n - chain_length)\n        chain = new_solution[start:start+chain_length]\n        new_solution[start:start+chain_length] = chain[::-1]\n\n        # Multi-segment rotation: Select 2-3 segments and rotate them\n        num_segments = np.random.randint(2, 4)\n        segment_starts = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n        segment_lengths = np.random.randint(2, min(5, n//num_segments), size=num_segments)\n\n        for i in range(num_segments):\n            start = segment_starts[i]\n            length = segment_lengths[i]\n            if start + length < n:\n                segment = new_solution[start:start+length]\n                new_solution[start:start+length] = np.roll(segment, np.random.randint(1, length))\n\n    return new_solution\n\n",
        "score": [
            -0.8931201048817249,
            0.2385823130607605
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Novel local search: Combine node swapping with a dynamic segment relocation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to relocate\n    segment_length = np.random.randint(2, min(5, n))\n    start_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start_pos:start_pos + segment_length]\n\n    # Remove the segment from the solution\n    new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n\n    # Insert the segment in a new random position\n    insert_pos = np.random.randint(0, n - segment_length + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Dynamic node swapping: Swap nodes based on their distance in both objective spaces\n    if n > 2:\n        i, j = np.random.choice(n, 2, replace=False)\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                       distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                      distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Revert if the swap doesn't improve both objectives\n        if (cost1_after >= cost1_before) and (cost2_after >= cost2_before):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8047933069582259,
            0.22342205047607422
        ]
    },
    {
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on its potential for improvement, then applies a hybrid local search operator that combines edge swaps and node insertions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by the sum of objectives to prioritize solutions with lower costs\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 20% of solutions for random selection\n        top_solutions = archive_sorted[:max(1, len(archive_sorted) // 5)]\n        selected_solution = random.choice(top_solutions)[0].copy()\n    else:\n        selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps and node insertions\n    if n > 3:\n        # Randomly choose between edge swap or node insertion\n        if random.random() < 0.5:\n            # Edge swap\n            i, j = sorted(random.sample(range(1, n), 2))\n            new_solution[i:j] = new_solution[i:j][::-1]\n        else:\n            # Node insertion\n            i = random.randint(0, n-1)\n            j = random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7895037245011808,
            0.217376708984375
        ]
    },
    {
        "algorithm": "{The algorithm intelligently selects a solution from the archive by prioritizing those with the highest potential for improvement, then applies a hybrid local search operator that combines 3-opt with a novel segment inversion and reinsertion strategy to explore diverse neighborhoods while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., not Pareto-optimal in the archive)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: 3-opt with segment inversion and reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select three distinct positions\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Try segment inversion\n    if random.random() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n    else:\n        # Try segment reinsertion\n        segment = new_solution[b:c+1]\n        new_solution = np.concatenate([new_solution[:b], new_solution[c+1:], segment])\n\n    # Ensure feasibility (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # Fallback to standard inversion if invalid\n        new_solution = base_solution.copy()\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8588519433664235,
            0.22379541397094727
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution with balanced objective improvement potential, then applies a novel hybrid local search combining adaptive segment swapping and objective-aware edge flipping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective improvement potential\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(archive_sorted))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 5:\n        return new_solution\n\n    # Adaptive segment swapping\n    a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n    segment1 = new_solution[a:b]\n    segment2 = new_solution[c:d]\n    new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b:c], segment1, new_solution[d:]])\n\n    # Objective-aware edge flipping\n    for i in range(1, n-1):\n        cost1_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        cost2_before = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n\n        cost1_after = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        cost2_after = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or (np.random.random() < 0.1):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8612328424689331,
            0.30258631706237793
        ]
    },
    {
        "algorithm": "{A new hybrid local search algorithm that combines a novel segment relocation with a dynamic inversion strategy to explore diverse neighborhoods while ensuring feasibility, by first selecting a promising solution from the archive and then applying a combination of segment operations and dynamic inversions to generate high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(3, len(sorted_archive))  # Top 3 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a new position\n    if n > 4:\n        i, j, k = sorted(np.random.choice(range(n), 3, replace=False))\n        segment = new_solution[i:j]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], segment, new_solution[k:]])\n\n    # Dynamic inversion: Invert segments based on distance matrices\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        # Decide inversion based on distance matrices\n        cost_before = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        cost_after = distance_matrix_1[new_solution[i-1], new_solution[j-1]] + distance_matrix_1[new_solution[i], new_solution[j]]\n        if cost_after < cost_before:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8578526905831331,
            0.2900117039680481
        ]
    },
    {
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (e.g., top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Combine 3-opt with a novel segment inversion\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 distinct segments\n    a, b, c = sorted(np.random.choice(n, 3, replace=False))\n\n    # Apply 3-opt: reverse segments between a-b, b-c, and a-c\n    new_solution[a:b] = new_solution[a:b][::-1]\n    new_solution[b:c] = new_solution[b:c][::-1]\n    new_solution[a:c] = new_solution[a:c][::-1]\n\n    # Novel segment inversion: Invert a random segment and reinsert it\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], segment, new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7408560644247593,
            0.243660569190979
        ]
    },
    {
        "algorithm": "{The new algorithm combines a novel segment relocation strategy with a multi-objective-aware segment inversion, where segments are relocated based on their potential to improve both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (top 20% in both objectives)\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))\n    candidate_indices = min(2, len(sorted_archive))  # Top 2 candidates\n    selected_idx = np.random.choice(candidate_indices)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation: Move a segment to a position that improves both objectives\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        best_pos = i\n        min_cost = float('inf')\n\n        # Evaluate potential positions for the segment\n        for pos in range(n - (j - i) + 1):\n            if pos == i:\n                continue\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            total_cost = cost1 + cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Multi-objective-aware segment inversion: Invert a segment if it improves both objectives\n    if n > 4:\n        i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n        segment = new_solution[i:j]\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:i], inverted_segment, new_solution[j:]])\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if (cost1 < current_cost1 and cost2 < current_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8362971610778605,
            0.428544819355011
        ]
    }
]