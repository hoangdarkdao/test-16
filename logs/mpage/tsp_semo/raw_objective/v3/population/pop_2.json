[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    normalized_objectives = [(obj[0] / (obj[0] + obj[1] + 1e-10), obj[1] / (obj[0] + obj[1] + 1e-10)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to modify\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k = np.random.randint(1, n-1)\n\n    # Novel move: reverse segment between i and j, then insert segment between k and k+1\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen due to segment insertion)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.343084386472292,
               6.398679333078661
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    scores = []\n    for sol, _ in archive:\n        # Calculate diversity score (number of unique edges not in other solutions)\n        diversity = 0\n        edges = set(zip(sol, np.roll(sol, -1)))\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges - other_edges)\n        scores.append(diversity)\n\n    if all(s == 0 for s in scores):\n        # If all solutions are identical, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Normalize scores and select with probability\n        total = sum(scores)\n        probs = [s / total for s in scores]\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for segment relocation\n        # Select segment length based on instance size\n        max_segment = min(5, n // 4)\n        segment_length = random.randint(2, max_segment)\n\n        # Select random segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position that improves both objectives\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue  # Skip current position\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and best_cost < float('inf'):\n            # Apply the best move\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n    else:  # Edge insertion\n        # Select random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select random node to insert between\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i-1)%n:\n            k = random.randint(0, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]  # Reverse the edge\n        candidate = np.roll(candidate, -i)  # Make i the first element\n        candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n        candidate = np.roll(candidate, i)  # Restore original order\n\n        # Check if the move is valid (visits all nodes exactly once)\n        if len(set(candidate)) == n:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.602584769458544,
               5.827298074802924
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first evaluates the archive of solutions by computing their Pareto dominance relationships, then selects a promising solution with high potential for improvement using a custom selection criterion that balances objective diversity and local search potential. The selected solution undergoes a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge exchange mechanism, where segments of varying lengths are inverted and edges are exchanged based on their contribution to reducing the total tour length in both objective spaces. The inversion length is dynamically determined using a probabilistic model that considers both the distance matrices and the current solution's structure, while the edge exchange is guided by a weighted combination of the two objectives. The function ensures feasibility by maintaining the permutation property of TSP tours throughout the local search process, and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n // 2))\n    segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        new_solution[current_pos:current_pos + length] = segment[::-1]\n        current_pos += length\n\n    # Guided edge exchange\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Weighted decision based on both objectives\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               6.372959628179613,
               6.543599011883715
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution (higher probability for non-dominated or less crowded solutions)\n    ranks = np.array([i for i in range(len(archive))])  # Simplified rank (in practice, use proper non-dominated sorting)\n    probabilities = 1 / (1 + ranks)\n    probabilities = probabilities / np.sum(probabilities)\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost = archive[selected_idx][1]\n\n    # Step 2: Hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with objective-aware acceptance\n    if n > 2:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted_segment = segment[::-1]\n        candidate = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n        # Calculate new cost\n        cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n        new_cost = (cost1, cost2)\n\n        # Accept if weighted sum improves (weighted by inverse costs to balance objectives)\n        if (cost1 / current_cost[0] + cost2 / current_cost[1]) < 2:  # Simplified acceptance criterion\n            new_solution = candidate\n\n    # Edge exchange with objective-aware acceptance\n    if n > 3:\n        i, j, k, l = sorted(np.random.choice(n, 4, replace=False))\n        if abs(i - j) > 1 and abs(k - l) > 1:\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidate[k], candidate[l] = candidate[l], candidate[k]\n\n            # Calculate new cost\n            cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n            new_cost = (cost1, cost2)\n\n            # Accept if weighted sum improves\n            if (cost1 / current_cost[0] + cost2 / current_cost[1]) < 2:\n                new_solution = candidate\n\n    # Ensure the solution is valid (no duplicates and all nodes visited)\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()  # Fallback to original if invalid\n\n    return new_solution\n\n",
          "score": [
               6.459716852001758,
               7.052657272676352
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-stage approach to generate high-quality neighbor solutions by first identifying the most promising solutions in the archive using a combination of dominance and diversity metrics, then applying a novel 'node clustering' strategy that groups nodes based on their spatial proximity in both objective spaces. The algorithm then performs a probabilistic 'cluster-based insertion' where segments of the tour are replaced with the best matching clusters from the original solution, followed by a 'multi-objective edge optimization' step that selectively improves edges based on Pareto dominance in the combined objective space. The method ensures feasibility by maintaining valid tour structures throughout all operations, and incorporates an adaptive acceptance criterion that balances exploration and exploitation by considering the non-dominated front of the current solution and its neighbors.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select promising solution using dominance and diversity\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate dominance counts\n    dominance_counts = [0] * len(solutions)\n    for i in range(len(solutions)):\n        for j in range(len(solutions)):\n            if i != j:\n                if (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                    (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                    dominance_counts[i] += 1\n\n    # Calculate crowding distances\n    crowding_distances = []\n    for i in range(len(objectives)):\n        obj1, obj2 = objectives[i]\n        left = (obj1, obj2)\n        right = (obj1, obj2)\n        for j in range(len(objectives)):\n            if i != j:\n                obj1_j, obj2_j = objectives[j]\n                if obj1_j <= left[0] and obj2_j <= left[1]:\n                    left = (obj1_j, obj2_j)\n                if obj1_j >= right[0] and obj2_j >= right[1]:\n                    right = (obj1_j, obj2_j)\n        crowding_distances.append((right[0] - left[0]) + (right[1] - left[1]))\n\n    # Select solution with lowest dominance count and highest crowding distance\n    scores = [-dominance_counts[i] * crowding_distances[i] for i in range(len(solutions))]\n    selected_idx = np.argmax(scores)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Node clustering based on spatial proximity\n    n = len(base_solution)\n    clusters = []\n    visited = set()\n\n    for i in range(n):\n        if i not in visited:\n            cluster = [i]\n            visited.add(i)\n            for j in range(i+1, n):\n                if j not in visited:\n                    node_i = base_solution[i]\n                    node_j = base_solution[j]\n                    # Check spatial proximity in both objective spaces\n                    dist1 = np.sqrt((instance[node_i, 0] - instance[node_j, 0])**2 +\n                                   (instance[node_i, 1] - instance[node_j, 1])**2)\n                    dist2 = np.sqrt((instance[node_i, 2] - instance[node_j, 2])**2 +\n                                   (instance[node_i, 3] - instance[node_j, 3])**2)\n                    if dist1 < 10 and dist2 < 10:  # Threshold for clustering\n                        cluster.append(j)\n                        visited.add(j)\n            clusters.append(cluster)\n\n    # Step 3: Cluster-based insertion\n    new_solution = base_solution.copy()\n    for _ in range(10):\n        # Select a random cluster to move\n        cluster = clusters[np.random.randint(len(clusters))]\n        if len(cluster) < 2:\n            continue\n\n        # Remove the cluster from current position\n        cluster_nodes = [new_solution[i] for i in cluster]\n        mask = np.ones(len(new_solution), dtype=bool)\n        mask[cluster] = False\n        temp_solution = new_solution[mask]\n\n        # Find best insertion position\n        best_cost = float('inf')\n        best_pos = 0\n        for pos in range(len(temp_solution)):\n            # Insert cluster at position pos\n            candidate = np.concatenate([temp_solution[:pos], cluster_nodes, temp_solution[pos:]])\n\n            # Calculate cost difference\n            cost1 = 0\n            cost2 = 0\n            for i in range(len(candidate)):\n                prev = candidate[i-1]\n                curr = candidate[i]\n                cost1 += distance_matrix_1[prev, curr]\n                cost2 += distance_matrix_2[prev, curr]\n\n            if cost1 + cost2 < best_cost:\n                best_cost = cost1 + cost2\n                best_pos = pos\n\n        # Perform insertion\n        new_solution = np.concatenate([temp_solution[:best_pos], cluster_nodes, temp_solution[best_pos:]])\n\n    # Step 4: Multi-objective edge optimization\n    for _ in range(20):\n        # Select two random edges\n        i, j = sorted(np.random.choice(len(new_solution), 2, replace=False))\n\n        # Calculate current cost\n        prev_i = new_solution[i-1]\n        curr_i = new_solution[i]\n        next_i = new_solution[(i+1)%len(new_solution)]\n        prev_j = new_solution[j-1]\n        curr_j = new_solution[j]\n        next_j = new_solution[(j+1)%len(new_solution)]\n\n        cost1_before = (distance_matrix_1[prev_i, curr_i] + distance_matrix_1[curr_i, next_i] +\n                        distance_matrix_1[prev_j, curr_j] + distance_matrix_1[curr_j, next_j])\n        cost2_before = (distance_matrix_2[prev_i, curr_i] + distance_matrix_2[curr_i, next_i] +\n                        distance_matrix_2[prev_j, curr_j] + distance_matrix_2[curr_j, next_j])\n\n        # Calculate new cost if edges are swapped\n        cost1_after = (distance_matrix_1[prev_i, curr_j] + distance_matrix_1[curr_j, next_i] +\n                       distance_matrix_1[prev_j, curr_i] + distance_matrix_1[curr_i, next_j])\n        cost2_after = (distance_matrix_2[prev_i, curr_j] + distance_matrix_2[curr_j, next_i] +\n                       distance_matrix_2[prev_j, curr_i] + distance_matrix_2[curr_i, next_j])\n\n        # Accept if Pareto dominates\n        if ((cost1_after <= cost1_before and cost2_after <= cost2_before) and\n            (cost1_after < cost1_before or cost2_after < cost2_before)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               7.109242367827888,
               6.685315639921361
          ]
     },
     {
          "algorithm": "{The new algorithm employs a multi-phase approach that begins by clustering solutions in the objective space using k-means, then selects a solution from the least crowded cluster to ensure diversity. It then applies a novel \"path inversion with objective-aware segment selection\" that identifies the most promising contiguous segment to invert based on the combined improvement potential in both objective spaces, followed by a \"cross-objective edge swapping\" operator that exchanges edges between the two objective spaces to balance improvements. The algorithm dynamically adjusts the acceptance criteria based on the current Pareto front dominance, ensuring high-quality neighbors while maintaining feasibility through strict validation checks.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Cluster solutions in objective space and select from least crowded cluster\n    objectives = np.array([obj for _, obj in archive])\n    if len(archive) > 1:\n        from sklearn.cluster import KMeans\n        k = min(3, len(archive))\n        kmeans = KMeans(n_clusters=k, random_state=42).fit(objectives)\n        cluster_sizes = np.bincount(kmeans.labels_)\n        least_crowded_cluster = np.argmin(cluster_sizes)\n        cluster_indices = np.where(kmeans.labels_ == least_crowded_cluster)[0]\n    else:\n        cluster_indices = [0]\n\n    selected_idx = np.random.choice(cluster_indices)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost = archive[selected_idx][1]\n\n    # Step 2: Path inversion with objective-aware segment selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 2:\n        # Calculate potential improvement for all possible segments\n        improvements = []\n        for a in range(n):\n            for b in range(a+1, n):\n                segment = new_solution[a:b+1]\n                inverted_segment = segment[::-1]\n                candidate = np.concatenate([new_solution[:a], inverted_segment, new_solution[b+1:]])\n\n                # Calculate new cost\n                cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n                cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n                # Calculate improvement potential\n                improvement = (current_cost[0] - cost1) + (current_cost[1] - cost2)\n                improvements.append((improvement, a, b))\n\n        if improvements:\n            # Select segment with highest improvement potential\n            best_improvement, best_a, best_b = max(improvements)\n            if best_improvement > 0:\n                segment = new_solution[best_a:best_b+1]\n                inverted_segment = segment[::-1]\n                new_solution = np.concatenate([new_solution[:best_a], inverted_segment, new_solution[best_b+1:]])\n\n    # Step 3: Cross-objective edge swapping\n    if n > 3:\n        # Find edges that are long in one space but short in the other\n        edges = [(i, (i+1)%n) for i in range(n)]\n        swap_candidates = []\n\n        for i, j in edges:\n            node_i = new_solution[i]\n            node_j = new_solution[j]\n\n            cost1_ij = distance_matrix_1[node_i, node_j]\n            cost2_ij = distance_matrix_2[node_i, node_j]\n\n            # Find alternative edges that could improve both objectives\n            for k in range(n):\n                if k != i and k != j and (k+1)%n != i and (k+1)%n != j:\n                    node_k = new_solution[k]\n                    node_l = new_solution[(k+1)%n]\n\n                    cost1_kl = distance_matrix_1[node_k, node_l]\n                    cost2_kl = distance_matrix_2[node_k, node_l]\n\n                    # Calculate potential improvement\n                    if (cost1_ij + cost1_kl) > (distance_matrix_1[node_i, node_k] + distance_matrix_1[node_l, node_j]) and \\\n                       (cost2_ij + cost2_kl) > (distance_matrix_2[node_i, node_k] + distance_matrix_2[node_l, node_j]):\n                        swap_candidates.append((i, j, k, (k+1)%n))\n\n        if swap_candidates:\n            # Select random swap candidate\n            i, j, k, l = random.choice(swap_candidates)\n            candidate = new_solution.copy()\n            candidate[i], candidate[k] = candidate[k], candidate[i]\n            candidate[j], candidate[l] = candidate[l], candidate[j]\n\n            # Verify feasibility\n            if len(np.unique(candidate)) == n:\n                new_solution = candidate\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.766986731722818,
               7.219290246888874
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first identifies promising solutions in the archive by evaluating their potential for improvement using a combination of objective values and diversity metrics. It then intelligently selects one solution based on a weighted random selection that favors solutions with lower costs and higher diversity. For local search, it employs a novel hybrid approach: it first applies a randomized version of the Lin-Kernighan algorithm to escape local optima, followed by a biased random walk to explore the solution space while maintaining feasibility. The walk is guided by a weighted combination of the two objective spaces, ensuring progress toward both objectives. The function always checks the feasibility of the generated neighbor solution, ensuring it remains a valid TSP tour with no skipped or revisited nodes.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate diversity and objective scores\n    objectives = np.array([obj for (sol, obj) in archive])\n    costs = objectives.sum(axis=1)\n    norm_costs = (costs - costs.min()) / (costs.max() - costs.min() + 1e-10)\n\n    # Calculate diversity (average distance to other solutions)\n    diversity = []\n    for i, (sol, _) in enumerate(archive):\n        dists = [np.sum(sol != other_sol) for j, (other_sol, _) in enumerate(archive) if i != j]\n        diversity.append(np.mean(dists) if dists else 0)\n    diversity = np.array(diversity)\n    norm_diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-10)\n\n    # Combine scores (weighted sum of normalized cost and diversity)\n    scores = 0.7 * norm_costs + 0.3 * norm_diversity\n    probs = np.exp(-scores) / np.exp(-scores).sum()  # Softmax-like selection\n\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Step 2: Generate a neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Randomized Lin-Kernighan + Biased Random Walk\n    # First phase: Randomized Lin-Kernighan (k=3)\n    for _ in range(10):\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Try different segment reversals\n        for seg in [(i, j), (j, k), (i, k)]:\n            a, b = seg\n            segment = new_solution[a:b+1]\n            reversed_segment = segment[::-1]\n            candidate = np.concatenate([new_solution[:a], reversed_segment, new_solution[b+1:]])\n\n            # Calculate cost change\n            old_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[a-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(b+1)%n]]\n            delta1 = new_cost1 - old_cost1\n\n            old_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[a-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(b+1)%n]]\n            delta2 = new_cost2 - old_cost2\n\n            # Accept if both objectives improve\n            if delta1 < 0 and delta2 < 0:\n                new_solution = candidate\n                break\n\n    # Second phase: Biased Random Walk\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate cost change\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        delta1 = new_cost1 - old_cost1\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n        delta2 = new_cost2 - old_cost2\n\n        # Accept with probability based on cost improvement\n        prob = min(1.0, np.exp(-(0.5 * delta1 + 0.5 * delta2) / 1000))  # Temperature-like parameter\n        if random.random() < prob:\n            new_solution = candidate\n\n    # Ensure the solution is valid (no duplicates)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               7.083802600128497,
               7.273785255666639
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies and preserves the most stable segments of high-performing solutions in the archive, then systematically disrupts and reconstructs these segments using a combination of adaptive segment mutation and probabilistic node swapping, while maintaining feasibility through continuous validation and repair mechanisms, ultimately generating a neighbor solution that balances exploration of promising regions with exploitation of known good structures.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n\n    # Step 2: Identify stable segments in the base solution\n    segment_length = max(3, n // 5)\n    segment_start = np.random.randint(0, n - segment_length)\n    stable_segment = base_solution[segment_start:segment_start + segment_length]\n\n    # Step 3: Create a new solution by disrupting and reconstructing the stable segment\n    new_solution = base_solution.copy()\n\n    # Remove the stable segment\n    new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_start + segment_length:]])\n\n    # Adaptively mutate the stable segment\n    if np.random.rand() < 0.6:\n        # Reverse the segment\n        stable_segment = stable_segment[::-1]\n    else:\n        # Shuffle the segment\n        np.random.shuffle(stable_segment)\n\n    # Reinsert the mutated segment at a new position\n    insert_pos = np.random.randint(0, len(new_solution) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], stable_segment, new_solution[insert_pos:]])\n\n    # Step 4: Apply probabilistic node swapping to further diversify\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j and abs(i - j) > 1:  # Ensure meaningful swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 5: Validate and repair the solution\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for missing in missing_nodes:\n            idx = np.where(new_solution == new_solution[-1])[0][0]\n            new_solution[idx] = missing\n\n    return new_solution\n\n",
          "score": [
               6.963020395864539,
               7.339388006091197
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: max(x[1]))[0].copy()\n\n    # Step 2: Apply a hybrid local search operator (3-opt with objective-aware edge selection)\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Randomly select three distinct edges to modify\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create three possible new tours by reconnecting the edges\n    candidates = [\n        np.concatenate([new_solution[:a+1], new_solution[b+1:c+1], new_solution[a+1:b+1], new_solution[c+1:]]),\n        np.concatenate([new_solution[:a+1], new_solution[c+1:b+1], new_solution[a+1:c+1], new_solution[b+1:]]),\n        np.concatenate([new_solution[:b+1], new_solution[a+1:c+1], new_solution[b+1:a+1], new_solution[c+1:]])\n    ]\n\n    # Evaluate each candidate based on both objectives\n    def evaluate(tour):\n        cost1 = sum(distance_matrix_1[tour[i], tour[i+1]] for i in range(n-1)) + distance_matrix_1[tour[-1], tour[0]]\n        cost2 = sum(distance_matrix_2[tour[i], tour[i+1]] for i in range(n-1)) + distance_matrix_2[tour[-1], tour[0]]\n        return cost1, cost2\n\n    # Select the candidate that improves the worst objective\n    current_costs = evaluate(selected_solution)\n    best_candidate = None\n    best_improvement = -float('inf')\n\n    for candidate in candidates:\n        candidate_costs = evaluate(candidate)\n        improvement = min(candidate_costs[i] - current_costs[i] for i in range(2))\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_candidate = candidate\n\n    if best_candidate is not None:\n        new_solution = best_candidate\n\n    return new_solution\n\n",
          "score": [
               7.520170723852601,
               7.309382578806057
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify those with the highest potential for local improvement, prioritizing solutions with low objective values and high diversity in their node sequences. It then intelligently selects one such solution as the base for generating a neighbor. The novel local search operator, inspired by the 'path relinking' and 'large neighborhood search' paradigms, combines elements of both: it first identifies a critical segment in the base solution where significant improvements could be made, then explores a large neighborhood around this segment by considering multiple node insertions and deletions, while ensuring feasibility. The operator also incorporates a biased random walk to escape local optima, allowing it to explore diverse regions of the search space. The generated neighbor solution is validated to ensure it remains a feasible TSP tour, with all nodes visited exactly once. The function returns this new solution, which is expected to outperform the base solution in terms of both objectives, leveraging the hybrid approach to balance exploration and exploitation effectively.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select the solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Identify a critical segment for improvement\n    segment_length = max(3, n // 4)\n    segment_start = np.random.randint(0, n - segment_length)\n    segment = new_solution[segment_start:segment_start + segment_length]\n\n    # Step 2: Explore large neighborhood around the segment\n    # Shuffle the segment and reinsert it\n    np.random.shuffle(segment)\n    new_solution[segment_start:segment_start + segment_length] = segment\n\n    # Step 3: Apply biased random walk to escape local optima\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible (no duplicates, all nodes visited)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(np.arange(n), unique_nodes)\n        for missing in missing_nodes:\n            idx = np.where(new_solution == new_solution[-1])[0][0]\n            new_solution[idx] = missing\n\n    return new_solution\n\n",
          "score": [
               7.716272384556294,
               7.58112182765195
          ]
     }
]