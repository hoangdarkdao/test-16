[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm combines probabilistic Pareto selection with a novel \"cost-balanced segment insertion\" operator that prioritizes segments with high objective disparities, followed by dynamic \"objective-aware edge reversal\" that adaptively flips edges to improve at least one objective while maintaining feasibility through permutation validation and a fallback mechanism. It intelligently selects solutions based on objective disparities and balances improvements across both objectives, with segment insertion favoring cost-ratio-based positions and edge reversal focusing on improving either objective.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective disparity\n    disparities = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(disparities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cost-balanced segment insertion\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment costs\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n\n    # Calculate cost ratios and determine insertion position\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n    if cost_ratio > 1.2:\n        # Insert at position with minimal disruption to objective 2\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            cost = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n    elif cost_ratio < 0.8:\n        # Insert at position with minimal disruption to objective 1\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n    else:\n        # Random insertion for balanced segments\n        best_pos = random.randint(0, len(remaining))\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Dynamic objective-aware edge reversal\n    for _ in range(random.randint(1, 3)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(4, n//2))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\n        Please create a new algorithm that has a different form but can be a modified version of the provided algorithm. Attempt to introduce more novel mechanisms and new equations or programme segments.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 301,
        "algorithm": "The algorithm selects a solution from the archive based on its objective correlation, then applies an adaptive segment rearrangement that prioritizes high-correlation segments and minimizes cost differences, followed by a direction-aware edge swapping that reverses segments when both objectives improve significantly or when one improves substantially while the other improves minimally. The method ensures feasibility by falling back to simple segment reversal if needed.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective correlation\n    correlations = [(obj[0] * obj[1]) / (np.sqrt(obj[0]**2 + obj[1]**2) + 1e-10) for _, obj in archive]\n    selected_idx = np.argmax(correlations)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rearrangement\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment correlations\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_correlation = (seg_cost1 * seg_cost2) / (np.sqrt(seg_cost1**2 + seg_cost2**2) + 1e-10)\n\n    # Determine insertion position based on correlation\n    if seg_correlation > 0.7:\n        # Insert at position that maintains high correlation\n        best_pos = 0\n        max_corr = -float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            temp_corr = (temp_cost1 * temp_cost2) / (np.sqrt(temp_cost1**2 + temp_cost2**2) + 1e-10)\n            if temp_corr > max_corr:\n                max_corr = temp_corr\n                best_pos = pos\n    else:\n        # Insert at position that minimizes cost difference\n        best_pos = 0\n        min_diff = float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            cost_diff = abs(temp_cost1 - temp_cost2)\n            if cost_diff < min_diff:\n                min_diff = cost_diff\n                best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Direction-aware edge swapping\n    for _ in range(random.randint(1, 3)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n//2))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Calculate improvement weights\n        imp1 = (old_cost1 - new_cost1) / (old_cost1 + 1e-10)\n        imp2 = (old_cost2 - new_cost2) / (old_cost2 + 1e-10)\n\n        # Correlation-aware acceptance\n        if (imp1 * imp2) > 0.5:  # Both objectives improve significantly\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif (imp1 > 0.3 and imp2 > 0) or (imp2 > 0.3 and imp1 > 0):  # One objective improves substantially\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9491704249351169,
            4.029421269893646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective correlation\n    correlations = [(obj[0] * obj[1]) / (np.sqrt(obj[0]**2 + obj[1]**2) + 1e-10) for _, obj in archive]\n    selected_idx = np.argmax(correlations)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rearrangement\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment correlations\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_correlation = (seg_cost1 * seg_cost2) / (np.sqrt(seg_cost1**2 + seg_cost2**2) + 1e-10)\n\n    # Determine insertion position based on correlation\n    if seg_correlation > 0.7:\n        # Insert at position that maintains high correlation\n        best_pos = 0\n        max_corr = -float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            temp_corr = (temp_cost1 * temp_cost2) / (np.sqrt(temp_cost1**2 + temp_cost2**2) + 1e-10)\n            if temp_corr > max_corr:\n                max_corr = temp_corr\n                best_pos = pos\n    else:\n        # Insert at position that minimizes cost difference\n        best_pos = 0\n        min_diff = float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            temp_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            temp_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            cost_diff = abs(temp_cost1 - temp_cost2)\n            if cost_diff < min_diff:\n                min_diff = cost_diff\n                best_pos = pos\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Direction-aware edge swapping\n    for _ in range(random.randint(1, 3)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n//2))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Calculate improvement weights\n        imp1 = (old_cost1 - new_cost1) / (old_cost1 + 1e-10)\n        imp2 = (old_cost2 - new_cost2) / (old_cost2 + 1e-10)\n\n        # Correlation-aware acceptance\n        if (imp1 * imp2) > 0.5:  # Both objectives improve significantly\n            new_solution[i:j] = new_solution[i:j][::-1]\n        elif (imp1 > 0.3 and imp2 > 0) or (imp2 > 0.3 and imp1 > 0):  # One objective improves substantially\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "operation": "m1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm combines probabilistic Pareto selection with a novel \"cost-balanced segment insertion\" operator that prioritizes segments with high objective disparities, followed by dynamic \"objective-aware edge reversal\" that adaptively flips edges to improve at least one objective while maintaining feasibility through permutation validation and a fallback mechanism. It intelligently selects solutions based on objective disparities and balances improvements across both objectives, with segment insertion favoring cost-ratio-based positions and edge reversal focusing on improving either objective.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective disparity\n    disparities = [abs(obj[0] - obj[1]) for _, obj in archive]\n    selected_idx = np.argmax(disparities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cost-balanced segment insertion\n    segment_length = random.randint(2, min(5, n//3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment costs\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n\n    # Calculate cost ratios and determine insertion position\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n    if cost_ratio > 1.2:\n        # Insert at position with minimal disruption to objective 2\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            cost = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n    elif cost_ratio < 0.8:\n        # Insert at position with minimal disruption to objective 1\n        best_pos = 0\n        min_cost = float('inf')\n        for pos in range(len(remaining)):\n            temp_sol = np.insert(remaining, pos, segment)\n            cost = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, len(temp_sol)))\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n    else:\n        # Random insertion for balanced segments\n        best_pos = random.randint(0, len(remaining))\n\n    new_solution = np.insert(remaining, best_pos, segment)\n\n    # Dynamic objective-aware edge reversal\n    for _ in range(random.randint(1, 3)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(4, n//2))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < old_cost1) or (new_cost2 < old_cost2):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n\n        Please identify the main algorithm parameters and help me in creating a new algorithm that has different parameter settings to equations compared to the provided algorithm.\n        1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n        2. Next, implement the idea in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax, code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 302,
        "algorithm": "The algorithm combines probabilistic Pareto selection (favoring solutions with high objective disparities) with an adaptive path-swapping operator (dynamically adjusting segment sizes based on cost differences) and a multi-objective edge-flipping step (selectively reversing edges to improve both objectives). It prioritizes solutions where objectives differ significantly, uses weighted segment swaps to balance improvements across both spaces, and employs edge reversals with strict improvement conditions, with a fallback mechanism to maintain feasibility. The critical design choices involve prioritizing solutions with objective disparities, using weighted segment swaps, and applying edge flips only when both objectives improve or at least one improves sufficiently.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective disparity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_disparities = np.abs((objectives[:,0] - objectives[:,1]) / (objectives[:,0] + objectives[:,1] + 1e-10))\n    selected_idx = np.argmax(normalized_disparities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive objective-weighted path swapping\n    max_segment = min(6, n//2)\n    segment_length = random.randint(2, max_segment)\n    start1 = random.randint(0, n - segment_length)\n    start2 = random.randint(0, n - segment_length)\n\n    segment1 = new_solution[start1:start1+segment_length]\n    segment2 = new_solution[start2:start2+segment_length]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(1, segment_length))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(1, segment_length))\n\n    cost1_seg2 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(1, segment_length))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(1, segment_length))\n\n    # Calculate weight factors\n    weight1 = cost1_seg1 / (cost1_seg2 + 1e-10)\n    weight2 = cost2_seg1 / (cost2_seg2 + 1e-10)\n\n    # Swap segments with probability based on weight factors\n    if random.random() < (weight1 + weight2) / 2:\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n    # Multi-objective edge flipping\n    for _ in range(random.randint(1, 4)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n//3))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if ((new_cost1 < old_cost1 and new_cost2 < old_cost2) or\n            (new_cost1 < old_cost1 and (old_cost2 - new_cost2) < 0.2 * old_cost2) or\n            (new_cost2 < old_cost2 and (old_cost1 - new_cost1) < 0.2 * old_cost1)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5514553809206316,
            0.44702911376953125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest normalized objective disparity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_disparities = np.abs((objectives[:,0] - objectives[:,1]) / (objectives[:,0] + objectives[:,1] + 1e-10))\n    selected_idx = np.argmax(normalized_disparities)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive objective-weighted path swapping\n    max_segment = min(6, n//2)\n    segment_length = random.randint(2, max_segment)\n    start1 = random.randint(0, n - segment_length)\n    start2 = random.randint(0, n - segment_length)\n\n    segment1 = new_solution[start1:start1+segment_length]\n    segment2 = new_solution[start2:start2+segment_length]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i-1], segment1[i]] for i in range(1, segment_length))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i-1], segment1[i]] for i in range(1, segment_length))\n\n    cost1_seg2 = sum(distance_matrix_1[segment2[i-1], segment2[i]] for i in range(1, segment_length))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i-1], segment2[i]] for i in range(1, segment_length))\n\n    # Calculate weight factors\n    weight1 = cost1_seg1 / (cost1_seg2 + 1e-10)\n    weight2 = cost2_seg1 / (cost2_seg2 + 1e-10)\n\n    # Swap segments with probability based on weight factors\n    if random.random() < (weight1 + weight2) / 2:\n        new_solution[start1:start1+segment_length] = segment2\n        new_solution[start2:start2+segment_length] = segment1\n\n    # Multi-objective edge flipping\n    for _ in range(random.randint(1, 4)):\n        i = random.randint(0, n-1)\n        j = (i + random.randint(2, min(5, n//3))) % n\n\n        # Calculate potential costs\n        old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n\n        old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n        # Accept if both objectives improve or at least one improves significantly\n        if ((new_cost1 < old_cost1 and new_cost2 < old_cost2) or\n            (new_cost1 < old_cost1 and (old_cost2 - new_cost2) < 0.2 * old_cost2) or\n            (new_cost2 < old_cost2 and (old_cost1 - new_cost1) < 0.2 * old_cost1)):\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if permutation is invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "operation": "m2"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have 6 existing algorithms with their codes as follows:\n        No. 1 algorithm's description and the corresponding code are:\nThe algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n\nNo. 2 algorithm's description and the corresponding code are:\nThe heuristic algorithm selects a promising solution from the archive by prioritizing balanced objectives (40% weight for the first cost, 60% for the second) and randomly applies either a node swap or a path reversal to generate a neighbor, ensuring feasibility by verifying no nodes are duplicated or missing. The method balances exploration and exploitation by favoring more balanced solutions and using a hybrid local search strategy.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with lower weighted objectives (prioritize balanced solutions)\n    archive_sorted = sorted(archive, key=lambda x: (0.4 * x[1][0] + 0.6 * x[1][1]))\n    selected_idx = min(5, len(archive_sorted) - 1)  # Select from top 5 or all if fewer\n    selected_solution = archive_sorted[random.randint(0, selected_idx)][0].copy()\n\n    # Hybrid local search: combine node swaps and path reversal\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly choose between swap or path reversal\n    if random.random() < 0.6:\n        # Node swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Path reversal between two random indices\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution is valid (no duplicates or missing nodes)\n    assert len(new_solution) == len(selected_solution), \"Solution length changed\"\n    assert len(np.unique(new_solution)) == len(selected_solution), \"Duplicate nodes in solution\"\n\n    return new_solution\n\n\nNo. 3 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using Pareto-dominance-based selection, prioritizing non-dominated solutions, then applies a hybrid local search operator that combines segment rotation and edge insertion to generate a neighbor solution while ensuring feasibility by validating the tour and reverting to the original if invalid. The segment size and rotation are randomized to balance diversification and intensification, with the solution's objective values implicitly guiding the search.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto-dominance based selection\n    pareto_front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj[0] and obj_j[1] <= obj[1] and (obj_j[0] < obj[0] or obj_j[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if not pareto_front:\n        pareto_front = list(range(len(archive)))\n\n    selected_idx = random.choice(pareto_front)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment rotation and edge insertion\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Rotate the segment\n    rotation = random.randint(1, segment_length - 1)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the rotated segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    best_pos = random.randint(0, len(remaining))\n\n    # Insert the rotated segment at the best position\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Validate the solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nNo. 4 algorithm's description and the corresponding code are:\nThe algorithm selects a promising solution from the archive using inverse lexicographical ordering, then applies a hybrid local search combining adaptive segment relocations, probabilistic edge crossings, and dynamic node swaps with varying segment sizes and insertion probabilities to explore the solution space more thoroughly. The selection prioritizes solutions with better objectives, while the local search operators dynamically adjust their intensity based on segment costs and random probabilities to ensure diverse exploration.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with inverse lexicographical ordering of objectives\n    objectives = np.array([obj for (sol, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    selected_idx = sorted_indices[np.random.randint(0, min(3, len(sorted_indices)))]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with dynamic size\n    segment_size = random.randint(3, min(6, n//3))\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    remaining = np.delete(new_solution, range(start, start+segment_size))\n\n    # Calculate segment's contribution to objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_size))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_size))\n\n    # Dynamic insertion with probability based on segment cost\n    insertion_prob = min(0.9, 0.4 + (seg_cost1 + seg_cost2) / (sum(distance_matrix_1.flatten()) + sum(distance_matrix_2.flatten()) + 1e-10))\n    if random.random() < insertion_prob:\n        best_pos = random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, best_pos, segment)\n    else:\n        new_solution = np.concatenate([remaining, segment])\n\n    # Probabilistic edge crossing\n    if random.random() < 0.5:\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            k = random.randint(i+1, j-1)\n            new_solution = np.concatenate([new_solution[:i], new_solution[k:j], new_solution[i:k], new_solution[j:]])\n\n    # Dynamic node swaps with varying segment sizes\n    if random.random() < 0.4:\n        swap_size = random.randint(1, min(3, n//4))\n        i = random.randint(0, n - swap_size)\n        j = random.randint(0, n - swap_size)\n        if abs(i - j) >= swap_size:\n            temp = new_solution[i:i+swap_size].copy()\n            new_solution[i:i+swap_size] = new_solution[j:j+swap_size]\n            new_solution[j:j+swap_size] = temp\n\n    return new_solution\n\n\nNo. 5 algorithm's description and the corresponding code are:\nThe algorithm selects nondominated solutions with inverse Pareto rank probability, then applies a hybrid local search combining cost-aware segment rotations (prioritizing high-cost-ratio segments) and adaptive edge flips (prioritizing cost-improving flips), ensuring feasibility through permutation checks. The method balances exploration (via segment rotation) and exploitation (via edge flips) while maintaining valid TSP tours.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto ranking and selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    ranks = np.zeros(len(objectives))\n    for i in range(len(objectives)):\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                ranks[i] += 1\n\n    # Select with inverse rank probability\n    selected_idx = np.random.choice(np.where(ranks == np.min(ranks))[0])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Cost-aware segment rotation\n    segment_length = random.randint(3, min(7, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    remaining = np.delete(new_solution, range(start, start+segment_length))\n\n    # Calculate segment cost ratios\n    seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(1, segment_length))\n    seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(1, segment_length))\n    cost_ratio = seg_cost1 / (seg_cost2 + 1e-10)\n\n    # Rotate based on cost ratio\n    rotation = random.randint(1, segment_length-1)\n    if cost_ratio > 1.3:\n        rotation = -rotation\n    rotated_segment = np.roll(segment, rotation)\n\n    # Find best insertion position\n    best_pos = 0\n    best_cost = float('inf')\n    for pos in range(len(remaining) + 1):\n        temp_solution = np.insert(remaining, pos, rotated_segment)\n        cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(len(temp_solution)))\n        total_cost = cost1 + 0.6 * cost2  # Weighted sum\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n    new_solution = np.insert(remaining, best_pos, rotated_segment)\n\n    # Adaptive edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n            if (flip_cost1 + flip_cost2) < (seg_cost1 + seg_cost2):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        return base_solution\n    return new_solution\n\n\nNo. 6 algorithm's description and the corresponding code are:\nThe algorithm combines dominance-depth-based selection with a hybrid local search that adaptively reorders variable-length segments based on their normalized cost contributions in both objectives, using probabilistic segment inversion and cost-aware edge swaps to balance exploration and exploitation. It prioritizes segments with high normalized costs (>0.3) for inversion (70% chance) or rotation, while other segments are rotated. Edge swaps are performed when they improve both objectives or with a 30% probability for single-objective improvement. The solution is validated to ensure feasibility, falling back to the original if invalid.\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Dominance-depth-based selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    dominance_depth = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominance_depth[i] += 1\n\n    # Calculate selection probabilities\n    selection_probs = 1 / (dominance_depth + 1)\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reordering\n    segment_length = random.randint(3, min(7, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate normalized segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    norm_cost1 = segment_cost1 / total_cost1 if total_cost1 > 0 else 0\n    norm_cost2 = segment_cost2 / total_cost2 if total_cost2 > 0 else 0\n\n    # Adaptive segment reordering\n    if norm_cost1 > 0.3 or norm_cost2 > 0.3:\n        if random.random() < 0.7:\n            segment = segment[::-1]  # Invert segment with higher probability\n        else:\n            segment = np.roll(segment, random.randint(1, segment_length - 1))\n    else:\n        segment = np.roll(segment, random.randint(1, segment_length - 1))\n\n    # Insert the modified segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, segment)\n\n    # Cost-aware edge swaps\n    for i in range(1, len(new_solution) - 1):\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[i+1]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i+1]] + distance_matrix_1[new_solution[i+1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[i+1]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i+1]] + distance_matrix_2[new_solution[i+1], new_solution[i]]\n\n        if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n           (random.random() < 0.3 and (swapped_cost1 < current_cost1 or swapped_cost2 < current_cost2)):\n            new_solution[i], new_solution[i+1] = new_solution[i+1], new_solution[i]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\n\n        Adjusted long-term guide: Here\u2019s the refined heuristic design in your requested format:\n\n- **Keywords**: Bi-objective TSP, hybrid local search, adaptive segment rotation, edge cost prioritization, feasibility checks.\n- **Advice**: Select nondominated solutions with inverse rank-based probability, then apply a hybrid operator combining adaptive segment rotation and high-cost edge flips, ensuring feasibility via permutation validation.\n- **Avoid**: Static selection, invalid segments, or excessive computational overhead; enforce tour validity via permutation checks.\n- **Explanation**: This heuristic balances exploration (Pareto selection) and exploitation (cost-aware local search) while dynamically refining segments, guaranteeing feasible and high-quality solutions across objectives.\n\n*(Step-by-step reasoning: 1. Identified Pareto dominance as the foundation for selection. 2. Designed a hybrid operator combining segment rotation (for macro-improvement) and edge flips (for micro-improvement). 3. Ensured feasibility via permutation checks. 4. Balanced exploration/exploitation dynamically via inverse rank-based selection.)*\n        Please create a new algorithm inspired by above with better objectives, using the long-term guide.\n        1. Describe new algorithm in one sentence. Boxed {}.\n        2. Implement:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        Check syntax. No extra explanations.",
        "sample_order": 303,
        "algorithm": "The algorithm selects a promising solution from the archive using a hybrid Pareto-dominance and cost-aware segment selection strategy, then applies adaptive segment rotation (with direction based on cost ratios) and prioritized edge flips to generate neighbors, ensuring feasibility through permutation validation. It prioritizes segments where one objective dominates the other, performs cost-aware rotations, and applies directed edge flips to improve both objectives, falling back to the original solution if invalid. The selection favors non-dominated solutions with lower dominance depth, while the local search balances exploration and exploitation through cost-sensitive operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid Pareto and cost-aware selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    dominance_depth = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominance_depth[i] += 1\n\n    # Calculate selection probabilities\n    selection_probs = 1 / (dominance_depth + 1)\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation with cost-aware direction\n    segment_length = random.randint(3, min(7, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate normalized segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    norm_cost1 = segment_cost1 / total_cost1 if total_cost1 > 0 else 0\n    norm_cost2 = segment_cost2 / total_cost2 if total_cost2 > 0 else 0\n\n    # Direction based on cost ratio\n    cost_ratio = norm_cost1 / (norm_cost2 + 1e-10)\n    rotation = random.randint(1, segment_length - 1)\n    if cost_ratio > 1.2:\n        rotation = -rotation  # Reverse if first objective dominates\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the modified segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, rotated_segment)\n\n    # Prioritized edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Flip if both objectives improve or with 40% probability for single improvement\n            if (flip_cost1 < seg_cost1 and flip_cost2 < seg_cost2) or \\\n               (random.random() < 0.4 and (flip_cost1 < seg_cost1 or flip_cost2 < seg_cost2)):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9223464880137506,
            2.3363152146339417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid Pareto and cost-aware selection\n    objectives = np.array([obj for (sol, obj) in archive])\n    dominance_depth = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominance_depth[i] += 1\n\n    # Calculate selection probabilities\n    selection_probs = 1 / (dominance_depth + 1)\n    selection_probs /= np.sum(selection_probs)\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation with cost-aware direction\n    segment_length = random.randint(3, min(7, n // 3))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate normalized segment costs\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n    norm_cost1 = segment_cost1 / total_cost1 if total_cost1 > 0 else 0\n    norm_cost2 = segment_cost2 / total_cost2 if total_cost2 > 0 else 0\n\n    # Direction based on cost ratio\n    cost_ratio = norm_cost1 / (norm_cost2 + 1e-10)\n    rotation = random.randint(1, segment_length - 1)\n    if cost_ratio > 1.2:\n        rotation = -rotation  # Reverse if first objective dominates\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert the modified segment back\n    remaining = np.delete(new_solution, range(start, start + segment_length))\n    insert_pos = random.randint(0, len(remaining))\n    new_solution = np.insert(remaining, insert_pos, rotated_segment)\n\n    # Prioritized edge flips\n    for _ in range(3):\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 2:\n            seg_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            seg_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            flip_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[j-1]]\n            flip_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j-1]]\n\n            # Flip if both objectives improve or with 40% probability for single improvement\n            if (flip_cost1 < seg_cost1 and flip_cost2 < seg_cost2) or \\\n               (random.random() < 0.4 and (flip_cost1 < seg_cost1 or flip_cost2 < seg_cost2)):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Validate solution\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "operation": "elitist"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n\n        \n        Your **sole objective** is to reduce the runtime of the algorithm as much as possible.\n        Ignore any performance metrics other than runtime.\n        \n        Please create a new algorithm that is a modified, faster version of the provided one.\n        Focus on optimizations such as reducing algorithmic complexity, improving loops,\n        using efficient data structures, removing redundant computations, and simplifying logic.\n        \n        1. First, identify parts of the code that most likely cause high runtime and suggest optimizations.\n        2. Next, describe your new optimized algorithm and its main steps in one detailed sentence. The description must be inside boxed {}.\n        3. Finally, implement the optimized algorithm in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        \n        Check syntax and code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 304,
        "algorithm": null,
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute normalized objectives for all solutions\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_objectives = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n\n    # Select the best solution directly without additional operations\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Optimized edge swap with precomputed indices\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8819978245490063,
            1.2880420088768005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute normalized objectives for all solutions\n    objectives = np.array([obj for _, obj in archive])\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized_objectives = (objectives - min_obj) / (max_obj - min_obj + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n\n    # Select the best solution directly without additional operations\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Optimized edge swap with precomputed indices\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    if i > j:\n        i, j = j, i\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "operation": "r1"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n        I have one algorithm with its code as follows. Algorithm description:\n        The algorithm selects the most promising solution from the archive by prioritizing those with the lowest sum of normalized objectives, then applies a hybrid local search combining edge swapping and node insertion to explore diverse neighborhoods while ensuring feasibility. The selection is based on normalized objective values to balance trade-offs between the two objectives, while the local search operates on randomly chosen segments of the tour to avoid getting stuck in local optima. The critical design ideas are the intelligent selection of solutions and the hybrid local search strategy, which together aim to improve solution quality across multiple objectives.\n        Code:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of normalized objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge swap + node insertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution  # Too small to perform meaningful operations\n\n    # Randomly select segments to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n    k, l = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Edge swap between i-j and k-l\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion: move a random node to a new position\n    node_to_move = np.random.choice(new_solution)\n    pos = np.where(new_solution == node_to_move)[0][0]\n    new_pos = np.random.randint(0, n)\n    if pos != new_pos:\n        new_solution = np.insert(np.delete(new_solution, pos), new_pos, node_to_move)\n\n    return new_solution\n\n\n        \n        Your **sole objective** is to reduce the runtime of the algorithm as much as possible.\n        Ignore any performance metrics other than runtime.\n        \n        Please create a new algorithm that is a modified, faster version of the provided one.\n        Focus on optimizations such as reducing algorithmic complexity, improving loops,\n        using efficient data structures, removing redundant computations, and simplifying logic.\n        \n        1. First, identify parts of the code that most likely cause high runtime and suggest optimizations.\n        2. Next, describe your new optimized algorithm and its main steps in one detailed sentence. The description must be inside boxed {}.\n        3. Finally, implement the optimized algorithm in the following Python function:\n        def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\n        \n        Check syntax and code carefully before returning the final function. Do not give additional explanations.",
        "sample_order": 305,
        "algorithm": "The algorithm selects the most promising solution from the archive based on the lowest sum of normalized objectives, then generates a neighbor solution by performing a random edge swap and node insertion. It prioritizes solutions with better objective values and ensures feasibility by maintaining valid TSP tours through careful edge and node operations. The local search is hybrid, combining edge swaps and node insertions for exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute normalized objectives and scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Random positions for edge swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge swap\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion\n    pos = np.random.randint(n)\n    new_pos = np.random.randint(n)\n    if pos != new_pos:\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8822224828512425,
            0.5693493485450745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Precompute normalized objectives and scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    scores = np.sum(normalized_objectives, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Random positions for edge swap\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k, l = sorted(np.random.choice(n, 2, replace=False))\n\n    # Edge swap\n    new_solution[i], new_solution[j] = new_solution[k], new_solution[l]\n\n    # Node insertion\n    pos = np.random.randint(n)\n    new_pos = np.random.randint(n)\n    if pos != new_pos:\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "operation": "r1"
    }
]