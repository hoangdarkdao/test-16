[
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility, using a different parameter setting for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.7:  # Increased probability\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping with increased iterations\n    for _ in range(3):  # Increased to 3 rounds\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check with relaxed conditions\n        if (candidate_cost1 <= current_cost1 * 1.05 and candidate_cost2 < current_cost2 * 1.05) or \\\n           (candidate_cost1 < current_cost1 * 1.05 and candidate_cost2 <= current_cost2 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.586758163817032,
            5.824724534941522
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt move with a probabilistic node relocation heuristic, guided by an adaptive Pareto dominance criterion to balance improvements in both objectives while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply dynamic 4-opt with probabilistic node relocation\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select four random positions to modify\n    i, j, k, l = sorted(random.sample(range(1, n), 4))\n\n    # Create candidate solutions for 4-opt\n    candidates = []\n    # 4-opt move 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j] = candidate1[i:j][::-1]\n    candidates.append(candidate1)\n\n    # 4-opt move 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k] = candidate2[j:k][::-1]\n    candidates.append(candidate2)\n\n    # 4-opt move 3: Reverse segment between k and l\n    candidate3 = new_solution.copy()\n    candidate3[k:l] = candidate3[k:l][::-1]\n    candidates.append(candidate3)\n\n    # 4-opt move 4: Reverse entire segment between i and l\n    candidate4 = new_solution.copy()\n    candidate4[i:l] = candidate4[i:l][::-1]\n    candidates.append(candidate4)\n\n    # Evaluate candidates based on adaptive Pareto dominance\n    best_candidate = new_solution.copy()\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Adaptive weight based on current solution quality\n        weight = 0.5 + 0.5 * (total_dist1 + total_dist2) / (sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)) + sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)))\n\n        # Weighted score\n        score = weight * total_dist1 + (1 - weight) * total_dist2\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    # Probabilistic node relocation for further improvement\n    if random.random() < 0.4:  # 40% chance to apply node relocation\n        # Select a random node to relocate\n        m = random.randint(1, n-1)\n\n        # Find the best position to insert the node\n        best_pos = m\n        best_improvement = 0\n\n        for pos in range(1, n):\n            if pos == m or pos == m-1:\n                continue\n\n            # Create candidate by moving node to new position\n            candidate_relocate = best_candidate.copy()\n            node = candidate_relocate[m]\n            candidate_relocate = np.concatenate([candidate_relocate[:m], candidate_relocate[m+1:]])\n            candidate_relocate = np.concatenate([candidate_relocate[:pos], [node], candidate_relocate[pos:]])\n\n            # Calculate improvement in both objectives\n            old_dist1 = distance_matrix_1[best_candidate[m-1], best_candidate[m]] + distance_matrix_1[best_candidate[m], best_candidate[(m+1)%n]]\n            old_dist2 = distance_matrix_2[best_candidate[m-1], best_candidate[m]] + distance_matrix_2[best_candidate[m], best_candidate[(m+1)%n]]\n\n            new_dist1 = distance_matrix_1[candidate_relocate[pos-1], node] + distance_matrix_1[node, candidate_relocate[(pos+1)%n]]\n            new_dist2 = distance_matrix_2[candidate_relocate[pos-1], node] + distance_matrix_2[node, candidate_relocate[(pos+1)%n]]\n\n            improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_improvement > 0:\n            # Perform the relocation\n            node = best_candidate[m]\n            best_candidate = np.concatenate([best_candidate[:m], best_candidate[m+1:]])\n            best_candidate = np.concatenate([best_candidate[:best_pos], [node], best_candidate[best_pos:]])\n\n    return best_candidate\n\n",
        "score": [
            5.721238601616928,
            6.619566953840236
        ]
    },
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility, using a different parameter setting for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.7:  # Increased probability\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping with increased iterations\n    for _ in range(3):  # Increased to 3 rounds\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check with relaxed conditions\n        if (candidate_cost1 <= current_cost1 * 1.05 and candidate_cost2 < current_cost2 * 1.05) or \\\n           (candidate_cost1 < current_cost1 * 1.05 and candidate_cost2 <= current_cost2 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.586758163817032,
            5.824724534941522
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic 4-opt move with a probabilistic node relocation heuristic, guided by an adaptive Pareto dominance criterion to balance improvements in both objectives while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    # Apply dynamic 4-opt with probabilistic node relocation\n    n = len(new_solution)\n    if n < 5:\n        return new_solution\n\n    # Select four random positions to modify\n    i, j, k, l = sorted(random.sample(range(1, n), 4))\n\n    # Create candidate solutions for 4-opt\n    candidates = []\n    # 4-opt move 1: Reverse segment between i and j\n    candidate1 = new_solution.copy()\n    candidate1[i:j] = candidate1[i:j][::-1]\n    candidates.append(candidate1)\n\n    # 4-opt move 2: Reverse segment between j and k\n    candidate2 = new_solution.copy()\n    candidate2[j:k] = candidate2[j:k][::-1]\n    candidates.append(candidate2)\n\n    # 4-opt move 3: Reverse segment between k and l\n    candidate3 = new_solution.copy()\n    candidate3[k:l] = candidate3[k:l][::-1]\n    candidates.append(candidate3)\n\n    # 4-opt move 4: Reverse entire segment between i and l\n    candidate4 = new_solution.copy()\n    candidate4[i:l] = candidate4[i:l][::-1]\n    candidates.append(candidate4)\n\n    # Evaluate candidates based on adaptive Pareto dominance\n    best_candidate = new_solution.copy()\n    best_score = float('inf')\n\n    for candidate in candidates:\n        # Calculate total distance in both objectives\n        total_dist1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n        # Adaptive weight based on current solution quality\n        weight = 0.5 + 0.5 * (total_dist1 + total_dist2) / (sum(distance_matrix_1[base_solution[i-1], base_solution[i]] for i in range(n)) + sum(distance_matrix_2[base_solution[i-1], base_solution[i]] for i in range(n)))\n\n        # Weighted score\n        score = weight * total_dist1 + (1 - weight) * total_dist2\n\n        if score < best_score:\n            best_score = score\n            best_candidate = candidate.copy()\n\n    # Probabilistic node relocation for further improvement\n    if random.random() < 0.4:  # 40% chance to apply node relocation\n        # Select a random node to relocate\n        m = random.randint(1, n-1)\n\n        # Find the best position to insert the node\n        best_pos = m\n        best_improvement = 0\n\n        for pos in range(1, n):\n            if pos == m or pos == m-1:\n                continue\n\n            # Create candidate by moving node to new position\n            candidate_relocate = best_candidate.copy()\n            node = candidate_relocate[m]\n            candidate_relocate = np.concatenate([candidate_relocate[:m], candidate_relocate[m+1:]])\n            candidate_relocate = np.concatenate([candidate_relocate[:pos], [node], candidate_relocate[pos:]])\n\n            # Calculate improvement in both objectives\n            old_dist1 = distance_matrix_1[best_candidate[m-1], best_candidate[m]] + distance_matrix_1[best_candidate[m], best_candidate[(m+1)%n]]\n            old_dist2 = distance_matrix_2[best_candidate[m-1], best_candidate[m]] + distance_matrix_2[best_candidate[m], best_candidate[(m+1)%n]]\n\n            new_dist1 = distance_matrix_1[candidate_relocate[pos-1], node] + distance_matrix_1[node, candidate_relocate[(pos+1)%n]]\n            new_dist2 = distance_matrix_2[candidate_relocate[pos-1], node] + distance_matrix_2[node, candidate_relocate[(pos+1)%n]]\n\n            improvement = (old_dist1 - new_dist1) + (old_dist2 - new_dist2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_improvement > 0:\n            # Perform the relocation\n            node = best_candidate[m]\n            best_candidate = np.concatenate([best_candidate[:m], best_candidate[m+1:]])\n            best_candidate = np.concatenate([best_candidate[:best_pos], [node], best_candidate[best_pos:]])\n\n    return best_candidate\n\n",
        "score": [
            5.721238601616928,
            6.619566953840236
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment insertion with multi-objective edge refinement, where segments from diverse solutions are strategically inserted and refined through Pareto-guided edge swaps to balance improvements across both objectives while preserving solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive segment insertion from multiple solutions\n    if len(archive) > 1:\n        num_segments = random.randint(1, min(3, len(archive) - 1))\n        selected_indices = random.sample(range(len(archive)), num_segments)\n\n        for idx in selected_indices:\n            if idx == selected_idx:\n                continue\n            other_solution, _ = archive[idx]\n\n            # Select a random segment from the other solution\n            start, end = sorted(random.sample(range(n), 2))\n            segment = other_solution[start:end]\n\n            # Find optimal insertion point\n            best_pos = 0\n            best_cost = float('inf')\n\n            for pos in range(n - len(segment) + 1):\n                candidate = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:]\n                ])\n\n                # Remove duplicates\n                _, unique_indices = np.unique(candidate, return_index=True)\n                candidate = candidate[np.sort(unique_indices)]\n\n                # Ensure all nodes are included\n                missing_nodes = set(range(n)) - set(candidate)\n                if missing_nodes:\n                    for node in missing_nodes:\n                        insert_pos = random.randint(0, len(candidate))\n                        candidate = np.insert(candidate, insert_pos, node)\n\n                # Calculate costs\n                cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n                cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            # Apply the best insertion\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n\n            # Remove duplicates and ensure completeness\n            _, unique_indices = np.unique(new_solution, return_index=True)\n            new_solution = new_solution[np.sort(unique_indices)]\n\n            missing_nodes = set(range(n)) - set(new_solution)\n            if missing_nodes:\n                for node in missing_nodes:\n                    insert_pos = random.randint(0, len(new_solution))\n                    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge refinement\n    for _ in range(3):  # Apply 3 rounds of edge refinement\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by reversing segment\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check with aspiration criteria\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2 * 1.05) or \\\n           (candidate_cost1 < current_cost1 * 1.05 and candidate_cost2 <= current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.187708767935583,
            5.869127897117393
        ]
    },
    {
        "algorithm": "{This algorithm combines a novel segment-based crossover with a multi-objective edge swapping heuristic, where promising segments are exchanged between solutions and refined through adaptive edge swaps guided by a Pareto-based selection criterion to balance improvements across both objectives while maintaining solution feasibility, using a different parameter setting for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Segment-based crossover with another random solution\n    if len(archive) > 1 and random.random() < 0.7:  # Increased probability\n        other_idx = random.choice([i for i in range(len(archive)) if i != selected_idx])\n        other_solution, _ = archive[other_idx]\n\n        # Select a random segment from the other solution\n        start, end = sorted(random.sample(range(n), 2))\n        segment = other_solution[start:end]\n\n        # Insert this segment into the current solution\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n        # Ensure all nodes are included\n        missing_nodes = set(range(n)) - set(new_solution)\n        if missing_nodes:\n            for node in missing_nodes:\n                insert_pos = random.randint(0, len(new_solution))\n                new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Multi-objective edge swapping with increased iterations\n    for _ in range(3):  # Increased to 3 rounds\n        i, j = sorted(random.sample(range(n), 2))\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto dominance check with relaxed conditions\n        if (candidate_cost1 <= current_cost1 * 1.05 and candidate_cost2 < current_cost2 * 1.05) or \\\n           (candidate_cost1 < current_cost1 * 1.05 and candidate_cost2 <= current_cost2 * 1.05):\n            new_solution = candidate\n\n    return new_solution\n\n",
        "score": [
            6.586758163817032,
            5.824724534941522
        ]
    },
    {
        "algorithm": "{This algorithm implements a novel hybrid local search operator that combines a multi-objective segment inversion heuristic with a probabilistic node relocation strategy, guided by a Pareto-based evaluation criterion to balance improvements in both objectives while maintaining solution feasibility through a comprehensive validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    weights = np.array([1.0 / (obj[0] + obj[1]) for _, obj in archive])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-objective segment inversion heuristic\n    for _ in range(3):  # Apply 3 rounds of segment inversions\n        i, j = sorted(random.sample(range(n), 2))\n        candidate = new_solution.copy()\n        candidate[i:j] = candidate[i:j][::-1]\n\n        # Calculate costs for both objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(n))\n            return cost1, cost2\n\n        current_cost1, current_cost2 = calculate_cost(new_solution)\n        candidate_cost1, candidate_cost2 = calculate_cost(candidate)\n\n        # Pareto improvement check\n        if (candidate_cost1 <= current_cost1 and candidate_cost2 < current_cost2) or \\\n           (candidate_cost1 < current_cost1 and candidate_cost2 <= current_cost2):\n            new_solution = candidate\n\n    # Probabilistic node relocation strategy\n    if random.random() < 0.4:  # 40% chance to apply relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n\n        # Find best insertion position\n        best_pos = -1\n        best_score = float('inf')\n\n        for pos in range(n):\n            if pos == node_idx or pos == (node_idx - 1) % n:\n                continue\n\n            # Create candidate solution\n            candidate = np.delete(new_solution, node_idx)\n            candidate = np.insert(candidate, pos, node)\n\n            # Calculate costs\n            cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(n))\n            score = cost1 + cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, node_idx)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            6.135236752345165,
            6.072703628148185
        ]
    },
    {
        "algorithm": "{A novel hybrid local search operator combines a dynamic segment rearrangement with a probabilistic node reinsertion heuristic, guided by a multi-objective improvement criterion that considers both objectives' improvements while ensuring feasibility through a validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by non-dominated status)\n    weights = np.array([1.0 / (1 + i) for i in range(len(archive))])\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution, _ = archive[selected_idx]\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n < 3:\n        return new_solution\n\n    # Dynamic segment rearrangement\n    segment_size = random.randint(2, max(2, n // 3))\n    start = random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    # Create candidate by moving the segment to a new position\n    segment = new_solution[start:end]\n    remaining = np.concatenate([new_solution[:start], new_solution[end:]])\n    new_pos = random.randint(0, len(remaining))\n    candidate = np.concatenate([remaining[:new_pos], segment, remaining[new_pos:]])\n\n    # Evaluate the candidate\n    def calculate_score(solution):\n        total_dist1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(n))\n        total_dist2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(n))\n        return total_dist1 + total_dist2\n\n    current_score = calculate_score(new_solution)\n    candidate_score = calculate_score(candidate)\n\n    if candidate_score < current_score:\n        new_solution = candidate.copy()\n\n    # Probabilistic node reinsertion\n    if random.random() < 0.4:  # 40% chance to apply node reinsertion\n        node_pos = random.randint(0, n-1)\n        node = new_solution[node_pos]\n\n        # Remove the node and find the best position to reinsert\n        temp_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        best_pos = 0\n        best_score = float('inf')\n\n        for pos in range(len(temp_solution)):\n            candidate_reinsert = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n            score = calculate_score(candidate_reinsert)\n            if score < best_score:\n                best_score = score\n                best_pos = pos\n\n        new_solution = np.concatenate([temp_solution[:best_pos], [node], temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            6.0465091550003764,
            6.455644376518854
        ]
    }
]