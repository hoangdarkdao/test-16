[
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9773673423984225,
               0.18285882472991943
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' employs a novel adaptive path decomposition and multi-objective guided crossover strategy to generate high-quality neighbors. It first decomposes the base solution into multiple non-overlapping segments based on the variance of edge costs across both objective spaces, then selectively recombines these segments using a guided crossover operator that prioritizes edges with complementary cost reductions in both objectives. The algorithm dynamically adjusts the segment size and crossover points based on the local Pareto front of edge improvements, ensuring feasibility through a segment validation and repair mechanism that maintains tour continuity and node uniqueness. To further enhance exploration, it incorporates a probabilistic edge flipping mechanism that flips segments with high objective cost variance, while preserving the overall tour structure. The function intelligently balances exploitation of known good segments with exploration of new segment combinations, using the distance matrices to evaluate the quality of generated neighbors and ensuring the solution remains feasible throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution in the archive\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Decompose the tour into segments based on edge cost variance\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1) % n]\n\n        # Calculate edge costs\n        cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n        variance = abs(cost1 - cost2)\n\n        if variance > 0.3 * (distance_matrix_1[prev_node, next_node] + distance_matrix_2[prev_node, next_node]):\n            segments.append(current_segment)\n            current_segment = [current_node]\n        else:\n            current_segment.append(current_node)\n    segments.append(current_segment)\n\n    # Guided segment crossover\n    if len(segments) > 1:\n        # Select two segments to crossover\n        seg_indices = np.random.choice(len(segments), 2, replace=False)\n        seg1, seg2 = segments[seg_indices[0]], segments[seg_indices[1]]\n\n        # Find crossover points based on edge improvements\n        min_improvement = float('inf')\n        best_crossover = (0, 0)\n        for i in range(len(seg1)):\n            for j in range(len(seg2)):\n                # Calculate potential improvement\n                a, b = seg1[i], seg1[(i+1)%len(seg1)]\n                c, d = seg2[j], seg2[(j+1)%len(seg2)]\n                original_cost = (distance_matrix_1[a,b] + distance_matrix_1[c,d] +\n                                distance_matrix_2[a,b] + distance_matrix_2[c,d])\n                new_cost = (distance_matrix_1[a,c] + distance_matrix_1[b,d] +\n                            distance_matrix_2[a,c] + distance_matrix_2[b,d])\n                improvement = original_cost - new_cost\n                if improvement < min_improvement:\n                    min_improvement = improvement\n                    best_crossover = (i, j)\n\n        # Perform crossover\n        i, j = best_crossover\n        new_seg1 = seg1[:i+1] + seg2[j:] + seg2[:j]\n        new_seg2 = seg2[:j+1] + seg1[i:] + seg1[:i]\n        segments[seg_indices[0]] = new_seg1\n        segments[seg_indices[1]] = new_seg2\n\n    # Reconstruct the tour\n    new_solution = np.concatenate(segments)\n\n    # Probabilistic edge flipping\n    if np.random.rand() < 0.3:\n        flip_start = np.random.randint(n)\n        flip_length = min(3, n - flip_start)\n        new_solution[flip_start:flip_start+flip_length] = new_solution[flip_start:flip_start+flip_length][::-1]\n\n    # Validate and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        # If invalid, revert to original\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -0.9122878710931449,
               0.1251642107963562
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle with cost-aware segment selection\n        segment_lengths = np.random.randint(2, min(5, n//2), size=np.random.randint(1, min(3, n//2)))\n        segment_starts = np.sort(np.random.choice(n - sum(segment_lengths), len(segment_lengths), replace=False))\n        segments = []\n        current_pos = 0\n        for i, start in enumerate(segment_starts):\n            segments.append(new_solution[current_pos:start])\n            segments.append(new_solution[start:start+segment_lengths[i]])\n            current_pos = start + segment_lengths[i]\n        segments.append(new_solution[current_pos:])\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion with cost balancing\n        for _ in range(min(3, n//2)):\n            # Select a node to move based on its cost imbalance\n            costs = []\n            for i in range(n):\n                u = new_solution[i]\n                v = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[u, v]\n                cost2 = distance_matrix_2[u, v]\n                costs.append(abs(cost1 - cost2))\n            node_idx = np.argmax(costs)\n            node = new_solution[node_idx]\n\n            # Find insertion position that balances both costs\n            best_pos = -1\n            best_balance = float('inf')\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                balance = abs(cost1 - cost2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -1.03763919442391,
               0.25300854444503784
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge crossings or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-segment shuffle with a guided edge insertion, where the shuffle randomly reorders multiple segments of the tour while the insertion strategically places nodes based on their relative costs in both objective spaces, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-segment shuffle\n        num_segments = np.random.randint(2, min(5, n//2))\n        segment_indices = sorted(np.random.choice(n, num_segments, replace=False))\n        segments = [new_solution[i:j] for i, j in zip([0] + segment_indices, segment_indices + [n])]\n        np.random.shuffle(segments)\n        new_solution = np.concatenate(segments)\n\n        # Guided edge insertion\n        for _ in range(min(3, n//2)):\n            # Select a node to move\n            node_idx = np.random.randint(n)\n            node = new_solution[node_idx]\n\n            # Find insertion position with minimal combined cost\n            min_cost = float('inf')\n            best_pos = -1\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] + \\\n                       distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9736372770910497,
               0.17719495296478271
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge diversity or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-node relocation with a guided edge swapping, where the relocation strategically moves nodes based on their relative costs in both objective spaces while the swapping reorders edges to balance the costs, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-node relocation with cost-aware node selection\n        num_relocations = np.random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            # Select a node to relocate based on its cost imbalance\n            costs = []\n            for i in range(n):\n                u = new_solution[i]\n                v = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[u, v]\n                cost2 = distance_matrix_2[u, v]\n                costs.append(abs(cost1 - cost2))\n            node_idx = np.argmax(costs)\n            node = new_solution[node_idx]\n\n            # Find relocation position that balances both costs\n            best_pos = -1\n            best_balance = float('inf')\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                balance = abs(cost1 - cost2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9123353398893009,
               0.14902621507644653
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify the most promising candidate for local improvement, prioritizing those with lower objective values or exhibiting characteristics of suboptimality (e.g., high edge crossings or non-dominated solutions). It then applies a novel hybrid local search strategy that combines a segment inversion operator with a biased 3-opt move, where the inversion is guided by the relative costs of edges in the two objective spaces, and the 3-opt is constrained to preserve feasibility by ensuring no nodes are skipped or revisited. The inversion operator selects two random segments of the tour and reverses their order, while the 3-opt operator identifies three non-adjacent edges and reconnects them to form a new cycle, with the selection of edges biased towards those with higher relative costs in either objective space. The function ensures feasibility by validating the generated neighbor solution before returning it, thus maintaining the integrity of the TSP tour.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest sum of objectives as the base\n    base_solution, _ = min(archive, key=lambda x: sum(x[1]))\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with biased 3-opt\n    if n >= 4:\n        # Segment inversion\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = new_solution[a:b][::-1]\n\n        # Biased 3-opt: select edges with higher relative costs\n        edges = []\n        for i in range(n):\n            u = new_solution[i]\n            v = new_solution[(i + 1) % n]\n            cost1 = distance_matrix_1[u, v]\n            cost2 = distance_matrix_2[u, v]\n            edges.append((i, (i + 1) % n, max(cost1, cost2)))\n\n        # Sort edges by descending cost and select top 3\n        edges.sort(key=lambda x: -x[2])\n        selected_edges = [edge for edge in edges[:3]]\n\n        if len(selected_edges) == 3:\n            # Perform 3-opt swap\n            i1, j1, _ = selected_edges[0]\n            i2, j2, _ = selected_edges[1]\n            i3, j3, _ = selected_edges[2]\n\n            # Ensure edges are non-adjacent and can form a valid cycle\n            if not (abs(i1 - i2) == 1 or abs(i1 - i3) == 1 or abs(i2 - i3) == 1):\n                # Create a new segment by reconnecting the edges\n                segment = new_solution[i1:j1] + new_solution[i2:j2] + new_solution[i3:j3]\n                new_solution = np.concatenate([new_solution[:i1], segment[::-1], new_solution[j3:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8976962591238635,
               0.14388447999954224
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Path Segmentation with Adaptive Segment Fusion,\" begins by selecting a solution from the archive using a crowding-distance-based selection that prioritizes solutions with high diversity in the objective space, then employs a novel path segmentation strategy that first partitions the tour into segments based on their objective-specific characteristics, followed by an adaptive segment fusion process where segments are strategically merged and reordered based on their contribution to each objective, with fusion points determined by a weighted combination of segment costs and objective-specific segment diversity, ensuring a more balanced exploration of the solution space while maintaining tour validity through a segment validation mechanism that checks for node uniqueness and connectivity at each step, and incorporates a local segment optimization phase that applies a restricted 3-opt operation within each segment to further improve the solution quality.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest crowding distance in objective space\n    def crowding_distance(solution, obj):\n        n = len(solution)\n        if n < 2:\n            return 0.0\n\n        # Calculate distances in objective space\n        obj1_distances = [distance_matrix_1[solution[i-1], solution[i]] for i in range(n)]\n        obj2_distances = [distance_matrix_2[solution[i-1], solution[i]] for i in range(n)]\n\n        # Normalize distances\n        max_obj1 = max(obj1_distances) if max(obj1_distances) > 0 else 1.0\n        max_obj2 = max(obj2_distances) if max(obj2_distances) > 0 else 1.0\n\n        obj1_distances = [d/max_obj1 for d in obj1_distances]\n        obj2_distances = [d/max_obj2 for d in obj2_distances]\n\n        # Calculate crowding distance\n        cd = 0.0\n        for i in range(n):\n            if i == 0 or i == n-1:\n                cd += float('inf')\n            else:\n                cd += abs(obj1_distances[i-1] - obj1_distances[i+1]) + abs(obj2_distances[i-1] - obj2_distances[i+1])\n        return cd\n\n    archive_with_cd = [(sol, obj, crowding_distance(sol, obj)) for sol, obj in archive]\n    archive_with_cd.sort(key=lambda x: x[2], reverse=True)\n    base_solution, _, _ = archive_with_cd[0]\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n < 4:\n        return new_solution\n\n    # Path segmentation based on objective-specific characteristics\n    segments = []\n    current_segment = [new_solution[0]]\n\n    for i in range(1, n):\n        prev = new_solution[i-1]\n        curr = new_solution[i]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = distance_matrix_1[prev, curr]\n        seg_cost2 = distance_matrix_2[prev, curr]\n\n        # Check if current segment should be split\n        if i > 1:\n            prev_seg_cost1 = distance_matrix_1[new_solution[i-2], prev]\n            prev_seg_cost2 = distance_matrix_2[new_solution[i-2], prev]\n\n            # Split if the current edge has significantly different characteristics\n            if (abs(seg_cost1 - prev_seg_cost1) > 0.3 * (seg_cost1 + prev_seg_cost1) or\n                abs(seg_cost2 - prev_seg_cost2) > 0.3 * (seg_cost2 + prev_seg_cost2)):\n                segments.append(current_segment)\n                current_segment = [prev, curr]\n            else:\n                current_segment.append(curr)\n        else:\n            current_segment.append(curr)\n\n    if current_segment:\n        segments.append(current_segment)\n\n    # Adaptive segment fusion\n    if len(segments) > 1:\n        # Calculate segment characteristics\n        segment_features = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i-1], seg[i]] for i in range(len(seg)))\n            seg_cost2 = sum(distance_matrix_2[seg[i-1], seg[i]] for i in range(len(seg)))\n            seg_len = len(seg)\n            segment_features.append((seg_cost1, seg_cost2, seg_len))\n\n        # Find best fusion points\n        best_fusion = None\n        best_score = -float('inf')\n\n        for i in range(len(segments)-1):\n            seg1 = segments[i]\n            seg2 = segments[i+1]\n\n            # Calculate fusion score based on objective balance\n            cost1_diff = abs(segment_features[i][0] - segment_features[i+1][0])\n            cost2_diff = abs(segment_features[i][1] - segment_features[i+1][1])\n            score = - (cost1_diff + cost2_diff) / (segment_features[i][2] + segment_features[i+1][2])\n\n            if score > best_score:\n                best_score = score\n                best_fusion = i\n\n        if best_fusion is not None:\n            # Perform fusion\n            fused_segment = segments[best_fusion] + segments[best_fusion+1]\n            new_segments = segments[:best_fusion] + [fused_segment] + segments[best_fusion+2:]\n\n            # Reconstruct solution from segments\n            new_solution = []\n            for seg in new_segments:\n                new_solution.extend(seg)\n\n            # Local segment optimization (3-opt within each segment)\n            optimized_solution = []\n            for seg in new_segments:\n                if len(seg) >= 3:\n                    # Apply 3-opt within the segment\n                    optimized_seg = seg.copy()\n                    for i in range(len(optimized_seg)-2):\n                        for j in range(i+1, len(optimized_seg)-1):\n                            for k in range(j+1, len(optimized_seg)):\n                                # Try all possible 3-opt moves\n                                new_seg = optimized_seg.copy()\n                                new_seg[i:j+1] = new_seg[i:j+1][::-1]\n                                new_seg[j:k+1] = new_seg[j:k+1][::-1]\n\n                                # Check if new segment is better\n                                new_cost1 = sum(distance_matrix_1[new_seg[l-1], new_seg[l]] for l in range(len(new_seg)))\n                                new_cost2 = sum(distance_matrix_2[new_seg[l-1], new_seg[l]] for l in range(len(new_seg)))\n                                old_cost1 = sum(distance_matrix_1[optimized_seg[l-1], optimized_seg[l]] for l in range(len(optimized_seg)))\n                                old_cost2 = sum(distance_matrix_2[optimized_seg[l-1], optimized_seg[l]] for l in range(len(optimized_seg)))\n\n                                if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                                    optimized_seg = new_seg\n                    optimized_solution.extend(optimized_seg)\n                else:\n                    optimized_solution.extend(seg)\n\n            new_solution = np.array(optimized_solution)\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        return base_solution\n\n    return new_solution\n\n",
          "score": [
               -1.0020994531813714,
               3.816782772541046
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Objective-Driven Path Reconstruction with Adaptive Node Reassignment,\" begins by selecting a solution from the archive based on a combined metric that evaluates both objective values and solution structure, then employs a novel path reconstruction strategy that first identifies critical nodes where the solution's objective costs are most imbalanced, followed by an adaptive node reassignment process where nodes are strategically moved to different positions in the tour based on their relative contributions to each objective, with reassignment positions determined by a weighted combination of the node's costs in both objectives and the current path's average costs, ensuring a more balanced exploration of the solution space while maintaining tour validity through strict feasibility checks at each step.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives using a combined metric\n    def combined_metric(obj, sol):\n        norm_obj1 = obj[0] / (np.max(distance_matrix_1) * len(sol))\n        norm_obj2 = obj[1] / (np.max(distance_matrix_2) * len(sol))\n        diversity = len(np.unique(sol)) / len(sol)\n        return (norm_obj1 + norm_obj2) * diversity\n\n    base_solution, _ = max(archive, key=lambda x: combined_metric(x[1], x[0]))\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 3:\n        # Identify critical nodes with most imbalanced costs\n        imbalances = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            curr = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            cost1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_node]\n            cost2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_node]\n            imbalance = abs(cost1 - cost2) / (cost1 + cost2 + 1e-6)\n            imbalances.append((imbalance, i))\n\n        # Sort nodes by imbalance (most imbalanced first)\n        imbalances.sort(reverse=True, key=lambda x: x[0])\n\n        # Adaptive node reassignment\n        for imbalance, node_idx in imbalances[:max(1, n//4)]:\n            node = new_solution[node_idx]\n            prev = new_solution[node_idx-1]\n            next_node = new_solution[(node_idx+1)%n]\n\n            # Calculate node's costs\n            node_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            node_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            # Find best reassignment position based on cost balance\n            best_pos = -1\n            best_score = -float('inf')\n\n            for i in range(n):\n                if i == node_idx or i == (node_idx-1)%n or i == (node_idx+1)%n:\n                    continue\n\n                # Calculate potential new costs\n                new_prev = new_solution[i-1]\n                new_next = new_solution[i]\n\n                new_cost1 = (distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next] +\n                            distance_matrix_1[prev, new_solution[(node_idx+1)%n]] +\n                            distance_matrix_1[new_solution[(node_idx-1)%n], next_node])\n                new_cost2 = (distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next] +\n                            distance_matrix_2[prev, new_solution[(node_idx+1)%n]] +\n                            distance_matrix_2[new_solution[(node_idx-1)%n], next_node])\n\n                # Calculate score based on cost balance\n                current_balance = abs(node_cost1 - node_cost2) / (node_cost1 + node_cost2 + 1e-6)\n                new_balance = abs(new_cost1 - new_cost2) / (new_cost1 + new_cost2 + 1e-6)\n                score = current_balance - new_balance\n\n                if score > best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Perform reassignment if beneficial\n            if best_pos != -1:\n                # Remove node from current position\n                new_solution = np.delete(new_solution, node_idx)\n\n                # Insert node at best position\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.9978062172831872,
               1.9996381998062134
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' employs a novel adaptive segment-based crossover with dynamic edge selection, where it first identifies promising solutions by analyzing the archive for those with balanced objective values and low edge overlap, then applies a multi-stage local search that combines a probabilistic segment exchange operator with a constrained edge reversal mechanism. The segment exchange probabilistically swaps segments of varying lengths between two solutions from the archive, while the edge reversal selectively inverts segments of the tour based on their relative costs in both objective spaces, with the selection of segments and edges guided by a dynamic fitness criterion that balances both objectives. The function ensures feasibility by validating the generated neighbor solution through a cycle consistency check and incorporates a fallback mechanism to revert to the original solution if the neighbor is infeasible, while also maintaining diversity by periodically introducing random perturbations to escape local optima.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objectives and low edge overlap\n    archive_sorted = sorted(archive, key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Adaptive segment-based crossover\n        if len(archive) > 1 and np.random.rand() < 0.3:\n            other_solution, _ = archive[np.random.choice(len(archive))]\n            seg_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = other_solution[start:start+seg_length]\n\n        # Dynamic edge selection and reversal\n        for _ in range(min(3, n//2)):\n            # Select a segment to reverse based on relative costs\n            seg_length = np.random.randint(2, min(5, n//2))\n            start = np.random.randint(0, n - seg_length)\n            segment = new_solution[start:start+seg_length]\n\n            # Calculate segment cost in both objectives\n            cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(seg_length-1))\n            cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(seg_length-1))\n\n            # Reverse if it improves the balance between objectives\n            if abs(cost1 - cost2) > np.random.rand() * 100:\n                new_solution[start:start+seg_length] = segment[::-1]\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9631515255401548,
               0.34843534231185913
          ]
     },
     {
          "algorithm": "{The new heuristic function 'select_neighbor' begins by analyzing the archive to identify solutions with high edge diversity or non-dominated fronts, then applies a novel hybrid local search strategy that combines a multi-node relocation with a guided edge swapping, where the relocation strategically moves nodes based on their relative costs in both objective spaces while the swapping reorders edges to balance the costs, ensuring feasibility by validating the solution and repairing any invalid cycles through a minimal perturbation mechanism. The function prioritizes diversity in the archive by selecting solutions with high crowding distances and uses a dynamic edge selection criterion that balances the reduction of both objectives, while maintaining tour validity through a cycle validation step and a fallback mechanism to revert to the original solution if the neighbor is infeasible.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high crowding distance or non-dominated front\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution, _ = archive_sorted[np.random.choice(min(3, len(archive_sorted)))]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n >= 4:\n        # Multi-node relocation with cost-aware node selection\n        num_relocations = np.random.randint(1, min(3, n//2))\n        for _ in range(num_relocations):\n            # Select a node to relocate based on its cost imbalance\n            costs = []\n            for i in range(n):\n                u = new_solution[i]\n                v = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[u, v]\n                cost2 = distance_matrix_2[u, v]\n                costs.append(abs(cost1 - cost2))\n            node_idx = np.argmax(costs)\n            node = new_solution[node_idx]\n\n            # Find relocation position that balances both costs\n            best_pos = -1\n            best_balance = float('inf')\n            for i in range(n):\n                if i == node_idx or i == (node_idx - 1) % n:\n                    continue\n                prev_node = new_solution[i]\n                next_node = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n                balance = abs(cost1 - cost2)\n                if balance < best_balance:\n                    best_balance = balance\n                    best_pos = i\n\n            if best_pos != -1:\n                # Remove node and insert at best position\n                new_solution = np.concatenate([\n                    new_solution[:node_idx],\n                    new_solution[node_idx+1:],\n                    [node]\n                ])\n                new_solution = np.concatenate([\n                    new_solution[:best_pos+1],\n                    [node],\n                    new_solution[best_pos+1:]\n                ])\n\n        # Guided edge swapping for cost balancing\n        for _ in range(min(2, n//2)):\n            # Select two edges to swap based on their cost imbalance\n            edges = []\n            for i in range(n):\n                u = new_solution[i]\n                v = new_solution[(i + 1) % n]\n                cost1 = distance_matrix_1[u, v]\n                cost2 = distance_matrix_2[u, v]\n                edges.append((i, (i + 1) % n, abs(cost1 - cost2)))\n\n            edges.sort(key=lambda x: -x[2])\n            if len(edges) >= 2:\n                i1, j1, _ = edges[0]\n                i2, j2, _ = edges[1]\n\n                # Ensure edges are not adjacent and can be swapped\n                if not (abs(i1 - i2) == 1 or abs(i1 - j2) == 1 or abs(j1 - i2) == 1):\n                    # Perform edge swap\n                    segment1 = new_solution[i1:j1]\n                    segment2 = new_solution[i2:j2]\n                    new_solution = np.concatenate([\n                        new_solution[:i1],\n                        segment2,\n                        new_solution[j1:i2],\n                        segment1,\n                        new_solution[j2:]\n                    ])\n\n        # Validate cycle and repair if necessary\n        if len(np.unique(new_solution)) != n:\n            # Fallback: revert to original if invalid\n            new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.922397008902011,
               0.195390522480011
          ]
     }
]