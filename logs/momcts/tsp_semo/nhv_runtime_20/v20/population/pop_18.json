[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on crowding distance in the Pareto front, then generates a neighbor by adaptively extracting and inserting a rotated segment from another solution, ensuring feasibility through uniqueness checks and circular validation. It dynamically adjusts the segment size and rotation based on solution quality, prioritizing well-distributed solutions for better exploration.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate crowding distance for Pareto front solutions\n    nondominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj1[0] >= obj2[0] and obj1[1] >= obj2[1] and (obj1[0] > obj2[0] or obj1[1] > obj2[1]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated.append((sol1, obj1))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Sort nondominated solutions by crowding distance (descending)\n    crowding_distances = []\n    for sol, obj in nondominated:\n        # Calculate distances to neighbors in objective space\n        left = right = None\n        for other_sol, other_obj in nondominated:\n            if other_obj[0] < obj[0] and other_obj[1] < obj[1]:\n                if left is None or (other_obj[0] > left[0] and other_obj[1] > left[1]):\n                    left = other_obj\n            if other_obj[0] > obj[0] and other_obj[1] > obj[1]:\n                if right is None or (other_obj[0] < right[0] and other_obj[1] < right[1]):\n                    right = other_obj\n        # Calculate crowding distance\n        if left is None or right is None:\n            crowding_distances.append(float('inf'))\n        else:\n            crowding_distances.append((right[0] - left[0]) + (right[1] - left[1]))\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    selected_solution = nondominated[selected_idx][0].copy()\n\n    # Select a random solution from the entire archive for crossover\n    crossover_idx = np.random.randint(0, len(archive))\n    crossover_solution = archive[crossover_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Dynamic segment size based on solution quality\n    segment_size = max(2, int(0.3 * n * (1 - np.random.rand() * 0.4)))\n    start = np.random.randint(0, n - segment_size + 1)\n\n    # Extract the segment from the crossover solution\n    segment = crossover_solution[start:start + segment_size]\n\n    # Find the position to insert the segment in the selected solution\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n\n    # Rotate the segment based on distance metrics\n    rotate_amount = np.random.randint(0, segment_size)\n    rotated_segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])\n\n    # Insert the rotated segment into the selected solution\n    new_solution = np.concatenate([\n        selected_solution[:insert_pos],\n        rotated_segment,\n        selected_solution[insert_pos + segment_size:]\n    ])\n\n    # Ensure uniqueness and validity\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = selected_solution.copy()\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -1.006136939204562,
            1.0287234783172607
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The algorithm selects a base solution from the archive based on objective diversity, then applies a hybrid local search combining adaptive segment relocations and node exchanges, ensuring feasibility through circular tour maintenance and evaluating improvements using an objective-weighted acceptance criterion. It prioritizes solutions with diverse objectives and uses probabilistic acceptance to balance improvements across both spaces, while maintaining valid TSP tours through segment manipulation and exchange operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_size = max(2, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Node exchange with objective-weighted acceptance\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Calculate cost changes\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Objective-weighted improvement criterion\n        delta1 = new_cost1 - old_cost1\n        delta2 = new_cost2 - old_cost2\n        acceptance_prob = 1.0 / (1.0 + np.exp(0.5 * (delta1 + delta2)))\n\n        if np.random.rand() < acceptance_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9739385286197475,
            0.7466378808021545
        ]
    },
    {
        "algorithm": "The algorithm combines nondominated solution prioritization with an adaptive segment-based crossover, dynamically adjusting segment sizes based on objective diversity to create balanced neighbors while ensuring feasibility. It selectively chooses segments from nondominated solutions, reverses or rotates them probabilistically, and merges them with the base solution, using objective improvements as acceptance criteria to guide exploration toward diverse, high-quality regions. The key design ideas are prioritizing nondominated solutions, adaptively adjusting segment sizes based on diversity, and probabilistically reversing segments to explore diverse neighborhoods while maintaining feasibility.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Identify nondominated solutions\n    nondominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol, obj))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a base solution and a crossover partner\n    base_sol, base_obj = random.choice(nondominated)\n    partner_sol, _ = random.choice(nondominated)\n    new_solution = base_sol.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective diversity\n    diversity = np.std([obj for _, obj in nondominated], axis=0)\n    segment_size = max(2, min(n//2, int(np.random.normal(loc=diversity[0] * n / 100, scale=2))))\n\n    # Perform segment-based crossover\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n    segment = partner_sol[start:end]\n\n    # Insert segment into base solution with possible reversal\n    if np.random.rand() < 0.5:\n        segment = segment[::-1]\n\n    # Find insertion point that minimizes objective changes\n    best_insert_pos = start\n    min_change = float('inf')\n\n    for pos in range(n - segment_size + 1):\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos + segment_size:]])\n        temp_sol = np.append(temp_sol, temp_sol[0])  # Ensure circularity\n\n        # Calculate objective changes\n        old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n        old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n        change = (new_cost1 - old_cost1) + (new_cost2 - old_cost2)\n        if change < min_change:\n            min_change = change\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos + segment_size:]])\n    new_solution = np.append(new_solution, new_solution[0])  # Ensure circularity\n\n    return new_solution\n\n",
        "score": [
            -0.9752539699322335,
            4.363247990608215
        ]
    },
    {
        "algorithm": "This algorithm selects extreme solutions from the archive (prioritizing those with highest combined objective values) and applies a hybrid local search combining dynamic segment rotations and node swaps, focusing on balanced improvements in both objectives while ensuring tour validity through circularity checks. The method uses probabilistic segment rotation and selective node swaps based on objective improvements, with a bias toward solutions that show potential for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with extreme objective values\n    objectives = np.array([obj for _, obj in archive])\n    extreme_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[extreme_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    segment_size = max(3, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    if np.random.rand() < 0.7:\n        # Rotate segment\n        segment = new_solution[start:end]\n        rotated = np.roll(segment, np.random.randint(1, segment_size))\n        new_solution[start:end] = rotated\n    else:\n        # Swap nodes with probability based on objective improvement\n        for _ in range(5):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.95 * old_cost1 and new_cost2 <= 0.95 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9648589443513792,
            0.49024927616119385
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on a weighted combination of objectives (60% for the first objective, 40% for the second), then applies a hybrid local search combining edge swaps (70% chance) with segment reversals (30% chance) to explore diverse neighborhoods while ensuring feasibility. It also includes an occasional random edge flip (30% chance) for additional diversity, and guarantees a circular tour by appending the start node if needed. The method prioritizes the first objective in selection but balances exploration of both objectives in perturbation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    weights = [0.6, 0.4]  # Weight for each objective\n    selected_solution = min(archive, key=lambda x: weights[0]*x[1][0] + weights[1]*x[1][1])[0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: combine edge swaps with segment reversal\n    if random.random() < 0.7:  # 70% chance for edge swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:  # 30% chance for segment reversal\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Additional perturbation for diversity\n    if random.random() < 0.3:  # 30% chance for random edge flip\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8907118218798389,
            0.2272680401802063
        ]
    },
    {
        "algorithm": "The algorithm combines nondominated solution selection with a hybrid local search that dynamically alternates between segment-based operations (reversal/rotation) and edge-based swaps, prioritizing objective diversity and adaptive segment sizes while ensuring feasibility through probabilistic operation selection and circular tour maintenance. It balances exploration (via segment operations) and exploitation (via edge swaps) with a focus on improving both objectives simultaneously.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size and operation selection\n    segment_size = max(2, int(np.ceil(n * 0.15 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Dynamic operation selection based on objective improvement potential\n    if np.random.rand() < 0.6:\n        # Segment-based operation\n        if np.random.rand() < 0.5:\n            # Dynamic segment reversal\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Dynamic segment rotation\n            segment = new_solution[start:end]\n            rotated = np.roll(segment, np.random.randint(1, segment_size))\n            new_solution[start:end] = rotated\n    else:\n        # Edge-based operation\n        for _ in range(3):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or at least one improves significantly\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.9 * old_cost1 and new_cost2 < old_cost2) or (new_cost1 < old_cost1 and new_cost2 <= 0.9 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9706242552447388,
            1.0275250673294067
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive based on normalized objective quality scores, then applies a hybrid local search that adaptively combines segment inversion and rotation with dynamic segment sizes, ensuring feasibility through validation checks. The selection prioritizes solutions with better combined objective values, while the local search balances exploration and exploitation through quality-dependent operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate solution quality scores (normalized)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n    quality_scores = 1 - (normalized_obj[:, 0] + normalized_obj[:, 1]) / 2  # Higher is better\n\n    # Select solution with probability proportional to quality\n    selected_idx = np.random.choice(len(archive), p=quality_scores/np.sum(quality_scores))\n    selected_solution = archive[selected_idx][0].copy()\n\n    # Select another solution for hybrid operation\n    hybrid_idx = np.random.choice(len(archive))\n    hybrid_solution = archive[hybrid_idx][0].copy()\n\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Adaptive segment size based on solution quality\n    quality = quality_scores[selected_idx]\n    segment_size = max(2, min(int(0.3 * n + 0.7 * n * quality), n - 1))\n    start = np.random.randint(0, n - segment_size + 1)\n\n    # Extract and process segment\n    segment = hybrid_solution[start:start + segment_size]\n    rotate_amount = np.random.randint(0, segment_size)\n\n    # Hybrid operation: invert segment with probability based on quality\n    if np.random.rand() < 0.5 + 0.5 * quality:\n        segment = segment[::-1]  # Inversion\n    else:\n        segment = np.concatenate([segment[rotate_amount:], segment[:rotate_amount]])  # Rotation\n\n    # Insert segment\n    insert_pos = np.random.randint(0, n - segment_size + 1)\n    new_solution = np.concatenate([\n        selected_solution[:insert_pos],\n        segment,\n        selected_solution[insert_pos + segment_size:]\n    ])\n\n    # Validate solution\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9669736747082317,
            0.8808766007423401
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive based on a weighted sum of objectives (60% first objective, 40% second), then applies a hybrid 3-opt-inspired local search by randomly selecting three edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. The method prioritizes solutions with lower combined costs and uses a creative edge-reconnection strategy to generate neighbors.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with lowest weighted sum of objectives (weight 0.6 for first objective, 0.4 for second)\n    selected_solution = min(archive, key=lambda x: 0.6 * x[1][0] + 0.4 * x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    a, b, c = sorted(random.sample(range(n), 3))\n\n    # Create a new tour by reconnecting the edges in a hybrid 3-opt manner\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.7497831716246897,
            0.2392069697380066
        ]
    }
]