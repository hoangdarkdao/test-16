[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8311942081231796,
            0.23212707042694092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8311942081231796,
            0.23212707042694092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8311942081231796,
            0.23212707042694092
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8713409949848904,
            0.37909936904907227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8713409949848904,
            0.37909936904907227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8363169573489454,
            0.20000022649765015
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search strategy combines a dynamic edge-swap operator with a probabilistic node reinsertion mechanism, guided by the Pareto dominance and crowding distance of solutions in the archive to intelligently explore the search space while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and crowding distance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -np.prod(x[1])))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap and probabilistic reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic edge-swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate cost before and after swap\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost_before_1 = get_cost(new_solution, distance_matrix_1)\n    cost_before_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Perform swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    cost_after_1 = get_cost(new_solution, distance_matrix_1)\n    cost_after_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Revert if not improving both objectives\n    if (cost_after_1 > cost_before_1 and cost_after_2 > cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Probabilistic reinsertion\n    if random.random() < 0.3:  # 30% chance to apply reinsertion\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9198377521725547,
            0.7517856359481812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and crowding distance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -np.prod(x[1])))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap and probabilistic reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic edge-swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate cost before and after swap\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost_before_1 = get_cost(new_solution, distance_matrix_1)\n    cost_before_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Perform swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    cost_after_1 = get_cost(new_solution, distance_matrix_1)\n    cost_after_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Revert if not improving both objectives\n    if (cost_after_1 > cost_before_1 and cost_after_2 > cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Probabilistic reinsertion\n    if random.random() < 0.3:  # 30% chance to apply reinsertion\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{A novel hybrid local search strategy combines a dynamic edge-swap operator with a probabilistic node reinsertion mechanism, guided by the Pareto dominance and crowding distance of solutions in the archive to intelligently explore the search space while preserving feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and crowding distance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -np.prod(x[1])))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap and probabilistic reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic edge-swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate cost before and after swap\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost_before_1 = get_cost(new_solution, distance_matrix_1)\n    cost_before_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Perform swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    cost_after_1 = get_cost(new_solution, distance_matrix_1)\n    cost_after_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Revert if not improving both objectives\n    if (cost_after_1 > cost_before_1 and cost_after_2 > cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Probabilistic reinsertion\n    if random.random() < 0.3:  # 30% chance to apply reinsertion\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9198377521725547,
            0.7517856359481812
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and crowding distance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -np.prod(x[1])))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap and probabilistic reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic edge-swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate cost before and after swap\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost_before_1 = get_cost(new_solution, distance_matrix_1)\n    cost_before_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Perform swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    cost_after_1 = get_cost(new_solution, distance_matrix_1)\n    cost_after_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Revert if not improving both objectives\n    if (cost_after_1 > cost_before_1 and cost_after_2 > cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Probabilistic reinsertion\n    if random.random() < 0.3:  # 30% chance to apply reinsertion\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7714680794521842,
            0.17661619186401367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized node relocation with a multi-objective edge swapping strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Randomized node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i - 1) % n or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Multi-objective edge swapping\n    for k in range(n):\n        l = (k + 1) % (n - 1)\n        m = (k + 2) % (n - 1)\n\n        current_edge1 = distance_matrix_1[new_solution[k], new_solution[l]]\n        current_edge2 = distance_matrix_2[new_solution[k], new_solution[l]]\n        new_edge1 = distance_matrix_1[new_solution[k], new_solution[m]]\n        new_edge2 = distance_matrix_2[new_solution[k], new_solution[m]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n",
        "score": [
            -0.8452359414857294,
            0.2975118160247803
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Randomized node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i - 1) % n or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Multi-objective edge swapping\n    for k in range(n):\n        l = (k + 1) % (n - 1)\n        m = (k + 2) % (n - 1)\n\n        current_edge1 = distance_matrix_1[new_solution[k], new_solution[l]]\n        current_edge2 = distance_matrix_2[new_solution[k], new_solution[l]]\n        new_edge1 = distance_matrix_1[new_solution[k], new_solution[m]]\n        new_edge2 = distance_matrix_2[new_solution[k], new_solution[m]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9065865659944647,
            0.24343258142471313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation, but with a novel adaptive probability mechanism that dynamically adjusts based on the current solution's quality and the local search's success rate to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.927394076164967,
            0.49046647548675537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{The new algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation, but with a novel adaptive probability mechanism that dynamically adjusts based on the current solution's quality and the local search's success rate to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.927394076164967,
            0.49046647548675537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{A novel hybrid local search operator that intelligently selects solutions from the archive based on their Pareto dominance, then applies a combination of segment rotation and adaptive edge insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Segment rotation: rotate a random segment by a random amount\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Adaptive edge insertion: insert nodes that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between i and j\n        best_node = None\n        best_improvement = 0\n\n        for candidate in range(n):\n            if candidate not in new_solution:\n                # Calculate potential improvement\n                removal_cost = distance_matrix_1[current_node, next_node] + distance_matrix_2[current_node, next_node]\n                insertion_cost = distance_matrix_1[current_node, candidate] + distance_matrix_1[candidate, next_node] + \\\n                                distance_matrix_2[current_node, candidate] + distance_matrix_2[candidate, next_node]\n                improvement = removal_cost - insertion_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = candidate\n\n        if best_node is not None and best_improvement > 0:\n            # Insert the best node\n            new_solution = np.insert(new_solution, j, best_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8200172377447911,
            1.5643484592437744
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.argmin([sum(obj) for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Segment rotation: rotate a random segment by a random amount\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Adaptive edge insertion: insert nodes that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between i and j\n        best_node = None\n        best_improvement = 0\n\n        for candidate in range(n):\n            if candidate not in new_solution:\n                # Calculate potential improvement\n                removal_cost = distance_matrix_1[current_node, next_node] + distance_matrix_2[current_node, next_node]\n                insertion_cost = distance_matrix_1[current_node, candidate] + distance_matrix_1[candidate, next_node] + \\\n                                distance_matrix_2[current_node, candidate] + distance_matrix_2[candidate, next_node]\n                improvement = removal_cost - insertion_cost\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_node = candidate\n\n        if best_node is not None and best_improvement > 0:\n            # Insert the best node\n            new_solution = np.insert(new_solution, j, best_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node insertion with a multi-objective edge reversal strategy to generate high-quality neighbors while ensuring feasibility by intelligently selecting promising solutions from the archive.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives and select solution with best balance\n        min_obj = objectives.min(axis=0, keepdims=True)\n        max_obj = objectives.max(axis=0, keepdims=True)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmin(scores)  # Prefer solutions with better balance\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Randomized node insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if b - a > 1:\n        # Move a segment to a different position\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Multi-objective edge reversal\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives or at least one is better, perform the reversal\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (new_edge1 < current_edge1 or new_edge2 < current_edge2):\n            # Reverse the segment between i and k\n            segment = new_solution[i:k+1]\n            new_solution[i:k+1] = np.flip(segment)\n\n    return new_solution\n\n",
        "score": [
            -0.8053600968555011,
            0.3096727132797241
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        # Normalize objectives and select solution with best balance\n        min_obj = objectives.min(axis=0, keepdims=True)\n        max_obj = objectives.max(axis=0, keepdims=True)\n        normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-10)\n        scores = normalized.sum(axis=1)\n        selected_idx = np.argmin(scores)  # Prefer solutions with better balance\n    else:\n        selected_idx = 0\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Randomized node insertion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if b - a > 1:\n        # Move a segment to a different position\n        segment = new_solution[a:b]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], segment])\n\n    # Multi-objective edge reversal\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives or at least one is better, perform the reversal\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (new_edge1 < current_edge1 or new_edge2 < current_edge2):\n            # Reverse the segment between i and k\n            segment = new_solution[i:k+1]\n            new_solution[i:k+1] = np.flip(segment)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining edge reversal and segment reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reinsertion (remove a segment and reinsert it at a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.delete(new_solution, np.arange(k, l+1))\n    pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if reinsertion breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.851771676169338,
            0.35092848539352417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reinsertion (remove a segment and reinsert it at a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.delete(new_solution, np.arange(k, l+1))\n    pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if reinsertion breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment inversion with an adaptive edge exchange strategy, guided by a weighted objective score to prioritize solutions with better potential for improvement while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange: swap edges that improve the weighted objective\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        current_weighted = 0.4 * current_edge1 + 0.6 * current_edge2\n\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n        new_weighted = 0.4 * new_edge1 + 0.6 * new_edge2\n\n        if new_weighted < current_weighted or (np.random.rand() < 0.2 and new_weighted <= current_weighted):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.6808904016048974,
            0.32084083557128906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [0.4 * obj[0] + 0.6 * obj[1] for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange: swap edges that improve the weighted objective\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        current_weighted = 0.4 * current_edge1 + 0.6 * current_edge2\n\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n        new_weighted = 0.4 * new_edge1 + 0.6 * new_edge2\n\n        if new_weighted < current_weighted or (np.random.rand() < 0.2 and new_weighted <= current_weighted):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{A novel hybrid local search operator that combines a randomized node relocation with a bi-objective-aware edge insertion strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random node relocation\n    node_to_move = np.random.randint(0, n)\n    new_pos = np.random.randint(0, n)\n    node = new_solution[node_to_move]\n\n    # Remove the node and insert it at new position\n    new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Bi-objective-aware edge insertion\n    for i in range(n-1):\n        j = (i + 1) % (n-1)\n        k = (i + 2) % (n-1)\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in at least one objective, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 <= current_edge2) or \\\n           (new_edge1 <= current_edge1 and new_edge2 < current_edge2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.88455516575041,
            0.37401795387268066
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: max(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random node relocation\n    node_to_move = np.random.randint(0, n)\n    new_pos = np.random.randint(0, n)\n    node = new_solution[node_to_move]\n\n    # Remove the node and insert it at new position\n    new_solution = np.concatenate([new_solution[:node_to_move], new_solution[node_to_move+1:]])\n    new_solution = np.insert(new_solution, new_pos, node)\n\n    # Bi-objective-aware edge insertion\n    for i in range(n-1):\n        j = (i + 1) % (n-1)\n        k = (i + 2) % (n-1)\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in at least one objective, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 <= current_edge2) or \\\n           (new_edge1 <= current_edge1 and new_edge2 < current_edge2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{This algorithm selects a solution from the archive, applies a node-based perturbation by swapping nodes based on their relative positions in the two objective spaces, followed by a guided edge optimization that selectively improves edges while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Select a solution that is not dominated by others\n        selected_idx = np.argmax(np.sum([(objectives[i] < objectives).all(axis=1) for i in range(len(archive))], axis=0))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Node-based perturbation: swap nodes based on relative positions in both spaces\n    for i in range(n):\n        node_i = base_solution[i]\n        for j in range(i+1, n):\n            node_j = base_solution[j]\n\n            # Calculate relative positions in both spaces\n            pos_i1 = instance[node_i, :2]\n            pos_j1 = instance[node_j, :2]\n            pos_i2 = instance[node_i, 2:]\n            pos_j2 = instance[node_j, 2:]\n\n            # Swap if nodes are closer in one space but farther in the other\n            if (np.linalg.norm(pos_i1 - pos_j1) < np.linalg.norm(pos_i2 - pos_j2)) and \\\n               (np.random.rand() < 0.5 or np.linalg.norm(pos_i1 - pos_j1) < 1.5 * np.linalg.norm(pos_i2 - pos_j2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided edge optimization: selectively improve edges\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Perform swap if it improves at least one objective\n        if (new_edge1 < current_edge1 or new_edge2 < current_edge2) and \\\n           (np.random.rand() < 0.4 or (new_edge1 + new_edge2) < (current_edge1 + current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8520084083282518,
            4.53301203250885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Select a solution that is not dominated by others\n        selected_idx = np.argmax(np.sum([(objectives[i] < objectives).all(axis=1) for i in range(len(archive))], axis=0))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 2:\n        return new_solution\n\n    # Node-based perturbation: swap nodes based on relative positions in both spaces\n    for i in range(n):\n        node_i = base_solution[i]\n        for j in range(i+1, n):\n            node_j = base_solution[j]\n\n            # Calculate relative positions in both spaces\n            pos_i1 = instance[node_i, :2]\n            pos_j1 = instance[node_j, :2]\n            pos_i2 = instance[node_i, 2:]\n            pos_j2 = instance[node_j, 2:]\n\n            # Swap if nodes are closer in one space but farther in the other\n            if (np.linalg.norm(pos_i1 - pos_j1) < np.linalg.norm(pos_i2 - pos_j2)) and \\\n               (np.random.rand() < 0.5 or np.linalg.norm(pos_i1 - pos_j1) < 1.5 * np.linalg.norm(pos_i2 - pos_j2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided edge optimization: selectively improve edges\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Perform swap if it improves at least one objective\n        if (new_edge1 < current_edge1 or new_edge2 < current_edge2) and \\\n           (np.random.rand() < 0.4 or (new_edge1 + new_edge2) < (current_edge1 + current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation strategy with a multi-objective edge insertion heuristic to generate diverse and high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        # Insert the segment at position i\n        temp_solution = np.insert(temp_solution, i, segment)\n\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            k = (j + 1) % n\n            total_cost += distance_matrix_1[temp_solution[j], temp_solution[k]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best relocation\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between current and next\n        best_insert = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference\n            cost_diff1 = distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] - distance_matrix_1[current_node, next_node]\n            cost_diff2 = distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] - distance_matrix_2[current_node, next_node]\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -10):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_insert = k\n\n        if best_insert != -1:\n            # Insert the node between current and next\n            new_solution = np.insert(new_solution, j, new_solution[best_insert])\n            # Remove the original occurrence of the inserted node\n            new_solution = np.delete(new_solution, np.where(new_solution == new_solution[best_insert])[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.9628426892723544,
            2.3709720373153687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        # Insert the segment at position i\n        temp_solution = np.insert(temp_solution, i, segment)\n\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            k = (j + 1) % n\n            total_cost += distance_matrix_1[temp_solution[j], temp_solution[k]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best relocation\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between current and next\n        best_insert = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference\n            cost_diff1 = distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] - distance_matrix_1[current_node, next_node]\n            cost_diff2 = distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] - distance_matrix_2[current_node, next_node]\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -10):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_insert = k\n\n        if best_insert != -1:\n            # Insert the node between current and next\n            new_solution = np.insert(new_solution, j, new_solution[best_insert])\n            # Remove the original occurrence of the inserted node\n            new_solution = np.delete(new_solution, np.where(new_solution == new_solution[best_insert])[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation strategy with a multi-objective edge insertion heuristic to generate diverse and high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        # Insert the segment at position i\n        temp_solution = np.insert(temp_solution, i, segment)\n\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            k = (j + 1) % n\n            total_cost += distance_matrix_1[temp_solution[j], temp_solution[k]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best relocation\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between current and next\n        best_insert = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference\n            cost_diff1 = distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] - distance_matrix_1[current_node, next_node]\n            cost_diff2 = distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] - distance_matrix_2[current_node, next_node]\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -10):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_insert = k\n\n        if best_insert != -1:\n            # Insert the node between current and next\n            new_solution = np.insert(new_solution, j, new_solution[best_insert])\n            # Remove the original occurrence of the inserted node\n            new_solution = np.delete(new_solution, np.where(new_solution == new_solution[best_insert])[0][1])\n\n    return new_solution\n\n",
        "score": [
            -0.9628426892723544,
            2.3709720373153687
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        # Insert the segment at position i\n        temp_solution = np.insert(temp_solution, i, segment)\n\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            k = (j + 1) % n\n            total_cost += distance_matrix_1[temp_solution[j], temp_solution[k]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best relocation\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between current and next\n        best_insert = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference\n            cost_diff1 = distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] - distance_matrix_1[current_node, next_node]\n            cost_diff2 = distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] - distance_matrix_2[current_node, next_node]\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -10):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_insert = k\n\n        if best_insert != -1:\n            # Insert the node between current and next\n            new_solution = np.insert(new_solution, j, new_solution[best_insert])\n            # Remove the original occurrence of the inserted node\n            new_solution = np.delete(new_solution, np.where(new_solution == new_solution[best_insert])[0][1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a dynamic edge-swap operator with a probabilistic node reinsertion mechanism, guided by the Pareto dominance and crowding distance of solutions in the archive to intelligently explore the search space while preserving feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by Pareto dominance and crowding distance\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1], -np.prod(x[1])))\n        selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: dynamic edge-swap and probabilistic reinsertion\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Step 1: Dynamic edge-swap\n    i, j = sorted(random.sample(range(n), 2))\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Calculate cost before and after swap\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost_before_1 = get_cost(new_solution, distance_matrix_1)\n    cost_before_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Perform swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    cost_after_1 = get_cost(new_solution, distance_matrix_1)\n    cost_after_2 = get_cost(new_solution, distance_matrix_2)\n\n    # Revert if not improving both objectives\n    if (cost_after_1 > cost_before_1 and cost_after_2 > cost_before_2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Step 2: Probabilistic reinsertion\n    if random.random() < 0.3:  # 30% chance to apply reinsertion\n        pos = random.randint(0, n-1)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation, but with a novel adaptive probability mechanism that dynamically adjusts based on the current solution's quality and the local search's success rate to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search that combines a dynamic segment inversion operator with a probabilistic edge relocation mechanism, guided by the trade-off between the two objectives to explore the search space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_score = (1 - normalized_obj[:, 0]) * (1 - normalized_obj[:, 1]) * diversity\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    if n > 3:\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n-1))\n        end = (start + length) % n\n        if start < end:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end+1]])\n            new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[end+1:start]])\n\n        # Probabilistic edge relocation\n        if random.random() < 0.4:\n            u, v = random.sample(range(n), 2)\n            if u > v:\n                u, v = v, u\n            if v - u > 1:\n                new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    # Trade-off guided improvement\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost1 = get_cost(new_solution, distance_matrix_1)\n    cost2 = get_cost(new_solution, distance_matrix_2)\n    tradeoff = cost1 / (cost1 + cost2 + 1e-8)\n\n    if random.random() < tradeoff:\n        # Focus on first objective\n        i, j = random.sample(range(n), 2)\n        temp = new_solution.copy()\n        temp[i], temp[j] = temp[j], temp[i]\n        if get_cost(temp, distance_matrix_1) < cost1:\n            new_solution = temp\n    else:\n        # Focus on second objective\n        k, l = random.sample(range(n), 2)\n        temp = new_solution.copy()\n        temp[k], temp[l] = temp[l], temp[k]\n        if get_cost(temp, distance_matrix_2) < cost2:\n            new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.7009433618248097,
            0.2855749726295471
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_score = (1 - normalized_obj[:, 0]) * (1 - normalized_obj[:, 1]) * diversity\n    selected_idx = np.argmax(selection_score)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    if n > 3:\n        start = random.randint(0, n-1)\n        length = random.randint(2, min(5, n-1))\n        end = (start + length) % n\n        if start < end:\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n        else:\n            segment = np.concatenate([new_solution[start:], new_solution[:end+1]])\n            new_solution = np.concatenate([new_solution[:start], segment[::-1], new_solution[end+1:start]])\n\n        # Probabilistic edge relocation\n        if random.random() < 0.4:\n            u, v = random.sample(range(n), 2)\n            if u > v:\n                u, v = v, u\n            if v - u > 1:\n                new_solution[u], new_solution[v] = new_solution[v], new_solution[u]\n\n    # Trade-off guided improvement\n    def get_cost(sol, dist_mat):\n        total = 0\n        for a, b in zip(sol, np.roll(sol, -1)):\n            total += dist_mat[a, b]\n        return total\n\n    cost1 = get_cost(new_solution, distance_matrix_1)\n    cost2 = get_cost(new_solution, distance_matrix_2)\n    tradeoff = cost1 / (cost1 + cost2 + 1e-8)\n\n    if random.random() < tradeoff:\n        # Focus on first objective\n        i, j = random.sample(range(n), 2)\n        temp = new_solution.copy()\n        temp[i], temp[j] = temp[j], temp[i]\n        if get_cost(temp, distance_matrix_1) < cost1:\n            new_solution = temp\n    else:\n        # Focus on second objective\n        k, l = random.sample(range(n), 2)\n        temp = new_solution.copy()\n        temp[k], temp[l] = temp[l], temp[k]\n        if get_cost(temp, distance_matrix_2) < cost2:\n            new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy, and incorporates a probabilistic swap mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = 1 / (costs + 1e-6)  # Avoid division by zero\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with larger segments\n    segment_size = min(5, n // 2)\n    a = np.random.randint(0, n - segment_size)\n    b = a + segment_size\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Enhanced guided edge exchange with probabilistic selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # More aggressive improvement condition\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.5 and (new_edge1 + new_edge2 <= current_edge1 + current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic swaps to diversify the solution\n    if np.random.rand() < 0.4:\n        swap_indices = np.random.choice(n, 2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n",
        "score": [
            -0.8266886143466001,
            0.2606157660484314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    weights = 1 / (costs + 1e-6)  # Avoid division by zero\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with larger segments\n    segment_size = min(5, n // 2)\n    a = np.random.randint(0, n - segment_size)\n    b = a + segment_size\n    new_solution[a:b] = np.flip(new_solution[a:b])\n\n    # Enhanced guided edge exchange with probabilistic selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # More aggressive improvement condition\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.5 and (new_edge1 + new_edge2 <= current_edge1 + current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic swaps to diversify the solution\n    if np.random.rand() < 0.4:\n        swap_indices = np.random.choice(n, 2, replace=False)\n        new_solution[swap_indices[0]], new_solution[swap_indices[1]] = new_solution[swap_indices[1]], new_solution[swap_indices[0]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{The algorithm selects a solution from the archive based on both objective quality and diversity, then applies a hybrid local search combining a novel segment rotation with an adaptive edge insertion strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation and adaptive edge insertion\n    if n >= 4:\n        # Segment rotation: rotate a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:a+3] = rotated_segment\n\n        # Adaptive edge insertion: insert a node between two nodes if it improves both objectives\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the insertion\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution = np.insert(new_solution, j, k)\n                new_solution = np.delete(new_solution, [i, j+1] if i < j else [j, i+1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.848706533533174,
            0.2526024580001831
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation and adaptive edge insertion\n    if n >= 4:\n        # Segment rotation: rotate a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:a+3] = rotated_segment\n\n        # Adaptive edge insertion: insert a node between two nodes if it improves both objectives\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the insertion\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution = np.insert(new_solution, j, k)\n                new_solution = np.delete(new_solution, [i, j+1] if i < j else [j, i+1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8136722395928158,
            0.21144700050354004
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation, but with a novel adaptive probability mechanism that dynamically adjusts based on the current solution's quality and the local search's success rate to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and structural diversity, then applies a novel hybrid local search combining segment inversion and node insertion with adaptive probability, ensuring feasibility while dynamically adjusting the search intensity based on the solution's quality and improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.6 * (1 - normalized_obj.mean(axis=1)) + 0.4 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improvement_factor = 0.7\n\n    # Adaptive hybrid local search\n    for _ in range(2):\n        # Segment inversion with adaptive probability\n        if np.random.rand() < 0.5 * improvement_factor:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Node insertion with adaptive probability\n        if np.random.rand() < 0.4 * improvement_factor:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Update improvement factor\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.3 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            improvement_factor = min(1.0, improvement_factor * 1.2)\n        else:\n            improvement_factor = max(0.3, improvement_factor * 0.8)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8332444879908266,
            0.4266989827156067
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.6 * (1 - normalized_obj.mean(axis=1)) + 0.4 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    improvement_factor = 0.7\n\n    # Adaptive hybrid local search\n    for _ in range(2):\n        # Segment inversion with adaptive probability\n        if np.random.rand() < 0.5 * improvement_factor:\n            k, l = sorted(np.random.choice(n, 2, replace=False))\n            new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n        # Node insertion with adaptive probability\n        if np.random.rand() < 0.4 * improvement_factor:\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, pos, node)\n\n        # Update improvement factor\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.3 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            improvement_factor = min(1.0, improvement_factor * 1.2)\n        else:\n            improvement_factor = max(0.3, improvement_factor * 0.8)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge exchange (swap two edges)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment relocation (move a segment to a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining edge reversal and segment reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reinsertion (remove a segment and reinsert it at a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.delete(new_solution, np.arange(k, l+1))\n    pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if reinsertion breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node insertion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node insertion (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Segment reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n-1, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9118434901364778,
            0.3112879991531372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node insertion (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Segment reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n-1, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining edge reversal and segment reinsertion to generate a high-quality neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Step 2: Segment reinsertion (remove a segment and reinsert it at a different position)\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.delete(new_solution, np.arange(k, l+1))\n    pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if reinsertion breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and a score function that considers both the cost improvement potential and the solution's diversity, then applies a hybrid local search combining edge reversal with a novel segment relocation strategy to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for selection: combination of objective values and diversity\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        diversity = np.sum(sol != archive[0][0]) / len(sol)\n        scores.append((cost1 + cost2) * (1 + diversity))\n    scores = np.array(scores)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reversal with cost-based selection\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    delta1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[-2], segment[0]] +\n              distance_matrix_1[reversed_segment[0], reversed_segment[1]] + distance_matrix_1[reversed_segment[-1], reversed_segment[-2]]) - \\\n             (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[-2], segment[-1]] +\n              distance_matrix_1[segment[0], segment[1]] + distance_matrix_1[segment[-1], segment[-2]])\n    delta2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[-2], segment[0]] +\n              distance_matrix_2[reversed_segment[0], reversed_segment[1]] + distance_matrix_2[reversed_segment[-1], reversed_segment[-2]]) - \\\n             (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[-2], segment[-1]] +\n              distance_matrix_2[segment[0], segment[1]] + distance_matrix_2[segment[-1], segment[-2]])\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Novel segment relocation\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.delete(new_solution, np.arange(k, l+1))\n    candidates = []\n    for pos in range(len(new_solution)):\n        if pos == 0:\n            prev = new_solution[-1]\n            next_node = new_solution[0]\n        elif pos == len(new_solution):\n            prev = new_solution[-1]\n            next_node = new_solution[0]\n        else:\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n        delta1 = (distance_matrix_1[prev, segment[0]] + distance_matrix_1[segment[-1], next_node]) - \\\n                 (distance_matrix_1[prev, next_node])\n        delta2 = (distance_matrix_2[prev, segment[0]] + distance_matrix_2[segment[-1], next_node]) - \\\n                 (distance_matrix_2[prev, next_node])\n        candidates.append((delta1 + delta2, pos))\n    if candidates:\n        best_pos = min(candidates, key=lambda x: x[0])[1]\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7857590238850118,
            0.7458956837654114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate scores for selection: combination of objective values and diversity\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        diversity = np.sum(sol != archive[0][0]) / len(sol)\n        scores.append((cost1 + cost2) * (1 + diversity))\n    scores = np.array(scores)\n    probs = np.exp(-scores) / np.sum(np.exp(-scores))\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Edge reversal with cost-based selection\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    segment = new_solution[i:j+1]\n    reversed_segment = segment[::-1]\n    delta1 = (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[-2], segment[0]] +\n              distance_matrix_1[reversed_segment[0], reversed_segment[1]] + distance_matrix_1[reversed_segment[-1], reversed_segment[-2]]) - \\\n             (distance_matrix_1[segment[-1], segment[0]] + distance_matrix_1[segment[-2], segment[-1]] +\n              distance_matrix_1[segment[0], segment[1]] + distance_matrix_1[segment[-1], segment[-2]])\n    delta2 = (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[-2], segment[0]] +\n              distance_matrix_2[reversed_segment[0], reversed_segment[1]] + distance_matrix_2[reversed_segment[-1], reversed_segment[-2]]) - \\\n             (distance_matrix_2[segment[-1], segment[0]] + distance_matrix_2[segment[-2], segment[-1]] +\n              distance_matrix_2[segment[0], segment[1]] + distance_matrix_2[segment[-1], segment[-2]])\n    if delta1 < 0 or delta2 < 0:\n        new_solution[i:j+1] = reversed_segment\n\n    # Step 2: Novel segment relocation\n    k, l = np.random.choice(n, 2, replace=False)\n    if k > l:\n        k, l = l, k\n    segment = new_solution[k:l+1]\n    new_solution = np.delete(new_solution, np.arange(k, l+1))\n    candidates = []\n    for pos in range(len(new_solution)):\n        if pos == 0:\n            prev = new_solution[-1]\n            next_node = new_solution[0]\n        elif pos == len(new_solution):\n            prev = new_solution[-1]\n            next_node = new_solution[0]\n        else:\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n        delta1 = (distance_matrix_1[prev, segment[0]] + distance_matrix_1[segment[-1], next_node]) - \\\n                 (distance_matrix_1[prev, next_node])\n        delta2 = (distance_matrix_2[prev, segment[0]] + distance_matrix_2[segment[-1], next_node]) - \\\n                 (distance_matrix_2[prev, next_node])\n        candidates.append((delta1 + delta2, pos))\n    if candidates:\n        best_pos = min(candidates, key=lambda x: x[0])[1]\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized node relocation with a multi-objective edge swapping strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Randomized node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i - 1) % n or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Multi-objective edge swapping\n    for k in range(n):\n        l = (k + 1) % (n - 1)\n        m = (k + 2) % (n - 1)\n\n        current_edge1 = distance_matrix_1[new_solution[k], new_solution[l]]\n        current_edge2 = distance_matrix_2[new_solution[k], new_solution[l]]\n        new_edge1 = distance_matrix_1[new_solution[k], new_solution[m]]\n        new_edge2 = distance_matrix_2[new_solution[k], new_solution[m]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9808021754597421,
            1.2174485325813293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized node relocation with a multi-objective edge swapping strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Randomized node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i - 1) % n or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Multi-objective edge swapping\n    for k in range(n):\n        l = (k + 1) % (n - 1)\n        m = (k + 2) % (n - 1)\n\n        current_edge1 = distance_matrix_1[new_solution[k], new_solution[l]]\n        current_edge2 = distance_matrix_2[new_solution[k], new_solution[l]]\n        new_edge1 = distance_matrix_1[new_solution[k], new_solution[m]]\n        new_edge2 = distance_matrix_2[new_solution[k], new_solution[m]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[l], new_solution[m] = new_solution[m], new_solution[l]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9808021754597421,
            1.2174485325813293
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with dynamic length\n    segment_length = min(5, max(2, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with multiple candidates\n    candidates = []\n    for i in range(n):\n        for j in range(i+2, n):\n            if j != (i+1) % n:\n                candidates.append((i, j))\n\n    if candidates:\n        i, j = candidates[np.random.choice(len(candidates))]\n        node_to_insert = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8455080877980214,
            0.3277089595794678
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with dynamic length\n    segment_length = min(5, max(2, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with multiple candidates\n    candidates = []\n    for i in range(n):\n        for j in range(i+2, n):\n            if j != (i+1) % n:\n                candidates.append((i, j))\n\n    if candidates:\n        i, j = candidates[np.random.choice(len(candidates))]\n        node_to_insert = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A novel adaptive local search operator that combines a probabilistic segment reshuffling with a guided multi-objective edge reversal strategy, using adaptive temperature-based acceptance criteria to balance exploration and exploitation in the bi-objective space while maintaining tour feasibility}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1]) + 1e-8))\n    if len(archive_sorted) > 3:\n        selected = archive_sorted[np.random.randint(1, min(3, len(archive_sorted)))][0]\n    else:\n        selected = archive_sorted[0][0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshuffling\n    seg_size = max(3, min(7, n // 4))\n    start = np.random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    np.random.shuffle(segment)\n    new_solution[start:start+seg_size] = segment\n\n    # Guided multi-objective edge reversal\n    temperature = 1.0 - (0.9 * np.random.rand())\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        delta1 = distance_matrix_1[new_solution[i], new_solution[k]] - distance_matrix_1[new_solution[i], new_solution[j]]\n        delta2 = distance_matrix_2[new_solution[i], new_solution[k]] - distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (delta1 < 0 and delta2 < 0) or \\\n           (np.random.rand() < temperature * np.exp(-(delta1 + delta2) / (1e-8 + sum(archive_sorted[0][1])))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic node reinsertion\n    if np.random.rand() < 0.3:\n        pos = np.random.randint(0, n)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.869248633023664,
            0.35893213748931885
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / (sum(x[1]) + 1e-8))\n    if len(archive_sorted) > 3:\n        selected = archive_sorted[np.random.randint(1, min(3, len(archive_sorted)))][0]\n    else:\n        selected = archive_sorted[0][0]\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reshuffling\n    seg_size = max(3, min(7, n // 4))\n    start = np.random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    np.random.shuffle(segment)\n    new_solution[start:start+seg_size] = segment\n\n    # Guided multi-objective edge reversal\n    temperature = 1.0 - (0.9 * np.random.rand())\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        delta1 = distance_matrix_1[new_solution[i], new_solution[k]] - distance_matrix_1[new_solution[i], new_solution[j]]\n        delta2 = distance_matrix_2[new_solution[i], new_solution[k]] - distance_matrix_2[new_solution[i], new_solution[j]]\n\n        if (delta1 < 0 and delta2 < 0) or \\\n           (np.random.rand() < temperature * np.exp(-(delta1 + delta2) / (1e-8 + sum(archive_sorted[0][1])))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic node reinsertion\n    if np.random.rand() < 0.3:\n        pos = np.random.randint(0, n)\n        node = new_solution[pos]\n        new_solution = np.delete(new_solution, pos)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{A novel hybrid local search operator that intelligently selects solutions based on their dominance in both objectives, combines a dynamic segment inversion with a probabilistic edge exchange strategy, and incorporates a novel node insertion mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores) if np.random.rand() < 0.7 else np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion based on objective dominance\n    seg_size = min(4, max(2, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Check if inversion improves both objectives\n    current_cost1 = distance_matrix_1[base_solution[a], base_solution[a+1]] + distance_matrix_1[base_solution[b], base_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[a], base_solution[a+1]] + distance_matrix_2[base_solution[b], base_solution[(b+1)%n]]\n    new_cost1 = distance_matrix_1[base_solution[b], base_solution[a]] + distance_matrix_1[base_solution[a+1], base_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[b], base_solution[a]] + distance_matrix_2[base_solution[a+1], base_solution[(b+1)%n]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Probabilistic edge exchange with objective-aware selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Objective-aware acceptance criteria\n        prob = 0.5 if (new_edge1 < current_edge1 and new_edge2 < current_edge2) else 0.2\n        if np.random.rand() < prob:\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Novel node insertion mechanism\n    if np.random.rand() < 0.3:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        while q == p or q == (p + 1) % n:\n            q = np.random.randint(0, n)\n        node = new_solution[q]\n        new_solution = np.delete(new_solution, q)\n        new_solution = np.insert(new_solution, p, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7438150018649586,
            0.2892037034034729
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmin(scores) if np.random.rand() < 0.7 else np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion based on objective dominance\n    seg_size = min(4, max(2, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Check if inversion improves both objectives\n    current_cost1 = distance_matrix_1[base_solution[a], base_solution[a+1]] + distance_matrix_1[base_solution[b], base_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[a], base_solution[a+1]] + distance_matrix_2[base_solution[b], base_solution[(b+1)%n]]\n    new_cost1 = distance_matrix_1[base_solution[b], base_solution[a]] + distance_matrix_1[base_solution[a+1], base_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[b], base_solution[a]] + distance_matrix_2[base_solution[a+1], base_solution[(b+1)%n]]\n\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.3:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Probabilistic edge exchange with objective-aware selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Objective-aware acceptance criteria\n        prob = 0.5 if (new_edge1 < current_edge1 and new_edge2 < current_edge2) else 0.2\n        if np.random.rand() < prob:\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Novel node insertion mechanism\n    if np.random.rand() < 0.3:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        while q == p or q == (p + 1) % n:\n            q = np.random.randint(0, n)\n        node = new_solution[q]\n        new_solution = np.delete(new_solution, q)\n        new_solution = np.insert(new_solution, p, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment relocation with a dominance-based edge exchange strategy to generate high-quality neighbors by intelligently balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.delete(new_solution, np.arange(a, b+1))\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dominance-based edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9390985627940619,
            0.3117101192474365
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.delete(new_solution, np.arange(a, b+1))\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dominance-based edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9693267478510855,
            0.278140664100647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm intelligently selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining edge exchange and segment relocation, but with a novel adaptive probability mechanism that dynamically adjusts based on the current solution's quality and the local search's success rate to generate high-quality neighbor solutions while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.std(normalized_obj, axis=0).mean()\n    selection_prob = 0.5 * (1 - normalized_obj.mean(axis=1)) + 0.5 * (1 - diversity)\n    selection_prob = selection_prob / selection_prob.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_prob)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    success_rate = 0.5  # Initial success rate\n\n    # Adaptive hybrid local search\n    for _ in range(3):  # Perform multiple iterations\n        # Edge exchange with adaptive probability\n        if np.random.rand() < 0.7 * success_rate:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Segment relocation with adaptive probability\n        if np.random.rand() < 0.3 * success_rate:\n            k, l = np.random.choice(n, 2, replace=False)\n            if k > l:\n                k, l = l, k\n            segment = new_solution[k:l+1]\n            new_solution = np.concatenate([new_solution[:k], new_solution[l+1:], segment])\n\n        # Update success rate based on improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        prev_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        prev_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        if (current_cost1 < prev_cost1 and current_cost2 < prev_cost2) or \\\n           (np.random.rand() < 0.2 and (current_cost1 <= prev_cost1 or current_cost2 <= prev_cost2)):\n            success_rate = min(1.0, success_rate * 1.1)\n        else:\n            success_rate = max(0.1, success_rate * 0.9)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This algorithm combines a novel adaptive path decomposition with a guided crossover-inspired operator, where it selectively breaks and recombines solution segments based on their relative quality in both objectives, while dynamically adjusting the decomposition granularity based on the current solution's Pareto dominance characteristics.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.all(objectives <= objectives, axis=1)\n    if np.sum(pareto_front) > 0:\n        selected_idx = np.random.choice(np.where(pareto_front)[0])\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition\n    decomposition_size = max(3, min(7, n // 4 + np.random.randint(1, 3)))\n    segments = []\n    for i in range(0, n, decomposition_size):\n        segments.append(new_solution[i:i+decomposition_size])\n\n    # Guided segment crossover\n    if len(segments) > 1:\n        # Select two segments based on their relative quality\n        segment_qualities = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n            segment_qualities.append((seg_cost1, seg_cost2))\n\n        # Find segments with balanced quality\n        balanced_segments = []\n        for i, (q1, q2) in enumerate(segment_qualities):\n            if abs(q1 - q2) < 0.3 * (np.mean(objectives[:,0]) + np.mean(objectives[:,1])):\n                balanced_segments.append(i)\n\n        if len(balanced_segments) >= 2:\n            a, b = np.random.choice(balanced_segments, 2, replace=False)\n            # Swap segments with 30% probability\n            if np.random.rand() < 0.3:\n                segments[a], segments[b] = segments[b], segments[a]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Additional local improvement\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse segment with 40% probability if it improves both objectives\n        if np.random.rand() < 0.4:\n            segment = new_solution[i:j+1]\n            reversed_segment = np.flip(segment)\n            new_solution[i:j+1] = reversed_segment\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8619960612220947,
            0.397566556930542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objectives\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.all(objectives <= objectives, axis=1)\n    if np.sum(pareto_front) > 0:\n        selected_idx = np.random.choice(np.where(pareto_front)[0])\n    else:\n        selected_idx = np.argmin(np.sum(objectives, axis=1))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path decomposition\n    decomposition_size = max(3, min(7, n // 4 + np.random.randint(1, 3)))\n    segments = []\n    for i in range(0, n, decomposition_size):\n        segments.append(new_solution[i:i+decomposition_size])\n\n    # Guided segment crossover\n    if len(segments) > 1:\n        # Select two segments based on their relative quality\n        segment_qualities = []\n        for seg in segments:\n            seg_cost1 = sum(distance_matrix_1[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n            seg_cost2 = sum(distance_matrix_2[seg[i], seg[(i+1)%len(seg)]] for i in range(len(seg)))\n            segment_qualities.append((seg_cost1, seg_cost2))\n\n        # Find segments with balanced quality\n        balanced_segments = []\n        for i, (q1, q2) in enumerate(segment_qualities):\n            if abs(q1 - q2) < 0.3 * (np.mean(objectives[:,0]) + np.mean(objectives[:,1])):\n                balanced_segments.append(i)\n\n        if len(balanced_segments) >= 2:\n            a, b = np.random.choice(balanced_segments, 2, replace=False)\n            # Swap segments with 30% probability\n            if np.random.rand() < 0.3:\n                segments[a], segments[b] = segments[b], segments[a]\n\n    # Reconstruct solution\n    new_solution = np.concatenate(segments)\n\n    # Additional local improvement\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        # Reverse segment with 40% probability if it improves both objectives\n        if np.random.rand() < 0.4:\n            segment = new_solution[i:j+1]\n            reversed_segment = np.flip(segment)\n            new_solution[i:j+1] = reversed_segment\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{This algorithm combines a novel adaptive segment rotation with a multi-objective edge insertion strategy to generate high-quality neighbors, balancing exploration and exploitation through dynamic segment sizes and guided edge insertion based on Pareto dominance criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, seg_size))\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find best insertion point for node k\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == i or pos == j or pos == k:\n                continue\n\n            # Calculate potential new edges\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            new_edge1 = distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            old_edge1 = distance_matrix_1[prev_node, next_node]\n\n            new_edge2 = distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            old_edge2 = distance_matrix_2[prev_node, next_node]\n\n            # Pareto dominance check\n            if (new_edge1 < old_edge1 and new_edge2 <= old_edge2) or (new_edge1 <= old_edge1 and new_edge2 < old_edge2):\n                improvement = (old_edge1 - new_edge1) + (old_edge2 - new_edge2)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Insert node k after best_pos\n            node_to_insert = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Random segment reversal for diversity\n    if np.random.rand() < 0.15:\n        seg_size = min(3, n // 5)\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8153733136725387,
            1.0290135145187378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj[0] + obj[1] for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotated_segment = np.roll(new_solution[a:b+1], np.random.randint(1, seg_size))\n    new_solution[a:b+1] = rotated_segment\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find best insertion point for node k\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == i or pos == j or pos == k:\n                continue\n\n            # Calculate potential new edges\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n\n            new_edge1 = distance_matrix_1[prev_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node]\n            old_edge1 = distance_matrix_1[prev_node, next_node]\n\n            new_edge2 = distance_matrix_2[prev_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node]\n            old_edge2 = distance_matrix_2[prev_node, next_node]\n\n            # Pareto dominance check\n            if (new_edge1 < old_edge1 and new_edge2 <= old_edge2) or (new_edge1 <= old_edge1 and new_edge2 < old_edge2):\n                improvement = (old_edge1 - new_edge1) + (old_edge2 - new_edge2)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Insert node k after best_pos\n            node_to_insert = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_pos, node_to_insert)\n\n    # Random segment reversal for diversity\n    if np.random.rand() < 0.15:\n        seg_size = min(3, n // 5)\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on both objective quality and diversity, then applies a hybrid local search combining a novel segment rotation with an adaptive edge insertion strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation and adaptive edge insertion\n    if n >= 4:\n        # Segment rotation: rotate a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:a+3] = rotated_segment\n\n        # Adaptive edge insertion: insert a node between two nodes if it improves both objectives\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the insertion\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution = np.insert(new_solution, j, k)\n                new_solution = np.delete(new_solution, [i, j+1] if i < j else [j, i+1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{This new algorithm selects a solution from the archive based on both objective quality and diversity, then applies a hybrid local search combining a novel segment reversal with an adaptive node relocation strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal and adaptive node relocation\n    if n >= 3:\n        # Segment reversal: reverse a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        reversed_segment = segment[::-1]\n        new_solution[a:a+3] = reversed_segment\n\n        # Adaptive node relocation: move a node to a better position if it improves both objectives\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for j in range(n):\n            if j == i or (j == i-1) % n or (j == i+1) % n:\n                continue\n\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            current_edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            new_edge1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]]\n            new_edge2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]]\n            insert_edge1 = distance_matrix_1[new_solution[(j-1)%n], node] + distance_matrix_1[node, new_solution[j]]\n            insert_edge2 = distance_matrix_2[new_solution[(j-1)%n], node] + distance_matrix_2[node, new_solution[j]]\n            improvement1 = (new_edge1 + insert_edge1) - current_edge1\n            improvement2 = (new_edge2 + insert_edge2) - current_edge2\n\n            if improvement1 < best_improvement[0] and improvement2 < best_improvement[1]:\n                best_improvement = (improvement1, improvement2)\n                best_pos = j\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8573419454138402,
            0.3544209599494934
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal and adaptive node relocation\n    if n >= 3:\n        # Segment reversal: reverse a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        reversed_segment = segment[::-1]\n        new_solution[a:a+3] = reversed_segment\n\n        # Adaptive node relocation: move a node to a better position if it improves both objectives\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for j in range(n):\n            if j == i or (j == i-1) % n or (j == i+1) % n:\n                continue\n\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            current_edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            new_edge1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]]\n            new_edge2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]]\n            insert_edge1 = distance_matrix_1[new_solution[(j-1)%n], node] + distance_matrix_1[node, new_solution[j]]\n            insert_edge2 = distance_matrix_2[new_solution[(j-1)%n], node] + distance_matrix_2[node, new_solution[j]]\n            improvement1 = (new_edge1 + insert_edge1) - current_edge1\n            improvement2 = (new_edge2 + insert_edge2) - current_edge2\n\n            if improvement1 < best_improvement[0] and improvement2 < best_improvement[1]:\n                best_improvement = (improvement1, improvement2)\n                best_pos = j\n\n        if best_pos != -1:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel hybrid local search operator that combines a multi-segment inversion strategy with a Pareto-guided edge exchange mechanism to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion with adaptive segment sizes\n    num_segments = min(3, n // 4)\n    for _ in range(num_segments):\n        seg_size = np.random.randint(2, min(7, n // 2))\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Pareto-guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_edge1 < current_edge1 and new_edge2 <= current_edge2) or \\\n           (new_edge1 <= current_edge1 and new_edge2 < current_edge2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random block swap for diversity\n    if np.random.rand() < 0.3:\n        block_size = np.random.randint(2, min(5, n // 3))\n        p = np.random.randint(0, n - block_size)\n        q = np.random.randint(0, n - block_size)\n        new_solution[p:p+block_size], new_solution[q:q+block_size] = new_solution[q:q+block_size], new_solution[p:p+block_size]\n\n    return new_solution\n\n",
        "score": [
            -0.7624665217231326,
            0.20570111274719238
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n    top_solutions = sorted_archive[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion with adaptive segment sizes\n    num_segments = min(3, n // 4)\n    for _ in range(num_segments):\n        seg_size = np.random.randint(2, min(7, n // 2))\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Pareto-guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_edge1 < current_edge1 and new_edge2 <= current_edge2) or \\\n           (new_edge1 <= current_edge1 and new_edge2 < current_edge2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random block swap for diversity\n    if np.random.rand() < 0.3:\n        block_size = np.random.randint(2, min(5, n // 3))\n        p = np.random.randint(0, n - block_size)\n        q = np.random.randint(0, n - block_size)\n        new_solution[p:p+block_size], new_solution[q:q+block_size] = new_solution[q:q+block_size], new_solution[p:p+block_size]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node insertion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node insertion (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Segment reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n-1, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive node swapping and segment rotation to generate a neighbor solution while ensuring feasibility, using a novel selection criterion that balances objective improvement and solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a novel selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n    diversity_score = np.mean(diversity_scores) if diversity_scores.size > 0 else 1.0\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_score\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining adaptive node swapping and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node swapping based on distance in both objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n    dist1_before = distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_i, new_solution[(i+1)%n]] + distance_matrix_1[node_j, new_solution[(j-1)%n]] + distance_matrix_1[node_j, new_solution[(j+1)%n]]\n    dist1_after = distance_matrix_1[node_j, new_solution[(i-1)%n]] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + distance_matrix_1[node_i, new_solution[(j-1)%n]] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n    dist2_before = distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_i, new_solution[(i+1)%n]] + distance_matrix_2[node_j, new_solution[(j-1)%n]] + distance_matrix_2[node_j, new_solution[(j+1)%n]]\n    dist2_after = distance_matrix_2[node_j, new_solution[(i-1)%n]] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + distance_matrix_2[node_i, new_solution[(j-1)%n]] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n    if (dist1_after + dist2_after) < (dist1_before + dist2_before):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment rotation with adaptive length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if segment rotation breaks the tour\n        new_solution = base_solution.copy()\n        rotation = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.9022675187316578,
            1.846754014492035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a novel selection criterion\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n    diversity_score = np.mean(diversity_scores) if diversity_scores.size > 0 else 1.0\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity_score\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator combining adaptive node swapping and segment rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node swapping based on distance in both objectives\n    i, j = np.random.choice(n, 2, replace=False)\n    node_i = new_solution[i]\n    node_j = new_solution[j]\n    dist1_before = distance_matrix_1[node_i, new_solution[(i-1)%n]] + distance_matrix_1[node_i, new_solution[(i+1)%n]] + distance_matrix_1[node_j, new_solution[(j-1)%n]] + distance_matrix_1[node_j, new_solution[(j+1)%n]]\n    dist1_after = distance_matrix_1[node_j, new_solution[(i-1)%n]] + distance_matrix_1[node_j, new_solution[(i+1)%n]] + distance_matrix_1[node_i, new_solution[(j-1)%n]] + distance_matrix_1[node_i, new_solution[(j+1)%n]]\n    dist2_before = distance_matrix_2[node_i, new_solution[(i-1)%n]] + distance_matrix_2[node_i, new_solution[(i+1)%n]] + distance_matrix_2[node_j, new_solution[(j-1)%n]] + distance_matrix_2[node_j, new_solution[(j+1)%n]]\n    dist2_after = distance_matrix_2[node_j, new_solution[(i-1)%n]] + distance_matrix_2[node_j, new_solution[(i+1)%n]] + distance_matrix_2[node_i, new_solution[(j-1)%n]] + distance_matrix_2[node_i, new_solution[(j+1)%n]]\n\n    if (dist1_after + dist2_after) < (dist1_before + dist2_before):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 2: Segment rotation with adaptive length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if segment rotation breaks the tour\n        new_solution = base_solution.copy()\n        rotation = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{The algorithm selects a non-dominated solution from the archive using crowding distance to prioritize diverse solutions, then applies a hybrid local search combining adaptive node swapping and objective-aware edge reversal to generate a neighbor solution while maintaining feasibility and potentially improving both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high crowding distance\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Calculate crowding distance for non-dominated solutions\n        crowding = np.zeros(len(non_dominated))\n        for m in range(2):\n            sorted_idx = np.argsort([archive[i][1][m] for i in non_dominated])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            if len(sorted_idx) > 2:\n                min_val = archive[non_dominated[sorted_idx[0]]][1][m]\n                max_val = archive[non_dominated[sorted_idx[-1]]][1][m]\n                for i in range(1, len(sorted_idx) - 1):\n                    crowding[sorted_idx[i]] += (archive[non_dominated[sorted_idx[i+1]]][1][m] - archive[non_dominated[sorted_idx[i-1]]][1][m]) / (max_val - min_val)\n\n        selected_idx = non_dominated[np.argmax(crowding)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Adaptive node swapping based on objective improvement\n    i, j = np.random.randint(0, n, size=2)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement\n    original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    # If no improvement, revert and try edge reversal\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2) or np.random.random() < 0.3:\n        new_solution = base_solution.copy()\n\n        # Step 2: Objective-aware edge reversal\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n\n        # Choose which objective to prioritize\n        if np.random.random() < 0.5:\n            # Prioritize first objective\n            if distance_matrix_1[new_solution[k], new_solution[l]] > distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[l]]:\n                new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n        else:\n            # Prioritize second objective\n            if distance_matrix_2[new_solution[k], new_solution[l]] > distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[l]]:\n                new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7874897366663484,
            9.345501780509949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a non-dominated solution with high crowding distance\n    non_dominated = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (_, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Calculate crowding distance for non-dominated solutions\n        crowding = np.zeros(len(non_dominated))\n        for m in range(2):\n            sorted_idx = np.argsort([archive[i][1][m] for i in non_dominated])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            if len(sorted_idx) > 2:\n                min_val = archive[non_dominated[sorted_idx[0]]][1][m]\n                max_val = archive[non_dominated[sorted_idx[-1]]][1][m]\n                for i in range(1, len(sorted_idx) - 1):\n                    crowding[sorted_idx[i]] += (archive[non_dominated[sorted_idx[i+1]]][1][m] - archive[non_dominated[sorted_idx[i-1]]][1][m]) / (max_val - min_val)\n\n        selected_idx = non_dominated[np.argmax(crowding)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Adaptive node swapping based on objective improvement\n    i, j = np.random.randint(0, n, size=2)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement\n    original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    # If no improvement, revert and try edge reversal\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2) or np.random.random() < 0.3:\n        new_solution = base_solution.copy()\n\n        # Step 2: Objective-aware edge reversal\n        k = np.random.randint(0, n)\n        l = np.random.randint(0, n)\n        while l == k or l == (k + 1) % n:\n            l = np.random.randint(0, n)\n\n        # Choose which objective to prioritize\n        if np.random.random() < 0.5:\n            # Prioritize first objective\n            if distance_matrix_1[new_solution[k], new_solution[l]] > distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_1[new_solution[(k+1)%n], new_solution[l]]:\n                new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n        else:\n            # Prioritize second objective\n            if distance_matrix_2[new_solution[k], new_solution[l]] > distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] + distance_matrix_2[new_solution[(k+1)%n], new_solution[l]]:\n                new_solution[k+1:l+1] = new_solution[k+1:l+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a probabilistic segment relocation with a dominance-based edge exchange strategy to generate high-quality neighbors by intelligently balancing exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.delete(new_solution, np.arange(a, b+1))\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dominance-based edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{This algorithm combines a dominance-aware path inversion with a probabilistic segment crossover to generate neighbors by either reversing promising segments or exchanging segments between paths, while ensuring feasibility through careful node selection and insertion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dominance-aware path inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Probabilistic segment crossover\n    if np.random.rand() < 0.3:\n        other_idx = np.random.choice(len(archive))\n        other_solution = archive[other_idx][0]\n        a_other, b_other = sorted(np.random.choice(n, 2, replace=False))\n        other_segment = other_solution[a_other:b_other+1]\n\n        # Find insertion point that maintains feasibility\n        insert_pos = np.random.randint(0, n - len(other_segment) + 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            other_segment,\n            new_solution[insert_pos + len(other_segment):]\n        ])\n\n        # Remove duplicates while preserving order\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n",
        "score": [
            -0.8609902219739527,
            0.28311002254486084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = np.sum(normalized, axis=1)\n    weights = scores / np.sum(scores)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dominance-aware path inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Probabilistic segment crossover\n    if np.random.rand() < 0.3:\n        other_idx = np.random.choice(len(archive))\n        other_solution = archive[other_idx][0]\n        a_other, b_other = sorted(np.random.choice(n, 2, replace=False))\n        other_segment = other_solution[a_other:b_other+1]\n\n        # Find insertion point that maintains feasibility\n        insert_pos = np.random.randint(0, n - len(other_segment) + 1)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            other_segment,\n            new_solution[insert_pos + len(other_segment):]\n        ])\n\n        # Remove duplicates while preserving order\n        _, unique_indices = np.unique(new_solution, return_index=True)\n        new_solution = new_solution[np.sort(unique_indices)]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node exchange\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 3:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8015694706460815,
            0.40969157218933105
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node exchange\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 3:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation strategy with a multi-objective edge insertion heuristic to generate diverse and high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        # Insert the segment at position i\n        temp_solution = np.insert(temp_solution, i, segment)\n\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            k = (j + 1) % n\n            total_cost += distance_matrix_1[temp_solution[j], temp_solution[k]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best relocation\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between current and next\n        best_insert = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference\n            cost_diff1 = distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] - distance_matrix_1[current_node, next_node]\n            cost_diff2 = distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] - distance_matrix_2[current_node, next_node]\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -10):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_insert = k\n\n        if best_insert != -1:\n            # Insert the node between current and next\n            new_solution = np.insert(new_solution, j, new_solution[best_insert])\n            # Remove the original occurrence of the inserted node\n            new_solution = np.delete(new_solution, np.where(new_solution == new_solution[best_insert])[0][1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation strategy with a multi-objective edge insertion heuristic to generate diverse and high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n\n    # Find best insertion point for the segment\n    best_pos = a\n    best_cost = float('inf')\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        # Temporarily remove the segment\n        temp_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        # Insert the segment at position i\n        temp_solution = np.insert(temp_solution, i, segment)\n\n        # Calculate total cost\n        total_cost = 0\n        for j in range(n):\n            k = (j + 1) % n\n            total_cost += distance_matrix_1[temp_solution[j], temp_solution[k]] + distance_matrix_2[temp_solution[j], temp_solution[k]]\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = i\n\n    # Apply the best relocation\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Multi-objective edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best node to insert between current and next\n        best_insert = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference\n            cost_diff1 = distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] - distance_matrix_1[current_node, next_node]\n            cost_diff2 = distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] - distance_matrix_2[current_node, next_node]\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -10):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_insert = k\n\n        if best_insert != -1:\n            # Insert the node between current and next\n            new_solution = np.insert(new_solution, j, new_solution[best_insert])\n            # Remove the original occurrence of the inserted node\n            new_solution = np.delete(new_solution, np.where(new_solution == new_solution[best_insert])[0][1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment inversion with a multi-objective edge swapping heuristic to generate diverse and high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Multi-objective edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best swap candidate\n        best_swap = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference for swap\n            cost_diff1 = (distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] -\n                         distance_matrix_1[current_node, next_node] - distance_matrix_1[next_node, new_solution[k]])\n\n            cost_diff2 = (distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] -\n                         distance_matrix_2[current_node, next_node] - distance_matrix_2[next_node, new_solution[k]])\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -5):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_swap = k\n\n        if best_swap != -1:\n            # Perform the swap\n            new_solution[j], new_solution[best_swap] = new_solution[best_swap], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.7519863550019599,
            2.103524625301361
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_scores = [sum(obj) for _, obj in archive]\n    selected_idx = np.argmax(archive_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Multi-objective edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        next_node = new_solution[j]\n\n        # Find the best swap candidate\n        best_swap = -1\n        best_improvement = 0\n\n        for k in range(n):\n            if k == i or k == j or k in new_solution[:j]:\n                continue\n\n            # Calculate cost difference for swap\n            cost_diff1 = (distance_matrix_1[current_node, new_solution[k]] + distance_matrix_1[new_solution[k], next_node] -\n                         distance_matrix_1[current_node, next_node] - distance_matrix_1[next_node, new_solution[k]])\n\n            cost_diff2 = (distance_matrix_2[current_node, new_solution[k]] + distance_matrix_2[new_solution[k], next_node] -\n                         distance_matrix_2[current_node, next_node] - distance_matrix_2[next_node, new_solution[k]])\n\n            # If both objectives improve or at least one improves significantly\n            if (cost_diff1 < 0 and cost_diff2 < 0) or (cost_diff1 + cost_diff2 < -5):\n                if cost_diff1 + cost_diff2 < best_improvement:\n                    best_improvement = cost_diff1 + cost_diff2\n                    best_swap = k\n\n        if best_swap != -1:\n            # Perform the swap\n            new_solution[j], new_solution[best_swap] = new_solution[best_swap], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted score function that emphasizes diversity and objective balance, then applies a hybrid local search combining adaptive segment reversal and targeted edge relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = 1 - np.mean(np.abs(normalized_obj - normalized_obj.mean(axis=0)), axis=1)\n    scores = 0.5 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(5, max(2, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Targeted edge relocation with distance-based selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_relocate = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_relocate], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        swap1, swap2 = np.random.choice(n, 2, replace=False)\n        new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n    return new_solution\n\n",
        "score": [
            -0.7049192024512047,
            0.18256372213363647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = 1 - np.mean(np.abs(normalized_obj - normalized_obj.mean(axis=0)), axis=1)\n    scores = 0.5 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(5, max(2, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Targeted edge relocation with distance-based selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_relocate = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_relocate], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if relocation breaks the tour\n        new_solution = base_solution.copy()\n        swap1, swap2 = np.random.choice(n, 2, replace=False)\n        new_solution[swap1], new_solution[swap2] = new_solution[swap2], new_solution[swap1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a probabilistic segment relocation with a dominance-based edge exchange strategy to generate high-quality neighbors by intelligently balancing exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.delete(new_solution, np.arange(a, b+1))\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dominance-based edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search that combines a probabilistic node swap with a guided segment crossover to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(archive[i][0]) for i in range(len(archive))])\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Probabilistic node swap with guided selection\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.3:  # Higher probability for guided swap\n            # Select nodes that are far apart in both spaces\n            i = np.argmax(np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1))\n            j = np.argmin(np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided segment crossover\n    if n > 4:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        remaining = np.delete(new_solution, np.arange(a, b+1))\n        # Find the best insertion point based on both objectives\n        best_insert_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if crossover breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8473332670800663,
            0.9687628746032715
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on a combination of objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(archive[i][0]) for i in range(len(archive))])\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Probabilistic node swap with guided selection\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if np.random.rand() < 0.3:  # Higher probability for guided swap\n            # Select nodes that are far apart in both spaces\n            i = np.argmax(np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1))\n            j = np.argmin(np.sum(distance_matrix_1, axis=1) + np.sum(distance_matrix_2, axis=1))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Guided segment crossover\n    if n > 4:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        remaining = np.delete(new_solution, np.arange(a, b+1))\n        # Find the best insertion point based on both objectives\n        best_insert_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(remaining) + 1):\n            candidate = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n            total_cost = 0.5 * cost1 + 0.5 * cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_insert_pos = pos\n        new_solution = np.concatenate([remaining[:best_insert_pos], segment, remaining[best_insert_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if crossover breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{This novel hybrid local search operator intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy, and incorporates a dynamic neighborhood exploration mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion with adaptive size and position\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Dynamic neighborhood exploration with adaptive selection\n    neighborhood_size = min(5, n // 4)\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        current_neighbor = new_solution[j]\n\n        # Find best neighbors in dynamic neighborhood\n        candidates = []\n        for k in range(1, neighborhood_size + 1):\n            left = (i - k) % n\n            right = (i + k) % n\n            candidates.append((left, new_solution[left]))\n            candidates.append((right, new_solution[right]))\n\n        best_pos = -1\n        best_improvement = 0\n        for pos, candidate in candidates:\n            # Calculate improvement in both objectives\n            current_dist1 = distance_matrix_1[current_node, current_neighbor]\n            current_dist2 = distance_matrix_2[current_node, current_neighbor]\n            new_dist1 = distance_matrix_1[current_node, candidate]\n            new_dist2 = distance_matrix_2[current_node, candidate]\n            improvement1 = current_dist1 - new_dist1\n            improvement2 = current_dist2 - new_dist2\n\n            # Weighted improvement score\n            weight = 0.5 + 0.5 * (1 - (i / n))\n            score = weight * improvement1 + (1 - weight) * improvement2\n\n            if score > best_improvement:\n                best_improvement = score\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the exchange\n            if best_pos > i:\n                # Right side exchange\n                new_solution[i+1:best_pos+1] = np.roll(new_solution[i+1:best_pos+1], -1)\n            else:\n                # Left side exchange\n                new_solution[best_pos:i] = np.roll(new_solution[best_pos:i], 1)\n\n    # Additional dynamic swap to increase diversity\n    if np.random.rand() < 0.15:\n        swap_range = min(5, n // 3)\n        p = np.random.randint(0, n)\n        q = np.random.randint(max(0, p - swap_range), min(n, p + swap_range + 1))\n        if p != q:\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.7909147432116227,
            0.7143728137016296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion with adaptive size and position\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Dynamic neighborhood exploration with adaptive selection\n    neighborhood_size = min(5, n // 4)\n    for i in range(n):\n        j = (i + 1) % n\n        current_node = new_solution[i]\n        current_neighbor = new_solution[j]\n\n        # Find best neighbors in dynamic neighborhood\n        candidates = []\n        for k in range(1, neighborhood_size + 1):\n            left = (i - k) % n\n            right = (i + k) % n\n            candidates.append((left, new_solution[left]))\n            candidates.append((right, new_solution[right]))\n\n        best_pos = -1\n        best_improvement = 0\n        for pos, candidate in candidates:\n            # Calculate improvement in both objectives\n            current_dist1 = distance_matrix_1[current_node, current_neighbor]\n            current_dist2 = distance_matrix_2[current_node, current_neighbor]\n            new_dist1 = distance_matrix_1[current_node, candidate]\n            new_dist2 = distance_matrix_2[current_node, candidate]\n            improvement1 = current_dist1 - new_dist1\n            improvement2 = current_dist2 - new_dist2\n\n            # Weighted improvement score\n            weight = 0.5 + 0.5 * (1 - (i / n))\n            score = weight * improvement1 + (1 - weight) * improvement2\n\n            if score > best_improvement:\n                best_improvement = score\n                best_pos = pos\n\n        if best_pos != -1:\n            # Perform the exchange\n            if best_pos > i:\n                # Right side exchange\n                new_solution[i+1:best_pos+1] = np.roll(new_solution[i+1:best_pos+1], -1)\n            else:\n                # Left side exchange\n                new_solution[best_pos:i] = np.roll(new_solution[best_pos:i], 1)\n\n    # Additional dynamic swap to increase diversity\n    if np.random.rand() < 0.15:\n        swap_range = min(5, n // 3)\n        p = np.random.randint(0, n)\n        q = np.random.randint(max(0, p - swap_range), min(n, p + swap_range + 1))\n        if p != q:\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion with a guided node relocation strategy that prioritizes edges with the highest potential for cost reduction in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    combined_scores = normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.4 + diversity_scores * 0.2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = min(4, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Guided node relocation strategy\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find potential insertion points with highest cost reduction potential\n        potential_positions = []\n        for j in range(n):\n            if j == i or j == (i + 1) % n or j == (i - 1) % n:\n                continue\n\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], node] + distance_matrix_1[node, new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], node] + distance_matrix_2[node, new_solution[(j+1)%n]]\n\n            potential_positions.append((j, new_cost1 - old_cost1, new_cost2 - old_cost2))\n\n        # Sort by combined cost reduction potential\n        potential_positions.sort(key=lambda x: x[1] + x[2])\n\n        # Try top 3 positions\n        for j, _, _ in potential_positions[:3]:\n            temp_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+1:j+1],\n                [node],\n                new_solution[j+1:]\n            ])\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.8296656360472419,
            0.4763340950012207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    combined_scores = normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.4 + diversity_scores * 0.2\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = min(4, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = new_solution[start:start+segment_length][::-1]\n\n    # Guided node relocation strategy\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Find potential insertion points with highest cost reduction potential\n        potential_positions = []\n        for j in range(n):\n            if j == i or j == (i + 1) % n or j == (i - 1) % n:\n                continue\n\n            # Calculate cost change for both objectives\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], node] + distance_matrix_1[node, new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], node] + distance_matrix_2[node, new_solution[(j+1)%n]]\n\n            potential_positions.append((j, new_cost1 - old_cost1, new_cost2 - old_cost2))\n\n        # Sort by combined cost reduction potential\n        potential_positions.sort(key=lambda x: x[1] + x[2])\n\n        # Try top 3 positions\n        for j, _, _ in potential_positions[:3]:\n            temp_solution = np.concatenate([\n                new_solution[:i],\n                new_solution[i+1:j+1],\n                [node],\n                new_solution[j+1:]\n            ])\n            if len(np.unique(temp_solution)) == n:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection strategy, then applies a novel hybrid local search combining adaptive node relocation with guided path optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_edges = set()\n        for i in range(len(sol)):\n            edge = tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n            unique_edges.add(edge)\n        diversity_scores.append(len(unique_edges))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with guided path optimization\n    if n > 3:\n        # Select a segment to relocate\n        seg_length = min(4, n // 5)\n        seg_start = np.random.randint(0, n - seg_length)\n        seg_end = seg_start + seg_length\n\n        # Find optimal insertion point\n        best_pos = seg_start\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_end:\n                continue\n\n            # Calculate cost before and after relocation\n            old_cost1 = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                         distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]] +\n                         distance_matrix_1[new_solution[(seg_end)%n], new_solution[(seg_end+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_end]] +\n                         distance_matrix_1[new_solution[(pos-1)%n], new_solution[seg_start]] +\n                         distance_matrix_1[new_solution[seg_end-1], new_solution[(pos+seg_length)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                         distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end]] +\n                         distance_matrix_2[new_solution[(seg_end)%n], new_solution[(seg_end+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_end]] +\n                         distance_matrix_2[new_solution[(pos-1)%n], new_solution[seg_start]] +\n                         distance_matrix_2[new_solution[seg_end-1], new_solution[(pos+seg_length)%n]])\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Perform relocation\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n        # Additional path optimization\n        for _ in range(min(3, n // 4)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = np.random.randint(0, n)\n\n            # Calculate cost before and after swap\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6662431355896906,
            0.472639799118042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity potential\n    diversity_scores = []\n    for sol, _ in archive:\n        unique_edges = set()\n        for i in range(len(sol)):\n            edge = tuple(sorted((sol[i], sol[(i+1)%len(sol)])))\n            unique_edges.add(edge)\n        diversity_scores.append(len(unique_edges))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with guided path optimization\n    if n > 3:\n        # Select a segment to relocate\n        seg_length = min(4, n // 5)\n        seg_start = np.random.randint(0, n - seg_length)\n        seg_end = seg_start + seg_length\n\n        # Find optimal insertion point\n        best_pos = seg_start\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= seg_start and pos < seg_end:\n                continue\n\n            # Calculate cost before and after relocation\n            old_cost1 = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_start]] +\n                         distance_matrix_1[new_solution[seg_end-1], new_solution[seg_end]] +\n                         distance_matrix_1[new_solution[(seg_end)%n], new_solution[(seg_end+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[seg_start-1], new_solution[seg_end]] +\n                         distance_matrix_1[new_solution[(pos-1)%n], new_solution[seg_start]] +\n                         distance_matrix_1[new_solution[seg_end-1], new_solution[(pos+seg_length)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_start]] +\n                         distance_matrix_2[new_solution[seg_end-1], new_solution[seg_end]] +\n                         distance_matrix_2[new_solution[(seg_end)%n], new_solution[(seg_end+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[seg_start-1], new_solution[seg_end]] +\n                         distance_matrix_2[new_solution[(pos-1)%n], new_solution[seg_start]] +\n                         distance_matrix_2[new_solution[seg_end-1], new_solution[(pos+seg_length)%n]])\n\n            improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        # Perform relocation\n        segment = new_solution[seg_start:seg_end]\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:best_pos],\n            segment,\n            new_solution[best_pos:]\n        ])\n\n        # Additional path optimization\n        for _ in range(min(3, n // 4)):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i+1)%n or j == (i-1)%n:\n                j = np.random.randint(0, n)\n\n            # Calculate cost before and after swap\n            old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n            old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A hybrid local search operator that combines adaptive segment reversal with a multi-objective edge selection strategy to intelligently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with dynamic segment size\n    seg_size = min(max(2, n // 4), 5)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Multi-objective edge selection with dominance checking\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Check for Pareto dominance\n        if (new_edge1 < current_edge1 and new_edge2 <= current_edge2) or \\\n           (new_edge1 <= current_edge1 and new_edge2 < current_edge2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional guided mutation based on objective space characteristics\n    if np.random.rand() < 0.2:\n        # Identify nodes with high inter-objective distance\n        inter_obj_dist = np.abs(distance_matrix_1 - distance_matrix_2).mean(axis=1)\n        candidates = np.argsort(inter_obj_dist)[-min(3, n):]\n\n        if len(candidates) >= 2:\n            p, q = np.random.choice(candidates, 2, replace=False)\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.7694767000995681,
            0.3715428113937378
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / (objectives.sum(axis=0) + 1e-10)\n    weights = 1 / (normalized_obj.sum(axis=1) + 1e-10)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with dynamic segment size\n    seg_size = min(max(2, n // 4), 5)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Multi-objective edge selection with dominance checking\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Check for Pareto dominance\n        if (new_edge1 < current_edge1 and new_edge2 <= current_edge2) or \\\n           (new_edge1 <= current_edge1 and new_edge2 < current_edge2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional guided mutation based on objective space characteristics\n    if np.random.rand() < 0.2:\n        # Identify nodes with high inter-objective distance\n        inter_obj_dist = np.abs(distance_matrix_1 - distance_matrix_2).mean(axis=1)\n        candidates = np.argsort(inter_obj_dist)[-min(3, n):]\n\n        if len(candidates) >= 2:\n            p, q = np.random.choice(candidates, 2, replace=False)\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node insertion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node insertion (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Segment reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n-1, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node relocation with a guided edge rotation strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding = np.sum(normalized, axis=1)\n    probabilities = crowding / crowding.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Node relocation with guided edge rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node relocation (move a node to a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Guided edge rotation (rotate a segment of the tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if relocation breaks the tour\n        new_solution = base_solution.copy()\n        rotation = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, rotation)\n\n    return new_solution\n\n",
        "score": [
            -0.8746221936664159,
            0.3874449133872986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding = np.sum(normalized, axis=1)\n    probabilities = crowding / crowding.sum()\n    selected_idx = np.random.choice(len(archive), p=probabilities)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Node relocation with guided edge rotation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node relocation (move a node to a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Guided edge rotation (rotate a segment of the tour)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, len(segment))\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[a:b+1] = rotated_segment\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if relocation breaks the tour\n        new_solution = base_solution.copy()\n        rotation = np.random.randint(1, n)\n        new_solution = np.roll(new_solution, rotation)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a probabilistic segment relocation with a dominance-based edge exchange strategy to generate high-quality neighbors by intelligently balancing exploration and exploitation of the solution space.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.delete(new_solution, np.arange(a, b+1))\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dominance-based edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic node swap with a Pareto-dominance based segment inversion strategy to generate high-quality neighbors by adaptively balancing exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = 1 / (1 + normalized.sum(axis=1))\n    probs = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic node swap\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Pareto-dominance based segment inversion\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted = segment[::-1]\n\n        # Calculate costs\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = inverted\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= old_cost1 or new_cost2 <= old_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9254361756343885,
            0.45040273666381836
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-10)\n    scores = 1 / (1 + normalized.sum(axis=1))\n    probs = scores / scores.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic node swap\n    if np.random.rand() < 0.7:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Pareto-dominance based segment inversion\n    for _ in range(3):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        inverted = segment[::-1]\n\n        # Calculate costs\n        old_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        old_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = inverted\n        new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(n)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= old_cost1 or new_cost2 <= old_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{The new algorithm employs a hybrid approach combining adaptive segment inversion with multi-objective node relinking to generate neighbors by selectively inverting path segments and relinking nodes based on their combined objective improvement potential while ensuring feasibility through segment validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    segment_size = max(2, n // 4)\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_size + 1)\n        end = start + segment_size\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8738100003749749,
            0.9349109530448914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    segment_size = max(2, n // 4)\n    for _ in range(3):\n        start = np.random.randint(0, n - segment_size + 1)\n        end = start + segment_size\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and crowding distance, then applies a novel hybrid local search combining a guided 3-opt move with a probabilistic node relocation strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance and crowding distance for selection\n        non_dominated = []\n        for sol, obj in archive:\n            dominated = False\n            for other_sol, other_obj in archive:\n                if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol, obj))\n\n        if non_dominated:\n            # Select solution with best crowding distance\n            if len(non_dominated) > 1:\n                # Calculate crowding distance\n                objectives = np.array([obj for _, obj in non_dominated])\n                crowding = np.zeros(len(non_dominated))\n                for m in range(2):\n                    sorted_idx = np.argsort(objectives[:, m])\n                    crowding[sorted_idx[0]] = np.inf\n                    crowding[sorted_idx[-1]] = np.inf\n                    for i in range(1, len(non_dominated)-1):\n                        crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n                selected_idx = np.argmax(crowding)\n                base_solution = non_dominated[selected_idx][0].copy()\n            else:\n                base_solution = non_dominated[0][0].copy()\n        else:\n            # If no non-dominated solutions, select randomly\n            selected = random.choice(archive)\n            base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Hybrid 3-opt move with probabilistic node relocation\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible alternatives\n        alt1 = np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]])\n        alt2 = np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n        alt3 = np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c+1][::-1], new_solution[c+1:]])\n\n        # Evaluate alternatives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1, cost2\n\n        current_cost = evaluate(new_solution)\n        alt1_cost = evaluate(alt1)\n        alt2_cost = evaluate(alt2)\n        alt3_cost = evaluate(alt3)\n\n        # Select best alternative\n        alternatives = [(alt1, alt1_cost), (alt2, alt2_cost), (alt3, alt3_cost)]\n        best_alt = min(alternatives, key=lambda x: sum(x[1]))\n\n        if sum(best_alt[1]) < sum(current_cost):\n            new_solution = best_alt[0]\n\n        # Probabilistic node relocation\n        for _ in range(2):\n            if random.random() < 0.3:\n                node_idx = random.randint(0, n-1)\n                node = new_solution[node_idx]\n                new_solution = np.delete(new_solution, node_idx)\n                pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8627911963349171,
            5.462321102619171
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate dominance and crowding distance for selection\n        non_dominated = []\n        for sol, obj in archive:\n            dominated = False\n            for other_sol, other_obj in archive:\n                if (other_obj[0] < obj[0] and other_obj[1] <= obj[1]) or (other_obj[0] <= obj[0] and other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol, obj))\n\n        if non_dominated:\n            # Select solution with best crowding distance\n            if len(non_dominated) > 1:\n                # Calculate crowding distance\n                objectives = np.array([obj for _, obj in non_dominated])\n                crowding = np.zeros(len(non_dominated))\n                for m in range(2):\n                    sorted_idx = np.argsort(objectives[:, m])\n                    crowding[sorted_idx[0]] = np.inf\n                    crowding[sorted_idx[-1]] = np.inf\n                    for i in range(1, len(non_dominated)-1):\n                        crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m])\n                selected_idx = np.argmax(crowding)\n                base_solution = non_dominated[selected_idx][0].copy()\n            else:\n                base_solution = non_dominated[0][0].copy()\n        else:\n            # If no non-dominated solutions, select randomly\n            selected = random.choice(archive)\n            base_solution = selected[0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Hybrid 3-opt move with probabilistic node relocation\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Create three possible alternatives\n        alt1 = np.concatenate([new_solution[:a], new_solution[b:c+1], new_solution[a:b], new_solution[c+1:]])\n        alt2 = np.concatenate([new_solution[:a], new_solution[b:c+1][::-1], new_solution[a:b], new_solution[c+1:]])\n        alt3 = np.concatenate([new_solution[:a], new_solution[a:b], new_solution[b:c+1][::-1], new_solution[c+1:]])\n\n        # Evaluate alternatives\n        def evaluate(sol):\n            cost1 = sum(distance_matrix_1[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[i], sol[i+1]] for i in range(n-1)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1, cost2\n\n        current_cost = evaluate(new_solution)\n        alt1_cost = evaluate(alt1)\n        alt2_cost = evaluate(alt2)\n        alt3_cost = evaluate(alt3)\n\n        # Select best alternative\n        alternatives = [(alt1, alt1_cost), (alt2, alt2_cost), (alt3, alt3_cost)]\n        best_alt = min(alternatives, key=lambda x: sum(x[1]))\n\n        if sum(best_alt[1]) < sum(current_cost):\n            new_solution = best_alt[0]\n\n        # Probabilistic node relocation\n        for _ in range(2):\n            if random.random() < 0.3:\n                node_idx = random.randint(0, n-1)\n                node = new_solution[node_idx]\n                new_solution = np.delete(new_solution, node_idx)\n                pos = random.randint(0, n-2)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This algorithm combines a novel multi-objective segment inversion strategy with dynamic path balancing to generate high-quality neighbors by intelligently inverting segments based on their combined objective improvement potential while ensuring feasibility through dynamic path rebalancing and feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic path balancing and segment inversion\n    for _ in range(3):  # Perform multiple inversion attempts\n        # Select a random segment to invert\n        start = np.random.randint(1, n-1)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create inverted segment\n        inverted_segment = segment[::-1]\n\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = inverted_segment\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Check for improvement in either objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n            # Additional dynamic balancing step\n            if np.random.rand() < 0.5:\n                # Try swapping adjacent segments\n                swap_pos = np.random.randint(0, n-1)\n                new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    return new_solution\n\n",
        "score": [
            -0.8618747783356215,
            0.5079270005226135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic path balancing and segment inversion\n    for _ in range(3):  # Perform multiple inversion attempts\n        # Select a random segment to invert\n        start = np.random.randint(1, n-1)\n        end = np.random.randint(start+1, n)\n        segment = new_solution[start:end]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create inverted segment\n        inverted_segment = segment[::-1]\n\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = inverted_segment\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Check for improvement in either objective\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n            # Additional dynamic balancing step\n            if np.random.rand() < 0.5:\n                # Try swapping adjacent segments\n                swap_pos = np.random.randint(0, n-1)\n                new_solution[swap_pos], new_solution[swap_pos+1] = new_solution[swap_pos+1], new_solution[swap_pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This new algorithm employs a hybrid of multi-objective path inversion and adaptive segment swapping, where it dynamically inverts segments of the tour based on their combined improvement potential while using cluster-based validation to ensure feasibility, creating a balance between exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    cluster_size = max(2, n // 4)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    for _ in range(3):\n        i = np.random.randint(0, len(clusters))\n        cluster = clusters[i]\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        start_idx = np.where(new_solution == cluster[0])[0][0]\n        end_idx = np.where(new_solution == cluster[-1])[0][0]\n        temp_solution[start_idx:end_idx+1] = temp_solution[start_idx:end_idx+1][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.7942226051691883,
            3.2912009954452515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    cluster_size = max(2, n // 4)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    for _ in range(3):\n        i = np.random.randint(0, len(clusters))\n        cluster = clusters[i]\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        start_idx = np.where(new_solution == cluster[0])[0][0]\n        end_idx = np.where(new_solution == cluster[-1])[0][0]\n        temp_solution[start_idx:end_idx+1] = temp_solution[start_idx:end_idx+1][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on both objective quality and diversity, then applies a hybrid local search combining a novel segment rotation with an adaptive edge insertion strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation and adaptive edge insertion\n    if n >= 4:\n        # Segment rotation: rotate a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:a+3] = rotated_segment\n\n        # Adaptive edge insertion: insert a node between two nodes if it improves both objectives\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the insertion\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution = np.insert(new_solution, j, k)\n                new_solution = np.delete(new_solution, [i, j+1] if i < j else [j, i+1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{This novel algorithm selects a solution from the archive based on both objective quality and diversity, then applies a hybrid local search combining a novel segment relocation with an adaptive edge contraction strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment relocation and adaptive edge contraction\n    if n >= 4:\n        # Segment relocation: move a segment of 2 nodes to a different position\n        a = np.random.randint(0, n-1)\n        segment = new_solution[a:a+2]\n        new_solution = np.delete(new_solution, [a, a+1])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Adaptive edge contraction: contract two adjacent nodes if it improves both objectives\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the contraction\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution[i], new_solution[j] = k, k\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9265912657759403,
            0.3352629542350769
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment relocation and adaptive edge contraction\n    if n >= 4:\n        # Segment relocation: move a segment of 2 nodes to a different position\n        a = np.random.randint(0, n-1)\n        segment = new_solution[a:a+2]\n        new_solution = np.delete(new_solution, [a, a+1])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Adaptive edge contraction: contract two adjacent nodes if it improves both objectives\n        i = np.random.randint(0, n-1)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the contraction\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution[i], new_solution[j] = k, k\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{This new algorithm employs an adaptive segment inversion strategy with multi-objective cost evaluation, where segments are dynamically selected based on their combined improvement potential across both objectives, and inversions are validated through a weighted cost improvement heuristic to ensure feasibility and quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Segment inversion with multi-objective evaluation\n    for _ in range(3):  # Perform multiple inversion attempts\n        # Select segment boundaries\n        start = np.random.randint(0, n)\n        end = np.random.randint(0, n)\n        if start > end:\n            start, end = end, start\n        if end - start <= 1:\n            continue\n\n        # Create inverted segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Weighted cost improvement check\n        weight = 0.5  # Balance between objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (weight * new_cost1 + (1 - weight) * new_cost2 < weight * current_cost1 + (1 - weight) * current_cost2):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.7143019593141668,
            1.3488017916679382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Segment inversion with multi-objective evaluation\n    for _ in range(3):  # Perform multiple inversion attempts\n        # Select segment boundaries\n        start = np.random.randint(0, n)\n        end = np.random.randint(0, n)\n        if start > end:\n            start, end = end, start\n        if end - start <= 1:\n            continue\n\n        # Create inverted segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Weighted cost improvement check\n        weight = 0.5  # Balance between objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (weight * new_cost1 + (1 - weight) * new_cost2 < weight * current_cost1 + (1 - weight) * current_cost2):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8646445057843833,
            0.2499745488166809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{The new algorithm combines a multi-objective node reallocation strategy with adaptive segment inversion to generate neighbors by intelligently inverting segments based on their combined objective improvement potential while ensuring feasibility through segment-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    segment_size = max(2, n // 4)\n    for _ in range(3):  # Perform multiple inversion attempts\n        start = np.random.randint(0, n - segment_size + 1)\n        end = start + segment_size\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution with inverted segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = new_solution[start:end][::-1]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if both objectives improve or at least one improves with some probability\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8028991525083565,
            1.1763617992401123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    segment_size = max(2, n // 4)\n    for _ in range(3):  # Perform multiple inversion attempts\n        start = np.random.randint(0, n - segment_size + 1)\n        end = start + segment_size\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution with inverted segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = new_solution[start:end][::-1]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if both objectives improve or at least one improves with some probability\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on both objective quality and diversity, then applies a hybrid local search combining a novel segment rotation with an adaptive edge insertion strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment rotation and adaptive edge insertion\n    if n >= 4:\n        # Segment rotation: rotate a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        rotated_segment = np.roll(segment, 1)\n        new_solution[a:a+3] = rotated_segment\n\n        # Adaptive edge insertion: insert a node between two nodes if it improves both objectives\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n\n        # Skip if k is already in the edge\n        if k not in [new_solution[i], new_solution[j]]:\n            # Calculate current and potential new edges\n            current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], k] + distance_matrix_1[k, new_solution[j]]\n            new_edge2 = distance_matrix_2[new_solution[i], k] + distance_matrix_2[k, new_solution[j]]\n\n            # If new edges are better in both objectives, perform the insertion\n            if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n               (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n                new_solution = np.insert(new_solution, j, k)\n                new_solution = np.delete(new_solution, [i, j+1] if i < j else [j, i+1])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective quality and diversity, then applies a hybrid local search combining a novel segment reversal with an adaptive node repositioning strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj[:, np.newaxis] - normalized_obj, axis=2).sum(axis=1)\n    combined_scores = 0.6 * normalized_obj.mean(axis=1) + 0.4 * (diversity_scores / diversity_scores.max())\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal and adaptive node repositioning\n    if n >= 4:\n        # Segment reversal: reverse a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        reversed_segment = segment[::-1]\n        new_solution[a:a+3] = reversed_segment\n\n        # Adaptive node repositioning: move a node to a better position if it improves both objectives\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for j in range(n-1):\n            # Calculate potential improvement\n            prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node = new_solution[j]\n            current_edge1 = distance_matrix_1[prev_node, next_node]\n            current_edge2 = distance_matrix_2[prev_node, next_node]\n            new_edge1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_edge2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            improvement1 = new_edge1 - current_edge1\n            improvement2 = new_edge2 - current_edge2\n\n            if improvement1 < best_improvement[0] and improvement2 < best_improvement[1]:\n                best_pos = j\n                best_improvement = (improvement1, improvement2)\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n        else:\n            # If no improvement found, insert at random position\n            j = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8800652704743681,
            0.34296929836273193
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n    diversity_scores = np.linalg.norm(normalized_obj[:, np.newaxis] - normalized_obj, axis=2).sum(axis=1)\n    combined_scores = 0.6 * normalized_obj.mean(axis=1) + 0.4 * (diversity_scores / diversity_scores.max())\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Segment reversal and adaptive node repositioning\n    if n >= 4:\n        # Segment reversal: reverse a segment of 3 nodes\n        a = np.random.randint(0, n-2)\n        segment = new_solution[a:a+3]\n        reversed_segment = segment[::-1]\n        new_solution[a:a+3] = reversed_segment\n\n        # Adaptive node repositioning: move a node to a better position if it improves both objectives\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for j in range(n-1):\n            # Calculate potential improvement\n            prev_node = new_solution[j-1] if j > 0 else new_solution[-1]\n            next_node = new_solution[j]\n            current_edge1 = distance_matrix_1[prev_node, next_node]\n            current_edge2 = distance_matrix_2[prev_node, next_node]\n            new_edge1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            new_edge2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            improvement1 = new_edge1 - current_edge1\n            improvement2 = new_edge2 - current_edge2\n\n            if improvement1 < best_improvement[0] and improvement2 < best_improvement[1]:\n                best_pos = j\n                best_improvement = (improvement1, improvement2)\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n        else:\n            # If no improvement found, insert at random position\n            j = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the operation breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{This algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with diversity preservation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement in both objectives\n    a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[j]\n    current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n    current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n    new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n    new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n    # Only perform insertion if it improves both objectives or has a high probability\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.4:\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9335585889135467,
            0.29808980226516724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with diversity preservation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with objective-aware selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    # Calculate potential improvement in both objectives\n    a, b, c = new_solution[i], new_solution[(i+1)%n], new_solution[j]\n    current_cost1 = distance_matrix_1[a, b] + distance_matrix_1[b, c]\n    current_cost2 = distance_matrix_2[a, b] + distance_matrix_2[b, c]\n    new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[c, b]\n    new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[c, b]\n\n    # Only perform insertion if it improves both objectives or has a high probability\n    if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or np.random.rand() < 0.4:\n        new_solution = np.concatenate([new_solution[:i+1], [new_solution[j]], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node insertion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node insertion (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Segment reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n-1, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive segment rotation and guided node relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    seg_size = min(4, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Step 2: Guided node relocation\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            # Relocate node j to after i\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, (i + 1) % (n - 1), node)\n\n    # Step 3: Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Perform a simple swap as fallback\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.829830099524382,
            0.37940627336502075
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    seg_size = min(4, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Step 2: Guided node relocation\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            # Relocate node j to after i\n            node = new_solution[j]\n            new_solution = np.delete(new_solution, j)\n            new_solution = np.insert(new_solution, (i + 1) % (n - 1), node)\n\n    # Step 3: Check feasibility and repair if needed\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Perform a simple swap as fallback\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{The new algorithm employs an adaptive segment reversal strategy combined with multi-objective edge evaluation to generate neighbors by intelligently reversing path segments based on their combined objective improvement potential, while ensuring feasibility through edge-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal strategy\n    for _ in range(3):  # Perform multiple reversal attempts\n        # Select random segment\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, min(start+5, n))\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end)) + \\\n                       distance_matrix_1[new_solution[start-1], new_solution[start]] + \\\n                       distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end)) + \\\n                       distance_matrix_2[new_solution[start-1], new_solution[start]] + \\\n                       distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Reverse the segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start, end)) + \\\n                    distance_matrix_1[temp_solution[start-1], temp_solution[start]] + \\\n                    distance_matrix_1[temp_solution[end], temp_solution[(end+1)%n]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start, end)) + \\\n                    distance_matrix_2[temp_solution[start-1], temp_solution[start]] + \\\n                    distance_matrix_2[temp_solution[end], temp_solution[(end+1)%n]]\n\n        # Multi-objective edge evaluation\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9279294228205998,
            0.8435707688331604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal strategy\n    for _ in range(3):  # Perform multiple reversal attempts\n        # Select random segment\n        start = np.random.randint(0, n-1)\n        end = np.random.randint(start+1, min(start+5, n))\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(start, end)) + \\\n                       distance_matrix_1[new_solution[start-1], new_solution[start]] + \\\n                       distance_matrix_1[new_solution[end], new_solution[(end+1)%n]]\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(start, end)) + \\\n                       distance_matrix_2[new_solution[start-1], new_solution[start]] + \\\n                       distance_matrix_2[new_solution[end], new_solution[(end+1)%n]]\n\n        # Reverse the segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[i+1]] for i in range(start, end)) + \\\n                    distance_matrix_1[temp_solution[start-1], temp_solution[start]] + \\\n                    distance_matrix_1[temp_solution[end], temp_solution[(end+1)%n]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[i+1]] for i in range(start, end)) + \\\n                    distance_matrix_2[temp_solution[start-1], temp_solution[start]] + \\\n                    distance_matrix_2[temp_solution[end], temp_solution[(end+1)%n]]\n\n        # Multi-objective edge evaluation\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-based selection criterion, then applies a hybrid local search combining segment reversal and node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Compute crowding distance for each solution\n        objectives = np.array([x[1] for x in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with highest crowding distance (most diverse)\n        selected_idx = np.argmax(crowding)\n        selected = archive[selected_idx]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment reversal and node swapping\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Randomly swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7264563748937936,
            0.5877971053123474
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Compute crowding distance for each solution\n        objectives = np.array([x[1] for x in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with highest crowding distance (most diverse)\n        selected_idx = np.argmax(crowding)\n        selected = archive[selected_idx]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: segment reversal and node swapping\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Randomly swap two nodes\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{An adaptive, multi-strategy local search operator that combines randomized segment reversal with a Pareto-guided edge replacement strategy, dynamically adjusting segment sizes and replacement criteria based on solution quality and objective trade-offs to generate diverse high-quality neighbors.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with quality-based size adjustment\n    seg_size = min(7, max(3, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new1 <= current1 and new2 < current2) or (new1 < current1 and new2 <= current2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n        elif np.random.rand() < 0.15 * (1 - (i / n)):  # Probabilistic exploration\n            if (new1 < current1 or new2 < current2) and (new1 <= 1.1 * current1 and new2 <= 1.1 * current2):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Quality-aware random insertion\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        if p != q:\n            node = new_solution[p]\n            new_solution = np.concatenate([new_solution[:p], new_solution[p+1:q], [node], new_solution[q:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8777426309301599,
            0.4287697672843933
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    top_solutions = sorted_archive[:max(1, len(archive) // 5)]\n    selected_idx = np.random.choice(len(top_solutions))\n    base_solution = top_solutions[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with quality-based size adjustment\n    seg_size = min(7, max(3, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new1 <= current1 and new2 < current2) or (new1 < current1 and new2 <= current2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n        elif np.random.rand() < 0.15 * (1 - (i / n)):  # Probabilistic exploration\n            if (new1 < current1 or new2 < current2) and (new1 <= 1.1 * current1 and new2 <= 1.1 * current2):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Quality-aware random insertion\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        if p != q:\n            node = new_solution[p]\n            new_solution = np.concatenate([new_solution[:p], new_solution[p+1:q], [node], new_solution[q:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The new algorithm combines adaptive multi-objective segment relocation with guided node reinsertion, using a hybrid of distance-based clustering and objective-aware segment selection to generate high-quality neighbors by intelligently repositioning segments while maintaining feasibility through dynamic feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relocation with multi-objective awareness\n    segment_size = max(2, n // 4)\n    for _ in range(3):  # Perform multiple relocation attempts\n        # Select a random segment\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        segment = new_solution[start:end]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try relocating the segment to a different position\n        new_pos = np.random.randint(0, n - segment_size)\n        while new_pos == start:\n            new_pos = np.random.randint(0, n - segment_size)\n\n        temp_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[end:]\n        ])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if improvement in both objectives or probabilistic acceptance\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Guided node reinsertion based on distance and objective improvement\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Calculate potential insertion points\n        insertion_points = [i for i in range(n) if i != node_pos and i != (node_pos - 1) % n and i != (node_pos + 1) % n]\n\n        best_improvement = 0\n        best_pos = node_pos\n\n        for pos in insertion_points:\n            # Calculate cost before insertion\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n            cost_remove1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost_remove2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate cost after insertion\n            if node_pos < pos:\n                prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[(node_pos + 1) % n]\n                cost_add1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost_add2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            else:\n                prev_node = new_solution[(node_pos - 1) % n]\n                next_node = new_solution[pos]\n                cost_add1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost_add2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            improvement1 = cost_remove1 - cost_add1\n            improvement2 = cost_remove2 - cost_add2\n\n            if (improvement1 > 0 and improvement2 > 0) or \\\n               (np.random.rand() < 0.2 and (improvement1 >= 0 or improvement2 >= 0)):\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_pos != node_pos:\n            # Remove node from current position\n            temp_solution = np.delete(new_solution, node_pos)\n            # Insert node at best position\n            temp_solution = np.insert(temp_solution, best_pos, node)\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8137251139289738,
            0.43616288900375366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relocation with multi-objective awareness\n    segment_size = max(2, n // 4)\n    for _ in range(3):  # Perform multiple relocation attempts\n        # Select a random segment\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n        segment = new_solution[start:end]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try relocating the segment to a different position\n        new_pos = np.random.randint(0, n - segment_size)\n        while new_pos == start:\n            new_pos = np.random.randint(0, n - segment_size)\n\n        temp_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:start],\n            new_solution[end:]\n        ])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if improvement in both objectives or probabilistic acceptance\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Guided node reinsertion based on distance and objective improvement\n    for _ in range(2):\n        # Select a random node to reinsert\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n\n        # Calculate potential insertion points\n        insertion_points = [i for i in range(n) if i != node_pos and i != (node_pos - 1) % n and i != (node_pos + 1) % n]\n\n        best_improvement = 0\n        best_pos = node_pos\n\n        for pos in insertion_points:\n            # Calculate cost before insertion\n            prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n            next_node = new_solution[pos]\n            cost_remove1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            cost_remove2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Calculate cost after insertion\n            if node_pos < pos:\n                prev_node = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n                next_node = new_solution[(node_pos + 1) % n]\n                cost_add1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost_add2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n            else:\n                prev_node = new_solution[(node_pos - 1) % n]\n                next_node = new_solution[pos]\n                cost_add1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n                cost_add2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            improvement1 = cost_remove1 - cost_add1\n            improvement2 = cost_remove2 - cost_add2\n\n            if (improvement1 > 0 and improvement2 > 0) or \\\n               (np.random.rand() < 0.2 and (improvement1 >= 0 or improvement2 >= 0)):\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        if best_pos != node_pos:\n            # Remove node from current position\n            temp_solution = np.delete(new_solution, node_pos)\n            # Insert node at best position\n            temp_solution = np.insert(temp_solution, best_pos, node)\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node insertion and segment reversal to generate a high-quality neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node insertion (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Segment reversal (reverse a segment of the tour)\n    i, j = np.random.choice(n-1, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{The algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining node relocation and edge exchange to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node relocation (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Edge exchange (swap two edges if it improves both objectives)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Apply edge exchange if it improves both objectives\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if exchange breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8438854800128911,
            0.3010796904563904
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Node relocation (remove a node and insert it at a different position)\n    node_idx = np.random.randint(0, n)\n    node = new_solution[node_idx]\n    new_solution = np.delete(new_solution, node_idx)\n    pos = np.random.randint(0, n)\n    new_solution = np.insert(new_solution, pos, node)\n\n    # Step 2: Edge exchange (swap two edges if it improves both objectives)\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n\n    # Calculate current and potential costs\n    current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    potential_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    potential_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    # Apply edge exchange if it improves both objectives\n    if (potential_cost1 < current_cost1) and (potential_cost2 < current_cost2):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if exchange breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines an adaptive segment reversal with a guided edge exchange strategy, and incorporates a probabilistic edge swap mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = np.random.choice(min(3, len(archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with larger segment size\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with probabilistic acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Probabilistic acceptance with adaptive temperature\n        temp = 0.5 * (1 - (i / n))\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < temp and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic edge swap\n    if np.random.rand() < 0.3:\n        p, q = np.random.choice(n, 2, replace=False)\n        if abs(p - q) > 1:  # Ensure non-adjacent nodes\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.7233424863345284,
            0.29329657554626465
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) / 2)\n    selected_idx = np.random.choice(min(3, len(archive)))\n    base_solution = sorted_archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with larger segment size\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with probabilistic acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Probabilistic acceptance with adaptive temperature\n        temp = 0.5 * (1 - (i / n))\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < temp and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic edge swap\n    if np.random.rand() < 0.3:\n        p, q = np.random.choice(n, 2, replace=False)\n        if abs(p - q) > 1:  # Ensure non-adjacent nodes\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement using an adaptive score function that balances objective values and solution diversity, then applies a hybrid local search combining variable-length segment reversal and intelligent edge reinsertion with different parameter settings.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]) for sol, _ in archive])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 4)\n        new_solution[start:start+4] = new_solution[start:start+4][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8210889959576435,
            0.7524911761283875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))]) for sol, _ in archive])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 4)\n        new_solution[start:start+4] = new_solution[start:start+4][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node reinsertion with adaptive segment lengths and guided edge selection criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node reinsertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7275211232389325,
            0.6157528758049011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node reinsertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and neighborhood diversity, then applies a hybrid local search combining 3-opt and node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted selection based on normalized objective values\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        weights = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1]\n        selected = random.choices(archive, weights=weights, k=1)[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Apply 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n        # Apply node relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8938683617300458,
            0.257185697555542
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted selection based on normalized objective values\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        weights = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1]\n        selected = random.choices(archive, weights=weights, k=1)[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Apply 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n        # Apply node relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{The new algorithm combines an adaptive segment relinking strategy with a multi-objective edge insertion heuristic to generate high-quality neighbors by intelligently relinking path segments and inserting nodes based on their combined improvement potential while ensuring feasibility through dynamic segment validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relinking\n    segment_size = max(2, n // 4)\n    segments = []\n    for i in range(0, n, segment_size):\n        segments.append(new_solution[i:i+segment_size])\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        i = np.random.randint(0, len(segments))\n        segment = segments[i]\n        segment_start = np.where(new_solution == segment[0])[0][0]\n        segment_end = np.where(new_solution == segment[-1])[0][0]\n\n        # Try inserting segment in a new position\n        for _ in range(2):\n            pos = np.random.randint(0, n)\n            if pos == segment_start or pos == segment_end:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n            # Ensure no duplicates and all nodes are included\n            if len(np.unique(temp_solution)) == n:\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n                current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.757436493354014,
            0.7924522161483765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relinking\n    segment_size = max(2, n // 4)\n    segments = []\n    for i in range(0, n, segment_size):\n        segments.append(new_solution[i:i+segment_size])\n\n    # Multi-objective edge insertion\n    for _ in range(3):\n        i = np.random.randint(0, len(segments))\n        segment = segments[i]\n        segment_start = np.where(new_solution == segment[0])[0][0]\n        segment_end = np.where(new_solution == segment[-1])[0][0]\n\n        # Try inserting segment in a new position\n        for _ in range(2):\n            pos = np.random.randint(0, n)\n            if pos == segment_start or pos == segment_end:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n            # Ensure no duplicates and all nodes are included\n            if len(np.unique(temp_solution)) == n:\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n                current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{This new algorithm employs a hybrid approach combining adaptive segment reversal and objective-weighted node swapping to generate high-quality neighbors by intelligently reversing segments and swapping nodes based on their combined objective improvement potential while maintaining feasibility through dynamic segment validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = max(2, n // 4)\n    for _ in range(3):  # Perform multiple reversal attempts\n        start = np.random.randint(0, n - segment_size + 1)\n        end = start + segment_size\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Objective-weighted acceptance\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Objective-weighted node swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Weighted acceptance based on objective improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.951906266718368,
            0.9665428400039673
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal\n    segment_size = max(2, n // 4)\n    for _ in range(3):  # Perform multiple reversal attempts\n        start = np.random.randint(0, n - segment_size + 1)\n        end = start + segment_size\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Objective-weighted acceptance\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Objective-weighted node swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Weighted acceptance based on objective improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{The new algorithm selects a solution from the archive using a weighted random selection based on normalized objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with a novel guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate diversity scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.mean(normalized_obj, axis=1)\n\n    # Weighted selection based on normalized objectives and diversity\n    weights = normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.3 + diversity_scores * 0.1\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(5, max(3, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or abs(j - i) < 3:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.781425353329381,
            0.25752294063568115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Normalize objectives and calculate diversity scores\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.mean(normalized_obj, axis=1)\n\n    # Weighted selection based on normalized objectives and diversity\n    weights = normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.3 + diversity_scores * 0.1\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(5, max(3, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or abs(j - i) < 3:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9821663842915196,
            0.28467029333114624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: Randomized segment inversion + guided edge exchange\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution  # No meaningful inversion possible\n\n    # Random segment inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange: swap edges that improve both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # If new edges are better in both objectives, perform the swap\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9821663842915196,
            0.28467029333114624
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{This algorithm selects a high-potential solution from the archive using a combined objective-aware selection mechanism, then applies a novel hybrid local search combining adaptive path segmentation with guided node substitution and multi-objective edge flipping to generate high-quality neighbors while ensuring feasibility through segment validation and edge consistency checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with combined objective-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4\n    selected_idx = np.random.choice(len(archive), p=scores / np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive path segmentation\n    segment_size = max(2, min(5, n // 3))\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Guided node substitution\n    for _ in range(2):\n        seg_idx = np.random.randint(0, len(segments))\n        segment = segments[seg_idx]\n\n        for node in segment:\n            candidates = [i for i in range(n) if i not in segment]\n            if not candidates:\n                continue\n\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                temp = new_solution.copy()\n                temp_pos = np.where(temp == node)[0][0]\n                candidate_pos = np.where(temp == new_solution[candidate])[0][0]\n\n                temp[temp_pos], temp[candidate_pos] = temp[candidate_pos], temp[temp_pos]\n\n                cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n                improvement = (objectives[selected_idx][0] - cost1) * 0.7 + (objectives[selected_idx][1] - cost2) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                node_pos = np.where(new_solution == node)[0][0]\n                candidate_pos = np.where(new_solution == new_solution[best_candidate])[0][0]\n                new_solution[node_pos], new_solution[candidate_pos] = new_solution[candidate_pos], new_solution[node_pos]\n                break\n\n    # Multi-objective edge flipping\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        temp = new_solution.copy()\n        temp[i:j] = temp[i:j][::-1]\n\n        cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n        cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n        if (cost1 < objectives[selected_idx][0] and cost2 < objectives[selected_idx][1]) or \\\n           (np.random.rand() < 0.4 and (cost1 <= objectives[selected_idx][0] or cost2 <= objectives[selected_idx][1])):\n            new_solution = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8370532448646638,
            5.039049804210663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with combined objective-aware selection\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * 0.6 + normalized[:, 1] * 0.4\n    selected_idx = np.random.choice(len(archive), p=scores / np.sum(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive path segmentation\n    segment_size = max(2, min(5, n // 3))\n    segments = [new_solution[i:i+segment_size] for i in range(0, n, segment_size)]\n\n    # Guided node substitution\n    for _ in range(2):\n        seg_idx = np.random.randint(0, len(segments))\n        segment = segments[seg_idx]\n\n        for node in segment:\n            candidates = [i for i in range(n) if i not in segment]\n            if not candidates:\n                continue\n\n            best_candidate = None\n            best_improvement = 0\n\n            for candidate in candidates:\n                temp = new_solution.copy()\n                temp_pos = np.where(temp == node)[0][0]\n                candidate_pos = np.where(temp == new_solution[candidate])[0][0]\n\n                temp[temp_pos], temp[candidate_pos] = temp[candidate_pos], temp[temp_pos]\n\n                cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n                cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n                improvement = (objectives[selected_idx][0] - cost1) * 0.7 + (objectives[selected_idx][1] - cost2) * 0.3\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_candidate = candidate\n\n            if best_candidate is not None:\n                node_pos = np.where(new_solution == node)[0][0]\n                candidate_pos = np.where(new_solution == new_solution[best_candidate])[0][0]\n                new_solution[node_pos], new_solution[candidate_pos] = new_solution[candidate_pos], new_solution[node_pos]\n                break\n\n    # Multi-objective edge flipping\n    for _ in range(3):\n        i = np.random.randint(0, n-1)\n        j = np.random.randint(i+1, n)\n\n        temp = new_solution.copy()\n        temp[i:j] = temp[i:j][::-1]\n\n        cost1 = sum(distance_matrix_1[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_1[temp[-1], temp[0]]\n        cost2 = sum(distance_matrix_2[temp[k], temp[k+1]] for k in range(n-1)) + distance_matrix_2[temp[-1], temp[0]]\n\n        if (cost1 < objectives[selected_idx][0] and cost2 < objectives[selected_idx][1]) or \\\n           (np.random.rand() < 0.4 and (cost1 <= objectives[selected_idx][0] or cost2 <= objectives[selected_idx][1])):\n            new_solution = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{The new algorithm employs a multi-objective segment inversion strategy with adaptive segment length selection to generate neighbors by intelligently inverting path segments based on their combined objective improvement potential while maintaining feasibility through segment length validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment length selection\n    max_segment_length = max(2, n // 4)\n    segment_length = np.random.randint(2, max_segment_length + 1)\n\n    # Multi-objective segment inversion\n    for _ in range(3):  # Perform multiple inversion attempts\n        # Select a random segment to invert\n        start_idx = np.random.randint(0, n - segment_length + 1)\n        end_idx = start_idx + segment_length\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution with inverted segment\n        temp_solution = new_solution.copy()\n        temp_solution[start_idx:end_idx] = new_solution[start_idx:end_idx][::-1]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if both objectives improve or at least one improves with some probability\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.7290715025591389,
            1.0551884770393372
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment length selection\n    max_segment_length = max(2, n // 4)\n    segment_length = np.random.randint(2, max_segment_length + 1)\n\n    # Multi-objective segment inversion\n    for _ in range(3):  # Perform multiple inversion attempts\n        # Select a random segment to invert\n        start_idx = np.random.randint(0, n - segment_length + 1)\n        end_idx = start_idx + segment_length\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution with inverted segment\n        temp_solution = new_solution.copy()\n        temp_solution[start_idx:end_idx] = new_solution[start_idx:end_idx][::-1]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if both objectives improve or at least one improves with some probability\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a probabilistic segment relocation with a dominance-based edge exchange strategy to generate high-quality neighbors by intelligently balancing exploration and exploitation of the solution space.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    weights = np.array([1.0 / (i + 1) for i in range(len(archive))])\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[a:b+1]\n    remaining = np.delete(new_solution, np.arange(a, b+1))\n    insert_pos = np.random.randint(0, len(remaining) + 1)\n    new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Dominance-based edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{The new algorithm combines a probabilistic node sequence inversion with a multi-objective edge flipping strategy that dynamically adapts the search focus based on the relative improvement potential of each objective, using a weighted dominance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Calculate objective weights based on relative improvement potential\n    obj1_improvement = archive[selected_idx][1][0] - np.min([obj[0] for obj in archive])\n    obj2_improvement = archive[selected_idx][1][1] - np.min([obj[1] for obj in archive])\n    total_improvement = obj1_improvement + obj2_improvement\n\n    if total_improvement > 0:\n        weight1 = obj1_improvement / total_improvement\n        weight2 = obj2_improvement / total_improvement\n    else:\n        weight1 = weight2 = 0.5\n\n    # Probabilistic node sequence inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge flipping with weighted dominance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        weighted_score = weight1 * improvement1 + weight2 * improvement2\n\n        if weighted_score > 0 or (np.random.rand() < 0.1 and (improvement1 > 0 or improvement2 > 0)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.9321172421037551,
            0.43603450059890747
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Calculate objective weights based on relative improvement potential\n    obj1_improvement = archive[selected_idx][1][0] - np.min([obj[0] for obj in archive])\n    obj2_improvement = archive[selected_idx][1][1] - np.min([obj[1] for obj in archive])\n    total_improvement = obj1_improvement + obj2_improvement\n\n    if total_improvement > 0:\n        weight1 = obj1_improvement / total_improvement\n        weight2 = obj2_improvement / total_improvement\n    else:\n        weight1 = weight2 = 0.5\n\n    # Probabilistic node sequence inversion\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if np.random.rand() < 0.5:\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Multi-objective edge flipping with weighted dominance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        weighted_score = weight1 * improvement1 + weight2 * improvement2\n\n        if weighted_score > 0 or (np.random.rand() < 0.1 and (improvement1 > 0 or improvement2 > 0)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combined score of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation and guided node exchange to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided node exchange with distance-based selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n    if dist1 + dist2 > 0.7 * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if exchange breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8496349959732442,
            0.24889737367630005
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided node exchange with distance-based selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n    dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n    if dist1 + dist2 > 0.7 * (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                              distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if exchange breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment relocation with an adaptive edge crossover strategy to generate diverse neighbors while maintaining feasibility through careful node swapping and segment inversion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation with adaptive segment size\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    insert_pos = np.random.randint(0, n - seg_size)\n    if insert_pos >= a:\n        insert_pos += seg_size\n\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Adaptive edge crossover with guided selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[l]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[l]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            if np.random.rand() < 0.5:\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n            else:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Additional controlled swap to increase diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        temp = new_solution[p]\n        new_solution[p] = new_solution[q]\n        new_solution[q] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.8620612019963869,
            0.24200564622879028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (objectives.sum(axis=0) + 1e-8)\n    weights = 1 / (normalized.sum(axis=1) + 1e-8)\n    weights = weights / weights.sum()\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment relocation with adaptive segment size\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    insert_pos = np.random.randint(0, n - seg_size)\n    if insert_pos >= a:\n        insert_pos += seg_size\n\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([\n        new_solution[:a],\n        new_solution[b+1:insert_pos],\n        segment,\n        new_solution[insert_pos:]\n    ])\n\n    # Adaptive edge crossover with guided selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[l]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[l]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            if np.random.rand() < 0.5:\n                new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n            else:\n                new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Additional controlled swap to increase diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        temp = new_solution[p]\n        new_solution[p] = new_solution[q]\n        new_solution[q] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A novel hybrid local search operator that combines a randomized segment relocation with an adaptive edge flipping strategy, guided by both objective values to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return instance[:, 0].astype(int)\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment relocation with adaptive segment size\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) - seg_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge flipping strategy\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Flip edge if it improves both objectives or with probability based on position\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 < current_edge1 or new_edge2 < current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random 2-opt move for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8807911124878988,
            0.2687074542045593
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        return instance[:, 0].astype(int)\n\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment relocation with adaptive segment size\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) - seg_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Adaptive edge flipping strategy\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Flip edge if it improves both objectives or with probability based on position\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 < current_edge1 or new_edge2 < current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random 2-opt move for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a hybrid local search combining 3-opt and segment reversal moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted selection based on normalized objective values and diversity\n        normalized = []\n        for sol, (obj1, obj2) in archive:\n            norm_obj1 = obj1 / max(1, np.max([x[1][0] for x in archive]))\n            norm_obj2 = obj2 / max(1, np.max([x[1][1] for x in archive]))\n            diversity = np.std([distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol))])\n            score = 0.4 * (norm_obj1 + norm_obj2) + 0.6 * diversity\n            normalized.append((sol, (obj1, obj2), score))\n\n        # Select top 20% solutions based on score\n        top_solutions = sorted(normalized, key=lambda x: x[2])[:max(1, len(normalized) // 5)]\n        selected = random.choice(top_solutions)[0]\n    else:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n > 4:\n        # Hybrid 3-opt and segment reversal\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Perform 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        # Reverse a random segment\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7293226382675146,
            1.0242565870285034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Weighted selection based on normalized objective values and diversity\n        normalized = []\n        for sol, (obj1, obj2) in archive:\n            norm_obj1 = obj1 / max(1, np.max([x[1][0] for x in archive]))\n            norm_obj2 = obj2 / max(1, np.max([x[1][1] for x in archive]))\n            diversity = np.std([distance_matrix_1[sol[i-1], sol[i]] + distance_matrix_2[sol[i-1], sol[i]] for i in range(len(sol))])\n            score = 0.4 * (norm_obj1 + norm_obj2) + 0.6 * diversity\n            normalized.append((sol, (obj1, obj2), score))\n\n        # Select top 20% solutions based on score\n        top_solutions = sorted(normalized, key=lambda x: x[2])[:max(1, len(normalized) // 5)]\n        selected = random.choice(top_solutions)[0]\n    else:\n        selected = archive[0][0]\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n > 4:\n        # Hybrid 3-opt and segment reversal\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Perform 3-opt move\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n        # Reverse a random segment\n        seg_start = random.randint(0, n-2)\n        seg_end = random.randint(seg_start+1, n-1)\n        new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{This new algorithm implements a multi-segment inversion strategy with adaptive cluster-based validation that intelligently inverts segments of the tour based on their combined objective improvement potential while ensuring feasibility through cluster-based validation and dominance checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive cluster-based validation\n    cluster_size = max(2, n // 4)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-segment inversion with dominance checks\n    for _ in range(3):  # More inversion attempts\n        i = np.random.randint(0, len(clusters))\n        cluster = clusters[i]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try inverting the cluster\n        temp_solution = new_solution.copy()\n        start_idx = np.where(new_solution == cluster[0])[0][0]\n        end_idx = np.where(new_solution == cluster[-1])[0][0]\n        temp_solution[start_idx:end_idx+1] = temp_solution[start_idx:end_idx+1][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if strictly better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution = temp_solution\n        # Or accept with probability if better in at least one objective\n        elif (new_cost1 <= current_cost1 or new_cost2 <= current_cost2) and np.random.rand() < 0.4:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7738418152326937,
            2.5760204195976257
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive cluster-based validation\n    cluster_size = max(2, n // 4)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-segment inversion with dominance checks\n    for _ in range(3):  # More inversion attempts\n        i = np.random.randint(0, len(clusters))\n        cluster = clusters[i]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try inverting the cluster\n        temp_solution = new_solution.copy()\n        start_idx = np.where(new_solution == cluster[0])[0][0]\n        end_idx = np.where(new_solution == cluster[-1])[0][0]\n        temp_solution[start_idx:end_idx+1] = temp_solution[start_idx:end_idx+1][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        # Accept if strictly better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            new_solution = temp_solution\n        # Or accept with probability if better in at least one objective\n        elif (new_cost1 <= current_cost1 or new_cost2 <= current_cost2) and np.random.rand() < 0.4:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of improvement potential in both objectives, then applies a hybrid local search combining segment inversion and adaptive edge flipping to generate a neighbor solution while ensuring feasibility through dynamic feasibility checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8358948839434985,
            0.285732626914978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9182645389798682,
            0.25334304571151733
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n",
        "score": [
            -0.9030063178094941,
            0.23903512954711914
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the normalized objective differences\n        objectives = np.array([obj for _, obj in archive])\n        obj1_min, obj1_max = objectives[:, 0].min(), objectives[:, 0].max()\n        obj2_min, obj2_max = objectives[:, 1].min(), objectives[:, 1].max()\n\n        # Normalize objectives to [0, 1] range\n        norm_obj1 = (objectives[:, 0] - obj1_min) / (obj1_max - obj1_min + 1e-8)\n        norm_obj2 = (objectives[:, 1] - obj2_min) / (obj2_max - obj2_min + 1e-8)\n\n        # Calculate diversity score (distance from the origin in normalized space)\n        diversity_scores = np.sqrt(norm_obj1**2 + norm_obj2**2)\n\n        # Select solutions with top 30% diversity scores\n        threshold = np.percentile(diversity_scores, 70)\n        candidates = [archive[i] for i in range(len(archive)) if diversity_scores[i] >= threshold]\n\n        # If no candidates found, select from top 50% by objective sum\n        if not candidates:\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            candidates = sorted_archive[:max(1, len(sorted_archive) // 2)]\n\n        selected = random.choice(candidates)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion with objective-aware selection\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate the improvement potential of the segment\n    original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    inverted_segment = np.flip(new_solution[a:b+1])\n    new_cost1 = distance_matrix_1[new_solution[a-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(b+1)%n]]\n\n    # Accept inversion if it improves at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (np.random.rand() < 0.3):\n        new_solution[a:b+1] = inverted_segment\n\n    # Objective-aware edge exchange with guided selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria based on objective improvement\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap with objective-aware probability\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        original_cost1 = distance_matrix_1[new_solution[p-1], new_solution[p]] + distance_matrix_1[new_solution[p], new_solution[(p+1)%n]] + \\\n                         distance_matrix_1[new_solution[q-1], new_solution[q]] + distance_matrix_1[new_solution[q], new_solution[(q+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[p-1], new_solution[p]] + distance_matrix_2[new_solution[p], new_solution[(p+1)%n]] + \\\n                         distance_matrix_2[new_solution[q-1], new_solution[q]] + distance_matrix_2[new_solution[q], new_solution[(q+1)%n]]\n\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n        new_cost1 = distance_matrix_1[new_solution[p-1], new_solution[p]] + distance_matrix_1[new_solution[p], new_solution[(p+1)%n]] + \\\n                   distance_matrix_1[new_solution[q-1], new_solution[q]] + distance_matrix_1[new_solution[q], new_solution[(q+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[p-1], new_solution[p]] + distance_matrix_2[new_solution[p], new_solution[(p+1)%n]] + \\\n                   distance_matrix_2[new_solution[q-1], new_solution[q]] + distance_matrix_2[new_solution[q], new_solution[(q+1)%n]]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.960803477438018,
            0.5618290305137634
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate the normalized objective differences\n        objectives = np.array([obj for _, obj in archive])\n        obj1_min, obj1_max = objectives[:, 0].min(), objectives[:, 0].max()\n        obj2_min, obj2_max = objectives[:, 1].min(), objectives[:, 1].max()\n\n        # Normalize objectives to [0, 1] range\n        norm_obj1 = (objectives[:, 0] - obj1_min) / (obj1_max - obj1_min + 1e-8)\n        norm_obj2 = (objectives[:, 1] - obj2_min) / (obj2_max - obj2_min + 1e-8)\n\n        # Calculate diversity score (distance from the origin in normalized space)\n        diversity_scores = np.sqrt(norm_obj1**2 + norm_obj2**2)\n\n        # Select solutions with top 30% diversity scores\n        threshold = np.percentile(diversity_scores, 70)\n        candidates = [archive[i] for i in range(len(archive)) if diversity_scores[i] >= threshold]\n\n        # If no candidates found, select from top 50% by objective sum\n        if not candidates:\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            candidates = sorted_archive[:max(1, len(sorted_archive) // 2)]\n\n        selected = random.choice(candidates)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion with objective-aware selection\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate the improvement potential of the segment\n    original_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    inverted_segment = np.flip(new_solution[a:b+1])\n    new_cost1 = distance_matrix_1[new_solution[a-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(b+1)%n]]\n\n    # Accept inversion if it improves at least one objective\n    if (new_cost1 < original_cost1) or (new_cost2 < original_cost2) or (np.random.rand() < 0.3):\n        new_solution[a:b+1] = inverted_segment\n\n    # Objective-aware edge exchange with guided selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria based on objective improvement\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap with objective-aware probability\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        original_cost1 = distance_matrix_1[new_solution[p-1], new_solution[p]] + distance_matrix_1[new_solution[p], new_solution[(p+1)%n]] + \\\n                         distance_matrix_1[new_solution[q-1], new_solution[q]] + distance_matrix_1[new_solution[q], new_solution[(q+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[p-1], new_solution[p]] + distance_matrix_2[new_solution[p], new_solution[(p+1)%n]] + \\\n                         distance_matrix_2[new_solution[q-1], new_solution[q]] + distance_matrix_2[new_solution[q], new_solution[(q+1)%n]]\n\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n        new_cost1 = distance_matrix_1[new_solution[p-1], new_solution[p]] + distance_matrix_1[new_solution[p], new_solution[(p+1)%n]] + \\\n                   distance_matrix_1[new_solution[q-1], new_solution[q]] + distance_matrix_1[new_solution[q], new_solution[(q+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[p-1], new_solution[p]] + distance_matrix_2[new_solution[p], new_solution[(p+1)%n]] + \\\n                   distance_matrix_2[new_solution[q-1], new_solution[q]] + distance_matrix_2[new_solution[q], new_solution[(q+1)%n]]\n\n        # Revert swap if it doesn't improve at least one objective\n        if not ((new_cost1 < original_cost1) or (new_cost2 < original_cost2)):\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and edge diversity, then applies a hybrid local search combining random edge swaps and partial inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance (non-dominated first) and then by edge diversity\n        dominated = []\n        non_dominated = []\n        for sol in archive:\n            is_dominated = False\n            for other in archive:\n                if other is not sol and other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and (other[1][0] < sol[1][0] or other[1][1] < sol[1][1]):\n                    is_dominated = True\n                    break\n            if is_dominated:\n                dominated.append(sol)\n            else:\n                non_dominated.append(sol)\n\n        # Prioritize non-dominated solutions, then dominated ones\n        if non_dominated:\n            candidates = non_dominated\n        else:\n            candidates = dominated\n\n        # Select solution with highest edge diversity\n        def edge_diversity(solution):\n            edges = set()\n            n = len(solution)\n            for i in range(n):\n                edges.add((min(solution[i], solution[(i+1)%n]), max(solution[i], solution[(i+1)%n])))\n            return len(edges)\n\n        selected = max(candidates, key=lambda x: edge_diversity(x[0]))\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random edge swap and partial inversion\n    n = len(new_solution)\n    if n > 3:\n        # Random edge swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Random partial inversion\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8936495257978629,
            0.5375950336456299
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance (non-dominated first) and then by edge diversity\n        dominated = []\n        non_dominated = []\n        for sol in archive:\n            is_dominated = False\n            for other in archive:\n                if other is not sol and other[1][0] <= sol[1][0] and other[1][1] <= sol[1][1] and (other[1][0] < sol[1][0] or other[1][1] < sol[1][1]):\n                    is_dominated = True\n                    break\n            if is_dominated:\n                dominated.append(sol)\n            else:\n                non_dominated.append(sol)\n\n        # Prioritize non-dominated solutions, then dominated ones\n        if non_dominated:\n            candidates = non_dominated\n        else:\n            candidates = dominated\n\n        # Select solution with highest edge diversity\n        def edge_diversity(solution):\n            edges = set()\n            n = len(solution)\n            for i in range(n):\n                edges.add((min(solution[i], solution[(i+1)%n]), max(solution[i], solution[(i+1)%n])))\n            return len(edges)\n\n        selected = max(candidates, key=lambda x: edge_diversity(x[0]))\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: random edge swap and partial inversion\n    n = len(new_solution)\n    if n > 3:\n        # Random edge swap\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Random partial inversion\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective improvement score, then applies a novel hybrid local search combining adaptive segment relocation and constrained edge insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives and incorporating a probabilistic acceptance criterion that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement score\n    objectives = np.array([obj for _, obj in archive])\n    improvement_scores = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.7 * improvement_scores[:, 0] + 0.3 * improvement_scores[:, 1]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with edge insertion\n    seg_size = min(4, n // 2)\n    start = np.random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    insertion_pos = np.random.randint(0, n - seg_size)\n    if insertion_pos >= start:\n        insertion_pos += seg_size\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos],\n        segment,\n        new_solution[insertion_pos:start],\n        new_solution[start+seg_size:]\n    ])\n\n    # Constrained edge insertion with probabilistic acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        while k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n            k = np.random.randint(0, n)\n\n        # Calculate potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Insert if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                [new_solution[k]],\n                new_solution[i+1:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.6859399759031491,
            0.3544628620147705
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective improvement score\n    objectives = np.array([obj for _, obj in archive])\n    improvement_scores = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.7 * improvement_scores[:, 0] + 0.3 * improvement_scores[:, 1]\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with edge insertion\n    seg_size = min(4, n // 2)\n    start = np.random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    insertion_pos = np.random.randint(0, n - seg_size)\n    if insertion_pos >= start:\n        insertion_pos += seg_size\n    new_solution = np.concatenate([\n        new_solution[:insertion_pos],\n        segment,\n        new_solution[insertion_pos:start],\n        new_solution[start+seg_size:]\n    ])\n\n    # Constrained edge insertion with probabilistic acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        while k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n            k = np.random.randint(0, n)\n\n        # Calculate potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Insert if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution = np.concatenate([\n                new_solution[:i+1],\n                [new_solution[k]],\n                new_solution[i+1:j],\n                new_solution[j+1:]\n            ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a weighted combination of objective values and neighborhood diversity, then applies a hybrid local search combining 3-opt and node relocation to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Weighted selection based on normalized objective values\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n        weights = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1]\n        selected = random.choices(archive, weights=weights, k=1)[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Apply 3-opt move\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b+1]\n        segment2 = new_solution[b+1:c+1]\n        new_solution[a:c+1] = np.concatenate([segment2, segment1[::-1]])\n\n        # Apply node relocation\n        node_idx = random.randint(0, n-1)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        insert_pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal and guided node swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node swapping\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and neighborhood diversity, then applies a hybrid local search combining adaptive segment insertion and guided edge reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([x[1] for x in archive])\n        diversity = np.array([np.sum(np.abs(x[0] - archive[i][0])) for i, x in enumerate(archive)])\n        combined = 0.7 * (objectives[:, 0] + objectives[:, 1]) + 0.3 * diversity\n        selected = archive[np.argmin(combined)][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        segment_length = min(3, n // 4)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, slice(start, end))\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.789107749114883,
            0.28957921266555786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([x[1] for x in archive])\n        diversity = np.array([np.sum(np.abs(x[0] - archive[i][0])) for i, x in enumerate(archive)])\n        combined = 0.7 * (objectives[:, 0] + objectives[:, 1]) + 0.3 * diversity\n        selected = archive[np.argmin(combined)][0].copy()\n    else:\n        selected = archive[0][0].copy()\n\n    base_solution = selected.copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        segment_length = min(3, n // 4)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, slice(start, end))\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        a, b = sorted(np.random.choice(range(n), 2, replace=False))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{The new algorithm employs a multi-objective path relinking strategy combined with adaptive node grouping and guided segment crossover to generate high-quality neighbors by intelligently recombining promising path segments from diverse solutions while maintaining feasibility through adaptive grouping validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    if n <= 2:\n        return base_solution\n\n    # Adaptive node grouping\n    group_size = max(2, n // 4)\n    groups = []\n    for i in range(0, n, group_size):\n        groups.append(base_solution[i:i+group_size])\n\n    # Select two different groups for crossover\n    i, j = np.random.choice(len(groups), size=2, replace=False)\n\n    # Create a new solution by combining groups\n    new_solution = np.concatenate([groups[i], groups[j]])\n\n    # Complete the tour by adding remaining nodes in order\n    remaining_nodes = np.setdiff1d(base_solution, new_solution)\n    new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    # Guided segment crossover\n    crossover_point = np.random.randint(1, len(groups[i]))\n    temp = new_solution[:crossover_point].copy()\n    new_solution[:crossover_point] = new_solution[crossover_point:crossover_point+len(temp)]\n    new_solution[crossover_point:crossover_point+len(temp)] = temp\n\n    # Path relinking with objective guidance\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8465013282123091,
            0.46003735065460205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    if n <= 2:\n        return base_solution\n\n    # Adaptive node grouping\n    group_size = max(2, n // 4)\n    groups = []\n    for i in range(0, n, group_size):\n        groups.append(base_solution[i:i+group_size])\n\n    # Select two different groups for crossover\n    i, j = np.random.choice(len(groups), size=2, replace=False)\n\n    # Create a new solution by combining groups\n    new_solution = np.concatenate([groups[i], groups[j]])\n\n    # Complete the tour by adding remaining nodes in order\n    remaining_nodes = np.setdiff1d(base_solution, new_solution)\n    new_solution = np.concatenate([new_solution, remaining_nodes])\n\n    # Guided segment crossover\n    crossover_point = np.random.randint(1, len(groups[i]))\n    temp = new_solution[:crossover_point].copy()\n    new_solution[:crossover_point] = new_solution[crossover_point:crossover_point+len(temp)]\n    new_solution[crossover_point:crossover_point+len(temp)] = temp\n\n    # Path relinking with objective guidance\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{This new algorithm selects a solution from the archive based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion, while ensuring feasibility by using a fallback to a simple swap if the insertion breaks the tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with distance-based guidance\n    i = np.random.randint(1, n - 1)\n    node = new_solution[i]\n    candidates = list(range(n))\n    candidates.remove(i)\n    if i > 0:\n        candidates.remove(i - 1)\n    if i < n - 1:\n        candidates.remove(i + 1)\n\n    # Select insertion position based on distance improvement\n    min_cost = float('inf')\n    best_j = -1\n    for j in candidates:\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, i)\n        temp_solution = np.insert(temp_solution, j, node)\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_j = j\n\n    if best_j != -1:\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, best_j, node)\n    else:\n        # Fallback to simple swap\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9574360787386036,
            1.0507532358169556
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with distance-based guidance\n    i = np.random.randint(1, n - 1)\n    node = new_solution[i]\n    candidates = list(range(n))\n    candidates.remove(i)\n    if i > 0:\n        candidates.remove(i - 1)\n    if i < n - 1:\n        candidates.remove(i + 1)\n\n    # Select insertion position based on distance improvement\n    min_cost = float('inf')\n    best_j = -1\n    for j in candidates:\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, i)\n        temp_solution = np.insert(temp_solution, j, node)\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n))\n        total_cost = cost1 + cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_j = j\n\n    if best_j != -1:\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, best_j, node)\n    else:\n        # Fallback to simple swap\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic segment size\n    max_segment = min(7, n // 2)\n    segment_length = np.random.randint(3, max_segment + 1)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with objective-aware selection\n    i = np.random.randint(1, n - 1)\n    node = new_solution[i]\n\n    # Find insertion positions that improve both objectives\n    candidates = []\n    for j in range(n):\n        if j == i or j == i - 1:\n            continue\n        # Calculate potential improvement\n        prev = new_solution[i - 1]\n        next_node = new_solution[j] if j < n - 1 else new_solution[0]\n        current_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, new_solution[(i + 1) % n]]\n        current_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, new_solution[(i + 1) % n]]\n        new_cost1 = distance_matrix_1[prev, next_node] + distance_matrix_1[node, new_solution[(j + 1) % n]]\n        new_cost2 = distance_matrix_2[prev, next_node] + distance_matrix_2[node, new_solution[(j + 1) % n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            candidates.append(j)\n\n    if candidates:\n        j = np.random.choice(candidates)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9236769888172598,
            0.5725894570350647
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic segment size\n    max_segment = min(7, n // 2)\n    segment_length = np.random.randint(3, max_segment + 1)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with objective-aware selection\n    i = np.random.randint(1, n - 1)\n    node = new_solution[i]\n\n    # Find insertion positions that improve both objectives\n    candidates = []\n    for j in range(n):\n        if j == i or j == i - 1:\n            continue\n        # Calculate potential improvement\n        prev = new_solution[i - 1]\n        next_node = new_solution[j] if j < n - 1 else new_solution[0]\n        current_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, new_solution[(i + 1) % n]]\n        current_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, new_solution[(i + 1) % n]]\n        new_cost1 = distance_matrix_1[prev, next_node] + distance_matrix_1[node, new_solution[(j + 1) % n]]\n        new_cost2 = distance_matrix_2[prev, next_node] + distance_matrix_2[node, new_solution[(j + 1) % n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            candidates.append(j)\n\n    if candidates:\n        j = np.random.choice(candidates)\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange, insertion, and a novel path reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange, insertion, and path reversal\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Apply path reversal between two random points\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9215744549214325,
            0.3238123655319214
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange, insertion, and path reversal\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n        # Apply path reversal between two random points\n        a = random.randint(0, n-2)\n        b = random.randint(a+1, n-1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized improvement potential in both objectives, using a weighted score function with different weights, then applies a hybrid local search combining adaptive segment relocation and constrained edge inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    relocate_length = min(4, n // 3)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8863189585352624,
            0.3695251941680908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    relocate_length = min(4, n // 3)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive segment rotation and constrained node reinsertion to generate a neighbor solution while ensuring feasibility, using a multi-objective improvement metric that balances both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Constrained node reinsertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or abs(j - i) < 2:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a + 1))\n\n    return new_solution\n\n",
        "score": [
            -0.7539705550052144,
            0.3807747960090637
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 5)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Constrained node reinsertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or abs(j - i) < 2:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        insert_pos = np.random.randint(0, len(new_solution) - 1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a + 1))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{The new algorithm combines adaptive objective-weighted node sampling with a multi-phase local search that alternates between segment-based perturbations and cluster-aware edge flips to generate high-quality neighbors by intelligently balancing exploration and exploitation of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with probability inversely proportional to its objective sum\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if len(objectives) > 1:\n        probs = 1 / (objectives - np.min(objectives) + 1e-6)\n        probs = probs / np.sum(probs)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-phase local search\n    for phase in range(2):\n        # Phase 1: Segment-based perturbations\n        if phase == 0:\n            # Select a random segment and reverse it\n            seg_start = np.random.randint(0, n-2)\n            seg_end = np.random.randint(seg_start+2, n)\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Phase 2: Cluster-aware edge flips\n        else:\n            # Identify clusters based on objective-weighted distances\n            cluster_size = max(2, n // 4)\n            clusters = []\n            for i in range(0, n, cluster_size):\n                clusters.append(new_solution[i:i+cluster_size])\n\n            # Randomly select two clusters and flip edges between them\n            if len(clusters) > 1:\n                i, j = np.random.choice(len(clusters), 2, replace=False)\n                cluster_i = clusters[i]\n                cluster_j = clusters[j]\n\n                # Flip edges between nodes in different clusters\n                for node_i in cluster_i:\n                    for node_j in cluster_j:\n                        pos_i = np.where(new_solution == node_i)[0][0]\n                        pos_j = np.where(new_solution == node_j)[0][0]\n\n                        # Calculate potential improvement\n                        delta1 = (distance_matrix_1[new_solution[pos_i-1], node_j] + distance_matrix_1[node_j, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_1[new_solution[pos_j-1], node_i] + distance_matrix_1[node_i, new_solution[(pos_j+1)%n]]) - \\\n                                (distance_matrix_1[new_solution[pos_i-1], node_i] + distance_matrix_1[node_i, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_1[new_solution[pos_j-1], node_j] + distance_matrix_1[node_j, new_solution[(pos_j+1)%n]])\n\n                        delta2 = (distance_matrix_2[new_solution[pos_i-1], node_j] + distance_matrix_2[node_j, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_2[new_solution[pos_j-1], node_i] + distance_matrix_2[node_i, new_solution[(pos_j+1)%n]]) - \\\n                                (distance_matrix_2[new_solution[pos_i-1], node_i] + distance_matrix_2[node_i, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_2[new_solution[pos_j-1], node_j] + distance_matrix_2[node_j, new_solution[(pos_j+1)%n]])\n\n                        # Accept if both objectives improve or with probability\n                        if (delta1 < 0 and delta2 < 0) or (np.random.rand() < 0.2 and (delta1 < 0 or delta2 < 0)):\n                            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n                            break\n\n    return new_solution\n\n",
        "score": [
            -0.8782096857603121,
            0.7016309499740601
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with probability inversely proportional to its objective sum\n    objectives = np.array([sum(obj) for _, obj in archive])\n    if len(objectives) > 1:\n        probs = 1 / (objectives - np.min(objectives) + 1e-6)\n        probs = probs / np.sum(probs)\n        selected_idx = np.random.choice(len(archive), p=probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-phase local search\n    for phase in range(2):\n        # Phase 1: Segment-based perturbations\n        if phase == 0:\n            # Select a random segment and reverse it\n            seg_start = np.random.randint(0, n-2)\n            seg_end = np.random.randint(seg_start+2, n)\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n\n        # Phase 2: Cluster-aware edge flips\n        else:\n            # Identify clusters based on objective-weighted distances\n            cluster_size = max(2, n // 4)\n            clusters = []\n            for i in range(0, n, cluster_size):\n                clusters.append(new_solution[i:i+cluster_size])\n\n            # Randomly select two clusters and flip edges between them\n            if len(clusters) > 1:\n                i, j = np.random.choice(len(clusters), 2, replace=False)\n                cluster_i = clusters[i]\n                cluster_j = clusters[j]\n\n                # Flip edges between nodes in different clusters\n                for node_i in cluster_i:\n                    for node_j in cluster_j:\n                        pos_i = np.where(new_solution == node_i)[0][0]\n                        pos_j = np.where(new_solution == node_j)[0][0]\n\n                        # Calculate potential improvement\n                        delta1 = (distance_matrix_1[new_solution[pos_i-1], node_j] + distance_matrix_1[node_j, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_1[new_solution[pos_j-1], node_i] + distance_matrix_1[node_i, new_solution[(pos_j+1)%n]]) - \\\n                                (distance_matrix_1[new_solution[pos_i-1], node_i] + distance_matrix_1[node_i, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_1[new_solution[pos_j-1], node_j] + distance_matrix_1[node_j, new_solution[(pos_j+1)%n]])\n\n                        delta2 = (distance_matrix_2[new_solution[pos_i-1], node_j] + distance_matrix_2[node_j, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_2[new_solution[pos_j-1], node_i] + distance_matrix_2[node_i, new_solution[(pos_j+1)%n]]) - \\\n                                (distance_matrix_2[new_solution[pos_i-1], node_i] + distance_matrix_2[node_i, new_solution[(pos_i+1)%n]] +\n                                 distance_matrix_2[new_solution[pos_j-1], node_j] + distance_matrix_2[node_j, new_solution[(pos_j+1)%n]])\n\n                        # Accept if both objectives improve or with probability\n                        if (delta1 < 0 and delta2 < 0) or (np.random.rand() < 0.2 and (delta1 < 0 or delta2 < 0)):\n                            new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n                            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8233933951502936,
            0.272746741771698
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{A novel hybrid local search operator that combines a guided segment relocation strategy with an adaptive edge reversal mechanism to generate high-quality neighbors while ensuring feasibility by preserving the tour structure through intelligent node reinsertion and edge swapping.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity\n        objectives = np.array([obj for _, obj in archive])\n        means = np.mean(objectives, axis=0)\n        diversity = np.sum(np.abs(objectives - means), axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Guided segment relocation\n    seg_size = min(4, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate potential improvement\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    # Try inserting segment at different positions\n    best_pos = -1\n    best_improvement = 0\n    for pos in range(n - seg_size + 1):\n        if pos >= a and pos <= b:\n            continue\n        new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(pos+seg_size)%n]]\n        new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(pos+seg_size)%n]]\n        improvement = (current_cost1 - new_cost1 + current_cost2 - new_cost2) / 2\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Adaptive edge reversal\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 < current_edge1 or new_edge2 < current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random node reinsertion\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        node = new_solution[p]\n        new_solution = np.delete(new_solution, p)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8326211084524834,
            0.34895777702331543
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate objective diversity\n        objectives = np.array([obj for _, obj in archive])\n        means = np.mean(objectives, axis=0)\n        diversity = np.sum(np.abs(objectives - means), axis=1)\n        selected_idx = np.argmax(diversity)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Guided segment relocation\n    seg_size = min(4, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate potential improvement\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    # Try inserting segment at different positions\n    best_pos = -1\n    best_improvement = 0\n    for pos in range(n - seg_size + 1):\n        if pos >= a and pos <= b:\n            continue\n        new_cost1 = distance_matrix_1[new_solution[pos-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(pos+seg_size)%n]]\n        new_cost2 = distance_matrix_2[new_solution[pos-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(pos+seg_size)%n]]\n        improvement = (current_cost1 - new_cost1 + current_cost2 - new_cost2) / 2\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        segment = new_solution[a:b+1]\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n        new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Adaptive edge reversal\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 < current_edge1 or new_edge2 < current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random node reinsertion\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        node = new_solution[p]\n        new_solution = np.delete(new_solution, p)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel hybrid local search operator that intelligently selects diverse solutions from the archive, combines a randomized segment crossover with a guided node relocation strategy to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    norm_obj = objectives / max_obj\n    weights = norm_obj.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment crossover with another solution\n    other_idx = np.random.choice(len(archive))\n    other_solution = archive[other_idx][0].copy()\n    seg_size = min(5, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = other_solution[a:b+1]\n\n    # Guided node relocation with adaptive selection\n    for i in range(n):\n        current_node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Find best insertion point for current node\n        best_pos = -1\n        min_cost = float('inf')\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n            # Calculate cost of moving current node to position j\n            cost1 = distance_matrix_1[prev_node, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], next_node]\n            cost2 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n            delta1 = (cost2 - cost1) + distance_matrix_1[new_solution[(j-1)%n], current_node] + distance_matrix_1[current_node, new_solution[j]] - distance_matrix_1[new_solution[(j-1)%n], new_solution[j]]\n\n            cost1 = distance_matrix_2[prev_node, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(i-1)%n], next_node]\n            cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n            delta2 = (cost2 - cost1) + distance_matrix_2[new_solution[(j-1)%n], current_node] + distance_matrix_2[current_node, new_solution[j]] - distance_matrix_2[new_solution[(j-1)%n], new_solution[j]]\n\n            total_delta = delta1 + delta2\n            if total_delta < min_cost:\n                min_cost = total_delta\n                best_pos = j\n\n        if best_pos != -1 and (min_cost < 0 or np.random.rand() < 0.3):\n            # Perform the relocation\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            if best_pos > i:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.7056109079231561,
            2.290232241153717
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    max_obj = objectives.max(axis=0)\n    norm_obj = objectives / max_obj\n    weights = norm_obj.sum(axis=1)\n    selected_idx = np.random.choice(len(archive), p=weights/weights.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment crossover with another solution\n    other_idx = np.random.choice(len(archive))\n    other_solution = archive[other_idx][0].copy()\n    seg_size = min(5, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = other_solution[a:b+1]\n\n    # Guided node relocation with adaptive selection\n    for i in range(n):\n        current_node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Find best insertion point for current node\n        best_pos = -1\n        min_cost = float('inf')\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n            # Calculate cost of moving current node to position j\n            cost1 = distance_matrix_1[prev_node, new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], next_node]\n            cost2 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n            delta1 = (cost2 - cost1) + distance_matrix_1[new_solution[(j-1)%n], current_node] + distance_matrix_1[current_node, new_solution[j]] - distance_matrix_1[new_solution[(j-1)%n], new_solution[j]]\n\n            cost1 = distance_matrix_2[prev_node, new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(i-1)%n], next_node]\n            cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n            delta2 = (cost2 - cost1) + distance_matrix_2[new_solution[(j-1)%n], current_node] + distance_matrix_2[current_node, new_solution[j]] - distance_matrix_2[new_solution[(j-1)%n], new_solution[j]]\n\n            total_delta = delta1 + delta2\n            if total_delta < min_cost:\n                min_cost = total_delta\n                best_pos = j\n\n        if best_pos != -1 and (min_cost < 0 or np.random.rand() < 0.3):\n            # Perform the relocation\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            if best_pos > i:\n                best_pos -= 1\n            new_solution = np.insert(new_solution, best_pos, node_to_move)\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This new algorithm employs a hybrid approach combining adaptive segment inversion with multi-objective edge swapping, where segments are dynamically sized based on node proximity and edges are swapped based on their combined objective improvement potential while maintaining feasibility through segment validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    segment_length = max(2, n // 4)\n    for _ in range(3):  # Perform multiple inversion attempts\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Invert segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Swap edges\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9285083740679616,
            0.9027952551841736
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    segment_length = max(2, n // 4)\n    for _ in range(3):  # Perform multiple inversion attempts\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Invert segment\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Multi-objective edge swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate current cost\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Swap edges\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This new algorithm uses adaptive segment inversion with multi-objective validation, where it randomly selects segments of varying lengths to invert, evaluates the improvement in both objectives, and accepts the inversion if it shows non-dominated improvement or meets a probabilistic acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    for _ in range(3):\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n",
        "score": [
            -0.7494207152919136,
            1.3104233145713806
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    for _ in range(3):\n        segment_length = np.random.randint(2, min(5, n//2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        temp_solution = new_solution.copy()\n        temp_solution[start:end] = temp_solution[start:end][::-1]\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n            current_cost1, current_cost2 = new_cost1, new_cost2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined objective score, then applies a novel hybrid local search combining adaptive segment reversal and constrained node insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives and incorporating a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = min(5, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained node insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate current and potential new connections\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n        new_cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Insert with probability based on improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n",
        "score": [
            -0.850566511670412,
            0.3165637254714966
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = min(5, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained node insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate current and potential new connections\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[(i-1)%n], new_solution[i]]\n        new_cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[(i-1)%n], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        # Insert with probability based on improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[i:j] = np.flip(new_solution[i:j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{This new algorithm combines a multi-objective tour rebalancing strategy with adaptive node pairing to generate high-quality neighbors by intelligently reordering node pairs based on their combined objective improvement potential while ensuring feasibility through pairwise validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node pairing\n    pair_size = max(2, n // 4)\n    pairs = []\n    for i in range(0, n, pair_size):\n        pairs.append(new_solution[i:i+pair_size])\n\n    # Multi-objective tour rebalancing\n    for _ in range(3):  # Perform multiple rebalancing attempts\n        i = np.random.randint(0, len(pairs))\n        j = np.random.randint(0, len(pairs))\n        while j == i:\n            j = np.random.randint(0, len(pairs))\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try rebalancing pairs\n        pair_i = pairs[i]\n        pair_j = pairs[j]\n\n        # Evaluate all possible pair swaps\n        for pos_i in range(len(pair_i)):\n            for pos_j in range(len(pair_j)):\n                temp_solution = new_solution.copy()\n                # Swap nodes between pairs\n                idx_i = np.where(new_solution == pair_i[pos_i])[0][0]\n                idx_j = np.where(new_solution == pair_j[pos_j])[0][0]\n                temp_solution[idx_i], temp_solution[idx_j] = temp_solution[idx_j], temp_solution[idx_i]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                # Accept if both objectives improve or with probability\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 * (1 - (i / len(pairs))) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    # Additional random pair reordering for diversity\n    if np.random.rand() < 0.15:\n        for pair in pairs:\n            if len(pair) > 1:\n                idx = np.where(new_solution == pair[0])[0][0]\n                new_solution[idx:idx+len(pair)] = np.random.permutation(new_solution[idx:idx+len(pair)])\n\n    return new_solution\n\n",
        "score": [
            -0.9278064335005182,
            2.3580824732780457
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node pairing\n    pair_size = max(2, n // 4)\n    pairs = []\n    for i in range(0, n, pair_size):\n        pairs.append(new_solution[i:i+pair_size])\n\n    # Multi-objective tour rebalancing\n    for _ in range(3):  # Perform multiple rebalancing attempts\n        i = np.random.randint(0, len(pairs))\n        j = np.random.randint(0, len(pairs))\n        while j == i:\n            j = np.random.randint(0, len(pairs))\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try rebalancing pairs\n        pair_i = pairs[i]\n        pair_j = pairs[j]\n\n        # Evaluate all possible pair swaps\n        for pos_i in range(len(pair_i)):\n            for pos_j in range(len(pair_j)):\n                temp_solution = new_solution.copy()\n                # Swap nodes between pairs\n                idx_i = np.where(new_solution == pair_i[pos_i])[0][0]\n                idx_j = np.where(new_solution == pair_j[pos_j])[0][0]\n                temp_solution[idx_i], temp_solution[idx_j] = temp_solution[idx_j], temp_solution[idx_i]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                # Accept if both objectives improve or with probability\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 * (1 - (i / len(pairs))) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    # Additional random pair reordering for diversity\n    if np.random.rand() < 0.15:\n        for pair in pairs:\n            if len(pair) > 1:\n                idx = np.where(new_solution == pair[0])[0][0]\n                new_solution[idx:idx+len(pair)] = np.random.permutation(new_solution[idx:idx+len(pair)])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of objective dominance ranking and random selection, then applies a novel multi-segment inversion strategy that adaptively selects segments based on their potential for improvement in both objectives, followed by a guided edge insertion mechanism that considers both objective improvements and spatial proximity to create a high-quality neighbor solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion with adaptive segment selection\n    num_segments = min(3, n // 5)\n    segment_lengths = np.random.randint(2, min(7, n // 3), size=num_segments)\n    segment_starts = np.random.choice(n - max(segment_lengths), size=num_segments, replace=False)\n\n    for start, length in zip(segment_starts, segment_lengths):\n        end = start + length - 1\n        # Check potential improvement in both objectives\n        current_cost1 = distance_matrix_1[base_solution[start], base_solution[(start-1)%n]] + distance_matrix_1[base_solution[end], base_solution[(end+1)%n]]\n        current_cost2 = distance_matrix_2[base_solution[start], base_solution[(start-1)%n]] + distance_matrix_2[base_solution[end], base_solution[(end+1)%n]]\n        inverted_cost1 = distance_matrix_1[base_solution[end], base_solution[(start-1)%n]] + distance_matrix_1[base_solution[start], base_solution[(end+1)%n]]\n        inverted_cost2 = distance_matrix_2[base_solution[end], base_solution[(start-1)%n]] + distance_matrix_2[base_solution[start], base_solution[(end+1)%n]]\n\n        if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (sum(segment_lengths) / n))):\n            new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Guided edge insertion with spatial consideration\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate spatial distance in both objectives\n        spatial_dist1 = np.linalg.norm(instance[new_solution[i]][:2] - instance[new_solution[k]][:2])\n        spatial_dist2 = np.linalg.norm(instance[new_solution[i]][2:] - instance[new_solution[k]][2:])\n\n        if (distance_matrix_1[new_solution[i], new_solution[k]] < distance_matrix_1[new_solution[i], new_solution[j]] and\n            distance_matrix_2[new_solution[i], new_solution[k]] < distance_matrix_2[new_solution[i], new_solution[j]]) or \\\n           (spatial_dist1 < spatial_dist2 and np.random.rand() < 0.2):\n            # Insert k between i and j\n            new_solution = np.concatenate([new_solution[:j], [new_solution[k]], new_solution[j:k], new_solution[k+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.827691591526155,
            11.581585109233856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment inversion with adaptive segment selection\n    num_segments = min(3, n // 5)\n    segment_lengths = np.random.randint(2, min(7, n // 3), size=num_segments)\n    segment_starts = np.random.choice(n - max(segment_lengths), size=num_segments, replace=False)\n\n    for start, length in zip(segment_starts, segment_lengths):\n        end = start + length - 1\n        # Check potential improvement in both objectives\n        current_cost1 = distance_matrix_1[base_solution[start], base_solution[(start-1)%n]] + distance_matrix_1[base_solution[end], base_solution[(end+1)%n]]\n        current_cost2 = distance_matrix_2[base_solution[start], base_solution[(start-1)%n]] + distance_matrix_2[base_solution[end], base_solution[(end+1)%n]]\n        inverted_cost1 = distance_matrix_1[base_solution[end], base_solution[(start-1)%n]] + distance_matrix_1[base_solution[start], base_solution[(end+1)%n]]\n        inverted_cost2 = distance_matrix_2[base_solution[end], base_solution[(start-1)%n]] + distance_matrix_2[base_solution[start], base_solution[(end+1)%n]]\n\n        if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (sum(segment_lengths) / n))):\n            new_solution[start:end+1] = np.flip(new_solution[start:end+1])\n\n    # Guided edge insertion with spatial consideration\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate spatial distance in both objectives\n        spatial_dist1 = np.linalg.norm(instance[new_solution[i]][:2] - instance[new_solution[k]][:2])\n        spatial_dist2 = np.linalg.norm(instance[new_solution[i]][2:] - instance[new_solution[k]][2:])\n\n        if (distance_matrix_1[new_solution[i], new_solution[k]] < distance_matrix_1[new_solution[i], new_solution[j]] and\n            distance_matrix_2[new_solution[i], new_solution[k]] < distance_matrix_2[new_solution[i], new_solution[j]]) or \\\n           (spatial_dist1 < spatial_dist2 and np.random.rand() < 0.2):\n            # Insert k between i and j\n            new_solution = np.concatenate([new_solution[:j], [new_solution[k]], new_solution[j:k], new_solution[k+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8759493807575216,
            0.17495423555374146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8759493807575216,
            0.17495423555374146
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{This novel algorithm selects a high-potential solution from the archive using a weighted combination of objective values, then applies a hybrid local search combining adaptive segment reversal and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted improvement potential\n    weights = [0.6, 0.4]  # Weight for each objective\n    potential = [w1 * obj[0] + w2 * obj[1] for (sol, obj), w1, w2 in zip(archive, weights, weights)]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with objective-aware selection\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        if len(segment) < 2:\n            continue\n\n        # Evaluate segment reversal impact\n        original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[i:i+segment_length] = segment[::-1]\n\n    # Step 2: Guided node insertion for diversity\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8019875911603702,
            0.2722073793411255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted improvement potential\n    weights = [0.6, 0.4]  # Weight for each objective\n    potential = [w1 * obj[0] + w2 * obj[1] for (sol, obj), w1, w2 in zip(archive, weights, weights)]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with objective-aware selection\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segment = new_solution[i:i+segment_length]\n        if len(segment) < 2:\n            continue\n\n        # Evaluate segment reversal impact\n        original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[i:i+segment_length] = segment[::-1]\n\n    # Step 2: Guided node insertion for diversity\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i != j:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective diversity and structural diversity, then applies a novel hybrid local search combining adaptive segment relocation and constrained edge insertion to generate a neighbor solution while ensuring feasibility, using a multi-objective evaluation of improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on both objectives and structural diversity\n        objectives = np.array([obj for _, obj in archive])\n        objective_diversity = np.std(objectives, axis=0)\n        structural_diversity = [np.mean([np.abs(np.where(sol == node)[0][0] - np.where(archive[0][0] == node)[0][0])\n                                        for node in archive[0][0]]) for sol, _ in archive]\n        scores = 0.5 * objective_diversity[0] + 0.3 * objective_diversity[1] + 0.2 * np.array(structural_diversity)\n        selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Constrained edge insertion\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9304052632441766,
            2.3462283611297607
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate diversity scores based on both objectives and structural diversity\n        objectives = np.array([obj for _, obj in archive])\n        objective_diversity = np.std(objectives, axis=0)\n        structural_diversity = [np.mean([np.abs(np.where(sol == node)[0][0] - np.where(archive[0][0] == node)[0][0])\n                                        for node in archive[0][0]]) for sol, _ in archive]\n        scores = 0.5 * objective_diversity[0] + 0.3 * objective_diversity[1] + 0.2 * np.array(structural_diversity)\n        selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Constrained edge insertion\n    for _ in range(2):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        node = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node], new_solution[b:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This novel algorithm selects a solution from the archive based on objective dominance, then applies a hybrid local search combining adaptive segment inversion and objective-biased edge swapping to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best objective balance (minimizing sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = max(2, n // 4)\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + \\\n                         distance_matrix_1[new_solution[end-1], new_solution[end % n]]\n        original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + \\\n                         distance_matrix_2[new_solution[end-1], new_solution[end % n]]\n        reversed_cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + \\\n                         distance_matrix_1[segment[0], new_solution[end % n]]\n        reversed_cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + \\\n                         distance_matrix_2[segment[0], new_solution[end % n]]\n\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[start:end] = segment[::-1]\n\n    # Step 2: Objective-biased edge swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1:\n            continue\n\n        # Calculate original and new costs\n        original_edges = [(new_solution[i-1], new_solution[i]), (new_solution[i], new_solution[(i+1)%n]),\n                          (new_solution[j-1], new_solution[j]), (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[j], new_solution[(i+1)%n]),\n                      (new_solution[j-1], new_solution[i]), (new_solution[i], new_solution[(j+1)%n])]\n\n        original_cost1 = sum(distance_matrix_1[a, b] for a, b in original_edges)\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        original_cost2 = sum(distance_matrix_2[a, b] for a, b in original_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7578128986663946,
            1.1647616028785706
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best objective balance (minimizing sum of normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / np.max(objectives, axis=0)\n    scores = np.sum(normalized, axis=1)\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = max(2, n // 4)\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_length + 1)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        original_cost1 = distance_matrix_1[new_solution[start-1], new_solution[start]] + \\\n                         distance_matrix_1[new_solution[end-1], new_solution[end % n]]\n        original_cost2 = distance_matrix_2[new_solution[start-1], new_solution[start]] + \\\n                         distance_matrix_2[new_solution[end-1], new_solution[end % n]]\n        reversed_cost1 = distance_matrix_1[new_solution[start-1], segment[-1]] + \\\n                         distance_matrix_1[segment[0], new_solution[end % n]]\n        reversed_cost2 = distance_matrix_2[new_solution[start-1], segment[-1]] + \\\n                         distance_matrix_2[segment[0], new_solution[end % n]]\n\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[start:end] = segment[::-1]\n\n    # Step 2: Objective-biased edge swapping\n    for _ in range(3):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1:\n            continue\n\n        # Calculate original and new costs\n        original_edges = [(new_solution[i-1], new_solution[i]), (new_solution[i], new_solution[(i+1)%n]),\n                          (new_solution[j-1], new_solution[j]), (new_solution[j], new_solution[(j+1)%n])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[j], new_solution[(i+1)%n]),\n                      (new_solution[j-1], new_solution[i]), (new_solution[i], new_solution[(j+1)%n])]\n\n        original_cost1 = sum(distance_matrix_1[a, b] for a, b in original_edges)\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        original_cost2 = sum(distance_matrix_2[a, b] for a, b in original_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.4 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8055914123336299,
            0.16598361730575562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8055914123336299,
            0.16598361730575562
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{This new algorithm employs a dynamic segment inversion and adaptive edge insertion strategy that intelligently selects and inverts segments of the tour based on their combined objective improvement potential, then inserts new edges through a constrained optimization process to balance both objectives while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Try inserting edge between i and j\n        temp_solution = new_solution.copy()\n        if i < j:\n            temp_solution = np.concatenate([temp_solution[:i+1], [temp_solution[j]], temp_solution[i+1:j], temp_solution[j+1:]])\n        else:\n            temp_solution = np.concatenate([temp_solution[:j+1], [temp_solution[i]], temp_solution[j+1:i], temp_solution[i+1:]])\n\n        new_cost1 = distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_1[temp_solution[(i+2)%n], temp_solution[(i+3)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[(i+2)%n], temp_solution[(i+3)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8459625115536153,
            0.3395993113517761
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment inversion\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Try inserting edge between i and j\n        temp_solution = new_solution.copy()\n        if i < j:\n            temp_solution = np.concatenate([temp_solution[:i+1], [temp_solution[j]], temp_solution[i+1:j], temp_solution[j+1:]])\n        else:\n            temp_solution = np.concatenate([temp_solution[:j+1], [temp_solution[i]], temp_solution[j+1:i], temp_solution[i+1:]])\n\n        new_cost1 = distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_1[temp_solution[(i+2)%n], temp_solution[(i+3)%n]]\n        new_cost2 = distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[(i+2)%n], temp_solution[(i+3)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution = temp_solution\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective improvement potential and solution quality, then applies a hybrid local search combining adaptive partial path reversal with constrained node reinsertion, ensuring feasibility through careful position selection and validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(normalized_obj[i] - normalized_obj)) for i in range(len(archive))])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive partial path reversal with constrained segment\n    segment_length = max(3, min(7, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Constrained node reinsertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n or j == (i + 2) % n or j == (i - 2) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 4)\n        new_solution[start:start+4] = new_solution[start:start+4][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8565353954456079,
            0.2559691071510315
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(normalized_obj[i] - normalized_obj)) for i in range(len(archive))])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive partial path reversal with constrained segment\n    segment_length = max(3, min(7, n // 4))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Constrained node reinsertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n or j == (i + 2) % n or j == (i - 2) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 4)\n        new_solution[start:start+4] = new_solution[start:start+4][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive segment rotation and objective-balanced edge replacement to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = max(3, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Objective-balanced edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + np.random.randint(2, min(5, n//2))) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Balanced acceptance criteria\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1) or \\\n           (np.random.rand() < 0.3 and (new_cost1 + new_cost2) < (current_cost1 + current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random segment shuffle for diversity\n    if np.random.rand() < 0.15:\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        np.random.shuffle(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7440292960077688,
            0.44912320375442505
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = max(3, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Objective-balanced edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + np.random.randint(2, min(5, n//2))) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Balanced acceptance criteria\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1) or \\\n           (np.random.rand() < 0.3 and (new_cost1 + new_cost2) < (current_cost1 + current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random segment shuffle for diversity\n    if np.random.rand() < 0.15:\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        np.random.shuffle(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A novel hybrid local search operator that combines a Pareto-guided segment inversion with a dynamic edge swapping strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Pareto-guided segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Check if inversion improves Pareto front\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    inverted_segment = segment[::-1]\n    new_cost1 = current_cost1 - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    new_cost1 += distance_matrix_1[new_solution[a-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(b+1)%n]]\n\n    new_cost2 = current_cost2 - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n    new_cost2 += distance_matrix_2[new_solution[a-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(b+1)%n]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n        new_solution[a:b+1] = inverted_segment\n\n    # Dynamic edge swapping\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6144803521594986,
            3.2391059398651123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Pareto-guided segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Check if inversion improves Pareto front\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    inverted_segment = segment[::-1]\n    new_cost1 = current_cost1 - distance_matrix_1[new_solution[a-1], new_solution[a]] - distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    new_cost1 += distance_matrix_1[new_solution[a-1], inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], new_solution[(b+1)%n]]\n\n    new_cost2 = current_cost2 - distance_matrix_2[new_solution[a-1], new_solution[a]] - distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n    new_cost2 += distance_matrix_2[new_solution[a-1], inverted_segment[0]] + distance_matrix_2[inverted_segment[-1], new_solution[(b+1)%n]]\n\n    if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n        new_solution[a:b+1] = inverted_segment\n\n    # Dynamic edge swapping\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion, but with modified segment length and insertion probability to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with modified segment length\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with modified probability\n    if np.random.random() < 0.7:\n        i = np.random.randint(1, n - 1)\n        j = np.random.randint(0, n)\n        while j == i or j == i - 1:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9122370874777476,
            0.31971055269241333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 0.8, len(archive)) / np.sum(np.linspace(0.2, 0.8, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with modified segment length\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with modified probability\n    if np.random.random() < 0.7:\n        i = np.random.randint(1, n - 1)\n        j = np.random.randint(0, n)\n        while j == i or j == i - 1:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 2)\n        new_solution[start:start+2] = new_solution[start:start+2][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined diversity and objective improvement metric, then applies a novel hybrid local search combining adaptive k-opt moves with guided node insertion and constrained edge reversal, ensuring feasibility through dynamic validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high diversity and improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n    for i, (sol, _) in enumerate(archive):\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                diversity_scores[i] += np.sum(sol != other_sol)\n    diversity_scores = diversity_scores / diversity_scores.max() if diversity_scores.max() > 0 else np.ones(len(archive))\n    improvement_scores = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.5 * diversity_scores + 0.3 * improvement_scores[:, 0] + 0.2 * improvement_scores[:, 1]\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k=3 or 4)\n    k = np.random.choice([3, 4])\n    if k == 3:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b+1] = np.concatenate([new_solution[b:b+1], new_solution[a:b]])\n        new_solution[b:c+1] = np.concatenate([new_solution[c:c+1], new_solution[b:c]])\n    else:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        new_solution[a:b+1] = np.concatenate([new_solution[b:b+1], new_solution[a:b]])\n        new_solution[b:c+1] = np.concatenate([new_solution[c:c+1], new_solution[b:c]])\n        new_solution[c:d+1] = np.concatenate([new_solution[d:d+1], new_solution[c:d]])\n\n    # Guided node insertion with objective awareness\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.3):\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Constrained edge reversal with objective consideration\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8211275533215594,
            1.1068416833877563
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high diversity and improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n    for i, (sol, _) in enumerate(archive):\n        for j, (other_sol, _) in enumerate(archive):\n            if i != j:\n                diversity_scores[i] += np.sum(sol != other_sol)\n    diversity_scores = diversity_scores / diversity_scores.max() if diversity_scores.max() > 0 else np.ones(len(archive))\n    improvement_scores = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.5 * diversity_scores + 0.3 * improvement_scores[:, 0] + 0.2 * improvement_scores[:, 1]\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k=3 or 4)\n    k = np.random.choice([3, 4])\n    if k == 3:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        new_solution[a:b+1] = np.concatenate([new_solution[b:b+1], new_solution[a:b]])\n        new_solution[b:c+1] = np.concatenate([new_solution[c:c+1], new_solution[b:c]])\n    else:\n        a, b, c, d = sorted(np.random.choice(n, 4, replace=False))\n        new_solution[a:b+1] = np.concatenate([new_solution[b:b+1], new_solution[a:b]])\n        new_solution[b:c+1] = np.concatenate([new_solution[c:c+1], new_solution[b:c]])\n        new_solution[c:d+1] = np.concatenate([new_solution[d:d+1], new_solution[c:d]])\n\n    # Guided node insertion with objective awareness\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.3):\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Constrained edge reversal with objective consideration\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (np.random.rand() < 0.2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and structural diversity, then applies a novel hybrid local search combining adaptive sub-tour inversion with guided multi-node relocation to generate a neighbor solution while ensuring feasibility through dynamic constraint validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(len(archive)) if i != j])\n    diversity_scores = np.mean(diversity_scores.reshape(len(archive), -1), axis=1)\n    scores = 0.5 * improvement_potential.mean(axis=1) + 0.3 * diversity_scores + 0.2 * np.random.rand(len(archive))\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive sub-tour inversion\n    k = min(4, n // 3)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if b - a > k:\n        a = np.random.randint(a, b - k)\n        b = a + k\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Guided multi-node relocation\n    m = min(3, n // 5)\n    nodes_to_relocate = np.random.choice(n, m, replace=False)\n    insertion_points = np.random.choice(n, m, replace=False)\n    for node, point in zip(nodes_to_relocate, insertion_points):\n        if point > node:\n            point -= 1\n        new_solution = np.delete(new_solution, node)\n        new_solution = np.insert(new_solution, point, base_solution[node])\n\n    # Dynamic constraint validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n",
        "score": [
            -0.8960940403510435,
            6.766294300556183
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced improvement potential and diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(len(archive)) if i != j])\n    diversity_scores = np.mean(diversity_scores.reshape(len(archive), -1), axis=1)\n    scores = 0.5 * improvement_potential.mean(axis=1) + 0.3 * diversity_scores + 0.2 * np.random.rand(len(archive))\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive sub-tour inversion\n    k = min(4, n // 3)\n    a, b = sorted(np.random.choice(n, 2, replace=False))\n    if b - a > k:\n        a = np.random.randint(a, b - k)\n        b = a + k\n    new_solution[a:b] = new_solution[a:b][::-1]\n\n    # Guided multi-node relocation\n    m = min(3, n // 5)\n    nodes_to_relocate = np.random.choice(n, m, replace=False)\n    insertion_points = np.random.choice(n, m, replace=False)\n    for node, point in zip(nodes_to_relocate, insertion_points):\n        if point > node:\n            point -= 1\n        new_solution = np.delete(new_solution, node)\n        new_solution = np.insert(new_solution, point, base_solution[node])\n\n    # Dynamic constraint validation\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b] = np.flip(new_solution[a:b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic node clustering with a Pareto-guided path inversion strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic node clustering\n    cluster_size = max(2, min(5, n // 3))\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Randomly select two clusters and swap them\n    if len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Pareto-guided path inversion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            # Invert the path between i and k\n            new_solution[i:k+1] = np.flip(new_solution[i:k+1])\n\n    # Random cluster rotation for diversity\n    if np.random.rand() < 0.2:\n        cluster_idx = np.random.randint(0, len(clusters))\n        shift = np.random.randint(1, len(clusters[cluster_idx]))\n        clusters[cluster_idx] = np.roll(clusters[cluster_idx], shift)\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n",
        "score": [
            -0.7948112386802075,
            0.39174360036849976
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic node clustering\n    cluster_size = max(2, min(5, n // 3))\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Randomly select two clusters and swap them\n    if len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Pareto-guided path inversion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            # Invert the path between i and k\n            new_solution[i:k+1] = np.flip(new_solution[i:k+1])\n\n    # Random cluster rotation for diversity\n    if np.random.rand() < 0.2:\n        cluster_idx = np.random.randint(0, len(clusters))\n        shift = np.random.randint(1, len(clusters[cluster_idx]))\n        clusters[cluster_idx] = np.roll(clusters[cluster_idx], shift)\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel hybrid local search operator that intelligently selects solutions based on their dominance in the Pareto front, then applies a multi-phase perturbation combining adaptive node reinsertion with constrained path reversal to generate high-quality neighbors while ensuring feasibility through dynamic feasibility checks and repair mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                          (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-phase perturbation\n    phases = np.random.choice([1, 2, 3])\n\n    if phases >= 1:\n        # Adaptive node reinsertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, j, node)\n\n    if phases >= 2:\n        # Constrained path reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Check feasibility of reversal\n        valid = True\n        for i in range(len(reversed_segment)-1):\n            if reversed_segment[i] == reversed_segment[i+1]:\n                valid = False\n                break\n\n        if valid:\n            new_solution[a:b+1] = reversed_segment\n\n    if phases == 3:\n        # Dynamic feasibility repair\n        if len(np.unique(new_solution)) != n:\n            missing = set(range(n)) - set(new_solution)\n            duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n            for dup in duplicates:\n                if missing:\n                    idx = np.where(new_solution == dup)[0][1]\n                    new_solution[idx] = missing.pop()\n\n    return new_solution\n\n",
        "score": [
            -0.9627345292532383,
            0.5076679587364197
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance rank\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1] and\n                          (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1])):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if non_dominated:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-phase perturbation\n    phases = np.random.choice([1, 2, 3])\n\n    if phases >= 1:\n        # Adaptive node reinsertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n-1)\n            if i != j:\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n                new_solution = np.insert(new_solution, j, node)\n\n    if phases >= 2:\n        # Constrained path reversal\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n\n        # Check feasibility of reversal\n        valid = True\n        for i in range(len(reversed_segment)-1):\n            if reversed_segment[i] == reversed_segment[i+1]:\n                valid = False\n                break\n\n        if valid:\n            new_solution[a:b+1] = reversed_segment\n\n    if phases == 3:\n        # Dynamic feasibility repair\n        if len(np.unique(new_solution)) != n:\n            missing = set(range(n)) - set(new_solution)\n            duplicates = [x for x in new_solution if list(new_solution).count(x) > 1]\n            for dup in duplicates:\n                if missing:\n                    idx = np.where(new_solution == dup)[0][1]\n                    new_solution[idx] = missing.pop()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{This new algorithm combines a dynamic multi-objective segment inversion strategy with adaptive node grouping to generate high-quality neighbors by intelligently inverting segments based on their combined objective improvement potential while ensuring feasibility through group-based validation and dynamic segment selection.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node grouping\n    group_size = max(2, n // 6)\n    groups = [new_solution[i:i+group_size] for i in range(0, n, group_size)]\n\n    # Dynamic multi-objective segment inversion\n    for _ in range(3):\n        # Select two random groups\n        i, j = np.random.choice(len(groups), 2, replace=False)\n        group_i, group_j = groups[i], groups[j]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try inverting segments\n        for pos_i in range(len(group_i)):\n            for pos_j in range(len(group_j)):\n                temp_solution = new_solution.copy()\n\n                # Find indices of nodes in groups\n                idx_i = np.where(new_solution == group_i[pos_i])[0][0]\n                idx_j = np.where(new_solution == group_j[pos_j])[0][0]\n\n                # Determine segment boundaries\n                start = min(idx_i, idx_j)\n                end = max(idx_i, idx_j)\n\n                # Invert the segment\n                temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                # Accept if better or with probability\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9160997679440575,
            0.9398979544639587
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized[:, 0] + 0.5 * normalized[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node grouping\n    group_size = max(2, n // 6)\n    groups = [new_solution[i:i+group_size] for i in range(0, n, group_size)]\n\n    # Dynamic multi-objective segment inversion\n    for _ in range(3):\n        # Select two random groups\n        i, j = np.random.choice(len(groups), 2, replace=False)\n        group_i, group_j = groups[i], groups[j]\n\n        # Calculate current costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Try inverting segments\n        for pos_i in range(len(group_i)):\n            for pos_j in range(len(group_j)):\n                temp_solution = new_solution.copy()\n\n                # Find indices of nodes in groups\n                idx_i = np.where(new_solution == group_i[pos_i])[0][0]\n                idx_j = np.where(new_solution == group_j[pos_j])[0][0]\n\n                # Determine segment boundaries\n                start = min(idx_i, idx_j)\n                end = max(idx_i, idx_j)\n\n                # Invert the segment\n                temp_solution[start:end+1] = temp_solution[start:end+1][::-1]\n\n                # Calculate new costs\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                # Accept if better or with probability\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a weighted combination of objective improvements and structural diversity, then applies a hybrid local search combining adaptive segment reversal and objective-aware node insertion to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective improvements and diversity\n    weights = [0.6 * (sum(archive[i][1]) / (sum(archive[0][1]) + 1e-6)) + 0.4 * (len(set(archive[i][0])) / len(archive[i][0])) for i in range(len(archive))]\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment selection and reversal\n    segment_size = max(3, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) > 1:\n            # Evaluate segment reversal impact\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n            original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-aware node insertion\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            # Evaluate insertion impact\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.6 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n                # Perform insertion\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9431338696512639,
            0.6672866940498352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Weighted selection based on objective improvements and diversity\n    weights = [0.6 * (sum(archive[i][1]) / (sum(archive[0][1]) + 1e-6)) + 0.4 * (len(set(archive[i][0])) / len(archive[i][0])) for i in range(len(archive))]\n    selected_idx = np.argmax(weights)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment selection and reversal\n    segment_size = max(3, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) > 1:\n            # Evaluate segment reversal impact\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n            original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-aware node insertion\n    if np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i != j:\n            # Evaluate insertion impact\n            original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.6 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n                # Perform insertion\n                node = new_solution[j]\n                new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic node insertion with a Pareto-guided segment inversion strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic node insertion\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    new_solution = np.concatenate([\n        new_solution[:pos],\n        [node],\n        new_solution[pos:]\n    ])\n\n    # Remove duplicate node (maintains feasibility)\n    mask = np.ones(n+1, dtype=bool)\n    mask[np.where(new_solution == node)[0][1]] = False\n    new_solution = new_solution[mask]\n\n    # Pareto-guided segment inversion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random segment inversion for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.824201878168659,
            0.6951324939727783
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic node insertion\n    node = np.random.choice(new_solution)\n    pos = np.random.randint(0, n)\n    new_solution = np.concatenate([\n        new_solution[:pos],\n        [node],\n        new_solution[pos:]\n    ])\n\n    # Remove duplicate node (maintains feasibility)\n    mask = np.ones(n+1, dtype=bool)\n    mask[np.where(new_solution == node)[0][1]] = False\n    new_solution = new_solution[mask]\n\n    # Pareto-guided segment inversion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random segment inversion for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{A novel hybrid local search operator that intelligently selects solutions with high potential for improvement based on their non-dominated status, then applies a combination of adaptive segment rotation, guided edge insertion, and probabilistic node reinsertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [s for s in archive if not any((s[1][0] > other[1][0] and s[1][1] > other[1][1]) for other in archive)]\n    if not non_dominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(len(non_dominated))\n        archive = non_dominated\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Guided edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        # Try inserting j between i and k\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            # Perform insertion\n            temp = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = (k + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n    # Probabilistic node reinsertion\n    if np.random.rand() < 0.2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7368271692257452,
            0.4600500464439392
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = [s for s in archive if not any((s[1][0] > other[1][0] and s[1][1] > other[1][1]) for other in archive)]\n    if not non_dominated:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(len(non_dominated))\n        archive = non_dominated\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment rotation\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(segment, rotation)\n\n    # Guided edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        # Try inserting j between i and k\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            # Perform insertion\n            temp = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            insert_pos = (k + 1) % n\n            new_solution = np.insert(new_solution, insert_pos, temp)\n\n    # Probabilistic node reinsertion\n    if np.random.rand() < 0.2:\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{A novel hybrid local search operator that intelligently selects diverse solutions from the archive, combines a probabilistic segment inversion with an adaptive edge exchange strategy that considers both objective spaces, and incorporates a guided mutation phase to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive size\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    if np.random.rand() < 0.7:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange considering both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Combined improvement criteria\n        if ((new_edge1 < current_edge1 and new_edge2 <= current_edge2) or\n            (new_edge1 <= current_edge1 and new_edge2 < current_edge2) or\n            (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Guided mutation phase\n    if np.random.rand() < 0.2:\n        # Select nodes based on their contribution to total cost\n        costs1 = np.array([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        costs2 = np.array([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        total_cost = costs1 + costs2\n        probs = total_cost / np.sum(total_cost)\n        p, q = np.random.choice(n, 2, replace=False, p=probs)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.8619289131135124,
            0.30800479650497437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 3:\n        archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]))[:max(1, len(archive) // 3)]\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment inversion with adaptive size\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    if np.random.rand() < 0.7:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange considering both objectives\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Combined improvement criteria\n        if ((new_edge1 < current_edge1 and new_edge2 <= current_edge2) or\n            (new_edge1 <= current_edge1 and new_edge2 < current_edge2) or\n            (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Guided mutation phase\n    if np.random.rand() < 0.2:\n        # Select nodes based on their contribution to total cost\n        costs1 = np.array([distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        costs2 = np.array([distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n)])\n        total_cost = costs1 + costs2\n        probs = total_cost / np.sum(total_cost)\n        p, q = np.random.choice(n, 2, replace=False, p=probs)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{A novel algorithm that selects a solution from the archive based on both objective values and structural diversity, then applies a hybrid local search combining adaptive path inversion with guided node swapping and Pareto-aware segment relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    diversity = np.array([np.std(np.diff(x[0])) for x in archive])\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion with Pareto dominance check\n    inv_length = min(5, n // 3)\n    start = np.random.randint(0, n - inv_length)\n    segment = new_solution[start:start+inv_length]\n\n    # Check if inversion improves Pareto front\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%inv_length]] for i in range(inv_length))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%inv_length]] for i in range(inv_length))\n    inv_segment = segment[::-1]\n    new_cost1 = sum(distance_matrix_1[inv_segment[i], inv_segment[(i+1)%inv_length]] for i in range(inv_length))\n    new_cost2 = sum(distance_matrix_2[inv_segment[i], inv_segment[(i+1)%inv_length]] for i in range(inv_length))\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) and (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution[start:start+inv_length] = inv_segment\n\n    # Guided node swapping\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i == j:\n            continue\n\n        # Check if swap improves at least one objective\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) and (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Pareto-aware segment relocation\n    if n > 5:\n        seg_size = min(3, n // 5)\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Evaluate segment removal cost\n        remove_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a+seg_size-1], new_solution[a+seg_size]])\n        remove_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a+seg_size-1], new_solution[a+seg_size]])\n\n        # Find best insertion position\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(0, n-seg_size+1):\n            if pos == a:\n                continue\n\n            # Evaluate insertion cost\n            insert_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[pos]])\n            insert_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[pos]])\n\n            # Calculate potential improvement\n            improvement = (remove_cost1 - insert_cost1) + (remove_cost2 - insert_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[a+seg_size:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if needed\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9398300228921401,
            2.3953552842140198
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement\n    objectives = np.array([x[1] for x in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    diversity = np.array([np.std(np.diff(x[0])) for x in archive])\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Adaptive path inversion with Pareto dominance check\n    inv_length = min(5, n // 3)\n    start = np.random.randint(0, n - inv_length)\n    segment = new_solution[start:start+inv_length]\n\n    # Check if inversion improves Pareto front\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%inv_length]] for i in range(inv_length))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%inv_length]] for i in range(inv_length))\n    inv_segment = segment[::-1]\n    new_cost1 = sum(distance_matrix_1[inv_segment[i], inv_segment[(i+1)%inv_length]] for i in range(inv_length))\n    new_cost2 = sum(distance_matrix_2[inv_segment[i], inv_segment[(i+1)%inv_length]] for i in range(inv_length))\n\n    if (new_cost1 <= current_cost1 and new_cost2 <= current_cost2) and (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution[start:start+inv_length] = inv_segment\n\n    # Guided node swapping\n    for _ in range(2):\n        i = np.random.randint(1, n-1)\n        j = np.random.randint(1, n-1)\n        if i == j:\n            continue\n\n        # Check if swap improves at least one objective\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[j+1]])\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[j+1]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[j+1]])\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[i+1]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[j+1]])\n\n        if (new_cost1 <= old_cost1 and new_cost2 <= old_cost2) and (new_cost1 < old_cost1 or new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Pareto-aware segment relocation\n    if n > 5:\n        seg_size = min(3, n // 5)\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Evaluate segment removal cost\n        remove_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_1[new_solution[a+seg_size-1], new_solution[a+seg_size]])\n        remove_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                        distance_matrix_2[new_solution[a+seg_size-1], new_solution[a+seg_size]])\n\n        # Find best insertion position\n        best_pos = -1\n        best_improvement = 0\n        for pos in range(0, n-seg_size+1):\n            if pos == a:\n                continue\n\n            # Evaluate insertion cost\n            insert_cost1 = (distance_matrix_1[new_solution[pos-1], segment[0]] +\n                           distance_matrix_1[segment[-1], new_solution[pos]])\n            insert_cost2 = (distance_matrix_2[new_solution[pos-1], segment[0]] +\n                           distance_matrix_2[segment[-1], new_solution[pos]])\n\n            # Calculate potential improvement\n            improvement = (remove_cost1 - insert_cost1) + (remove_cost2 - insert_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1 and best_improvement > 0:\n            new_solution = np.concatenate([\n                new_solution[:a],\n                new_solution[a+seg_size:],\n                segment\n            ])\n            new_solution = np.insert(new_solution, best_pos, segment)\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if needed\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{The new algorithm selects a solution from the archive using a Pareto dominance-based selection criterion, then applies a novel hybrid local search combining adaptive segment rotation with guided edge crossover to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance-based selection\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_idx = np.random.randint(0, len(archive))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        selected_idx = np.random.randint(0, len(non_dominated))\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    rotation = np.random.randint(1, seg_size)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert rotated segment\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        rotated_segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Guided edge crossover\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate edge costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto improvement check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            # Swap nodes to create a better edge\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random segment inversion for diversity\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(p, n)\n        new_solution[p:q+1] = new_solution[p:q+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8882257199281663,
            0.25369518995285034
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance-based selection\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        selected_idx = np.random.randint(0, len(archive))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        selected_idx = np.random.randint(0, len(non_dominated))\n        base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Rotate segment\n    rotation = np.random.randint(1, seg_size)\n    rotated_segment = np.roll(segment, rotation)\n\n    # Insert rotated segment\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        rotated_segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Guided edge crossover\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate edge costs\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto improvement check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            # Swap nodes to create a better edge\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random segment inversion for diversity\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(p, n)\n        new_solution[p:q+1] = new_solution[p:q+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement based on both objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion and guided edge insertion to generate a neighbor solution while ensuring feasibility, using different parameter settings for the selection score function.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with different segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], [node_to_insert], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        start = np.random.randint(0, n - 3)\n        new_solution[start:start+3] = new_solution[start:start+3][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective scores and diversity, then applies a novel hybrid local search combining adaptive node relocation with guided segment rotation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective scores and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(np.diff(solution)) for solution, _ in archive])\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with guided segment rotation\n    if n > 3:\n        # Select a segment to rotate\n        seg_length = min(4, n // 4)\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Rotate the segment\n        rotation = np.random.randint(1, seg_length)\n        rotated_segment = np.roll(new_solution[start:end], rotation)\n        new_solution[start:end] = rotated_segment\n\n        # Relocate a node from the rotated segment to a new position\n        relocated_node = new_solution[start]\n        new_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:new_pos], [relocated_node], new_solution[new_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if relocation breaks the tour\n        new_solution = base_solution.copy()\n        if n > 3:\n            seg_length = min(3, n // 3)\n            start = np.random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.7194179779138895,
            0.6440128087997437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective scores and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(np.diff(solution)) for solution, _ in archive])\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation with guided segment rotation\n    if n > 3:\n        # Select a segment to rotate\n        seg_length = min(4, n // 4)\n        start = np.random.randint(0, n - seg_length)\n        end = start + seg_length\n\n        # Rotate the segment\n        rotation = np.random.randint(1, seg_length)\n        rotated_segment = np.roll(new_solution[start:end], rotation)\n        new_solution[start:end] = rotated_segment\n\n        # Relocate a node from the rotated segment to a new position\n        relocated_node = new_solution[start]\n        new_pos = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+1:new_pos], [relocated_node], new_solution[new_pos:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if relocation breaks the tour\n        new_solution = base_solution.copy()\n        if n > 3:\n            seg_length = min(3, n // 3)\n            start = np.random.randint(0, n - seg_length)\n            new_solution[start:start+seg_length] = np.roll(new_solution[start:start+seg_length], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{This algorithm selects a random solution from the archive, applies a dynamic segment relocation strategy with adaptive segment size, and combines it with a probabilistic edge reversal mechanism to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation with adaptive segment size\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Relocate segment to a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Probabilistic edge reversal\n    for i in range(n - 1):\n        j = i + 1\n        if np.random.rand() < 0.3 * (1 - (i / n)):\n            # Reverse edge direction with probability\n            if (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]) > \\\n               (distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional random insertion to increase diversity\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        if p != q:\n            node = new_solution[p]\n            new_solution = np.delete(new_solution, p)\n            new_solution = np.insert(new_solution, q, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8861836637620808,
            0.36487847566604614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation with adaptive segment size\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Relocate segment to a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    new_solution = np.insert(new_solution, new_pos, segment)\n\n    # Probabilistic edge reversal\n    for i in range(n - 1):\n        j = i + 1\n        if np.random.rand() < 0.3 * (1 - (i / n)):\n            # Reverse edge direction with probability\n            if (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]) > \\\n               (distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[i]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Additional random insertion to increase diversity\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        if p != q:\n            node = new_solution[p]\n            new_solution = np.delete(new_solution, p)\n            new_solution = np.insert(new_solution, q, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a hybrid local search combining adaptive segment rotation and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality = objectives.sum(axis=1)\n    diversity = np.std(objectives, axis=0).sum()\n    score = quality + 0.3 * diversity\n    selected_idx = np.argmax(score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    seg_size = max(3, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Step 2: Guided node insertion with objective-aware selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        # Try inserting node j between i and k\n        if j != k:\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Step 3: Additional random segment reversal for diversity\n    if np.random.rand() < 0.15:\n        a = np.random.randint(0, n)\n        b = np.random.randint(a, n)\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.859813436287961,
            0.36868715286254883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential and objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    quality = objectives.sum(axis=1)\n    diversity = np.std(objectives, axis=0).sum()\n    score = quality + 0.3 * diversity\n    selected_idx = np.argmax(score)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    seg_size = max(3, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Step 2: Guided node insertion with objective-aware selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        # Try inserting node j between i and k\n        if j != k:\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Step 3: Additional random segment reversal for diversity\n    if np.random.rand() < 0.15:\n        a = np.random.randint(0, n)\n        b = np.random.randint(a, n)\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{The new algorithm selects a solution from the archive based on both objective values and diversity, then applies a hybrid local search combining adaptive path inversion with guided node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    segment_length = min(7, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided node relocation\n    for _ in range(2):\n        i = np.random.randint(1, n - 1)\n        j = np.random.randint(0, n)\n        while j == i or j == i - 1:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate potential improvement\n        prev_node = new_solution[i - 1]\n        next_node = new_solution[(i + 1) % n]\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_prev = new_solution[j - 1] if j > 0 else new_solution[-1]\n        new_next = new_solution[j] if j < n - 1 else new_solution[0]\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2) or np.random.rand() < 0.3:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge exchange if relocation breaks the tour\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8693320374731076,
            0.27824920415878296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    segment_length = min(7, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided node relocation\n    for _ in range(2):\n        i = np.random.randint(1, n - 1)\n        j = np.random.randint(0, n)\n        while j == i or j == i - 1:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n\n        # Calculate potential improvement\n        prev_node = new_solution[i - 1]\n        next_node = new_solution[(i + 1) % n]\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_prev = new_solution[j - 1] if j > 0 else new_solution[-1]\n        new_next = new_solution[j] if j < n - 1 else new_solution[0]\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        if (new_cost1 + new_cost2) < (old_cost1 + old_cost2) or np.random.rand() < 0.3:\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple edge exchange if relocation breaks the tour\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search operator that intelligently selects solutions from the archive based on their Pareto dominance, combines a dynamic segment inversion with an adaptive edge exchange strategy, and incorporates a probabilistic node reinsertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to find solutions with better combined performance\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% or at least 2 solutions\n        selection_pool = min(3, max(2, len(archive_sorted) // 3))\n        selected_idx = np.random.choice(selection_pool)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion with objective-aware size\n    seg_size = max(3, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Decide whether to invert segment based on objective improvement potential\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    inverted_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n    inverted_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n    if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2) or \\\n       (np.random.rand() < 0.3 and (inverted_cost1 <= current_cost1 or inverted_cost2 <= current_cost2)):\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange with objective balancing\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Objective-aware acceptance with dynamic probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.1 * (1 - (i / n)) * (1 + 0.5 * (current_edge1 + current_edge2) / (new_edge1 + new_edge2))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic node reinsertion\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        node = new_solution[p]\n        new_solution = np.delete(new_solution, p)\n        new_solution = np.insert(new_solution, q, node)\n\n    return new_solution\n\n",
        "score": [
            -0.6941763084249479,
            0.4787560701370239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort by sum of objectives to find solutions with better combined performance\n        archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% or at least 2 solutions\n        selection_pool = min(3, max(2, len(archive_sorted) // 3))\n        selected_idx = np.random.choice(selection_pool)\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion with objective-aware size\n    seg_size = max(3, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Decide whether to invert segment based on objective improvement potential\n    current_cost1 = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    inverted_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(b+1)%n]]\n    inverted_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(b+1)%n]]\n\n    if (inverted_cost1 < current_cost1 and inverted_cost2 < current_cost2) or \\\n       (np.random.rand() < 0.3 and (inverted_cost1 <= current_cost1 or inverted_cost2 <= current_cost2)):\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange with objective balancing\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Objective-aware acceptance with dynamic probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.1 * (1 - (i / n)) * (1 + 0.5 * (current_edge1 + current_edge2) / (new_edge1 + new_edge2))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic node reinsertion\n    if np.random.rand() < 0.2:\n        p = np.random.randint(0, n)\n        q = np.random.randint(0, n)\n        node = new_solution[p]\n        new_solution = np.delete(new_solution, p)\n        new_solution = np.insert(new_solution, q, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic edge swapping with a Pareto-guided segment inversion strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic edge swapping\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Pareto-guided segment inversion\n    for i in range(n):\n        j = (i + 1) % n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        for k in range(i + 2, n):\n            if k == j:\n                continue\n            l = (k + 1) % n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n               (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[k:l+1],\n                    new_solution[j+1:k],\n                    new_solution[l+1:],\n                    new_solution[j:j+1]\n                ])\n                break\n\n    # Random segment rotation for diversity\n    if np.random.rand() < 0.2:\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        shift = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, shift)\n\n    return new_solution\n\n",
        "score": [
            -0.9316586278596781,
            0.6994630694389343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic edge swapping\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        if j - i > 1:\n            new_solution[i:j+1] = np.flip(new_solution[i:j+1])\n\n    # Pareto-guided segment inversion\n    for i in range(n):\n        j = (i + 1) % n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        for k in range(i + 2, n):\n            if k == j:\n                continue\n            l = (k + 1) % n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n               (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    new_solution[k:l+1],\n                    new_solution[j+1:k],\n                    new_solution[l+1:],\n                    new_solution[j:j+1]\n                ])\n                break\n\n    # Random segment rotation for diversity\n    if np.random.rand() < 0.2:\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        shift = np.random.randint(1, len(segment))\n        new_solution[a:b+1] = np.roll(segment, shift)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and solution diversity, then applies a hybrid local search combining adaptive path inversion and constrained node insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of both objectives and solution structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement and high diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)]) for sol, _ in archive])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.5 * (1 - normalized_obj[:, 0]) + 0.3 * (1 - normalized_obj[:, 1]) + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion with dynamic segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Constrained node insertion with objective-aware selection\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        best_pos = 0\n        min_cost = float('inf')\n        for j in range(len(new_solution)):\n            temp_sol = np.insert(new_solution, j, node)\n            cost1 = distance_matrix_1[temp_sol[j-1], node] + distance_matrix_1[node, temp_sol[(j+1)%n]] - distance_matrix_1[temp_sol[j-1], temp_sol[(j+1)%n]]\n            cost2 = distance_matrix_2[temp_sol[j-1], node] + distance_matrix_2[node, temp_sol[(j+1)%n]] - distance_matrix_2[temp_sol[j-1], temp_sol[(j+1)%n]]\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.767370668297352,
            5.052355408668518
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with high potential for improvement and high diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[sol[i], sol[i+1]] for i in range(len(sol)-1)]) for sol, _ in archive])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.5 * (1 - normalized_obj[:, 0]) + 0.3 * (1 - normalized_obj[:, 1]) + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion with dynamic segment length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Constrained node insertion with objective-aware selection\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        best_pos = 0\n        min_cost = float('inf')\n        for j in range(len(new_solution)):\n            temp_sol = np.insert(new_solution, j, node)\n            cost1 = distance_matrix_1[temp_sol[j-1], node] + distance_matrix_1[node, temp_sol[(j+1)%n]] - distance_matrix_1[temp_sol[j-1], temp_sol[(j+1)%n]]\n            cost2 = distance_matrix_2[temp_sol[j-1], node] + distance_matrix_2[node, temp_sol[(j+1)%n]] - distance_matrix_2[temp_sol[j-1], temp_sol[(j+1)%n]]\n            total_cost = 0.6 * cost1 + 0.4 * cost2\n            if total_cost < min_cost:\n                min_cost = total_cost\n                best_pos = j\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized improvement potential across both objectives, then applies a hybrid local search combining adaptive segment shifting and constrained edge reversal to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential with different weighting parameters.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.3 * improvement_potential[:, 0] + 0.7 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    shift_length = min(4, n // 3)\n    start = np.random.randint(0, n - shift_length)\n    segment = new_solution[start:start+shift_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+shift_length:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.91335125123931,
            0.307428777217865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.3 * improvement_potential[:, 0] + 0.7 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    shift_length = min(4, n // 3)\n    start = np.random.randint(0, n - shift_length)\n    segment = new_solution[start:start+shift_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+shift_length:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined score of objective values and diversity, then applies a novel hybrid local search combining adaptive segment rotation and constrained node insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined score of objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[s[i], s[i+1]] for i in range(len(s)-1)]) for s, _ in archive])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = max(2, min(4, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    rotation = np.random.randint(1, segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Constrained node insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8227002835627335,
            0.9306820034980774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined score of objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[s[i], s[i+1]] for i in range(len(s)-1)]) for s, _ in archive])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = max(2, min(4, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    rotation = np.random.randint(1, segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Constrained node insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) <= 1:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{The new algorithm combines a multi-objective segment inversion strategy with adaptive node grouping to generate neighbors by intelligently reversing segments of the tour based on their combined objective improvement potential while ensuring feasibility through group-based validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    group_size = max(2, n // 4)\n    groups = []\n    for i in range(0, n, group_size):\n        groups.append(new_solution[i:i+group_size])\n\n    for _ in range(3):\n        i = np.random.randint(0, len(groups))\n        group = groups[i]\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if len(group) > 1:\n            start_idx = np.where(new_solution == group[0])[0][0]\n            end_idx = np.where(new_solution == group[-1])[0][0]\n\n            temp_solution = new_solution.copy()\n            temp_solution[start_idx:end_idx+1] = temp_solution[start_idx:end_idx+1][::-1]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7963288809248343,
            2.733422040939331
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    group_size = max(2, n // 4)\n    groups = []\n    for i in range(0, n, group_size):\n        groups.append(new_solution[i:i+group_size])\n\n    for _ in range(3):\n        i = np.random.randint(0, len(groups))\n        group = groups[i]\n\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if len(group) > 1:\n            start_idx = np.where(new_solution == group[0])[0][0]\n            end_idx = np.where(new_solution == group[-1])[0][0]\n\n            temp_solution = new_solution.copy()\n            temp_solution[start_idx:end_idx+1] = temp_solution[start_idx:end_idx+1][::-1]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on its combined potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive segment insertion and constrained node repositioning with guided diversification to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Constrained node repositioning with guided diversification\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8035284661020852,
            0.3504500389099121
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Constrained node repositioning with guided diversification\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n\n        if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment relocation with a guided multi-objective edge swapping strategy to generate high-quality neighbors by balancing exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    weights = np.random.dirichlet(np.ones(2))\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Find insertion point that minimizes both objectives\n    best_insert = a\n    best_cost = np.inf\n    for i in range(n - seg_size + 1):\n        if i >= a and i <= b:\n            continue\n        temp = new_solution.copy()\n        temp = np.concatenate([temp[:i], segment, temp[i:]])\n        temp = np.concatenate([temp[:a], temp[b+1:]])\n        cost1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_insert = i\n\n    new_solution = np.concatenate([new_solution[:best_insert], segment, new_solution[best_insert:]])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Multi-objective edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random 2-opt for diversification\n    if np.random.rand() < 0.2:\n        p, q = sorted(np.random.choice(n, 2, replace=False))\n        if q - p > 1:\n            new_solution[p:q] = np.flip(new_solution[p:q])\n\n    return new_solution\n\n",
        "score": [
            -0.8863041112138564,
            0.5593773126602173
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    weights = np.random.dirichlet(np.ones(2))\n    scores = [weights[0] * obj[0] + weights[1] * obj[1] for obj in objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Find insertion point that minimizes both objectives\n    best_insert = a\n    best_cost = np.inf\n    for i in range(n - seg_size + 1):\n        if i >= a and i <= b:\n            continue\n        temp = new_solution.copy()\n        temp = np.concatenate([temp[:i], segment, temp[i:]])\n        temp = np.concatenate([temp[:a], temp[b+1:]])\n        cost1 = sum(distance_matrix_1[temp[k], temp[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp[k], temp[(k+1)%n]] for k in range(n))\n        if cost1 + cost2 < best_cost:\n            best_cost = cost1 + cost2\n            best_insert = i\n\n    new_solution = np.concatenate([new_solution[:best_insert], segment, new_solution[best_insert:]])\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    # Multi-objective edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random 2-opt for diversification\n    if np.random.rand() < 0.2:\n        p, q = sorted(np.random.choice(n, 2, replace=False))\n        if q - p > 1:\n            new_solution[p:q] = np.flip(new_solution[p:q])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{A novel hybrid local search operator that intelligently combines a multi-segment shuffle with a Pareto-dominance guided edge insertion strategy to generate high-quality neighbors while maintaining feasibility through adaptive segment validation and dynamic edge replacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 4:\n        return new_solution\n\n    # Multi-segment shuffle with adaptive segment sizes\n    num_segments = np.random.randint(2, min(5, n // 3))\n    segment_indices = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n    segments = []\n    prev = 0\n    for idx in segment_indices:\n        segments.append(new_solution[prev:idx])\n        prev = idx\n    segments.append(new_solution[prev:])\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Pareto-dominance guided edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Try inserting node k between i and j\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            # Perform the insertion\n            temp = new_solution[k]\n            new_solution = np.concatenate([new_solution[:j], [temp], new_solution[j:]])\n\n    # Dynamic edge replacement with adaptive probability\n    for i in range(n):\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        while k in [i, j, (i-1)%n, (j+1)%n]:\n            k = np.random.randint(0, n)\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.1 * (1 - (i / n)) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            # Perform the replacement\n            temp = new_solution[k]\n            new_solution = np.concatenate([new_solution[:i+1], [temp], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8767098411588194,
            0.4640510678291321
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 4:\n        return new_solution\n\n    # Multi-segment shuffle with adaptive segment sizes\n    num_segments = np.random.randint(2, min(5, n // 3))\n    segment_indices = sorted(np.random.choice(range(1, n-1), num_segments, replace=False))\n    segments = []\n    prev = 0\n    for idx in segment_indices:\n        segments.append(new_solution[prev:idx])\n        prev = idx\n    segments.append(new_solution[prev:])\n    np.random.shuffle(segments)\n    new_solution = np.concatenate(segments)\n\n    # Pareto-dominance guided edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Try inserting node k between i and j\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            # Perform the insertion\n            temp = new_solution[k]\n            new_solution = np.concatenate([new_solution[:j], [temp], new_solution[j:]])\n\n    # Dynamic edge replacement with adaptive probability\n    for i in range(n):\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        while k in [i, j, (i-1)%n, (j+1)%n]:\n            k = np.random.randint(0, n)\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.1 * (1 - (i / n)) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            # Perform the replacement\n            temp = new_solution[k]\n            new_solution = np.concatenate([new_solution[:i+1], [temp], new_solution[i+1:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8674369309708381,
            0.3823819160461426
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective improvement potential and solution quality, then applies a hybrid local search combining adaptive segment reversal and constrained edge insertion to generate a neighbor solution while ensuring feasibility through dynamic validation checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + objectives.sum(axis=1))\n    scores = 0.5 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1] + 0.2 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained edge insertion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if abs(i - j) > 1:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9361861527132133,
            0.4133149981498718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + objectives.sum(axis=1))\n    scores = 0.5 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1] + 0.2 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    segment_length = min(4, n // 3)\n    for _ in range(2):\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained edge insertion\n    for _ in range(3):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if abs(i - j) > 1:\n            segment = new_solution[i:j]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{A novel hybrid local search operator that intelligently selects high-potential solutions from the archive, combines a dynamic segment reversal with a probabilistic edge replacement strategy to generate diverse neighbors while maintaining feasibility, using adaptive segment sizes and guided acceptance criteria based on objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment reversal with probabilistic acceptance\n    seg_size = max(3, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate segment cost before reversal\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Perform reversal\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Calculate segment cost after reversal\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Revert if not beneficial\n    if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() > 0.3:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Probabilistic edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + np.random.randint(2, min(5, n//2))) % n\n\n        if np.random.rand() < 0.4 * (1 - (i / n)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic swap\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.6372773289143083,
            0.29006195068359375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1], reverse=True)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment reversal with probabilistic acceptance\n    seg_size = max(3, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate segment cost before reversal\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Perform reversal\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Calculate segment cost after reversal\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Revert if not beneficial\n    if (new_cost1 >= current_cost1 and new_cost2 >= current_cost2) and np.random.rand() > 0.3:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Probabilistic edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + np.random.randint(2, min(5, n//2))) % n\n\n        if np.random.rand() < 0.4 * (1 - (i / n)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic swap\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining segment inversion with a novel guided node relocation strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with diverse objectives\n        objectives = np.array([x[1] for x in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n        # Combine crowding distance with solution quality\n        quality_scores = 1 / (np.sum(objectives, axis=1) + 1e-8)\n        combined_scores = crowding_distances * quality_scores\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive size\n        seg_size = min(4, n // 4)\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n        # Novel guided node relocation\n        for _ in range(2):\n            # Select a node to relocate\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n\n            # Calculate potential insertion positions\n            possible_positions = [i for i in range(n) if i != k and i != (k-1) % n and i != (k+1) % n]\n\n            # Evaluate insertion cost considering both objectives\n            best_pos = None\n            min_cost = np.inf\n            for pos in possible_positions:\n                # Calculate cost of inserting node at pos\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                total_cost = cost1 + cost2\n\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            if best_pos is not None:\n                # Remove node from current position\n                new_solution = np.delete(new_solution, k)\n                # Insert at best position\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8434596826673371,
            0.47513145208358765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with diverse objectives\n        objectives = np.array([x[1] for x in archive])\n        crowding_distances = np.zeros(len(archive))\n        for i in range(2):  # For each objective\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i])\n\n        # Combine crowding distance with solution quality\n        quality_scores = 1 / (np.sum(objectives, axis=1) + 1e-8)\n        combined_scores = crowding_distances * quality_scores\n        selected_idx = np.argmax(combined_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Segment inversion with adaptive size\n        seg_size = min(4, n // 4)\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n        # Novel guided node relocation\n        for _ in range(2):\n            # Select a node to relocate\n            k = np.random.randint(0, n)\n            node = new_solution[k]\n\n            # Calculate potential insertion positions\n            possible_positions = [i for i in range(n) if i != k and i != (k-1) % n and i != (k+1) % n]\n\n            # Evaluate insertion cost considering both objectives\n            best_pos = None\n            min_cost = np.inf\n            for pos in possible_positions:\n                # Calculate cost of inserting node at pos\n                prev_node = new_solution[pos-1]\n                next_node = new_solution[pos % n]\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n                total_cost = cost1 + cost2\n\n                if total_cost < min_cost:\n                    min_cost = total_cost\n                    best_pos = pos\n\n            if best_pos is not None:\n                # Remove node from current position\n                new_solution = np.delete(new_solution, k)\n                # Insert at best position\n                new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0350424674889869,
            0.49663078784942627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0350424674889869,
            0.49663078784942627
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation strategy with a multi-objective edge optimization heuristic to generate high-quality neighbors by intelligently balancing exploration and exploitation while maintaining solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Simple scoring based on objective values (lower is better)\n        score = obj[0] + obj[1]\n        scores.append(score)\n    scores = np.array(scores)\n    probs = np.max(scores) - scores + 1e-6  # Higher scores get higher probability\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) - seg_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Multi-objective edge optimization\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n        # Randomized improvement\n        elif np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional randomized perturbation\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9027630062292501,
            0.34330207109451294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, obj in archive:\n        # Simple scoring based on objective values (lower is better)\n        score = obj[0] + obj[1]\n        scores.append(score)\n    scores = np.array(scores)\n    probs = np.max(scores) - scores + 1e-6  # Higher scores get higher probability\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n    insert_pos = np.random.randint(0, len(new_solution) - seg_size + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Multi-objective edge optimization\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n        # Randomized improvement\n        elif np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional randomized perturbation\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{A novel adaptive hybrid local search operator that combines guided segment relocation with probabilistic edge reinsertion, using dynamic acceptance criteria based on both objective improvements and solution diversity metrics to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    seg_size = max(2, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Probabilistic edge reinsertion\n    for i in range(n):\n        j = (i + 1) % n\n        if np.random.rand() < 0.3 * (1 - (i / n)):\n            k = np.random.randint(0, n)\n            while k == i or k == j:\n                k = np.random.randint(0, n)\n            old_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            old_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n            if (new_edge1 < old_edge1 and new_edge2 < old_edge2) or \\\n               (np.random.rand() < 0.4 and (new_edge1 <= old_edge1 or new_edge2 <= old_edge2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Dynamic swap operation\n    if np.random.rand() < 0.2 * (1 - (len(archive) / max(10, len(archive)))):\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.8736326242251222,
            0.2803300619125366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    seg_size = max(2, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    np.random.shuffle(segment)\n    new_solution[a:b+1] = segment\n\n    # Probabilistic edge reinsertion\n    for i in range(n):\n        j = (i + 1) % n\n        if np.random.rand() < 0.3 * (1 - (i / n)):\n            k = np.random.randint(0, n)\n            while k == i or k == j:\n                k = np.random.randint(0, n)\n            old_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            old_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n            if (new_edge1 < old_edge1 and new_edge2 < old_edge2) or \\\n               (np.random.rand() < 0.4 and (new_edge1 <= old_edge1 or new_edge2 <= old_edge2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Dynamic swap operation\n    if np.random.rand() < 0.2 * (1 - (len(archive) / max(10, len(archive)))):\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{This new algorithm selects a solution from the archive based on a hybrid score combining objective values and diversity measures, then applies a novel local search combining adaptive segment inversion and objective-aware node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection score combining objectives and diversity\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / (sum(distance_matrix_1[np.arange(len(sol)), np.roll(sol, -1)]))\n        norm_obj2 = obj[1] / (sum(distance_matrix_2[np.arange(len(sol)), np.roll(sol, -1)]))\n        diversity = len(set(sol[:len(sol)//2])) / len(sol)\n        scores.append((norm_obj1 + norm_obj2) * (1 + diversity))\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with objective awareness\n    segment_size = max(2, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Evaluate segment inversion impact\n        original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with higher probability\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-aware node swapping\n    if n > 3 and np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        # Check if swap improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 < original_cost1 or swapped_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.6 and (swapped_cost1 <= original_cost1 or swapped_cost2 <= original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8294176132539992,
            1.6378620266914368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Hybrid selection score combining objectives and diversity\n    scores = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / (sum(distance_matrix_1[np.arange(len(sol)), np.roll(sol, -1)]))\n        norm_obj2 = obj[1] / (sum(distance_matrix_2[np.arange(len(sol)), np.roll(sol, -1)]))\n        diversity = len(set(sol[:len(sol)//2])) / len(sol)\n        scores.append((norm_obj1 + norm_obj2) * (1 + diversity))\n\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion with objective awareness\n    segment_size = max(2, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Evaluate segment inversion impact\n        original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with higher probability\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-aware node swapping\n    if n > 3 and np.random.rand() < 0.3:\n        i, j = np.random.choice(n, 2, replace=False)\n        # Check if swap improves at least one objective\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + \\\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + \\\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + \\\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + \\\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (swapped_cost1 < original_cost1 or swapped_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.6 and (swapped_cost1 <= original_cost1 or swapped_cost2 <= original_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{This algorithm selects a solution from the archive based on its dominance in both objectives, then applies a novel hybrid local search combining multi-segment relocation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility, using a dynamic trade-off between objective improvements and solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                dominated += 1\n        dominance_scores[i] = 1 / (dominated + 1)\n    selected_idx = np.random.choice(len(archive), p=dominance_scores / dominance_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    num_segments = min(3, n // 5)\n    segment_length = n // num_segments\n    for _ in range(num_segments):\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Adaptive edge insertion\n    for _ in range(min(5, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        new_edges = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_edges < old_edges or np.random.rand() < 0.1:\n            # Perform insertion\n            if i < j:\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    np.flip(new_solution[i+1:j+1]),\n                    new_solution[j+1:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:j+1],\n                    np.flip(new_solution[j+1:i+1]),\n                    new_solution[i+1:]\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9185632805894698,
            0.38778549432754517
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                dominated += 1\n        dominance_scores[i] = 1 / (dominated + 1)\n    selected_idx = np.random.choice(len(archive), p=dominance_scores / dominance_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment relocation\n    num_segments = min(3, n // 5)\n    segment_length = n // num_segments\n    for _ in range(num_segments):\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:], segment])\n\n    # Adaptive edge insertion\n    for _ in range(min(5, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        new_edges = (distance_matrix_1[new_solution[i], new_solution[j]] +\n                     distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n\n        if new_edges < old_edges or np.random.rand() < 0.1:\n            # Perform insertion\n            if i < j:\n                new_solution = np.concatenate([\n                    new_solution[:i+1],\n                    np.flip(new_solution[i+1:j+1]),\n                    new_solution[j+1:]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:j+1],\n                    np.flip(new_solution[j+1:i+1]),\n                    new_solution[i+1:]\n                ])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{This new algorithm selects solutions based on their dominance in the objective space, then applies a novel hybrid local search combining adaptive path reversal and constrained node insertion to generate high-quality neighbors while ensuring feasibility through a dynamic feasibility check and repair mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if all(objectives[i] < objectives[j]):\n                    dominance[i] += 1\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path reversal with segment selection\n    seg_size = min(4, n // 2)\n    start = np.random.randint(0, n - seg_size)\n    end = start + seg_size\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained node insertion with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_dist1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_dist2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (np.random.rand() < 0.3 and (new_dist1 <= current_dist1 or new_dist2 <= current_dist2)):\n            # Perform node insertion\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:j], np.array([node]), new_solution[j:]])\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n            break\n\n    # Dynamic feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.8810816881363459,
            7.889557182788849
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance in the Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if all(objectives[i] < objectives[j]):\n                    dominance[i] += 1\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path reversal with segment selection\n    seg_size = min(4, n // 2)\n    start = np.random.randint(0, n - seg_size)\n    end = start + seg_size\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained node insertion with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_dist1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_dist2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_dist1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_dist2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_dist1 < current_dist1 and new_dist2 < current_dist2) or \\\n           (np.random.rand() < 0.3 and (new_dist1 <= current_dist1 or new_dist2 <= current_dist2)):\n            # Perform node insertion\n            node = new_solution[k]\n            new_solution = np.concatenate([new_solution[:j], np.array([node]), new_solution[j:]])\n            if len(new_solution) > n:\n                new_solution = new_solution[:n]\n            break\n\n    # Dynamic feasibility check and repair\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n:\n        missing_nodes = np.setdiff1d(base_solution, unique_nodes)\n        for node in missing_nodes:\n            pos = np.random.randint(0, n)\n            new_solution = np.insert(new_solution, pos, node)\n        new_solution = new_solution[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and diversity, then applies a novel hybrid local search combining adaptive segment rotation and constrained node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives and high diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[archive[i][0][j], archive[i][0][j+1]] for j in range(len(archive[i][0])-1)]) for i in range(len(archive))])\n    combined_scores = 0.5 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Constrained node insertion\n    for _ in range(2):\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8471043750415659,
            0.8268550038337708
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives and high diversity\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[archive[i][0][j], archive[i][0][j+1]] for j in range(len(archive[i][0])-1)]) for i in range(len(archive))])\n    combined_scores = 0.5 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Constrained node insertion\n    for _ in range(2):\n        node_idx = np.random.randint(0, n)\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This algorithm combines a dynamic segment inversion with a multi-objective edge swap strategy, using Pareto dominance to guide edge replacements while maintaining tour feasibility and promoting solution diversity through probabilistic segment flips.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) * (1 - x[1][0] / x[1][1] if x[1][1] != 0 else 0))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Multi-objective edge swap\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n           (new_cost1 <= current_cost1 * 1.05 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.2:\n        rot_amount = np.random.randint(1, min(4, n // 2))\n        new_solution = np.roll(new_solution, rot_amount)\n\n    return new_solution\n\n",
        "score": [
            -0.8206038786913853,
            0.35034918785095215
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) * (1 - x[1][0] / x[1][1] if x[1][1] != 0 else 0))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Multi-objective edge swap\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Pareto dominance check\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.05) or \\\n           (new_cost1 <= current_cost1 * 1.05 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic segment rotation\n    if np.random.rand() < 0.2:\n        rot_amount = np.random.randint(1, min(4, n // 2))\n        new_solution = np.roll(new_solution, rot_amount)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{The new algorithm selects a solution from the archive based on both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion, while ensuring feasibility by validating the tour structure and using a fallback to a simple swap if necessary.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 1.0, len(archive)) / np.sum(np.linspace(0.2, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with position validation\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1 or j == i + 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7938803348449641,
            0.2699722647666931
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.2, 1.0, len(archive)) / np.sum(np.linspace(0.2, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with position validation\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1 or j == i + 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9713735390620513,
            0.23788714408874512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized improvement potential across both objectives, using a weighted score function with different parameters, then applies a hybrid local search combining dynamic segment relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    scores = 0.3 * normalized_obj[:, 0] + 0.7 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    relocate_length = min(4, n // 3)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8401574680613855,
            0.286624550819397
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    scores = 0.3 * normalized_obj[:, 0] + 0.7 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    relocate_length = min(4, n // 3)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This novel algorithm selects a solution from the archive based on a combination of objective diversity and spatial locality, then applies a hybrid local search combining adaptive segment reversal and guided node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with highest diversity in objectives\n        objectives = np.array([s[1] for s in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(np.sum(diversity))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal based on spatial locality\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segment_end = min(i + segment_length, n)\n        segment = new_solution[i:segment_end]\n\n        # Calculate centroids of the segment in both spaces\n        coords1 = instance[segment, :2]\n        coords2 = instance[segment, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Calculate distances from centroid to nodes\n        dist1 = np.linalg.norm(coords1 - centroid1, axis=1)\n        dist2 = np.linalg.norm(coords2 - centroid2, axis=1)\n\n        # Reverse segment if nodes are more spread out in either space\n        if np.std(dist1) > 1.5 * np.mean(dist1) or np.std(dist2) > 1.5 * np.mean(dist2):\n            new_solution[i:segment_end] = segment[::-1]\n\n    # Step 2: Guided node swapping based on objective improvement\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate cost change for both objectives\n        cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept swap if both objectives improve or at least one improves with probability\n        if (cost_change1 < 0 and cost_change2 < 0) or \\\n           (np.random.rand() < 0.3 and (cost_change1 <= 0 or cost_change2 <= 0)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8412585621674133,
            1.042233943939209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with highest diversity in objectives\n        objectives = np.array([s[1] for s in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(np.sum(diversity))\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal based on spatial locality\n    segment_length = max(2, n // 4)\n    for i in range(0, n, segment_length):\n        segment_end = min(i + segment_length, n)\n        segment = new_solution[i:segment_end]\n\n        # Calculate centroids of the segment in both spaces\n        coords1 = instance[segment, :2]\n        coords2 = instance[segment, 2:]\n        centroid1 = np.mean(coords1, axis=0)\n        centroid2 = np.mean(coords2, axis=0)\n\n        # Calculate distances from centroid to nodes\n        dist1 = np.linalg.norm(coords1 - centroid1, axis=1)\n        dist2 = np.linalg.norm(coords2 - centroid2, axis=1)\n\n        # Reverse segment if nodes are more spread out in either space\n        if np.std(dist1) > 1.5 * np.mean(dist1) or np.std(dist2) > 1.5 * np.mean(dist2):\n            new_solution[i:segment_end] = segment[::-1]\n\n    # Step 2: Guided node swapping based on objective improvement\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n\n        # Calculate cost change for both objectives\n        cost_change1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        cost_change2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                       (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Accept swap if both objectives improve or at least one improves with probability\n        if (cost_change1 < 0 and cost_change2 < 0) or \\\n           (np.random.rand() < 0.3 and (cost_change1 <= 0 or cost_change2 <= 0)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive with high potential for improvement by considering both objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(1, n - 1)\n    j = np.random.randint(0, n)\n    while j == i or j == i - 1:\n        j = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    new_solution = np.insert(new_solution, j, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{The new algorithm selects solutions based on their objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion, but with adjusted segment length and insertion criteria to explore different regions of the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj - np.mean(normalized_obj, axis=0), axis=1)\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(8, max(3, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with objective-aware selection\n    candidate_nodes = new_solution[1:-1]\n    node_scores = []\n    for node in candidate_nodes:\n        i = np.where(new_solution == node)[0][0]\n        for j in range(n):\n            if j == i or j == i - 1:\n                continue\n            temp_solution = np.delete(new_solution, i)\n            temp_solution = np.insert(temp_solution, j, node)\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            node_scores.append((i, j, cost1 + cost2))\n\n    if node_scores:\n        best_i, best_j, _ = min(node_scores, key=lambda x: x[2])\n        new_solution = np.delete(new_solution, best_i)\n        new_solution = np.insert(new_solution, best_j, base_solution[best_i])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7688592074726741,
            12.83986520767212
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj - np.mean(normalized_obj, axis=0), axis=1)\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with dynamic length\n    segment_length = min(8, max(3, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion with objective-aware selection\n    candidate_nodes = new_solution[1:-1]\n    node_scores = []\n    for node in candidate_nodes:\n        i = np.where(new_solution == node)[0][0]\n        for j in range(n):\n            if j == i or j == i - 1:\n                continue\n            temp_solution = np.delete(new_solution, i)\n            temp_solution = np.insert(temp_solution, j, node)\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n            node_scores.append((i, j, cost1 + cost2))\n\n    if node_scores:\n        best_i, best_j, _ = min(node_scores, key=lambda x: x[2])\n        new_solution = np.delete(new_solution, best_i)\n        new_solution = np.insert(new_solution, best_j, base_solution[best_i])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{This algorithm intelligently selects a solution from the archive and applies a combination of node reinsertion with adaptive segment selection and a guided edge flipping strategy to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (np.max(objectives, axis=0) + 1e-10)\n    scores = np.linalg.norm(norm_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reinsertion\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1].copy()\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    insert_pos = np.random.randint(0, len(new_solution) - len(segment) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Guided edge flipping with objective-aware selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        flipped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        flipped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Objective-aware acceptance criteria\n        if (flipped_cost1 < current_cost1 and flipped_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (flipped_cost1 <= current_cost1 or flipped_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random 3-opt for diversity\n    if np.random.rand() < 0.15:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7890700606932979,
            0.334470272064209
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    norm_objectives = objectives / (np.max(objectives, axis=0) + 1e-10)\n    scores = np.linalg.norm(norm_objectives, axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reinsertion\n    seg_size = min(4, n // 4)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1].copy()\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    insert_pos = np.random.randint(0, len(new_solution) - len(segment) + 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Guided edge flipping with objective-aware selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        flipped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        flipped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Objective-aware acceptance criteria\n        if (flipped_cost1 < current_cost1 and flipped_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (flipped_cost1 <= current_cost1 or flipped_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random 3-opt for diversity\n    if np.random.rand() < 0.15:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        new_solution = np.concatenate([new_solution[:a], segment2, segment1, new_solution[c:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm combines a multi-objective path segment reordering strategy with adaptive node clustering to generate high-quality neighbors by intelligently reordering segments based on their combined objective improvement potential while ensuring feasibility through cluster-based validation.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 0.9, len(archive)) / np.sum(np.linspace(0.1, 0.9, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        clusters.append(new_solution[i:i+cluster_size])\n\n    # Multi-objective path segment reordering\n    for _ in range(2):  # Perform multiple reordering attempts\n        i = np.random.randint(0, len(clusters))\n        j = np.random.randint(0, len(clusters))\n        while j == i:\n            j = np.random.randint(0, len(clusters))\n\n        # Calculate current and potential costs\n        current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n        current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        # Create temporary solution for evaluation\n        temp_solution = new_solution.copy()\n        cluster_i = clusters[i]\n        cluster_j = clusters[j]\n\n        # Try swapping clusters\n        for pos_i in range(len(cluster_i)):\n            for pos_j in range(len(cluster_j)):\n                temp_solution = new_solution.copy()\n                temp_solution[np.where(new_solution == cluster_i[pos_i])[0][0]] = cluster_j[pos_j]\n                temp_solution[np.where(new_solution == cluster_j[pos_j])[0][0]] = cluster_i[pos_i]\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n                new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n                if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                    new_solution = temp_solution\n                    current_cost1, current_cost2 = new_cost1, new_cost2\n                    break\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{This algorithm selects a solution from the archive using a tournament selection based on Pareto dominance and crowding distance, then applies a novel adaptive segment insertion and rotation operator that intelligently reinserts segments of the tour while rotating them to explore better objective trade-offs, ensuring feasibility through careful segment validation and boundary checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection based on Pareto dominance and crowding distance\n    selected_idx = np.random.choice(len(archive))\n    for _ in range(3):\n        candidate_idx = np.random.choice(len(archive))\n        if (archive[candidate_idx][1][0] < archive[selected_idx][1][0] and archive[candidate_idx][1][1] <= archive[selected_idx][1][1]) or \\\n           (archive[candidate_idx][1][0] <= archive[selected_idx][1][0] and archive[candidate_idx][1][1] < archive[selected_idx][1][1]):\n            selected_idx = candidate_idx\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment insertion and rotation\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Find insertion point with best objective improvement\n    best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    best_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < end:\n            continue  # Skip original position\n\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            rotated_segment,\n            new_solution[pos + segment_length:]\n        ])\n\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (cost1 < best_cost1 and cost2 < best_cost2) or \\\n           (np.random.rand() < 0.2 and (cost1 <= best_cost1 or cost2 <= best_cost2)):\n            best_cost1, best_cost2 = cost1, cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            rotated_segment,\n            new_solution[best_pos + segment_length:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8378054229492837,
            0.736831784248352
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Tournament selection based on Pareto dominance and crowding distance\n    selected_idx = np.random.choice(len(archive))\n    for _ in range(3):\n        candidate_idx = np.random.choice(len(archive))\n        if (archive[candidate_idx][1][0] < archive[selected_idx][1][0] and archive[candidate_idx][1][1] <= archive[selected_idx][1][1]) or \\\n           (archive[candidate_idx][1][0] <= archive[selected_idx][1][0] and archive[candidate_idx][1][1] < archive[selected_idx][1][1]):\n            selected_idx = candidate_idx\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment insertion and rotation\n    segment_length = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Rotate the segment\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n\n    # Find insertion point with best objective improvement\n    best_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    best_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(n-1)) + distance_matrix_2[new_solution[-1], new_solution[0]]\n    best_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < end:\n            continue  # Skip original position\n\n        temp_solution = np.concatenate([\n            new_solution[:pos],\n            rotated_segment,\n            new_solution[pos + segment_length:]\n        ])\n\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[k+1]] for k in range(n-1)) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        if (cost1 < best_cost1 and cost2 < best_cost2) or \\\n           (np.random.rand() < 0.2 and (cost1 <= best_cost1 or cost2 <= best_cost2)):\n            best_cost1, best_cost2 = cost1, cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            rotated_segment,\n            new_solution[best_pos + segment_length:]\n        ])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of both objectives' improvement potential, then applies a novel hybrid local search combining adaptive segment relocation and constrained edge inversion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    seg_size = min(4, n // 5)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    new_pos = np.random.randint(0, n - seg_size)\n    if new_pos > a:\n        new_pos += seg_size\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:new_pos], segment, new_solution[new_pos:]])\n\n    # Constrained edge inversion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Invert segment if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8637900211263909,
            0.20634490251541138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * improvement_potential[:, 0] + 0.5 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    seg_size = min(4, n // 5)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n    new_pos = np.random.randint(0, n - seg_size)\n    if new_pos > a:\n        new_pos += seg_size\n    new_solution = np.concatenate([new_solution[:a], new_solution[b+1:new_pos], segment, new_solution[new_pos:]])\n\n    # Constrained edge inversion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Invert segment if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j:k+1] = np.flip(new_solution[j:k+1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This novel algorithm selects a solution from the archive based on its Pareto dominance, then applies a hybrid local search combining adaptive segment inversion and multi-objective edge swapping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance count\n    pareto_counts = []\n    for i, (sol, _) in enumerate(archive):\n        dominated = 0\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j:\n                if (other_obj[0] <= archive[i][1][0] and other_obj[1] < archive[i][1][1]) or \\\n                   (other_obj[0] < archive[i][1][0] and other_obj[1] <= archive[i][1][1]):\n                    dominated += 1\n        pareto_counts.append(-dominated)  # Negative for minimization\n\n    selected_idx = np.argmax(pareto_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Evaluate inversion impact\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b))\n    inverted_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(b, a-1, -1))\n    inverted_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(b, a-1, -1))\n\n    # Accept if both objectives improve or at least one improves with probability\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n       (np.random.rand() < 0.3 and (inverted_cost1 <= original_cost1 or inverted_cost2 <= original_cost2)):\n        new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) < 2:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[i], new_solution[(i+1)%n], new_solution[(i-1)%n]),\n                        (new_solution[j], new_solution[(j+1)%n], new_solution[(j-1)%n])]\n        potential_edges = [(new_solution[i], new_solution[j], new_solution[(i-1)%n]),\n                          (new_solution[j], new_solution[i], new_solution[(j-1)%n])]\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[a, b] for a, b, _ in current_edges)\n        current_cost2 = sum(distance_matrix_2[a, b] for a, b, _ in current_edges)\n        potential_cost1 = sum(distance_matrix_1[a, b] for a, b, _ in potential_edges)\n        potential_cost2 = sum(distance_matrix_2[a, b] for a, b, _ in potential_edges)\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (potential_cost1 <= current_cost1 or potential_cost2 <= current_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Random node insertion for diversity\n    if np.random.rand() < 0.2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8010403221917192,
            1.0415247678756714
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance count\n    pareto_counts = []\n    for i, (sol, _) in enumerate(archive):\n        dominated = 0\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j:\n                if (other_obj[0] <= archive[i][1][0] and other_obj[1] < archive[i][1][1]) or \\\n                   (other_obj[0] < archive[i][1][0] and other_obj[1] <= archive[i][1][1]):\n                    dominated += 1\n        pareto_counts.append(-dominated)  # Negative for minimization\n\n    selected_idx = np.argmax(pareto_counts)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Evaluate inversion impact\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b))\n    inverted_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(b, a-1, -1))\n    inverted_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(b, a-1, -1))\n\n    # Accept if both objectives improve or at least one improves with probability\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n       (np.random.rand() < 0.3 and (inverted_cost1 <= original_cost1 or inverted_cost2 <= original_cost2)):\n        new_solution[a:b+1] = new_solution[b:a-1:-1]\n\n    # Step 2: Multi-objective edge swapping\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) < 2:\n            continue\n\n        # Get current and potential edges\n        current_edges = [(new_solution[i], new_solution[(i+1)%n], new_solution[(i-1)%n]),\n                        (new_solution[j], new_solution[(j+1)%n], new_solution[(j-1)%n])]\n        potential_edges = [(new_solution[i], new_solution[j], new_solution[(i-1)%n]),\n                          (new_solution[j], new_solution[i], new_solution[(j-1)%n])]\n\n        # Calculate costs\n        current_cost1 = sum(distance_matrix_1[a, b] for a, b, _ in current_edges)\n        current_cost2 = sum(distance_matrix_2[a, b] for a, b, _ in current_edges)\n        potential_cost1 = sum(distance_matrix_1[a, b] for a, b, _ in potential_edges)\n        potential_cost2 = sum(distance_matrix_2[a, b] for a, b, _ in potential_edges)\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (potential_cost1 < current_cost1 and potential_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (potential_cost1 <= current_cost1 or potential_cost2 <= current_cost2)):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Step 3: Random node insertion for diversity\n    if np.random.rand() < 0.2:\n        k = np.random.randint(0, n)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive segment inversion and objective-balanced relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Evaluate segment inversion impact\n        original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        inverted_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        inverted_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (inverted_cost1 <= original_cost1 or inverted_cost2 <= original_cost2)):\n            new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-balanced relinking\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        segment = new_solution[i:j+1]\n        if len(segment) < 2:\n            return new_solution\n\n        # Evaluate relinking impact\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        relinked_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        relinked_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (relinked_cost1 < original_cost1 and relinked_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.4 and (relinked_cost1 <= original_cost1 or relinked_cost2 <= original_cost2)):\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9421141699206269,
            0.29728394746780396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) < 2:\n            continue\n\n        # Evaluate segment inversion impact\n        original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        inverted_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n        inverted_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (inverted_cost1 <= original_cost1 or inverted_cost2 <= original_cost2)):\n            new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-balanced relinking\n    if np.random.rand() < 0.5:\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        segment = new_solution[i:j+1]\n        if len(segment) < 2:\n            return new_solution\n\n        # Evaluate relinking impact\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        relinked_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        relinked_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (relinked_cost1 < original_cost1 and relinked_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.4 and (relinked_cost1 <= original_cost1 or relinked_cost2 <= original_cost2)):\n            new_solution[i:j+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the product of objectives (ascending) to prioritize solutions with balanced improvements\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] * x[1][1])\n        # Select top 20% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and node reversal\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.788335191685038,
            0.22203856706619263
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the product of objectives (ascending) to prioritize solutions with balanced improvements\n        sorted_archive = sorted(archive, key=lambda x: x[1][0] * x[1][1])\n        # Select top 20% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 5)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and node reversal\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a segment to reverse\n        start = random.randint(0, n-2)\n        end = random.randint(start+1, n-1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{This algorithm selects a solution from the archive based on both objective values and spatial proximity, then applies a novel hybrid local search combining segment inversion and adaptive node reallocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with best balance between objectives and spatial diversity\n        def score(sol_obj):\n            obj1, obj2 = sol_obj[1]\n            diversity = np.mean(np.linalg.norm(instance[sol_obj[0][:-1], :2] - instance[sol_obj[0][1:], :2], axis=1))\n            return (obj1 + obj2) / diversity if diversity > 0 else (obj1 + obj2)\n\n        selected = min(archive, key=score)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with spatial awareness\n    if n > 3:\n        # Step 1: Find spatially distant segments to invert\n        segment_length = max(2, n // 6)\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Calculate spatial distance between segment endpoints\n        start_node = new_solution[start]\n        end_node = new_solution[end]\n        spatial_dist = np.linalg.norm(instance[start_node, :2] - instance[end_node, :2])\n\n        # Invert segment if it's spatially distant\n        if spatial_dist > np.mean(np.linalg.norm(instance[:, :2] - instance[:, :2].mean(axis=0), axis=1)):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Step 2: Adaptive node reallocation based on objective improvement\n        for i in range(n):\n            if random.random() < 0.1:\n                # Calculate potential improvement for moving current node\n                current_node = new_solution[i]\n                prev_node = new_solution[i-1]\n                next_node = new_solution[(i+1)%n]\n\n                original_cost = (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node] +\n                                distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node])\n\n                # Try moving to a position that would improve spatial proximity\n                candidates = [j for j in range(n) if j != i and j != i-1 and j != (i+1)%n]\n                if candidates:\n                    best_pos = None\n                    best_improvement = 0\n\n                    for pos in candidates:\n                        new_prev = new_solution[pos-1]\n                        new_next = new_solution[pos]\n\n                        new_cost = (distance_matrix_1[new_prev, current_node] + distance_matrix_1[current_node, new_next] +\n                                   distance_matrix_2[new_prev, current_node] + distance_matrix_2[current_node, new_next])\n\n                        improvement = original_cost - new_cost\n                        spatial_gain = np.linalg.norm(instance[new_prev, :2] - instance[current_node, :2]) + \\\n                                      np.linalg.norm(instance[current_node, :2] - instance[new_next, :2])\n\n                        if improvement + spatial_gain > best_improvement:\n                            best_improvement = improvement + spatial_gain\n                            best_pos = pos\n\n                    if best_pos is not None:\n                        new_solution = np.delete(new_solution, i)\n                        new_solution = np.insert(new_solution, best_pos, current_node)\n\n    return new_solution\n\n",
        "score": [
            -0.7861405675267548,
            1.0653082132339478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solution with best balance between objectives and spatial diversity\n        def score(sol_obj):\n            obj1, obj2 = sol_obj[1]\n            diversity = np.mean(np.linalg.norm(instance[sol_obj[0][:-1], :2] - instance[sol_obj[0][1:], :2], axis=1))\n            return (obj1 + obj2) / diversity if diversity > 0 else (obj1 + obj2)\n\n        selected = min(archive, key=score)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion with spatial awareness\n    if n > 3:\n        # Step 1: Find spatially distant segments to invert\n        segment_length = max(2, n // 6)\n        start = random.randint(0, n - segment_length - 1)\n        end = start + segment_length\n\n        # Calculate spatial distance between segment endpoints\n        start_node = new_solution[start]\n        end_node = new_solution[end]\n        spatial_dist = np.linalg.norm(instance[start_node, :2] - instance[end_node, :2])\n\n        # Invert segment if it's spatially distant\n        if spatial_dist > np.mean(np.linalg.norm(instance[:, :2] - instance[:, :2].mean(axis=0), axis=1)):\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Step 2: Adaptive node reallocation based on objective improvement\n        for i in range(n):\n            if random.random() < 0.1:\n                # Calculate potential improvement for moving current node\n                current_node = new_solution[i]\n                prev_node = new_solution[i-1]\n                next_node = new_solution[(i+1)%n]\n\n                original_cost = (distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node] +\n                                distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node])\n\n                # Try moving to a position that would improve spatial proximity\n                candidates = [j for j in range(n) if j != i and j != i-1 and j != (i+1)%n]\n                if candidates:\n                    best_pos = None\n                    best_improvement = 0\n\n                    for pos in candidates:\n                        new_prev = new_solution[pos-1]\n                        new_next = new_solution[pos]\n\n                        new_cost = (distance_matrix_1[new_prev, current_node] + distance_matrix_1[current_node, new_next] +\n                                   distance_matrix_2[new_prev, current_node] + distance_matrix_2[current_node, new_next])\n\n                        improvement = original_cost - new_cost\n                        spatial_gain = np.linalg.norm(instance[new_prev, :2] - instance[current_node, :2]) + \\\n                                      np.linalg.norm(instance[current_node, :2] - instance[new_next, :2])\n\n                        if improvement + spatial_gain > best_improvement:\n                            best_improvement = improvement + spatial_gain\n                            best_pos = pos\n\n                    if best_pos is not None:\n                        new_solution = np.delete(new_solution, i)\n                        new_solution = np.insert(new_solution, best_pos, current_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment reversal with a probabilistic edge exchange strategy, guided by both objective-specific distance matrices and a diversity-preserving swap mechanism to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate segment cost before reversal\n    seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Perform reversal\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Calculate segment cost after reversal\n    new_seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Revert if reversal worsens both objectives\n    if new_seg_cost1 > seg_cost1 and new_seg_cost2 > seg_cost2:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Probabilistic edge exchange with objective balancing\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Balanced acceptance criteria\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Objective-aware swap with diversity preservation\n    if np.random.rand() < 0.2:\n        # Select nodes with high potential for improvement\n        potential_nodes = []\n        for i in range(n):\n            j = (i + 1) % n\n            if (distance_matrix_1[new_solution[i], new_solution[j]] > np.median(distance_matrix_1) or\n                distance_matrix_2[new_solution[i], new_solution[j]] > np.median(distance_matrix_2)):\n                potential_nodes.append(i)\n\n        if len(potential_nodes) >= 2:\n            p, q = np.random.choice(potential_nodes, 2, replace=False)\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.6649275803282202,
            1.475908100605011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([sum(obj) for _, obj in archive])\n    selected_idx = np.argmin(objectives)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment reversal with objective-aware selection\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Calculate segment cost before reversal\n    seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Perform reversal\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Calculate segment cost after reversal\n    new_seg_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_seg_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Revert if reversal worsens both objectives\n    if new_seg_cost1 > seg_cost1 and new_seg_cost2 > seg_cost2:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Probabilistic edge exchange with objective balancing\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Balanced acceptance criteria\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= current_cost1 * 1.1):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Objective-aware swap with diversity preservation\n    if np.random.rand() < 0.2:\n        # Select nodes with high potential for improvement\n        potential_nodes = []\n        for i in range(n):\n            j = (i + 1) % n\n            if (distance_matrix_1[new_solution[i], new_solution[j]] > np.median(distance_matrix_1) or\n                distance_matrix_2[new_solution[i], new_solution[j]] > np.median(distance_matrix_2)):\n                potential_nodes.append(i)\n\n        if len(potential_nodes) >= 2:\n            p, q = np.random.choice(potential_nodes, 2, replace=False)\n            new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and improvement potential, then applies a hybrid local search combining adaptive segment reversal and guided node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with diverse objectives\n        objectives = np.array([x[1] for x in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_length = max(2, n // 4)\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Evaluate segment reversal impact\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (random.random() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    # Guided node reinsertion\n    if n > 4:\n        # Select a node with high potential for improvement\n        costs = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev, current] + distance_matrix_1[current, next_node]\n            cost2 = distance_matrix_2[prev, current] + distance_matrix_2[current, next_node]\n            costs.append(cost1 + cost2)\n\n        node_to_move = np.argmax(costs)\n        node = new_solution[node_to_move]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find best insertion position\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n-1):\n            # Evaluate insertion at position pos\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n            original_cost1 = distance_matrix_1[prev, next_node]\n            original_cost2 = distance_matrix_2[prev, next_node]\n\n            new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (improvement1 > 0 and improvement2 > 0) or \\\n               (random.random() < 0.3 and (improvement1 >= 0 or improvement2 >= 0)):\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        # Insert at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9086544279407758,
            0.3349236845970154
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with diverse objectives\n        objectives = np.array([x[1] for x in archive])\n        diversity = np.std(objectives, axis=0)\n        selected_idx = np.argmax(diversity)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal\n    if n > 3:\n        segment_length = max(2, n // 4)\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Evaluate segment reversal impact\n        original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost1 = sum(distance_matrix_1[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n        original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        reversed_cost2 = sum(distance_matrix_2[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n\n        # Accept if both objectives improve or at least one improves with probability\n        if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n           (random.random() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n            new_solution[start:start+segment_length] = segment[::-1]\n\n    # Guided node reinsertion\n    if n > 4:\n        # Select a node with high potential for improvement\n        costs = []\n        for i in range(n):\n            prev = new_solution[i-1]\n            current = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n            cost1 = distance_matrix_1[prev, current] + distance_matrix_1[current, next_node]\n            cost2 = distance_matrix_2[prev, current] + distance_matrix_2[current, next_node]\n            costs.append(cost1 + cost2)\n\n        node_to_move = np.argmax(costs)\n        node = new_solution[node_to_move]\n\n        # Remove the node\n        new_solution = np.delete(new_solution, node_to_move)\n\n        # Find best insertion position\n        best_pos = 0\n        best_improvement = 0\n        for pos in range(n-1):\n            # Evaluate insertion at position pos\n            prev = new_solution[pos-1]\n            next_node = new_solution[pos]\n            original_cost1 = distance_matrix_1[prev, next_node]\n            original_cost2 = distance_matrix_2[prev, next_node]\n\n            new_cost1 = distance_matrix_1[prev, node] + distance_matrix_1[node, next_node]\n            new_cost2 = distance_matrix_2[prev, node] + distance_matrix_2[node, next_node]\n\n            improvement1 = original_cost1 - new_cost1\n            improvement2 = original_cost2 - new_cost2\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (improvement1 > 0 and improvement2 > 0) or \\\n               (random.random() < 0.3 and (improvement1 >= 0 or improvement2 >= 0)):\n                if improvement1 + improvement2 > best_improvement:\n                    best_improvement = improvement1 + improvement2\n                    best_pos = pos\n\n        # Insert at best position\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive segment inversion and constrained k-opt moves to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    k = min(4, n // 3)\n    segments = []\n    for _ in range(k):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segments.append((a, b))\n\n    for a, b in sorted(segments, key=lambda x: x[0]):\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.15 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8430518073216486,
            0.503544270992279
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    k = min(4, n // 3)\n    segments = []\n    for _ in range(k):\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        segments.append((a, b))\n\n    for a, b in sorted(segments, key=lambda x: x[0]):\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[j], new_solution[l]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[j], new_solution[l]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.15 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -1.0064181753853354,
            0.4140263795852661
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined measure of objective improvement and solution quality, then applies a novel hybrid local search combining adaptive segment relocation and guided edge inversion with dynamic parameter adaptation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 - normalized_obj[:, 0] * 0.4 - normalized_obj[:, 1] * 0.6\n    selected_idx = np.random.choice(len(archive), p=quality_scores / quality_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_size = min(5, n // 2)\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    inversion_length = min(4, n // 3)\n    inv_start = np.random.randint(0, n - inversion_length)\n    new_solution[inv_start:inv_start+inversion_length] = new_solution[inv_start:inv_start+inversion_length][::-1]\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8382779269790338,
            0.36709141731262207
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 - normalized_obj[:, 0] * 0.4 - normalized_obj[:, 1] * 0.6\n    selected_idx = np.random.choice(len(archive), p=quality_scores / quality_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_size = min(5, n // 2)\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    inversion_length = min(4, n // 3)\n    inv_start = np.random.randint(0, n - inversion_length)\n    new_solution[inv_start:inv_start+inversion_length] = new_solution[inv_start:inv_start+inversion_length][::-1]\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search operator that combines adaptive edge insertion with guided segment rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Adaptive edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    # Step 2: Guided segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation_amount = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation_amount)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.830738791176237,
            0.43568098545074463
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Adaptive edge insertion\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    # Step 2: Guided segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation_amount = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation_amount)\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection strategy that combines objective values and solution structure, then applies a hybrid local search combining partial path reversal with adaptive node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diff = np.abs(solutions - solutions[i])\n        diversity_scores[i] = np.sum(diff != 0)\n\n    normalized_diversity = diversity_scores / (diversity_scores.max() + 1e-8)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9090978484057783,
            0.4568830132484436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    solutions = np.array([sol for sol, _ in archive])\n    n = len(solutions[0])\n\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diff = np.abs(solutions - solutions[i])\n        diversity_scores[i] = np.sum(diff != 0)\n\n    normalized_diversity = diversity_scores / (diversity_scores.max() + 1e-8)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n    insert_pos = np.random.randint(0, n - 1)\n    new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9389992377726866,
            0.18591547012329102
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines objective dominance and solution diversity, then applies an adaptive neighborhood search that combines partial path reversal with strategic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(solutions)\n\n    if n_solutions == 1:\n        base_solution = solutions[0].copy()\n    else:\n        dominated = np.zeros(n_solutions, dtype=bool)\n        for i in range(n_solutions):\n            for j in range(n_solutions):\n                if i != j and all(objectives[i] >= objectives[j]):\n                    dominated[i] = True\n                    break\n        non_dominated = [i for i in range(n_solutions) if not dominated[i]]\n\n        if not non_dominated:\n            non_dominated = range(n_solutions)\n\n        diversity_scores = []\n        for i in non_dominated:\n            distances = []\n            for j in non_dominated:\n                if i != j:\n                    diff = np.abs(objectives[i] - objectives[j])\n                    distances.append(np.linalg.norm(diff))\n            diversity_scores.append(np.mean(distances) if distances else 1.0)\n\n        selection_probs = np.array(diversity_scores) / np.sum(diversity_scores)\n        selected_idx = np.random.choice(non_dominated, p=selection_probs)\n        base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9203256393644741,
            1.3363584280014038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n_solutions = len(solutions)\n\n    if n_solutions == 1:\n        base_solution = solutions[0].copy()\n    else:\n        dominated = np.zeros(n_solutions, dtype=bool)\n        for i in range(n_solutions):\n            for j in range(n_solutions):\n                if i != j and all(objectives[i] >= objectives[j]):\n                    dominated[i] = True\n                    break\n        non_dominated = [i for i in range(n_solutions) if not dominated[i]]\n\n        if not non_dominated:\n            non_dominated = range(n_solutions)\n\n        diversity_scores = []\n        for i in non_dominated:\n            distances = []\n            for j in non_dominated:\n                if i != j:\n                    diff = np.abs(objectives[i] - objectives[j])\n                    distances.append(np.linalg.norm(diff))\n            diversity_scores.append(np.mean(distances) if distances else 1.0)\n\n        selection_probs = np.array(diversity_scores) / np.sum(diversity_scores)\n        selected_idx = np.random.choice(non_dominated, p=selection_probs)\n        base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:i], new_solution[j:k], new_solution[i:j], new_solution[k:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{This new algorithm selects a solution from the archive based on its normalized improvement potential in both objectives, then applies a hybrid local search combining adaptive segment reversal and probabilistic edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential with different parameter weights.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.3 * improvement_potential[:, 0] + 0.7 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + np.random.randint(2, min(5, n//2))) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8976777342676477,
            0.414847731590271
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.3 * improvement_potential[:, 0] + 0.7 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + np.random.randint(2, min(5, n//2))) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of objective dominance and solution quality, then applies a hybrid local search combining adaptive segment inversion with guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.array([not any((objectives[:, 0] <= obj[0]) & (objectives[:, 1] <= obj[1]) & ((objectives[:, 0] < obj[0]) | (objectives[:, 1] < obj[1]))) for obj in objectives])\n    quality_scores = 1 / (1 + np.sum(objectives, axis=1))\n    combined_scores = 0.6 * pareto_front + 0.4 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if inversion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        new_solution[i:] = np.roll(new_solution[i:], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.924926742379218,
            1.6383115649223328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.array([not any((objectives[:, 0] <= obj[0]) & (objectives[:, 1] <= obj[1]) & ((objectives[:, 0] < obj[0]) | (objectives[:, 1] < obj[1]))) for obj in objectives])\n    quality_scores = 1 / (1 + np.sum(objectives, axis=1))\n    combined_scores = 0.6 * pareto_front + 0.4 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[i], new_solution[i+1]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple rotation if inversion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        new_solution[i:] = np.roll(new_solution[i:], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive segment inversion and constrained node insertion with dynamic objective balancing to generate a neighbor solution while ensuring feasibility, using a probabilistic acceptance criterion that considers both objectives and solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.linalg.norm(np.mean(instance[archive[i][0]], axis=0) - np.mean(instance, axis=0)) for i in range(len(archive))])\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.833109622066501,
            1.1488231420516968
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.linalg.norm(np.mean(instance[archive[i][0]], axis=0) - np.mean(instance, axis=0)) for i in range(len(archive))])\n    diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if np.random.rand() < 0.3:\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{This novel hybrid local search operator combines a multi-segment shuffle with an adaptive Pareto-guided edge insertion strategy to create diverse high-quality neighbors while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment shuffle with adaptive segment sizes\n    num_segments = max(2, min(4, n // 5))\n    segment_indices = sorted(np.random.choice(range(1, n), num_segments-1, replace=False))\n    segments = np.split(new_solution, segment_indices)\n\n    # Shuffle segments with probability based on segment size\n    for i in range(len(segments)-1):\n        if np.random.rand() < 0.3 + (0.7 * len(segments[i]) / n):\n            j = np.random.randint(i+1, len(segments))\n            segments[i], segments[j] = segments[j], segments[i]\n\n    new_solution = np.concatenate(segments)\n\n    # Adaptive Pareto-guided edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best insertion point for node k\n        best_pos = j\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == i or pos == j:\n                continue\n\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            # Pareto dominance check\n            if (improvement1 > 0 and improvement2 >= 0) or (improvement1 >= 0 and improvement2 > 0):\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n        if best_pos != j:\n            # Perform the insertion\n            node_to_insert = new_solution[k]\n            new_solution = np.concatenate([\n                new_solution[:k],\n                new_solution[k+1:best_pos+1],\n                [node_to_insert],\n                new_solution[best_pos+1:]\n            ])\n\n    # Random edge reversal for additional diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7021170843500404,
            1.5651799440383911
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Multi-segment shuffle with adaptive segment sizes\n    num_segments = max(2, min(4, n // 5))\n    segment_indices = sorted(np.random.choice(range(1, n), num_segments-1, replace=False))\n    segments = np.split(new_solution, segment_indices)\n\n    # Shuffle segments with probability based on segment size\n    for i in range(len(segments)-1):\n        if np.random.rand() < 0.3 + (0.7 * len(segments[i]) / n):\n            j = np.random.randint(i+1, len(segments))\n            segments[i], segments[j] = segments[j], segments[i]\n\n    new_solution = np.concatenate(segments)\n\n    # Adaptive Pareto-guided edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best insertion point for node k\n        best_pos = j\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos == i or pos == j:\n                continue\n\n            # Calculate potential improvement\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            # Pareto dominance check\n            if (improvement1 > 0 and improvement2 >= 0) or (improvement1 >= 0 and improvement2 > 0):\n                total_improvement = improvement1 + improvement2\n                if total_improvement > best_improvement:\n                    best_improvement = total_improvement\n                    best_pos = pos\n\n        if best_pos != j:\n            # Perform the insertion\n            node_to_insert = new_solution[k]\n            new_solution = np.concatenate([\n                new_solution[:k],\n                new_solution[k+1:best_pos+1],\n                [node_to_insert],\n                new_solution[best_pos+1:]\n            ])\n\n    # Random edge reversal for additional diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment inversion with guided node insertion and edge optimization to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n    best_insert_pos = 0\n    min_cost = float('inf')\n    for pos in range(len(new_solution)):\n        temp_solution = np.insert(new_solution, pos, node_to_move)\n        cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        for k in range(len(temp_solution)-1):\n            cost1 += distance_matrix_1[temp_solution[k], temp_solution[k+1]]\n            cost2 += distance_matrix_2[temp_solution[k], temp_solution[k+1]]\n        total_cost = 0.6 * cost1 + 0.4 * cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = pos\n\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_move)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    return new_solution\n\n",
        "score": [
            -0.8262020671345962,
            1.1260889768600464
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n\n    best_insert_pos = 0\n    min_cost = float('inf')\n    for pos in range(len(new_solution)):\n        temp_solution = np.insert(new_solution, pos, node_to_move)\n        cost1 = distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = distance_matrix_2[temp_solution[-1], temp_solution[0]]\n        for k in range(len(temp_solution)-1):\n            cost1 += distance_matrix_1[temp_solution[k], temp_solution[k+1]]\n            cost2 += distance_matrix_2[temp_solution[k], temp_solution[k+1]]\n        total_cost = 0.6 * cost1 + 0.4 * cost2\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_insert_pos = pos\n\n    new_solution = np.insert(new_solution, best_insert_pos, node_to_move)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        k = np.random.randint(0, n)\n        while k == i or k == j:\n            k = np.random.randint(0, n)\n        new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This novel algorithm selects a high-potential solution from the archive, then applies a hybrid local search combining adaptive node clustering and guided path reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node clustering\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Step 2: Guided path reversal with objective-aware selection\n    for i in range(len(clusters)):\n        if np.random.rand() < 0.3:\n            cluster = clusters[i]\n            # Evaluate cluster reversal impact\n            original_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost1 = sum(distance_matrix_1[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n            original_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j+1)%len(cluster)]] for j in range(len(cluster)))\n            reversed_cost2 = sum(distance_matrix_2[cluster[j], cluster[(j-1)%len(cluster)]] for j in range(len(cluster)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.4 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                clusters[i] = cluster[::-1]\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Step 3: Additional random cluster swap for diversity\n    if np.random.rand() < 0.2 and len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        clusters[i], clusters[j] = clusters[j], clusters[i]\n        new_solution = np.concatenate(clusters)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{This novel algorithm selects a solution with high potential for improvement by combining adaptive segment inversion with objective-aware path smoothing to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) > 1:\n            # Evaluate segment inversion impact\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n            original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-aware path smoothing\n    for i in range(n):\n        if np.random.rand() < 0.1:\n            # Select random node to optimize\n            k = np.random.randint(0, n)\n            if k != i and k != (i+1)%n and k != (i-1)%n:\n                # Evaluate potential improvements\n                original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n                original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n\n                if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n                    # Perform the swap\n                    if i < k:\n                        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                    else:\n                        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8600687890176659,
            0.3131102919578552
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined improvement potential\n    potential = [sum(archive[i][1]) for i in range(len(archive))]\n    selected_idx = np.argmax(potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_size = max(2, n // 4)\n    for i in range(0, n, segment_size):\n        segment = new_solution[i:i+segment_size]\n        if len(segment) > 1:\n            # Evaluate segment inversion impact\n            original_cost1 = sum(distance_matrix_1[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost1 = sum(distance_matrix_1[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n            original_cost2 = sum(distance_matrix_2[segment[j], segment[(j+1)%len(segment)]] for j in range(len(segment)))\n            reversed_cost2 = sum(distance_matrix_2[segment[j], segment[(j-1)%len(segment)]] for j in range(len(segment)))\n\n            # Accept if both objectives improve or at least one improves with probability\n            if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2) or \\\n               (np.random.rand() < 0.5 and (reversed_cost1 <= original_cost1 or reversed_cost2 <= original_cost2)):\n                new_solution[i:i+segment_size] = segment[::-1]\n\n    # Step 2: Objective-aware path smoothing\n    for i in range(n):\n        if np.random.rand() < 0.1:\n            # Select random node to optimize\n            k = np.random.randint(0, n)\n            if k != i and k != (i+1)%n and k != (i-1)%n:\n                # Evaluate potential improvements\n                original_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[k], new_solution[(k+1)%n]]\n                new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n                original_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[k], new_solution[(k+1)%n]]\n                new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(k+1)%n]]\n\n                if (new_cost1 < original_cost1 and new_cost2 < original_cost2) or \\\n                   (np.random.rand() < 0.3 and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2)):\n                    # Perform the swap\n                    if i < k:\n                        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n                    else:\n                        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and solution quality, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.4 + 1e-8)\n    combined_scores = 0.4 * normalized_obj[:, 1] + 0.6 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    j = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9585993749374222,
            0.32454073429107666
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (normalized_obj[:, 0] * 0.6 + normalized_obj[:, 1] * 0.4 + 1e-8)\n    combined_scores = 0.4 * normalized_obj[:, 1] + 0.6 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    j = np.random.randint(0, n-1)\n    new_solution = np.insert(new_solution, j, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining adaptive segment inversion and probabilistic edge reconnection to generate a neighbor solution while ensuring feasibility, using a dynamic trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 1 / (normalized.sum(axis=1) + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    inv_length = min(4, n // 3)\n    start = np.random.randint(0, n - inv_length)\n    new_solution[start:start+inv_length] = np.flip(new_solution[start:start+inv_length])\n\n    # Probabilistic edge reconnection\n    for i in range(n):\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        if k != i and k != j and k != (i - 1) % n:\n            # Calculate potential new edges\n            old_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            old_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            # Reconnect with probability based on improvement\n            prob = np.exp(-0.5 * ((new_edge1 - old_edge1) + (new_edge2 - old_edge2)))\n            if np.random.rand() < prob:\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8512505572950452,
            0.36180657148361206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best trade-off between objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 1 / (normalized.sum(axis=1) + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    inv_length = min(4, n // 3)\n    start = np.random.randint(0, n - inv_length)\n    new_solution[start:start+inv_length] = np.flip(new_solution[start:start+inv_length])\n\n    # Probabilistic edge reconnection\n    for i in range(n):\n        j = (i + 1) % n\n        k = np.random.randint(0, n)\n        if k != i and k != j and k != (i - 1) % n:\n            # Calculate potential new edges\n            old_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            old_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            # Reconnect with probability based on improvement\n            prob = np.exp(-0.5 * ((new_edge1 - old_edge1) + (new_edge2 - old_edge2)))\n            if np.random.rand() < prob:\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines normalized objective values with solution quality metrics, then applies a novel local search strategy featuring adaptive segment inversion and targeted node reinsertion with dynamic parameter adjustments to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    quality_scores = 1 / (1 + np.sum(normalized_obj, axis=1))\n    diversity_scores = np.array([np.sum([np.abs(archive[i][0] - archive[j][0]).mean() for j in range(len(archive))]) for i in range(len(archive))])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n\n    combined_scores = 0.6 * quality_scores + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_size = min(5, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    if np.random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:end] = np.roll(new_solution[start:end], shift=np.random.randint(1, segment_size))\n\n    if np.random.random() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        candidates = []\n        for _ in range(5):\n            i, j = np.random.choice(n, 2, replace=False)\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidates.append(candidate)\n        new_solution = min(candidates, key=lambda x: sum(distance_matrix_1[x[:-1], x[1:]].sum() + distance_matrix_2[x[:-1], x[1:]].sum()))\n\n    return new_solution\n\n",
        "score": [
            -0.9607907078309599,
            4.5085256695747375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    quality_scores = 1 / (1 + np.sum(normalized_obj, axis=1))\n    diversity_scores = np.array([np.sum([np.abs(archive[i][0] - archive[j][0]).mean() for j in range(len(archive))]) for i in range(len(archive))])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n\n    combined_scores = 0.6 * quality_scores + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_size = min(5, n // 4)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n\n    if np.random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:end] = np.roll(new_solution[start:end], shift=np.random.randint(1, segment_size))\n\n    if np.random.random() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        candidates = []\n        for _ in range(5):\n            i, j = np.random.choice(n, 2, replace=False)\n            candidate = new_solution.copy()\n            candidate[i], candidate[j] = candidate[j], candidate[i]\n            candidates.append(candidate)\n        new_solution = min(candidates, key=lambda x: sum(distance_matrix_1[x[:-1], x[1:]].sum() + distance_matrix_2[x[:-1], x[1:]].sum()))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a hybrid local search combining adaptive segment inversion with guided node insertion and removal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + normalized_obj[:, 0] + normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=quality_scores / quality_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node_to_remove = new_solution[i]\n    remaining_nodes = np.delete(new_solution, i)\n\n    insertion_pos = np.random.randint(0, n - 1)\n    new_solution = np.concatenate([remaining_nodes[:insertion_pos], [node_to_remove], remaining_nodes[insertion_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9067854166377508,
            0.3676068186759949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + normalized_obj[:, 0] + normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=quality_scores / quality_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    node_to_remove = new_solution[i]\n    remaining_nodes = np.delete(new_solution, i)\n\n    insertion_pos = np.random.randint(0, n - 1)\n    new_solution = np.concatenate([remaining_nodes[:insertion_pos], [node_to_remove], remaining_nodes[insertion_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{A novel hybrid local search operator that intelligently selects solutions based on their non-dominated rank and combines a randomized segment inversion with a guided edge exchange strategy, while incorporating adaptive segment sizes and acceptance criteria to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = max(3, min(7, n // 2))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria with different probabilities\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.885206179180999,
            0.24717926979064941
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = max(3, min(7, n // 2))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria with different probabilities\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and crowding distance, then applies a hybrid local search combining adaptive segment reversal with objective-aware edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        neighbors = np.delete(objectives, i, axis=0)\n        crowding = np.sum(np.min(np.abs(objectives[i] - neighbors), axis=0))\n        crowding_distances[i] = crowding\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * crowding_distances / (crowding_distances.max() + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i:\n        j = np.random.randint(0, n)\n    if (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7345047240994401,
            0.8480151891708374
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        neighbors = np.delete(objectives, i, axis=0)\n        crowding = np.sum(np.min(np.abs(objectives[i] - neighbors), axis=0))\n        crowding_distances[i] = crowding\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * crowding_distances / (crowding_distances.max() + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i:\n        j = np.random.randint(0, n)\n    if (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment insertion with guided edge reversal, using different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8699245325998416,
            0.5130084156990051
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combined score of objective values and solution diversity, then applies a hybrid local search combining adaptive segment rotation and guided edge insertion with probabilistic acceptance criteria to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined score of objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum([int(a != b) for a, b in zip(archive[i][0], archive[0][0])]) for i in range(len(archive))])\n    normalized_div = diversity_scores / (diversity_scores.max() + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * normalized_div\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Guided edge insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n        # Probabilistic acceptance based on improvement\n        if np.random.rand() < 0.3:\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]]\n            if (new_cost1 > old_cost1 and new_cost2 > old_cost2):\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i], [node_to_move], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], shift=np.random.randint(1, b-a+1))\n\n    return new_solution\n\n",
        "score": [
            -0.8323656541826413,
            0.40929967164993286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on combined score of objectives and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum([int(a != b) for a, b in zip(archive[i][0], archive[0][0])]) for i in range(len(archive))])\n    normalized_div = diversity_scores / (diversity_scores.max() + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * normalized_div\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n    new_solution[start:start+segment_length] = rotated_segment\n\n    # Guided edge insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n        # Probabilistic acceptance based on improvement\n        if np.random.rand() < 0.3:\n            old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]]\n            if (new_cost1 > old_cost1 and new_cost2 > old_cost2):\n                new_solution = np.concatenate([new_solution[:j], new_solution[j+1:i], [node_to_move], new_solution[i:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], shift=np.random.randint(1, b-a+1))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{This algorithm selects a solution from the archive, applies a randomized segment reversal with adaptive segment size, and then performs a guided edge exchange strategy to improve both objectives while ensuring feasibility through adaptive acceptance criteria and occasional random swaps for diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias toward lower-cost solutions\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        selected_idx = np.random.randint(len(archive))\n    else:\n        probs = (1 / (costs + 1e-6)) / np.sum(1 / (costs + 1e-6))\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment size based on problem size\n    seg_size = min(4, max(2, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Randomized segment reversal\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive criteria\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Accept if both objectives improve or with probability based on improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap with adaptive probability\n    if np.random.rand() < 0.15 * (n / 100):\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9312739667701315,
            0.37472325563430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with a bias toward lower-cost solutions\n    costs = np.array([obj[0] + obj[1] for _, obj in archive])\n    if np.all(costs == costs[0]):\n        selected_idx = np.random.randint(len(archive))\n    else:\n        probs = (1 / (costs + 1e-6)) / np.sum(1 / (costs + 1e-6))\n        selected_idx = np.random.choice(len(archive), p=probs)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment size based on problem size\n    seg_size = min(4, max(2, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    # Randomized segment reversal\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive criteria\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        # Accept if both objectives improve or with probability based on improvement\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.3 * (1 - (i / n)) and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap with adaptive probability\n    if np.random.rand() < 0.15 * (n / 100):\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of normalized objective values and diversity, then applies a novel hybrid local search that combines adaptive segment rotation with guided node insertion and removal, ensuring feasibility through careful validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.3 * normalized_obj[:, 0] + 0.7 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[i:i+1], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8651809008243061,
            0.2125319242477417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.3 * normalized_obj[:, 0] + 0.7 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], new_solution[i:i+1], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{This algorithm selects a solution from the archive based on its balanced objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion with guided edge reinforcement, using a dynamic evaluation of improvement potential across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(np.diff(sol)) for sol, _ in archive])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_size = min(4, n // 3)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge reinforcement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Reinforce edges if beneficial for both objectives\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.9300846182141479,
            0.6641539335250854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std(np.diff(sol)) for sol, _ in archive])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_size = min(4, n // 3)\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge reinforcement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Reinforce edges if beneficial for both objectives\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8958330927235738,
            0.23886269330978394
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment reversal with a Pareto-dominated edge insertion strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment reversal\n    seg_size = max(3, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Pareto-dominated edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge swap for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.6774255173930002,
            0.3389892578125
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment reversal\n    seg_size = max(3, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Pareto-dominated edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge swap for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 1] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8246294188694597,
            0.4062635898590088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 1] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    node = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining adaptive segment inversion with guided edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 - (normalized_obj[:, 0] + normalized_obj[:, 1]) / 2\n    dominance_scores = np.array([np.sum((objectives <= obj).all(axis=1)) for obj in objectives])\n    combined_scores = 0.6 * quality_scores + 0.4 * dominance_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if inversion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8411212081453208,
            0.7068008780479431
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 - (normalized_obj[:, 0] + normalized_obj[:, 1]) / 2\n    dominance_scores = np.array([np.sum((objectives <= obj).all(axis=1)) for obj in objectives])\n    combined_scores = 0.6 * quality_scores + 0.4 * dominance_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided edge insertion\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i+1], [node], new_solution[i+1:j], new_solution[j+1:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if inversion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:i], [node], new_solution[i:j], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment inversion with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = min(j, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8299835643403447,
            0.3627985715866089
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(3, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node insertion\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i - j) < 2:\n        j = np.random.randint(0, n)\n\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    insert_pos = min(j, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple inversion if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm selects a solution from the archive using an adaptive weighted score combining normalized objectives and solution diversity, then applies a hybrid local search with dynamic segment rearrangement and targeted node insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[archive[i][0][j]][archive[i][0][j+1]] for j in range(len(archive[i][0])-1)]) for i in range(len(archive))])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    adaptive_weights = np.array([0.5 + 0.2 * np.random.random(), 0.5 + 0.2 * np.random.random()])\n    scores = adaptive_weights[0] * normalized_obj[:, 0] + adaptive_weights[1] * normalized_obj[:, 1] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.roll(new_solution[start:end], np.random.randint(1, segment_length))\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(j - i) <= 2:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8335446035323508,
            0.6064472198486328
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.std([distance_matrix_1[archive[i][0][j]][archive[i][0][j+1]] for j in range(len(archive[i][0])-1)]) for i in range(len(archive))])\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    adaptive_weights = np.array([0.5 + 0.2 * np.random.random(), 0.5 + 0.2 * np.random.random()])\n    scores = adaptive_weights[0] * normalized_obj[:, 0] + adaptive_weights[1] * normalized_obj[:, 1] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.roll(new_solution[start:end], np.random.randint(1, segment_length))\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(j - i) <= 2:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This algorithm selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment inversion, guided edge rotation, and probabilistic node relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                diversity[i] += np.sum(archive[i][0] != archive[j][0])\n                diversity[j] += np.sum(archive[i][0] != archive[j][0])\n        diversity = diversity / diversity.max() if diversity.max() > 0 else np.ones(len(archive))\n        scores = 0.7 * (1 - objectives[:, 0]/objectives[:, 0].max()) + 0.3 * diversity\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = np.flip(new_solution[a:a+seg_size])\n\n        # Guided edge rotation\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n            l = (i + 3) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            rotated_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            rotated_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (rotated_cost1 < current_cost1 and rotated_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.4 and (rotated_cost1 <= current_cost1 or rotated_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node relocation\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9014608055352716,
            1.4141967296600342
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                diversity[i] += np.sum(archive[i][0] != archive[j][0])\n                diversity[j] += np.sum(archive[i][0] != archive[j][0])\n        diversity = diversity / diversity.max() if diversity.max() > 0 else np.ones(len(archive))\n        scores = 0.7 * (1 - objectives[:, 0]/objectives[:, 0].max()) + 0.3 * diversity\n        selected_idx = np.random.choice(len(archive), p=scores/scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = np.flip(new_solution[a:a+seg_size])\n\n        # Guided edge rotation\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n            l = (i + 3) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            rotated_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            rotated_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (rotated_cost1 < current_cost1 and rotated_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.4 and (rotated_cost1 <= current_cost1 or rotated_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node relocation\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{This new algorithm selects a solution from the archive based on its combined objective improvement potential, then applies a dynamic multi-segment relocation strategy with adaptive edge optimization to generate diverse high-quality neighbors while maintaining feasibility through constrained segment insertion and Pareto-guided edge replacement.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic multi-segment relocation\n    num_segments = np.random.randint(2, min(4, n // 3))\n    segment_lengths = np.random.randint(2, min(4, n // num_segments), size=num_segments)\n    segment_lengths = np.clip(segment_lengths, 2, n // num_segments)\n\n    segments = []\n    positions = []\n    for length in segment_lengths:\n        pos = np.random.randint(0, n - length)\n        segments.append(new_solution[pos:pos+length])\n        positions.append(pos)\n\n    # Remove segments from original positions\n    for pos, length in zip(sorted(positions, reverse=True), segment_lengths):\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+length:]])\n\n    # Insert segments at new positions\n    insertion_points = sorted(np.random.choice(n - sum(segment_lengths), num_segments, replace=False))\n    for i, (segment, point) in enumerate(zip(segments, insertion_points)):\n        new_solution = np.concatenate([new_solution[:point], segment, new_solution[point:]])\n\n    # Adaptive edge optimization\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if ((new_cost1 < current_cost1 and new_cost2 <= current_cost2) or\n            (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or\n            (np.random.rand() < 0.1 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Constrained feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.912682086727032,
            0.5073862671852112
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic multi-segment relocation\n    num_segments = np.random.randint(2, min(4, n // 3))\n    segment_lengths = np.random.randint(2, min(4, n // num_segments), size=num_segments)\n    segment_lengths = np.clip(segment_lengths, 2, n // num_segments)\n\n    segments = []\n    positions = []\n    for length in segment_lengths:\n        pos = np.random.randint(0, n - length)\n        segments.append(new_solution[pos:pos+length])\n        positions.append(pos)\n\n    # Remove segments from original positions\n    for pos, length in zip(sorted(positions, reverse=True), segment_lengths):\n        new_solution = np.concatenate([new_solution[:pos], new_solution[pos+length:]])\n\n    # Insert segments at new positions\n    insertion_points = sorted(np.random.choice(n - sum(segment_lengths), num_segments, replace=False))\n    for i, (segment, point) in enumerate(zip(segments, insertion_points)):\n        new_solution = np.concatenate([new_solution[:point], segment, new_solution[point:]])\n\n    # Adaptive edge optimization\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n        if ((new_cost1 < current_cost1 and new_cost2 <= current_cost2) or\n            (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or\n            (np.random.rand() < 0.1 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Constrained feasibility check\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a novel hybrid local search combining adaptive segment inversion with guided node reinsertion and probabilistic edge contraction to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            dominance[i] = 1\n    if np.sum(dominance) > 0:\n        selected_idx = np.random.choice(np.where(dominance == 1)[0])\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    segment = new_solution[a:a+seg_size]\n    if np.random.rand() < 0.5:\n        new_solution[a:a+seg_size] = np.flip(segment)\n\n    # Guided node reinsertion\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Probabilistic edge contraction\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        contracted_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        contracted_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (contracted_cost1 < current_cost1 and contracted_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (contracted_cost1 <= current_cost1 or contracted_cost2 <= current_cost2)):\n            new_solution = np.delete(new_solution, j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8794313344141307,
            0.6576712131500244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and all(objectives[j] <= objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            dominance[i] = 1\n    if np.sum(dominance) > 0:\n        selected_idx = np.random.choice(np.where(dominance == 1)[0])\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    segment = new_solution[a:a+seg_size]\n    if np.random.rand() < 0.5:\n        new_solution[a:a+seg_size] = np.flip(segment)\n\n    # Guided node reinsertion\n    for _ in range(2):\n        node_pos = np.random.randint(0, n)\n        node = new_solution[node_pos]\n        new_solution = np.delete(new_solution, node_pos)\n        new_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, new_pos, node)\n\n    # Probabilistic edge contraction\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n        contracted_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        contracted_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (contracted_cost1 < current_cost1 and contracted_cost2 < current_cost2) or \\\n           (np.random.rand() < 0.4 and (contracted_cost1 <= current_cost1 or contracted_cost2 <= current_cost2)):\n            new_solution = np.delete(new_solution, j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a novel hybrid local search operator that combines adaptive segment rotation with Pareto-guided node insertion and edge swapping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        unique_pairs = set()\n        n = len(sol)\n        for i in range(n):\n            unique_pairs.add((sol[i], sol[(i+1)%n]))\n        diversity_scores.append(len(unique_pairs))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    rotation = np.random.randint(1, seg_size)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+seg_size] = rotated_segment\n\n    # Pareto-guided node insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_pos_cost1 = distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[j]]\n        new_pos_cost2 = distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[j]]\n\n        if (new_pos_cost1 < current_cost1 and new_pos_cost2 <= current_cost2) or \\\n           (new_pos_cost1 <= current_cost1 and new_pos_cost2 < current_cost2):\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Edge swapping with objective improvement\n    for i in range(n):\n        j = (i + 2) % n\n        if i == j or (i + 1) % n == j:\n            continue\n\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        current_cost1 = distance_matrix_1[a,b] + distance_matrix_1[c,d]\n        current_cost2 = distance_matrix_2[a,b] + distance_matrix_2[c,d]\n\n        new_cost1 = distance_matrix_1[a,c] + distance_matrix_1[b,d]\n        new_cost2 = distance_matrix_2[a,c] + distance_matrix_2[b,d]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[(i+1)%n], new_solution[j] = new_solution[j], new_solution[(i+1)%n]\n\n    return new_solution\n\n",
        "score": [
            -0.7303566857202972,
            1.8348312973976135
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high diversity\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        unique_pairs = set()\n        n = len(sol)\n        for i in range(n):\n            unique_pairs.add((sol[i], sol[(i+1)%n]))\n        diversity_scores.append(len(unique_pairs))\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = np.random.randint(2, min(5, n//2))\n    start = np.random.randint(0, n - seg_size)\n    segment = new_solution[start:start+seg_size]\n    rotation = np.random.randint(1, seg_size)\n    rotated_segment = np.roll(segment, rotation)\n    new_solution[start:start+seg_size] = rotated_segment\n\n    # Pareto-guided node insertion\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i+1)%n or j == (i-1)%n:\n            j = np.random.randint(0, n)\n\n        node = new_solution[i]\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        new_pos_cost1 = distance_matrix_1[new_solution[j-1], node] + distance_matrix_1[node, new_solution[j]]\n        new_pos_cost2 = distance_matrix_2[new_solution[j-1], node] + distance_matrix_2[node, new_solution[j]]\n\n        if (new_pos_cost1 < current_cost1 and new_pos_cost2 <= current_cost2) or \\\n           (new_pos_cost1 <= current_cost1 and new_pos_cost2 < current_cost2):\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Edge swapping with objective improvement\n    for i in range(n):\n        j = (i + 2) % n\n        if i == j or (i + 1) % n == j:\n            continue\n\n        a, b = new_solution[i], new_solution[(i+1)%n]\n        c, d = new_solution[j], new_solution[(j+1)%n]\n\n        current_cost1 = distance_matrix_1[a,b] + distance_matrix_1[c,d]\n        current_cost2 = distance_matrix_2[a,b] + distance_matrix_2[c,d]\n\n        new_cost1 = distance_matrix_1[a,c] + distance_matrix_1[b,d]\n        new_cost2 = distance_matrix_2[a,c] + distance_matrix_2[b,d]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[(i+1)%n], new_solution[j] = new_solution[j], new_solution[(i+1)%n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = np.random.randint(1, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6891347042859592,
            0.6990333199501038
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        node = new_solution[j]\n        new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n        insert_pos = np.random.randint(1, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining segment reversal and adaptive edge insertion to generate a neighbor solution while ensuring feasibility, using a weighted evaluation of improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance in Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] < objectives[j][0] and objectives[i][1] < objectives[j][1]):\n                dominance[i] += 1\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 2:\n            insert_pos = np.random.randint(i+1, j)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.8651901787470884,
            0.49029797315597534
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest dominance in Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i][0] < objectives[j][0] and objectives[i][1] < objectives[j][1]):\n                dominance[i] += 1\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment reversal with adaptive length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    new_solution[start:start+segment_length] = np.flip(new_solution[start:start+segment_length])\n\n    # Adaptive edge insertion\n    for _ in range(2):\n        i, j = sorted(np.random.choice(n, 2, replace=False))\n        if j - i > 2:\n            insert_pos = np.random.randint(i+1, j)\n            node = new_solution[j]\n            new_solution = np.concatenate([new_solution[:j], new_solution[j+1:]])\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning, but incorporates a novel 'route fusion' strategy that combines segments from multiple solutions in the archive to create a new high-quality solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_indices = np.random.choice(len(archive), size=min(3, len(archive)), p=scores / scores.sum(), replace=False)\n\n    base_solution = archive[selected_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(selected_indices) > 1:\n        for idx in selected_indices[1:]:\n            donor_solution = archive[idx][0]\n            segment_length = min(5, n // 2)\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            donor_segment = donor_solution[start:end]\n\n            new_solution[start:end] = donor_segment\n            if len(np.unique(new_solution)) != n:\n                new_solution = base_solution.copy()\n                break\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8314998563792105,
            0.21968334913253784
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_indices = np.random.choice(len(archive), size=min(3, len(archive)), p=scores / scores.sum(), replace=False)\n\n    base_solution = archive[selected_indices[0]][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(selected_indices) > 1:\n        for idx in selected_indices[1:]:\n            donor_solution = archive[idx][0]\n            segment_length = min(5, n // 2)\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            donor_segment = donor_solution[start:end]\n\n            new_solution[start:end] = donor_segment\n            if len(np.unique(new_solution)) != n:\n                new_solution = base_solution.copy()\n                break\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment inversion with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:end] = np.concatenate([new_solution[start:end][1:], [new_solution[start]]])\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6945663518992633,
            0.2797703146934509
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:end] = np.concatenate([new_solution[start:end][1:], [new_solution[start]]])\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective quality and diversity, then applies a hybrid local search using adaptive segment reversal, guided edge optimization, and probabilistic node relocation to generate improved neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = np.std(normalized, axis=0)\n        weights = 0.7 * (1 - normalized[:, 0]) + 0.3 * diversity[0]\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution[a:a+seg_size] = segment[::-1]\n\n        # Guided edge optimization\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n            new_cost = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if new_cost < current_cost or (np.random.rand() < 0.2 and new_cost <= current_cost):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node relocation\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7826068408341136,
            0.376788854598999
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n        diversity = np.std(normalized, axis=0)\n        weights = 0.7 * (1 - normalized[:, 0]) + 0.3 * diversity[0]\n        weights = weights / np.sum(weights)\n        selected_idx = np.random.choice(len(archive), p=weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution[a:a+seg_size] = segment[::-1]\n\n        # Guided edge optimization\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n            new_cost = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if new_cost < current_cost or (np.random.rand() < 0.2 and new_cost <= current_cost):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node relocation\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted random selection based on the combined quality of objectives and diversity, then applies a hybrid local search combining edge-based swaps, segment-wise reversals, and probabilistic node reinsertions to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        norm_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        combined_scores = np.sum(norm_objectives, axis=1)\n        selection_probs = 1 / (combined_scores + 1e-8)\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-based swap with objective-aware selection\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.4 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment-wise reversal with objective guidance\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        current_seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(seg_size))\n        current_seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(seg_size))\n\n        reversed_seg_cost1 = sum(distance_matrix_1[segment[i], segment[i-1]] for i in range(seg_size-1, -1, -1))\n        reversed_seg_cost2 = sum(distance_matrix_2[segment[i], segment[i-1]] for i in range(seg_size-1, -1, -1))\n\n        if (reversed_seg_cost1 < current_seg_cost1 and reversed_seg_cost2 < current_seg_cost2) or \\\n           (np.random.rand() < 0.3 and (reversed_seg_cost1 <= current_seg_cost1 or reversed_seg_cost2 <= current_seg_cost2)):\n            new_solution[a:a+seg_size] = segment[::-1]\n\n        # Probabilistic node reinsertion with objective consideration\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            old_pos = np.where(new_solution == node)[0][0]\n\n            old_cost1 = distance_matrix_1[new_solution[old_pos-1], new_solution[old_pos]] + distance_matrix_1[new_solution[old_pos], new_solution[(old_pos+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[old_pos-1], new_solution[old_pos]] + distance_matrix_2[new_solution[old_pos], new_solution[(old_pos+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2) or np.random.rand() < 0.2:\n                new_solution = np.delete(new_solution, old_pos)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8943158839116783,
            0.5849453210830688
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        norm_objectives = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        combined_scores = np.sum(norm_objectives, axis=1)\n        selection_probs = 1 / (combined_scores + 1e-8)\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Edge-based swap with objective-aware selection\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.4 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Segment-wise reversal with objective guidance\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        current_seg_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(seg_size))\n        current_seg_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(seg_size))\n\n        reversed_seg_cost1 = sum(distance_matrix_1[segment[i], segment[i-1]] for i in range(seg_size-1, -1, -1))\n        reversed_seg_cost2 = sum(distance_matrix_2[segment[i], segment[i-1]] for i in range(seg_size-1, -1, -1))\n\n        if (reversed_seg_cost1 < current_seg_cost1 and reversed_seg_cost2 < current_seg_cost2) or \\\n           (np.random.rand() < 0.3 and (reversed_seg_cost1 <= current_seg_cost1 or reversed_seg_cost2 <= current_seg_cost2)):\n            new_solution[a:a+seg_size] = segment[::-1]\n\n        # Probabilistic node reinsertion with objective consideration\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            old_pos = np.where(new_solution == node)[0][0]\n\n            old_cost1 = distance_matrix_1[new_solution[old_pos-1], new_solution[old_pos]] + distance_matrix_1[new_solution[old_pos], new_solution[(old_pos+1)%n]]\n            old_cost2 = distance_matrix_2[new_solution[old_pos-1], new_solution[old_pos]] + distance_matrix_2[new_solution[old_pos], new_solution[(old_pos+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n            new_cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n\n            if (new_cost1 + new_cost2) < (old_cost1 + old_cost2) or np.random.rand() < 0.2:\n                new_solution = np.delete(new_solution, old_pos)\n                new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection mechanism, then applies a novel hybrid local search combining adaptive segment insertion and guided node relocation with dynamic parameter adaptation to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(n):\n            diversity += abs(sol[i] - solutions[0][i])\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    k = min(3, n // 3)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    new_pos = np.random.randint(0, n - k)\n    while new_pos == start:\n        new_pos = np.random.randint(0, n - k)\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+k:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_solution[i+1:j],\n        [node_to_move],\n        new_solution[j:]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.737056960817938,
            0.615452229976654
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    n = len(solutions[0])\n\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(n):\n            diversity += abs(sol[i] - solutions[0][i])\n        diversity_scores.append(diversity)\n\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    k = min(3, n // 3)\n    start = np.random.randint(0, n - k)\n    segment = new_solution[start:start+k]\n    new_pos = np.random.randint(0, n - k)\n    while new_pos == start:\n        new_pos = np.random.randint(0, n - k)\n    new_solution = np.concatenate([\n        new_solution[:start],\n        new_solution[start+k:new_pos],\n        segment,\n        new_solution[new_pos:]\n    ])\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([\n        new_solution[:i],\n        new_solution[i+1:j],\n        [node_to_move],\n        new_solution[j:]\n    ])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This algorithm selects a solution from the archive using a normalized score combining objectives with different weights and solution quality metrics, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with novel parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8640424228858044,
            0.26042699813842773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9201079895939988,
            0.21796852350234985
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{A novel hybrid local search operator that selects solutions based on dominance-aware selection, applies a randomized segment reversal with adaptive segment size, and performs a guided edge exchange with objective-balanced acceptance criteria to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance (better in both objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = np.random.choice(len(selection_pool))\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Random segment reversal with adaptive size\n    seg_size = np.random.randint(2, min(7, n // 2))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with objective-balanced criteria\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Balanced acceptance criteria\n        if (new_cost1 < current_cost1 and new_cost2 <= 1.2 * current_cost2) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= 1.2 * current_cost1) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional randomized swap\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9028987202236126,
            0.3042163848876953
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by dominance (better in both objectives)\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select from top 30% or random if archive is small\n        selection_pool = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        selected_idx = np.random.choice(len(selection_pool))\n        base_solution = selection_pool[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n <= 3:\n        return new_solution\n\n    # Random segment reversal with adaptive size\n    seg_size = np.random.randint(2, min(7, n // 2))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with objective-balanced criteria\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Balanced acceptance criteria\n        if (new_cost1 < current_cost1 and new_cost2 <= 1.2 * current_cost2) or \\\n           (new_cost2 < current_cost2 and new_cost1 <= 1.2 * current_cost1) or \\\n           (np.random.rand() < 0.3 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional randomized swap\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new algorithm selects a solution from the archive based on its relative dominance in both objectives, then applies a hybrid local search combining segment reversal and adaptive edge insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential with weighted objective contributions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                dominated += 1\n        dominance_scores[i] = 1 / (dominated + 1)\n\n    scores = 0.7 * dominance_scores + 0.3 * (1 - objectives[:, 0] / objectives[:, 0].max()) * (1 - objectives[:, 1] / objectives[:, 1].max())\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_size = min(4, n // 3)\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        if np.random.rand() < 0.3:\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n    return new_solution\n\n",
        "score": [
            -0.866653485705039,
            0.4375995397567749
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]):\n                dominated += 1\n        dominance_scores[i] = 1 / (dominated + 1)\n\n    scores = 0.7 * dominance_scores + 0.3 * (1 - objectives[:, 0] / objectives[:, 0].max()) * (1 - objectives[:, 1] / objectives[:, 1].max())\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_size = min(4, n // 3)\n    start = np.random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:], segment])\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        if np.random.rand() < 0.3:\n            new_solution[j], new_solution[l] = new_solution[l], new_solution[j]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b:], new_solution[a:b]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9091279867947812,
            0.1901167631149292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution structure diversity, then applies a hybrid local search combining dynamic segment inversion with adaptive node insertion guided by both objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.sum(normalized_obj < normalized_obj.mean(axis=0), axis=1)\n    structure_scores = np.array([np.sum(np.abs(np.diff(sol)) > 1) for sol, _ in archive])\n    combined_scores = 0.6 * dominance_scores + 0.4 * structure_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9295515656689592,
            0.3572607636451721
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.sum(normalized_obj < normalized_obj.mean(axis=0), axis=1)\n    structure_scores = np.array([np.sum(np.abs(np.diff(sol)) > 1) for sol, _ in archive])\n    combined_scores = 0.6 * dominance_scores + 0.4 * structure_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.rand() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if np.random.rand() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware selection strategy that combines objective values and solution structure, then applies a novel local search operator that combines multiple segment reversals with guided node insertion based on both objective space distances and solution structure to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) for sol, _ in archive])\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(2):\n        segment_length = min(4, n // 5)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n\n    if np.random.random() < 0.5:\n        insertion_pos = np.argmin([distance_matrix_1[node_to_move, new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], node_to_move] +\n                                  distance_matrix_2[node_to_move, new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], node_to_move]\n                                  for j in range(n)])\n    else:\n        insertion_pos = np.argmax([distance_matrix_1[node_to_move, new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], node_to_move] +\n                                  distance_matrix_2[node_to_move, new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], node_to_move]\n                                  for j in range(n)])\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9108831220555528,
            0.4599066972732544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) for sol, _ in archive])\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    for _ in range(2):\n        segment_length = min(4, n // 5)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n\n    if np.random.random() < 0.5:\n        insertion_pos = np.argmin([distance_matrix_1[node_to_move, new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], node_to_move] +\n                                  distance_matrix_2[node_to_move, new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], node_to_move]\n                                  for j in range(n)])\n    else:\n        insertion_pos = np.argmax([distance_matrix_1[node_to_move, new_solution[(j-1)%n]] + distance_matrix_1[new_solution[j], node_to_move] +\n                                  distance_matrix_2[node_to_move, new_solution[(j-1)%n]] + distance_matrix_2[new_solution[j], node_to_move]\n                                  for j in range(n)])\n\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective dominance and structural diversity, then applies a novel hybrid local search combining adaptive path inversion with constrained node insertion to generate a neighbor solution while ensuring feasibility through a multi-phase validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                pareto_front[i] = False\n                break\n    if not np.any(pareto_front):\n        pareto_front = np.ones(len(archive), dtype=bool)\n\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = pareto_front.astype(float) * 0.7 + diversity_scores * 0.3\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive path inversion\n    inversion_length = min(5, n // 2)\n    start = np.random.randint(0, n - inversion_length)\n    end = start + inversion_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Constrained node insertion\n    if n > 3:\n        node_to_insert = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_insert]\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Multi-phase validation\n    if len(np.unique(new_solution)) != n:\n        # Phase 1: Repair by restoring missing nodes\n        missing_nodes = list(set(base_solution) - set(new_solution))\n        if missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, missing_nodes[0])\n\n    if len(np.unique(new_solution)) != n:\n        # Phase 2: Fallback to simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.906705009418089,
            0.5141618251800537
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = np.ones(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                pareto_front[i] = False\n                break\n    if not np.any(pareto_front):\n        pareto_front = np.ones(len(archive), dtype=bool)\n\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = pareto_front.astype(float) * 0.7 + diversity_scores * 0.3\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive path inversion\n    inversion_length = min(5, n // 2)\n    start = np.random.randint(0, n - inversion_length)\n    end = start + inversion_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Constrained node insertion\n    if n > 3:\n        node_to_insert = np.random.choice(new_solution)\n        new_solution = new_solution[new_solution != node_to_insert]\n        insert_pos = np.random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Multi-phase validation\n    if len(np.unique(new_solution)) != n:\n        # Phase 1: Repair by restoring missing nodes\n        missing_nodes = list(set(base_solution) - set(new_solution))\n        if missing_nodes:\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, insert_pos, missing_nodes[0])\n\n    if len(np.unique(new_solution)) != n:\n        # Phase 2: Fallback to simple swap\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion with guided node insertion that prioritizes both objective spaces to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        node1 = new_solution[i]\n        node2 = new_solution[j]\n        if (distance_matrix_1[node1, new_solution[i-1]] + distance_matrix_1[node2, new_solution[(i+1)%n]]) + \\\n           (distance_matrix_2[node1, new_solution[i-1]] + distance_matrix_2[node2, new_solution[(i+1)%n]]) > \\\n           (distance_matrix_1[node2, new_solution[i-1]] + distance_matrix_1[node1, new_solution[(i+1)%n]]) + \\\n           (distance_matrix_2[node2, new_solution[i-1]] + distance_matrix_2[node1, new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8901773202557336,
            0.33026790618896484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        node1 = new_solution[i]\n        node2 = new_solution[j]\n        if (distance_matrix_1[node1, new_solution[i-1]] + distance_matrix_1[node2, new_solution[(i+1)%n]]) + \\\n           (distance_matrix_2[node1, new_solution[i-1]] + distance_matrix_2[node2, new_solution[(i+1)%n]]) > \\\n           (distance_matrix_1[node2, new_solution[i-1]] + distance_matrix_1[node1, new_solution[(i+1)%n]]) + \\\n           (distance_matrix_2[node2, new_solution[i-1]] + distance_matrix_2[node1, new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{A novel hybrid local search operator that combines a dynamic segment relocation with a probabilistic edge reversal strategy, leveraging both objective-specific distance metrics to intelligently explore the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Normalize objectives to create selection probabilities\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n    weights = 1 / (1 + np.sum(normalized, axis=1))\n    weights = weights / np.sum(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(3, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Find insertion point based on both distance matrices\n    insertion_points = []\n    for i in range(n - seg_size):\n        if i >= a and i <= b:\n            continue\n        cost1 = distance_matrix_1[new_solution[i], segment[0]] + distance_matrix_1[segment[-1], new_solution[(i+seg_size)%n]]\n        cost2 = distance_matrix_2[new_solution[i], segment[0]] + distance_matrix_2[segment[-1], new_solution[(i+seg_size)%n]]\n        insertion_points.append((i, cost1 + cost2))\n\n    if insertion_points:\n        best_point = min(insertion_points, key=lambda x: x[1])[0]\n        new_solution = np.concatenate([\n            new_solution[:best_point],\n            segment,\n            new_solution[best_point:best_point+seg_size],\n            new_solution[best_point+seg_size:]\n        ])\n\n    # Probabilistic edge reversal with objective-aware acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if new_cost < current_cost or (np.random.rand() < 0.3 * (1 - (i / n))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.866306756163654,
            0.22883570194244385
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for (sol, obj) in archive])\n    if len(objectives) == 0:\n        return archive[0][0].copy()\n\n    # Normalize objectives to create selection probabilities\n    min_obj = np.min(objectives, axis=0)\n    max_obj = np.max(objectives, axis=0)\n    normalized = (objectives - min_obj) / (max_obj - min_obj + 1e-6)\n    weights = 1 / (1 + np.sum(normalized, axis=1))\n    weights = weights / np.sum(weights)\n\n    selected_idx = np.random.choice(len(archive), p=weights)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(3, min(7, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Find insertion point based on both distance matrices\n    insertion_points = []\n    for i in range(n - seg_size):\n        if i >= a and i <= b:\n            continue\n        cost1 = distance_matrix_1[new_solution[i], segment[0]] + distance_matrix_1[segment[-1], new_solution[(i+seg_size)%n]]\n        cost2 = distance_matrix_2[new_solution[i], segment[0]] + distance_matrix_2[segment[-1], new_solution[(i+seg_size)%n]]\n        insertion_points.append((i, cost1 + cost2))\n\n    if insertion_points:\n        best_point = min(insertion_points, key=lambda x: x[1])[0]\n        new_solution = np.concatenate([\n            new_solution[:best_point],\n            segment,\n            new_solution[best_point:best_point+seg_size],\n            new_solution[best_point+seg_size:]\n        ])\n\n    # Probabilistic edge reversal with objective-aware acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if new_cost < current_cost or (np.random.rand() < 0.3 * (1 - (i / n))):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This new algorithm selects a solution from the archive based on its dominance in the Pareto front, then applies a hybrid local search combining segment inversion and probabilistic edge reversal to generate a neighbor solution while ensuring feasibility, using a dynamic balance between exploration and exploitation of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best dominance in Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance[i] += 1\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    seg_length = min(4, n // 3)\n    start = np.random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = np.flip(new_solution[start:start+seg_length])\n\n    # Probabilistic edge reversal\n    for i in range(n):\n        j = (i + 1) % n\n        if np.random.rand() < 0.3:\n            # Reverse edge with probability based on potential improvement\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.1 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.831488385396167,
            0.7984431982040405
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with best dominance in Pareto front\n    objectives = np.array([obj for _, obj in archive])\n    dominance = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] < objectives[j, 1]) or \\\n                   (objectives[i, 0] < objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]):\n                    dominance[i] += 1\n    selected_idx = np.argmax(dominance)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Segment inversion with adaptive length\n    seg_length = min(4, n // 3)\n    start = np.random.randint(0, n - seg_length)\n    new_solution[start:start+seg_length] = np.flip(new_solution[start:start+seg_length])\n\n    # Probabilistic edge reversal\n    for i in range(n):\n        j = (i + 1) % n\n        if np.random.rand() < 0.3:\n            # Reverse edge with probability based on potential improvement\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[j], new_solution[i]]\n            new_cost2 = distance_matrix_2[new_solution[j], new_solution[i]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.1 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The heuristic function selects a solution from the archive based on a combination of objective diversity and potential for improvement, then applies a hybrid local search combining edge exchange and insertion moves to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Sort solutions by the sum of objectives (ascending) to prioritize better solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        # Select top 30% solutions for consideration\n        top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n        # Randomly select one from the top solutions\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n\n    # Apply hybrid local search: edge exchange and insertion\n    n = len(new_solution)\n    if n > 3:\n        # Randomly select two non-adjacent edges to exchange\n        i = random.randint(0, n-2)\n        j = random.randint(i+2, n-1) if i+2 < n-1 else n-1\n\n        # Perform edge exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Randomly select a node to reinsert\n        k = random.randint(0, n-1)\n        node = new_solution[k]\n\n        # Remove the node and reinsert it at a random position\n        new_solution = np.delete(new_solution, k)\n        pos = random.randint(0, n-2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This algorithm selects a solution from the archive based on both objective quality and spatial diversity, then applies a novel hybrid local search combining adaptive k-opt moves, guided node swapping, and probabilistic path inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions based on both quality and spatial diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        diversity_weights = np.zeros(len(archive))\n\n        for i, (sol, _) in enumerate(archive):\n            spatial_dist = 0\n            for j in range(len(sol)-1):\n                node1 = sol[j]\n                node2 = sol[j+1]\n                spatial_dist += np.linalg.norm(instance[node1, :2] - instance[node2, :2])\n                spatial_dist += np.linalg.norm(instance[node1, 2:] - instance[node2, 2:])\n            diversity_weights[i] = spatial_dist\n\n        diversity_weights = diversity_weights / np.sum(diversity_weights)\n        combined_weights = 0.6 * quality_weights + 0.4 * diversity_weights\n        combined_weights = combined_weights / np.sum(combined_weights)\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive k-opt move (k between 3 and 5)\n        k = np.random.randint(3, 6)\n        if k <= n:\n            a = np.random.randint(0, n - k)\n            segment = new_solution[a:a+k]\n\n            # Reorder the segment based on spatial proximity\n            segment_coords = instance[segment]\n            center = np.mean(segment_coords[:, :2], axis=0)\n            distances = np.linalg.norm(segment_coords[:, :2] - center, axis=1)\n            sorted_indices = np.argsort(distances)\n            new_segment = segment[sorted_indices]\n            new_solution[a:a+k] = new_segment\n\n        # Guided node swapping\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Swap nodes with better spatial locality\n            if np.random.rand() < 0.5:\n                swap_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                swap_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n                if (swap_cost1 < current_cost1 and swap_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.2 and (swap_cost1 <= current_cost1 or swap_cost2 <= current_cost2)):\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic path inversion\n        if np.random.rand() < 0.3:\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9190699780387062,
            4.5613550543785095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions based on both quality and spatial diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        diversity_weights = np.zeros(len(archive))\n\n        for i, (sol, _) in enumerate(archive):\n            spatial_dist = 0\n            for j in range(len(sol)-1):\n                node1 = sol[j]\n                node2 = sol[j+1]\n                spatial_dist += np.linalg.norm(instance[node1, :2] - instance[node2, :2])\n                spatial_dist += np.linalg.norm(instance[node1, 2:] - instance[node2, 2:])\n            diversity_weights[i] = spatial_dist\n\n        diversity_weights = diversity_weights / np.sum(diversity_weights)\n        combined_weights = 0.6 * quality_weights + 0.4 * diversity_weights\n        combined_weights = combined_weights / np.sum(combined_weights)\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive k-opt move (k between 3 and 5)\n        k = np.random.randint(3, 6)\n        if k <= n:\n            a = np.random.randint(0, n - k)\n            segment = new_solution[a:a+k]\n\n            # Reorder the segment based on spatial proximity\n            segment_coords = instance[segment]\n            center = np.mean(segment_coords[:, :2], axis=0)\n            distances = np.linalg.norm(segment_coords[:, :2] - center, axis=1)\n            sorted_indices = np.argsort(distances)\n            new_segment = segment[sorted_indices]\n            new_solution[a:a+k] = new_segment\n\n        # Guided node swapping\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Swap nodes with better spatial locality\n            if np.random.rand() < 0.5:\n                swap_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                swap_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n                if (swap_cost1 < current_cost1 and swap_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.2 and (swap_cost1 <= current_cost1 or swap_cost2 <= current_cost2)):\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic path inversion\n        if np.random.rand() < 0.3:\n            a = np.random.randint(0, n)\n            b = np.random.randint(0, n)\n            if a > b:\n                a, b = b, a\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{The new algorithm selects a solution from the archive based on a weighted combination of normalized objective values and solution quality, then applies a hybrid local search combining adaptive segment reversal with targeted edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values and high quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = np.array([np.sum(1 / (1 + objectives)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Targeted edge insertion\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    candidate = new_solution.copy()\n    candidate[i+1:j] = candidate[i+1:j][::-1]\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[candidate[i], candidate[i+1]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]]):\n        new_solution = candidate\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(0, n)\n        while j == i or j == i + 1:\n            j = np.random.randint(0, n)\n        new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.8837719251630849,
            0.5613147616386414
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective values and high quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = np.array([np.sum(1 / (1 + objectives)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Targeted edge insertion\n    i = np.random.randint(0, n - 2)\n    j = np.random.randint(i + 2, n)\n    candidate = new_solution.copy()\n    candidate[i+1:j] = candidate[i+1:j][::-1]\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[candidate[i], candidate[i+1]] + distance_matrix_1[candidate[j], candidate[(j+1)%n]]):\n        new_solution = candidate\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(0, n)\n        while j == i or j == i + 1:\n            j = np.random.randint(0, n)\n        new_solution = np.insert(np.delete(new_solution, i), j, new_solution[i])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{A novel hybrid local search operator that intelligently selects diverse solutions from the archive, combines a dynamic segment inversion with an adaptive edge exchange strategy, and incorporates a probabilistic swap mechanism to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion with adaptive segment size\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange with probabilistic acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria with temperature\n        temp = 1.0 - (i / n)\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * temp and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic swap with adaptive probability\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.9624821624824573,
            0.3035162091255188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment inversion with adaptive segment size\n    seg_size = min(7, n // 2)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Adaptive edge exchange with probabilistic acceptance\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria with temperature\n        temp = 1.0 - (i / n)\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 * temp and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional probabilistic swap with adaptive probability\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{This new algorithm selects a solution from the archive based on a combination of objective improvement potential and solution diversity, then applies a hybrid local search combining adaptive segment rotation and constrained node insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of trade-offs between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.mean([np.linalg.norm(sol - archive[i][0]) for i in range(len(archive))]) for sol, _ in archive])\n    normalized_div = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * normalized_div\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a + 1))\n\n    return new_solution\n\n",
        "score": [
            -0.8821660803386777,
            2.2211490869522095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.mean([np.linalg.norm(sol - archive[i][0]) for i in range(len(archive))]) for sol, _ in archive])\n    normalized_div = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * normalized_div\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a + 1))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection criterion that combines Pareto dominance and solution diversity, then applies a novel hybrid local search combining adaptive segment inversion, guided edge swapping with objective-aware acceptance, and probabilistic node relocation to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        pareto_front = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and all(objectives[j] <= objectives[i]):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n\n        if len(pareto_front) > 0:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            diversity_scores = []\n            for i in range(len(archive)):\n                distances = []\n                for j in range(len(archive)):\n                    if i != j:\n                        distances.append(np.sum(archive[i][0] != archive[j][0]))\n                diversity_scores.append(np.mean(distances))\n            diversity_scores = np.array(diversity_scores)\n            diversity_scores = diversity_scores / np.sum(diversity_scores)\n            selected_idx = np.random.choice(len(archive), p=diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.2 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8776535173779352,
            0.5687010288238525
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        pareto_front = []\n        for i in range(len(archive)):\n            dominated = False\n            for j in range(len(archive)):\n                if i != j and all(objectives[j] <= objectives[i]):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n\n        if len(pareto_front) > 0:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            diversity_scores = []\n            for i in range(len(archive)):\n                distances = []\n                for j in range(len(archive)):\n                    if i != j:\n                        distances.append(np.sum(archive[i][0] != archive[j][0]))\n                diversity_scores.append(np.mean(distances))\n            diversity_scores = np.array(diversity_scores)\n            diversity_scores = diversity_scores / np.sum(diversity_scores)\n            selected_idx = np.random.choice(len(archive), p=diversity_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.2 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel local search operator that combines adaptive node insertion with guided path reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node insertion with guided selection\n    if n > 3:\n        segment_length = min(3, n // 4)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        node_to_insert = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], node_to_insert])\n\n    # Step 2: Guided path reversal with distance improvement check\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8950697108824603,
            0.432733416557312
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node insertion with guided selection\n    if n > 3:\n        segment_length = min(3, n // 4)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        node_to_insert = new_solution[start:end]\n        new_solution = np.concatenate([new_solution[:start], new_solution[end:], node_to_insert])\n\n    # Step 2: Guided path reversal with distance improvement check\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple insertion if reversal breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{This novel algorithm intelligently selects a solution from the archive based on its objective values, then applies a hybrid local search combining adaptive segment rotation and constrained edge insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives and incorporating a novel segment-based perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    scores = 1 / (0.5 * normalized[:, 0] + 0.5 * normalized[:, 1] + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = min(4, n // 5)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Constrained edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 + 0.1 * current_edge1 < current_edge1 and new_edge2 + 0.1 * current_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= 1.1 * current_edge1 or new_edge2 <= 1.1 * current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Segment-based perturbation\n    if np.random.rand() < 0.2:\n        seg_start = np.random.randint(0, n)\n        seg_end = np.random.randint(seg_start, min(seg_start + 3, n))\n        new_solution[seg_start:seg_end+1] = np.flip(new_solution[seg_start:seg_end+1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a + 1))\n\n    return new_solution\n\n",
        "score": [
            -0.8686222185790695,
            0.30741041898727417
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with balanced objective values\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.ptp(axis=0) + 1e-8)\n    scores = 1 / (0.5 * normalized[:, 0] + 0.5 * normalized[:, 1] + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    seg_size = min(4, n // 5)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    rotation = np.random.randint(1, seg_size)\n    new_solution[a:b+1] = np.roll(new_solution[a:b+1], rotation)\n\n    # Constrained edge insertion\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_edge1 + 0.1 * current_edge1 < current_edge1 and new_edge2 + 0.1 * current_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.3 and (new_edge1 <= 1.1 * current_edge1 or new_edge2 <= 1.1 * current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Segment-based perturbation\n    if np.random.rand() < 0.2:\n        seg_start = np.random.randint(0, n)\n        seg_end = np.random.randint(seg_start, min(seg_start + 3, n))\n        new_solution[seg_start:seg_end+1] = np.flip(new_solution[seg_start:seg_end+1])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.roll(new_solution[a:b+1], np.random.randint(1, b - a + 1))\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of quality and diversity, then applies a hybrid local search combining adaptive segment reversal, guided edge flipping, and probabilistic node reinsertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        fitness = np.sqrt(np.sum(objectives**2, axis=1))\n        selection_probs = 1 / (fitness + 1e-6)\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 5))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution[a:a+seg_size] = segment[::-1]\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            flipped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            flipped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (flipped_cost1 < cost1 and flipped_cost2 < cost2) or (np.random.rand() < 0.4 and (flipped_cost1 <= cost1 or flipped_cost2 <= cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.885985583453474,
            0.3566340208053589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        fitness = np.sqrt(np.sum(objectives**2, axis=1))\n        selection_probs = 1 / (fitness + 1e-6)\n        selection_probs = selection_probs / np.sum(selection_probs)\n        selected_idx = np.random.choice(len(archive), p=selection_probs)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 5))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution[a:a+seg_size] = segment[::-1]\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            flipped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            flipped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (flipped_cost1 < cost1 and flipped_cost2 < cost2) or (np.random.rand() < 0.4 and (flipped_cost1 <= cost1 or flipped_cost2 <= cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive segment inversion and constrained node insertion to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives and incorporating spatial awareness from the instance coordinates.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained node insertion with spatial awareness\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(j - i) <= 1:\n            j = np.random.randint(0, n)\n\n        # Check spatial proximity in both objectives\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n        coords_i = instance[node_i]\n        coords_j = instance[node_j]\n\n        # Calculate spatial distance in both objectives\n        dist1 = np.sqrt((coords_i[0] - coords_j[0])**2 + (coords_i[1] - coords_j[1])**2)\n        dist2 = np.sqrt((coords_i[2] - coords_j[2])**2 + (coords_i[3] - coords_j[3])**2)\n\n        # Insert node with higher probability if spatially close in both objectives\n        if np.random.rand() < 0.5 * (1 - min(dist1, dist2) / max(dist1, dist2)):\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n",
        "score": [
            -0.892202374525825,
            0.2587115168571472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = np.flip(new_solution[start:end])\n\n    # Constrained node insertion with spatial awareness\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(j - i) <= 1:\n            j = np.random.randint(0, n)\n\n        # Check spatial proximity in both objectives\n        node_i = new_solution[i]\n        node_j = new_solution[j]\n        coords_i = instance[node_i]\n        coords_j = instance[node_j]\n\n        # Calculate spatial distance in both objectives\n        dist1 = np.sqrt((coords_i[0] - coords_j[0])**2 + (coords_i[1] - coords_j[1])**2)\n        dist2 = np.sqrt((coords_i[2] - coords_j[2])**2 + (coords_i[3] - coords_j[3])**2)\n\n        # Insert node with higher probability if spatially close in both objectives\n        if np.random.rand() < 0.5 * (1 - min(dist1, dist2) / max(dist1, dist2)):\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution quality metrics, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8320873586739521,
            0.17675477266311646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid quality-diversity metric, then applies a novel local search combining adaptive segment reshuffling, guided crossover-based recombination, and probabilistic edge insertion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n        diversity_score = np.mean(diversity)\n        hybrid_scores = (1 - 0.3 * (objectives[:, 0] + objectives[:, 1])) * (1 + 0.1 * diversity_score)\n        selected_idx = np.random.choice(len(archive), p=hybrid_scores / hybrid_scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        np.random.shuffle(segment)\n        new_solution[a:a+seg_size] = segment\n\n        if np.random.rand() < 0.4:\n            crossover_point = np.random.randint(1, n)\n            parent2 = archive[np.random.choice(len(archive))][0]\n            new_solution[:crossover_point] = parent2[:crossover_point]\n\n        if np.random.rand() < 0.3:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8093678540023245,
            2.548028290271759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n        diversity_score = np.mean(diversity)\n        hybrid_scores = (1 - 0.3 * (objectives[:, 0] + objectives[:, 1])) * (1 + 0.1 * diversity_score)\n        selected_idx = np.random.choice(len(archive), p=hybrid_scores / hybrid_scores.sum())\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        np.random.shuffle(segment)\n        new_solution[a:a+seg_size] = segment\n\n        if np.random.rand() < 0.4:\n            crossover_point = np.random.randint(1, n)\n            parent2 = archive[np.random.choice(len(archive))][0]\n            new_solution[:crossover_point] = parent2[:crossover_point]\n\n        if np.random.rand() < 0.3:\n            i, j = np.random.choice(n, 2, replace=False)\n            new_solution = np.insert(new_solution, i, new_solution[j])\n            new_solution = np.delete(new_solution, j + (1 if j > i else 0))\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This algorithm selects a solution from the archive based on Pareto dominance and solution diversity, then applies a hybrid local search combining adaptive edge exchange and guided segment inversion with varying neighborhood sizes to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        diversity = np.std(objectives, axis=0)\n        weights = diversity / diversity.sum()\n        selected_idx = np.random.choice(len(archive), p=weights[0] * 0.7 + weights[1] * 0.3)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:\n        k = min(4, n // 3)\n        i = np.random.randint(0, n - k)\n        j = np.random.randint(i + 1, min(i + k + 1, n))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.random() < 0.4:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a + 1) % n or b == (a - 1) % n:\n            b = np.random.randint(0, n)\n        node_to_move = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node_to_move], new_solution[b:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8813481691815725,
            1.3684742450714111
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    pareto_front = []\n    for i, obj in enumerate(objectives):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            pareto_front.append(i)\n\n    if pareto_front:\n        selected_idx = np.random.choice(pareto_front)\n    else:\n        diversity = np.std(objectives, axis=0)\n        weights = diversity / diversity.sum()\n        selected_idx = np.random.choice(len(archive), p=weights[0] * 0.7 + weights[1] * 0.3)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:\n        k = min(4, n // 3)\n        i = np.random.randint(0, n - k)\n        j = np.random.randint(i + 1, min(i + k + 1, n))\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.random() < 0.4:\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while b == a or b == (a + 1) % n or b == (a - 1) % n:\n            b = np.random.randint(0, n)\n        node_to_move = new_solution[a]\n        new_solution = np.concatenate([new_solution[:a], new_solution[a+1:b], [node_to_move], new_solution[b:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of Pareto dominance and crowding distance to identify promising solutions, then applies a novel hybrid local search operator that combines adaptive k-opt moves with guided node insertion and removal to generate high-quality neighbor solutions while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate Pareto dominance and crowding distance\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                dominated[i] = True\n                break\n\n    non_dominated = np.where(~dominated)[0]\n    if len(non_dominated) > 0:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        # If no non-dominated solutions, select based on crowding distance\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_dist = np.zeros(len(archive))\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] = abs(objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + abs(objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Adaptive k-opt move (k=3)\n    k = 3\n    if n >= k:\n        indices = np.random.choice(n, k, replace=False)\n        indices.sort()\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Step 2: Guided node insertion and removal\n    if n > 2:\n        # Remove a random node and insert it at a different position\n        i = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8887613960045009,
            0.43729352951049805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution using Pareto dominance and crowding distance\n    objectives = np.array([obj for _, obj in archive])\n    solutions = [sol for sol, _ in archive]\n\n    # Calculate Pareto dominance and crowding distance\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and not (objectives[j, 0] == objectives[i, 0] and objectives[j, 1] == objectives[i, 1]):\n                dominated[i] = True\n                break\n\n    non_dominated = np.where(~dominated)[0]\n    if len(non_dominated) > 0:\n        selected_idx = np.random.choice(non_dominated)\n    else:\n        # If no non-dominated solutions, select based on crowding distance\n        sorted_indices = np.argsort(objectives[:, 0])\n        crowding_dist = np.zeros(len(archive))\n        crowding_dist[sorted_indices[0]] = np.inf\n        crowding_dist[sorted_indices[-1]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_dist[sorted_indices[i]] = abs(objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) + abs(objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1])\n        selected_idx = np.argmax(crowding_dist)\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    # Step 1: Adaptive k-opt move (k=3)\n    k = 3\n    if n >= k:\n        indices = np.random.choice(n, k, replace=False)\n        indices.sort()\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Step 2: Guided node insertion and removal\n    if n > 2:\n        # Remove a random node and insert it at a different position\n        i = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:]])\n        j = np.random.randint(0, n-1)\n        new_solution = np.concatenate([new_solution[:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9205087007677362,
            0.21705639362335205
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a novel hybrid local search combining adaptive node relocation and constrained edge swapping to generate a neighbor solution while ensuring feasibility, using a dynamic evaluation of improvement potential across both objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement in both objectives\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * improvement_potential[:, 0] + 0.4 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node relocation\n    relocate_length = min(3, n // 4)\n    start = np.random.randint(0, n - relocate_length)\n    segment = new_solution[start:start+relocate_length]\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+relocate_length:], segment])\n\n    # Constrained edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        # Calculate current and potential new edges\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Swap if beneficial for both objectives or with probability\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = sorted(np.random.choice(n, 2, replace=False))\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This new algorithm selects a solution from the archive based on its potential for improvement in both objectives, then applies a hybrid local search combining adaptive segment inversion and constrained node insertion, which dynamically evaluates improvement potential across both objectives while ensuring feasibility through a novel segment validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment[::-1]])\n\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if j != i and j != (i + 1) % n and j != (i - 1) % n:\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n            break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8618221331394545,
            0.1816774606704712
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = (objectives.max(axis=0) - objectives) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * improvement_potential[:, 0] + 0.3 * improvement_potential[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:], segment[::-1]])\n\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if j != i and j != (i + 1) % n and j != (i - 1) % n:\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n            break\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        a, b = np.random.choice(n, 2, replace=False)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score that combines normalized objective values with diversity and dominance measures, then applies a hybrid local search with adaptive segment reversal and guided node repositioning, while ensuring feasibility through a fallback mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity and dominance measures\n    diversity = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    normalized_div = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    dominance = np.array([np.sum(objectives <= obj, axis=1) for obj in objectives]).mean(axis=1)\n    normalized_dom = (dominance - dominance.min()) / (dominance.max() - dominance.min() + 1e-8)\n\n    # Weighted score combining objectives, diversity, and dominance\n    scores = 0.3 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * normalized_div + 0.1 * normalized_dom\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length and selection\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n or j == (i + 2) % n or j == (i - 2) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8806139388046952,
            0.5201706886291504
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate diversity and dominance measures\n    diversity = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    normalized_div = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    dominance = np.array([np.sum(objectives <= obj, axis=1) for obj in objectives]).mean(axis=1)\n    normalized_dom = (dominance - dominance.min()) / (dominance.max() - dominance.min() + 1e-8)\n\n    # Weighted score combining objectives, diversity, and dominance\n    scores = 0.3 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * normalized_div + 0.1 * normalized_dom\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length and selection\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n or j == (i + 2) % n or j == (i - 2) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{This algorithm uses an adaptive segment insertion strategy combined with a Pareto-dominated edge swap heuristic to generate neighbors, where segment size and insertion points are dynamically adjusted based on solution quality and edge dominance relationships.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 4:\n        return new_solution\n\n    # Adaptive segment insertion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Pareto-dominated insertion position\n    best_pos = -1\n    best_improvement = 0\n    for pos in range(n - seg_size):\n        temp = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:a],\n            new_solution[b+1:]\n        ])\n        cost1 = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n        improvement1 = (sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) - cost1) / cost1\n        improvement2 = (sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) - cost2) / cost2\n\n        if (improvement1 > 0 and improvement2 >= 0) or (improvement1 >= 0 and improvement2 > 0):\n            if improvement1 + improvement2 > best_improvement:\n                best_improvement = improvement1 + improvement2\n                best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:a],\n            new_solution[b+1:]\n        ])\n\n    # Edge dominance swap\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2 and np.random.rand() < 0.3) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2 and np.random.rand() < 0.3):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random segment flip with probability based on solution quality\n    if np.random.rand() < 0.2 * (1 - (archive[0][1][0] + archive[0][1][1]) / (sum(x[1][0] + x[1][1] for x in archive) / len(archive))):\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.4977300760161972,
            0.7999982237815857
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.6 + x[1][1] * 0.4))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 4:\n        return new_solution\n\n    # Adaptive segment insertion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Pareto-dominated insertion position\n    best_pos = -1\n    best_improvement = 0\n    for pos in range(n - seg_size):\n        temp = np.concatenate([\n            new_solution[:pos],\n            segment,\n            new_solution[pos:a],\n            new_solution[b+1:]\n        ])\n        cost1 = sum(distance_matrix_1[temp[i], temp[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp[i], temp[(i+1)%n]] for i in range(n))\n        improvement1 = (sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) - cost1) / cost1\n        improvement2 = (sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) - cost2) / cost2\n\n        if (improvement1 > 0 and improvement2 >= 0) or (improvement1 >= 0 and improvement2 > 0):\n            if improvement1 + improvement2 > best_improvement:\n                best_improvement = improvement1 + improvement2\n                best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos:a],\n            new_solution[b+1:]\n        ])\n\n    # Edge dominance swap\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2 and np.random.rand() < 0.3) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2 and np.random.rand() < 0.3):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random segment flip with probability based on solution quality\n    if np.random.rand() < 0.2 * (1 - (archive[0][1][0] + archive[0][1][1]) / (sum(x[1][0] + x[1][1] for x in archive) / len(archive))):\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{An adaptive hybrid local search operator that employs dynamic segment inversion with Pareto-guided edge swapping and a probabilistic node relocation strategy to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    if np.random.rand() < 0.6:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n    else:\n        segment = new_solution[a:b+1]\n        new_pos = np.random.randint(0, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:a],\n            new_solution[b+1:]\n        ])\n\n    # Pareto-guided edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic node relocation\n    if np.random.rand() < 0.2:\n        u, v = np.random.choice(n, 2, replace=False)\n        if u > v:\n            u, v = v, u\n        new_solution = np.concatenate([\n            new_solution[:u],\n            new_solution[v:v+1],\n            new_solution[u:v],\n            new_solution[v+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8888900060925093,
            0.2719186544418335
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n\n    if np.random.rand() < 0.6:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n    else:\n        segment = new_solution[a:b+1]\n        new_pos = np.random.randint(0, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:a],\n            new_solution[b+1:]\n        ])\n\n    # Pareto-guided edge swapping\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n        l = (i + 3) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 * 1.1) or \\\n           (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Probabilistic node relocation\n    if np.random.rand() < 0.2:\n        u, v = np.random.choice(n, 2, replace=False)\n        if u > v:\n            u, v = v, u\n        new_solution = np.concatenate([\n            new_solution[:u],\n            new_solution[v:v+1],\n            new_solution[u:v],\n            new_solution[v+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that intelligently selects promising solutions from the archive, combines a randomized segment inversion with a guided edge exchange strategy to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = np.random.choice(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Random segment inversion with adaptive segment size\n    seg_size = min(5, n // 3)\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Guided edge exchange with adaptive selection\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_edge1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_edge1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_edge2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        # Adaptive acceptance criteria\n        if (new_edge1 < current_edge1 and new_edge2 < current_edge2) or \\\n           (np.random.rand() < 0.2 * (1 - (i / n)) and (new_edge1 <= current_edge1 or new_edge2 <= current_edge2)):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Additional random swap to increase diversity\n    if np.random.rand() < 0.1:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid local search combining adaptive segment reversal and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with diverse objectives\n        objectives = np.array([obj for (sol, obj) in archive])\n        diversity_scores = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n        diversity_scores = np.sum(diversity_scores, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        seg_size = min(4, n // 2)\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n        # Guided node insertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(j - i) <= 1:\n                j = np.random.randint(0, n)\n\n            # Calculate potential improvement\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or (np.random.rand() < 0.3):\n                # Perform insertion\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.71687999311592,
            0.35948872566223145
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with diverse objectives\n        objectives = np.array([obj for (sol, obj) in archive])\n        diversity_scores = np.sum(np.abs(objectives[:, None, :] - objectives[None, :, :]), axis=2)\n        diversity_scores = np.sum(diversity_scores, axis=1)\n        selected_idx = np.argmax(diversity_scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        seg_size = min(4, n // 2)\n        a = np.random.randint(0, n - seg_size)\n        b = a + seg_size - 1\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n        # Guided node insertion\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while abs(j - i) <= 1:\n                j = np.random.randint(0, n)\n\n            # Calculate potential improvement\n            old_dist1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_dist1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n\n            old_dist2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_dist2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n            if (new_dist1 < old_dist1 and new_dist2 < old_dist2) or (np.random.rand() < 0.3):\n                # Perform insertion\n                node = new_solution[i]\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining dynamic segment inversion with guided cross-segment swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start1 = np.random.randint(0, n - segment_length)\n    end1 = start1 + segment_length\n    start2 = np.random.randint(0, n - segment_length)\n    end2 = start2 + segment_length\n\n    if start1 < start2:\n        new_segment = new_solution[start1:end1]\n        new_solution[start1:end1] = new_solution[start2:end2]\n        new_solution[start2:start2 + len(new_segment)] = new_segment\n    else:\n        new_segment = new_solution[start2:end2]\n        new_solution[start2:end2] = new_solution[start1:end1]\n        new_solution[start1:start1 + len(new_segment)] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.868894557986414,
            0.5948938727378845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start1 = np.random.randint(0, n - segment_length)\n    end1 = start1 + segment_length\n    start2 = np.random.randint(0, n - segment_length)\n    end2 = start2 + segment_length\n\n    if start1 < start2:\n        new_segment = new_solution[start1:end1]\n        new_solution[start1:end1] = new_solution[start2:end2]\n        new_solution[start2:start2 + len(new_segment)] = new_segment\n    else:\n        new_segment = new_solution[start2:end2]\n        new_solution[start2:end2] = new_solution[start1:end1]\n        new_solution[start1:start1 + len(new_segment)] = new_segment\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and a novel diversity metric based on node sequence entropy, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        unique_positions = np.zeros(len(sol))\n        for i, node in enumerate(sol):\n            unique_positions[node] = i\n        diversity = np.std(unique_positions)\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    scores = 0.4 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * (diversity_scores / (diversity_scores.max() + 1e-8))\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    if i < j:\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:j], [node_to_move], new_solution[j:i], new_solution[i+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8009703801874348,
            0.6764322519302368
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    solutions = [sol for sol, _ in archive]\n    diversity_scores = []\n    for sol in solutions:\n        unique_positions = np.zeros(len(sol))\n        for i, node in enumerate(sol):\n            unique_positions[node] = i\n        diversity = np.std(unique_positions)\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n\n    scores = 0.4 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * (diversity_scores / (diversity_scores.max() + 1e-8))\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    if i < j:\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:j], [node_to_move], new_solution[j:i], new_solution[i+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9923102465417057,
            0.230221688747406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-based selection criterion, then applies a novel hybrid local search combining adaptive path inversion and multi-objective guided insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n = len(solutions[0])\n\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(n):\n            prev_node = sol[i-1]\n            curr_node = sol[i]\n            next_node = sol[(i+1)%n]\n            diversity += distance_matrix_1[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    k = np.random.randint(2, min(5, n//2))\n    segments = sorted(np.random.choice(n, k, replace=False))\n    segments = np.concatenate([[0], segments, [n]])\n\n    for i in range(len(segments)-1):\n        start = segments[i]\n        end = segments[i+1]\n        if np.random.rand() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i-j) < 2:\n        j = np.random.randint(0, n)\n\n    node_to_move = new_solution[i]\n    insertion_point = j if j < i else j+1\n\n    if insertion_point > i:\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:insertion_point], [node_to_move], new_solution[insertion_point:]])\n    else:\n        new_solution = np.concatenate([new_solution[:insertion_point], [node_to_move], new_solution[i:], new_solution[insertion_point:i]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8594607359070967,
            2.0950950980186462
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n    n = len(solutions[0])\n\n    diversity_scores = []\n    for sol in solutions:\n        diversity = 0\n        for i in range(n):\n            prev_node = sol[i-1]\n            curr_node = sol[i]\n            next_node = sol[(i+1)%n]\n            diversity += distance_matrix_1[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        diversity_scores.append(diversity)\n\n    diversity_scores = np.array(diversity_scores)\n    selected_idx = np.argmax(diversity_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n\n    k = np.random.randint(2, min(5, n//2))\n    segments = sorted(np.random.choice(n, k, replace=False))\n    segments = np.concatenate([[0], segments, [n]])\n\n    for i in range(len(segments)-1):\n        start = segments[i]\n        end = segments[i+1]\n        if np.random.rand() < 0.5:\n            new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while abs(i-j) < 2:\n        j = np.random.randint(0, n)\n\n    node_to_move = new_solution[i]\n    insertion_point = j if j < i else j+1\n\n    if insertion_point > i:\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:insertion_point], [node_to_move], new_solution[insertion_point:]])\n    else:\n        new_solution = np.concatenate([new_solution[:insertion_point], [node_to_move], new_solution[i:], new_solution[insertion_point:i]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This algorithm selects a solution from the archive using a score based on both objective values and their correlation with the instance's node distribution, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    correlation = np.corrcoef(objectives[:, 0], objectives[:, 1])[0, 1]\n    alpha = 0.7 if correlation > 0.5 else 0.3\n    scores = alpha * normalized_obj[:, 0] + (1 - alpha) * normalized_obj[:, 1]\n\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8468202407717877,
            0.24027478694915771
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    correlation = np.corrcoef(objectives[:, 0], objectives[:, 1])[0, 1]\n    alpha = 0.7 if correlation > 0.5 else 0.3\n    scores = alpha * normalized_obj[:, 0] + (1 - alpha) * normalized_obj[:, 1]\n\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective quality and solution diversity, then applies a novel local search combining adaptive segment shuffling, guided node exchange, and probabilistic segment inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on hybrid of quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality = np.sum(objectives, axis=1)\n        diversity = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                diversity[i] += np.sum(archive[i][0] != archive[j][0])\n                diversity[j] += np.sum(archive[i][0] != archive[j][0])\n        hybrid_score = 0.6 * quality + 0.4 * diversity\n        selected_idx = np.argmin(hybrid_score)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment shuffling\n        seg_size = random.randint(2, min(5, n // 3))\n        a = random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        random.shuffle(segment)\n        new_solution[a:a+seg_size] = segment\n\n        # Guided node exchange\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Exchange nodes\n            temp = new_solution.copy()\n            temp[i], temp[k] = temp[k], temp[i]\n            new_cost1 = distance_matrix_1[temp[i], temp[j]] + distance_matrix_1[temp[j], temp[k]]\n            new_cost2 = distance_matrix_2[temp[i], temp[j]] + distance_matrix_2[temp[j], temp[k]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (random.random() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution = temp\n\n        # Probabilistic segment inversion\n        if random.random() < 0.3:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7529859281885821,
            1.8620891571044922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on hybrid of quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality = np.sum(objectives, axis=1)\n        diversity = np.zeros(len(archive))\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                diversity[i] += np.sum(archive[i][0] != archive[j][0])\n                diversity[j] += np.sum(archive[i][0] != archive[j][0])\n        hybrid_score = 0.6 * quality + 0.4 * diversity\n        selected_idx = np.argmin(hybrid_score)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment shuffling\n        seg_size = random.randint(2, min(5, n // 3))\n        a = random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        random.shuffle(segment)\n        new_solution[a:a+seg_size] = segment\n\n        # Guided node exchange\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Exchange nodes\n            temp = new_solution.copy()\n            temp[i], temp[k] = temp[k], temp[i]\n            new_cost1 = distance_matrix_1[temp[i], temp[j]] + distance_matrix_1[temp[j], temp[k]]\n            new_cost2 = distance_matrix_2[temp[i], temp[j]] + distance_matrix_2[temp[j], temp[k]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n               (random.random() < 0.2 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution = temp\n\n        # Probabilistic segment inversion\n        if random.random() < 0.3:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reversal with guided node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node reinsertion\n    i = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    best_pos = 0\n    min_cost = float('inf')\n\n    for j in range(n - 1):\n        if j == i or j == i - 1:\n            continue\n        # Calculate insertion cost in both objectives\n        cost1 = distance_matrix_1[new_solution[j], node] + distance_matrix_1[node, new_solution[(j+1)%(n-1)]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%(n-1)]]\n        cost2 = distance_matrix_2[new_solution[j], node] + distance_matrix_2[node, new_solution[(j+1)%(n-1)]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%(n-1)]]\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = j + 1 if j < i else j\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9680460308823855,
            0.4717533588409424
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node reinsertion\n    i = np.random.randint(0, n)\n    node = new_solution[i]\n    new_solution = np.delete(new_solution, i)\n    best_pos = 0\n    min_cost = float('inf')\n\n    for j in range(n - 1):\n        if j == i or j == i - 1:\n            continue\n        # Calculate insertion cost in both objectives\n        cost1 = distance_matrix_1[new_solution[j], node] + distance_matrix_1[node, new_solution[(j+1)%(n-1)]] - distance_matrix_1[new_solution[j], new_solution[(j+1)%(n-1)]]\n        cost2 = distance_matrix_2[new_solution[j], node] + distance_matrix_2[node, new_solution[(j+1)%(n-1)]] - distance_matrix_2[new_solution[j], new_solution[(j+1)%(n-1)]]\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < min_cost:\n            min_cost = total_cost\n            best_pos = j + 1 if j < i else j\n\n    new_solution = np.insert(new_solution, best_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple reversal if insertion breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This algorithm selects a solution from the archive using an adaptive score combining normalized objective values, diversity, and solution quality, then applies a hybrid local search with dynamic segment reversal and guided node repositioning with adaptive parameters to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)):\n            diversity += np.abs(i - np.where(sol == sol[i])[0][0])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n\n    quality_scores = 1 / (1 + objectives[:, 0] + objectives[:, 1])\n    quality_scores = (quality_scores - quality_scores.min()) / (quality_scores.max() - quality_scores.min() + 1e-8)\n\n    scores = 0.4 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.1 * diversity_scores + 0.1 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8074464236434249,
            1.1725801229476929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    diversity_scores = []\n    for sol, _ in archive:\n        diversity = 0\n        for i in range(len(sol)):\n            diversity += np.abs(i - np.where(sol == sol[i])[0][0])\n        diversity_scores.append(diversity)\n    diversity_scores = np.array(diversity_scores)\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n\n    quality_scores = 1 / (1 + objectives[:, 0] + objectives[:, 1])\n    quality_scores = (quality_scores - quality_scores.min()) / (quality_scores.max() - quality_scores.min() + 1e-8)\n\n    scores = 0.4 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.1 * diversity_scores + 0.1 * quality_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid score combining normalized objective values and solution quality, then applies a novel local search strategy that combines adaptive segment rotation with guided multi-node insertion and adaptive segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + normalized_obj[:, 0] + normalized_obj[:, 1])\n    diversity_scores = np.array([np.mean([np.sum(sol[0] != archive[i][0][0]) for i in range(len(archive))]) for sol in archive])\n    combined_scores = 0.6 * quality_scores + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    num_insertions = min(3, n // 5)\n    for _ in range(num_insertions):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8140158627301775,
            4.744003355503082
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    quality_scores = 1 / (1 + normalized_obj[:, 0] + normalized_obj[:, 1])\n    diversity_scores = np.array([np.mean([np.sum(sol[0] != archive[i][0][0]) for i in range(len(archive))]) for sol in archive])\n    combined_scores = 0.6 * quality_scores + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    num_insertions = min(3, n // 5)\n    for _ in range(num_insertions):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and solution diversity, then applies a novel hybrid local search combining adaptive tour partitioning, guided node swapping with objective-aware selection, and probabilistic segment inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.linalg.norm(instance[archive[i][0]] - instance.mean(axis=0)) for i in range(len(archive))])\n    normalized_div = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * normalized_div\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive tour partitioning\n    k = max(2, min(5, n // 3))\n    partitions = np.array_split(np.random.permutation(n), k)\n    for part in partitions:\n        if len(part) > 1:\n            # Guided node swapping with objective-aware selection\n            i, j = np.random.choice(part, 2, replace=False)\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (cost1_change < 0 and cost2_change < 0) or \\\n               (np.random.rand() < 0.4 and (cost1_change <= 0 or cost2_change <= 0)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.3 and n > 4:\n        seg_size = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9380891707972983,
            1.9911864399909973
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined quality and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity = np.array([np.linalg.norm(instance[archive[i][0]] - instance.mean(axis=0)) for i in range(len(archive))])\n    normalized_div = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * normalized_div\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive tour partitioning\n    k = max(2, min(5, n // 3))\n    partitions = np.array_split(np.random.permutation(n), k)\n    for part in partitions:\n        if len(part) > 1:\n            # Guided node swapping with objective-aware selection\n            i, j = np.random.choice(part, 2, replace=False)\n            cost1_change = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n            cost2_change = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n            if (cost1_change < 0 and cost2_change < 0) or \\\n               (np.random.rand() < 0.4 and (cost1_change <= 0 or cost2_change <= 0)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Probabilistic segment inversion\n    if np.random.rand() < 0.3 and n > 4:\n        seg_size = np.random.randint(2, min(6, n//2))\n        start = np.random.randint(0, n - seg_size)\n        new_solution[start:start+seg_size] = new_solution[start:start+seg_size][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid approach of dominance-based selection and adaptive segment inversion, followed by guided edge swapping with probabilistic node relocation to create diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on dominance and diversity\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        selected_idx = sorted_indices[np.random.randint(0, min(3, len(sorted_indices)))]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        seg_size = max(2, min(4, n // 4))\n        start = np.random.randint(0, n - seg_size)\n        segment = new_solution[start:start+seg_size]\n        new_solution[start:start+seg_size] = segment[::-1]\n\n        # Guided edge swapping with probabilistic relocation\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node relocation\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8355542403983298,
            0.4105471968650818
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on dominance and diversity\n        objectives = np.array([obj for _, obj in archive])\n        sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n        selected_idx = sorted_indices[np.random.randint(0, min(3, len(sorted_indices)))]\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        seg_size = max(2, min(4, n // 4))\n        start = np.random.randint(0, n - seg_size)\n        segment = new_solution[start:start+seg_size]\n        new_solution[start:start+seg_size] = segment[::-1]\n\n        # Guided edge swapping with probabilistic relocation\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            swapped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            swapped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node relocation\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment inversion with guided node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]):\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = j if j < i else j - 1\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8842855142588113,
            1.0038418173789978
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.7:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node relocation\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    if (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]):\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        insert_pos = j if j < i else j - 1\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This algorithm combines a novel multi-objective segment crossover with a guided node repositioning strategy, leveraging both spatial and objective-based proximity to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on both objective quality and spatial diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        diversity_weights = np.zeros(len(archive))\n\n        for i in range(len(archive)):\n            sol = archive[i][0]\n            avg_dist1 = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n            avg_dist2 = np.mean([distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n            diversity_weights[i] = avg_dist1 + avg_dist2\n\n        diversity_weights = diversity_weights / np.sum(diversity_weights)\n        combined_weights = 0.7 * quality_weights + 0.3 * diversity_weights\n        combined_weights = combined_weights / np.sum(combined_weights)\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-objective segment crossover\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Find best insertion point based on both objectives\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(n - seg_size + 1):\n            if pos == a:\n                continue\n\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, np.where(np.isin(new_solution, segment)))\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, np.where(np.isin(new_solution, segment)))\n        ])\n\n        # Guided node repositioning\n        for _ in range(min(3, n // 2)):\n            # Select node based on its position in both objective spaces\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n\n            # Find best position based on spatial proximity and objective improvement\n            best_pos = node_idx\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.insert(np.delete(temp_sol, node_idx), pos, node)\n\n                # Calculate cost difference\n                old_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n                new_cost1 = (distance_matrix_1[temp_sol[pos-1], temp_sol[pos]] +\n                            distance_matrix_1[temp_sol[pos], temp_sol[(pos+1)%n]])\n\n                old_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n                new_cost2 = (distance_matrix_2[temp_sol[pos-1], temp_sol[pos]] +\n                            distance_matrix_2[temp_sol[pos], temp_sol[(pos+1)%n]])\n\n                improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_improvement > 0:\n                new_solution = np.insert(np.delete(new_solution, node_idx), best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5676302183345174,
            2.6603625416755676
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on both objective quality and spatial diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        diversity_weights = np.zeros(len(archive))\n\n        for i in range(len(archive)):\n            sol = archive[i][0]\n            avg_dist1 = np.mean([distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n            avg_dist2 = np.mean([distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol))])\n            diversity_weights[i] = avg_dist1 + avg_dist2\n\n        diversity_weights = diversity_weights / np.sum(diversity_weights)\n        combined_weights = 0.7 * quality_weights + 0.3 * diversity_weights\n        combined_weights = combined_weights / np.sum(combined_weights)\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-objective segment crossover\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Find best insertion point based on both objectives\n        best_pos = a\n        best_cost = float('inf')\n\n        for pos in range(n - seg_size + 1):\n            if pos == a:\n                continue\n\n            temp_sol = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, np.where(np.isin(new_solution, segment)))\n            ])\n\n            # Calculate total cost for both objectives\n            cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            np.delete(new_solution, np.where(np.isin(new_solution, segment)))\n        ])\n\n        # Guided node repositioning\n        for _ in range(min(3, n // 2)):\n            # Select node based on its position in both objective spaces\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n\n            # Find best position based on spatial proximity and objective improvement\n            best_pos = node_idx\n            best_improvement = 0\n\n            for pos in range(n):\n                if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n                    continue\n\n                temp_sol = new_solution.copy()\n                temp_sol = np.insert(np.delete(temp_sol, node_idx), pos, node)\n\n                # Calculate cost difference\n                old_cost1 = (distance_matrix_1[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_1[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n                new_cost1 = (distance_matrix_1[temp_sol[pos-1], temp_sol[pos]] +\n                            distance_matrix_1[temp_sol[pos], temp_sol[(pos+1)%n]])\n\n                old_cost2 = (distance_matrix_2[new_solution[node_idx-1], new_solution[node_idx]] +\n                            distance_matrix_2[new_solution[node_idx], new_solution[(node_idx+1)%n]])\n                new_cost2 = (distance_matrix_2[temp_sol[pos-1], temp_sol[pos]] +\n                            distance_matrix_2[temp_sol[pos], temp_sol[(pos+1)%n]])\n\n                improvement = (old_cost1 + old_cost2) - (new_cost1 + new_cost2)\n\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_improvement > 0:\n                new_solution = np.insert(np.delete(new_solution, node_idx), best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This new algorithm selects a solution from the archive based on a normalized objective score, then applies a hybrid local search combining adaptive segment rotation and dynamic node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives and select based on combined score\n        objectives = np.array([x[1] for x in archive])\n        min_vals = np.min(objectives, axis=0)\n        max_vals = np.max(objectives, axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n        scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Adaptive segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_size] = rotated\n\n        # Dynamic node insertion\n        if random.random() < 0.7:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8603602334573834,
            0.27010470628738403
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives and select based on combined score\n        objectives = np.array([x[1] for x in archive])\n        min_vals = np.min(objectives, axis=0)\n        max_vals = np.max(objectives, axis=0)\n        normalized = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n        scores = 0.6 * normalized[:, 0] + 0.4 * normalized[:, 1]\n        selected_idx = np.argmin(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 5:\n        # Adaptive segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated = np.concatenate([segment[rotation:], segment[:rotation]])\n        new_solution[start:start+segment_size] = rotated\n\n        # Dynamic node insertion\n        if random.random() < 0.7:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid score combining normalized objective values, solution quality, and adaptive weights, then applies a novel local search combining segment reversal with guided node insertion and adaptive parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    quality_scores = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-8)\n    diversity_scores = np.array([len(set(sol)) for sol, _ in archive]) / len(archive[0][0])\n\n    alpha = 0.7\n    scores = alpha * quality_scores + (1 - alpha) * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    if i < j:\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:j], [node_to_move], new_solution[j:i], new_solution[i+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9257471897571236,
            0.318825364112854
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    quality_scores = 1 / (normalized_obj[:, 0] + normalized_obj[:, 1] + 1e-8)\n    diversity_scores = np.array([len(set(sol)) for sol, _ in archive]) / len(archive[0][0])\n\n    alpha = 0.7\n    scores = alpha * quality_scores + (1 - alpha) * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    if i < j:\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n    else:\n        new_solution = np.concatenate([new_solution[:j], [node_to_move], new_solution[j:i], new_solution[i+1:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This algorithm selects a solution from the archive based on a combined score of objective values and diversity, then applies a novel hybrid local search that combines adaptive segment rotation with guided node insertion and Pareto-guided edge optimization to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.2 * (diversity_scores / diversity_scores.sum())\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(segment, rotation)\n\n    new_solution[start:end] = rotated_segment\n\n    insertion_point = np.random.randint(0, n)\n    if insertion_point >= start and insertion_point < end:\n        insertion_point = end\n\n    node_to_insert = new_solution[np.random.randint(start, end)]\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        [node_to_insert],\n        new_solution[insertion_point:]\n    ])\n\n    if len(new_solution) != n:\n        new_solution = new_solution[:n]\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.roll(new_solution[p:q+1], 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9557054441345717,
            0.9672682881355286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives[i] - objectives)) for i in range(len(archive))])\n    combined_scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1] + 0.2 * (diversity_scores / diversity_scores.sum())\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n <= 3:\n        return new_solution\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    rotation = np.random.randint(1, segment_length)\n    rotated_segment = np.roll(segment, rotation)\n\n    new_solution[start:end] = rotated_segment\n\n    insertion_point = np.random.randint(0, n)\n    if insertion_point >= start and insertion_point < end:\n        insertion_point = end\n\n    node_to_insert = new_solution[np.random.randint(start, end)]\n    new_solution = np.concatenate([\n        new_solution[:insertion_point],\n        [node_to_insert],\n        new_solution[insertion_point:]\n    ])\n\n    if len(new_solution) != n:\n        new_solution = new_solution[:n]\n\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.roll(new_solution[p:q+1], 1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive node clustering with guided path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.2 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    cluster_size = max(2, min(4, n // 4))\n    start = np.random.randint(0, n - cluster_size)\n    end = start + cluster_size\n\n    # Guided path inversion\n    if np.random.rand() < 0.4:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.3:\n        segment_length = min(3, n // 5)\n        seg_start = np.random.randint(0, n - segment_length)\n        seg_end = seg_start + segment_length\n        rotation = np.random.randint(1, segment_length)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.764209773854243,
            2.3878472447395325
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.2 * normalized_obj[:, 1] + 0.2 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering\n    cluster_size = max(2, min(4, n // 4))\n    start = np.random.randint(0, n - cluster_size)\n    end = start + cluster_size\n\n    # Guided path inversion\n    if np.random.rand() < 0.4:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Adaptive segment rotation\n    if np.random.rand() < 0.3:\n        segment_length = min(3, n // 5)\n        seg_start = np.random.randint(0, n - segment_length)\n        seg_end = seg_start + segment_length\n        rotation = np.random.randint(1, segment_length)\n        new_solution[seg_start:seg_end] = np.roll(new_solution[seg_start:seg_end], rotation)\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{An adaptive segment inversion operator that combines non-dominated sorting with a guided edge swapping strategy to balance exploration and exploitation of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to find promising solutions\n    fronts = []\n    dominated_count = {}\n    dominating_solutions = {}\n\n    for idx, (sol, _) in enumerate(archive):\n        dominated_count[idx] = 0\n        dominating_solutions[idx] = []\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] < obj_j[1]) or (obj_i[0] < obj_j[0] and obj_i[1] <= obj_j[1]):\n                dominating_solutions[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] < obj_i[1]) or (obj_j[0] < obj_i[0] and obj_j[1] <= obj_i[1]):\n                dominated_count[i] += 1\n\n        if dominated_count[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front or random if no fronts exist\n    if fronts:\n        selected_idx = np.random.choice(fronts[0])\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Adaptive segment inversion\n    seg_length = max(2, min(n // 2, np.random.randint(2, n // 2 + 1)))\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length - 1\n\n    # Invert the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Guided edge swapping\n    for _ in range(min(3, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8896360967939321,
            0.32819855213165283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Non-dominated sorting to find promising solutions\n    fronts = []\n    dominated_count = {}\n    dominating_solutions = {}\n\n    for idx, (sol, _) in enumerate(archive):\n        dominated_count[idx] = 0\n        dominating_solutions[idx] = []\n\n    for i, (sol_i, obj_i) in enumerate(archive):\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i == j:\n                continue\n            if (obj_i[0] <= obj_j[0] and obj_i[1] < obj_j[1]) or (obj_i[0] < obj_j[0] and obj_i[1] <= obj_j[1]):\n                dominating_solutions[i].append(j)\n            elif (obj_j[0] <= obj_i[0] and obj_j[1] < obj_i[1]) or (obj_j[0] < obj_i[0] and obj_j[1] <= obj_i[1]):\n                dominated_count[i] += 1\n\n        if dominated_count[i] == 0:\n            fronts.append([i])\n\n    # Select from the first front or random if no fronts exist\n    if fronts:\n        selected_idx = np.random.choice(fronts[0])\n    else:\n        selected_idx = np.random.randint(len(archive))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    if n <= 2:\n        return new_solution\n\n    # Adaptive segment inversion\n    seg_length = max(2, min(n // 2, np.random.randint(2, n // 2 + 1)))\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length - 1\n\n    # Invert the segment\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Guided edge swapping\n    for _ in range(min(3, n // 2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j:\n            continue\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel hybrid local search operator that combines adaptive segment inversion with a crowding-distance guided edge exchange strategy to generate high-quality neighbors while balancing exploration and exploitation in the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding_distances = []\n        for i in range(len(archive)):\n            left = archive[i-1][1] if i > 0 else archive[0][1]\n            right = archive[(i+1)%len(archive)][1]\n            distance = abs(right[0] - left[0]) + abs(right[1] - left[1])\n            crowding_distances.append(distance)\n        best_idx = np.argmax(crowding_distances)\n        base_solution = archive[best_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Crowding-distance guided edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 + 0.05 * current_cost2) or \\\n           (new_cost1 <= current_cost1 + 0.05 * current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random 2-opt for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n",
        "score": [
            -0.7824181500257757,
            0.3006095290184021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    if len(archive) > 1:\n        crowding_distances = []\n        for i in range(len(archive)):\n            left = archive[i-1][1] if i > 0 else archive[0][1]\n            right = archive[(i+1)%len(archive)][1]\n            distance = abs(right[0] - left[0]) + abs(right[1] - left[1])\n            crowding_distances.append(distance)\n        best_idx = np.argmax(crowding_distances)\n        base_solution = archive[best_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Adaptive segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Crowding-distance guided edge exchange\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2 + 0.05 * current_cost2) or \\\n           (new_cost1 <= current_cost1 + 0.05 * current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random 2-opt for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and spatial clustering, then applies a novel hybrid local search combining adaptive node rearrangement and guided path inversion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in at least one objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and ((obj_j[0] <= obj_i[0] and obj_j[1] < obj_i[1]) or (obj_j[0] < obj_i[0] and obj_j[1] <= obj_i[1])):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Select from non-dominated solutions with higher probability\n            selected = random.choices(non_dominated, weights=[1.5 if i < len(non_dominated)//2 else 1.0 for i in range(len(non_dominated))])[0]\n        else:\n            # If no non-dominated, select based on combined objective values\n            sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.uniform(-0.1, 0.1)))\n            selected = sorted_archive[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node rearrangement\n    if n > 4:\n        cluster_size = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n\n        # Calculate distances in both objective spaces\n        cluster_dist1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n        cluster_dist2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n\n        # Rearrange cluster based on combined distance\n        if random.random() < 0.6 or cluster_dist1 + cluster_dist2 > (distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[start-1], new_solution[start]]):\n            new_cluster = cluster.copy()\n            for _ in range(2):\n                i, j = random.sample(range(cluster_size), 2)\n                new_cluster[i], new_cluster[j] = new_cluster[j], new_cluster[i]\n            new_solution[start:start+cluster_size] = new_cluster\n\n    # Guided path inversion\n    if n > 5:\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 2, min(i + 5, n - 1))\n\n        # Calculate potential improvement\n        current_cost = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + \\\n                       distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        inverted_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] + \\\n                        distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        if inverted_cost < current_cost:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Perform a random insertion\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7920405490161264,
            7.234408915042877
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in at least one objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and ((obj_j[0] <= obj_i[0] and obj_j[1] < obj_i[1]) or (obj_j[0] < obj_i[0] and obj_j[1] <= obj_i[1])):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Select from non-dominated solutions with higher probability\n            selected = random.choices(non_dominated, weights=[1.5 if i < len(non_dominated)//2 else 1.0 for i in range(len(non_dominated))])[0]\n        else:\n            # If no non-dominated, select based on combined objective values\n            sorted_archive = sorted(archive, key=lambda x: (x[1][0] + x[1][1]) * (1 + random.uniform(-0.1, 0.1)))\n            selected = sorted_archive[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node rearrangement\n    if n > 4:\n        cluster_size = random.randint(2, min(4, n // 3))\n        start = random.randint(0, n - cluster_size)\n        cluster = new_solution[start:start+cluster_size]\n\n        # Calculate distances in both objective spaces\n        cluster_dist1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n        cluster_dist2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n\n        # Rearrange cluster based on combined distance\n        if random.random() < 0.6 or cluster_dist1 + cluster_dist2 > (distance_matrix_1[new_solution[start-1], new_solution[start]] + distance_matrix_2[new_solution[start-1], new_solution[start]]):\n            new_cluster = cluster.copy()\n            for _ in range(2):\n                i, j = random.sample(range(cluster_size), 2)\n                new_cluster[i], new_cluster[j] = new_cluster[j], new_cluster[i]\n            new_solution[start:start+cluster_size] = new_cluster\n\n    # Guided path inversion\n    if n > 5:\n        i = random.randint(0, n - 3)\n        j = random.randint(i + 2, min(i + 5, n - 1))\n\n        # Calculate potential improvement\n        current_cost = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + \\\n                       distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        inverted_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]] + \\\n                        distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n        if inverted_cost < current_cost:\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Perform a random insertion\n        i, j = random.sample(range(n), 2)\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{This algorithm selects a diverse solution from the archive using a combination of objective-based selection and adaptive segment reversal, then applies a hybrid local search combining probabilistic node displacement with guided edge contraction to generate a high-quality neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n        selection_weights = 0.6 * normalized[:, 0] + 0.4 * diversity_scores\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal with probabilistic acceptance\n        seg_size = max(2, min(6, n // 4))\n        start = np.random.randint(0, n - seg_size)\n        segment = new_solution[start:start+seg_size]\n        if np.random.rand() < 0.4:\n            new_solution[start:start+seg_size] = segment[::-1]\n\n        # Probabilistic node displacement\n        if np.random.rand() < 0.5:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Guided edge contraction\n        for _ in range(2):\n            i = np.random.randint(0, n - 2)\n            j = np.random.randint(i + 2, n)\n            if j > i + 2:\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                contract_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n                contract_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n                if (contract_cost1 < current_cost1 and contract_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (contract_cost1 <= current_cost1 or contract_cost2 <= current_cost2)):\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9474772513885981,
            1.041181743144989
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n        selection_weights = 0.6 * normalized[:, 0] + 0.4 * diversity_scores\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal with probabilistic acceptance\n        seg_size = max(2, min(6, n // 4))\n        start = np.random.randint(0, n - seg_size)\n        segment = new_solution[start:start+seg_size]\n        if np.random.rand() < 0.4:\n            new_solution[start:start+seg_size] = segment[::-1]\n\n        # Probabilistic node displacement\n        if np.random.rand() < 0.5:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Guided edge contraction\n        for _ in range(2):\n            i = np.random.randint(0, n - 2)\n            j = np.random.randint(i + 2, n)\n            if j > i + 2:\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n                contract_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n                contract_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n                if (contract_cost1 < current_cost1 and contract_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (contract_cost1 <= current_cost1 or contract_cost2 <= current_cost2)):\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion that balances between exploration of objective space and exploitation of solution quality, then applies a novel hybrid local search combining adaptive edge insertion and segment shifting to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Diversity-aware selection\n        objectives = np.array([x[1] for x in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]\n        selected_idx = np.argmax(crowding)\n        selected = archive[selected_idx]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive edge insertion\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                segment = new_solution[i:j] if i < j else new_solution[j:i]\n                new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n        # Segment shifting\n        if random.random() < 0.4:\n            shift_size = random.randint(1, min(3, n // 4))\n            pos = random.randint(0, n - shift_size - 1)\n            segment = new_solution[pos:pos+shift_size]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+shift_size:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7596184889759388,
            0.4910452365875244
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Diversity-aware selection\n        objectives = np.array([x[1] for x in archive])\n        crowding = np.zeros(len(archive))\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(archive)-1):\n                crowding[sorted_idx[j]] += objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]\n        selected_idx = np.argmax(crowding)\n        selected = archive[selected_idx]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive edge insertion\n        if random.random() < 0.5:\n            i, j = random.sample(range(n), 2)\n            if abs(i - j) > 1:\n                segment = new_solution[i:j] if i < j else new_solution[j:i]\n                new_solution = np.concatenate([new_solution[:i], segment[::-1], new_solution[j:]])\n\n        # Segment shifting\n        if random.random() < 0.4:\n            shift_size = random.randint(1, min(3, n // 4))\n            pos = random.randint(0, n - shift_size - 1)\n            segment = new_solution[pos:pos+shift_size]\n            new_solution = np.concatenate([new_solution[:pos], new_solution[pos+shift_size:], segment])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid of objective-based selection and diversity-aware clustering, then applies a novel combination of adaptive path inversion, guided node clustering, and probabilistic segment reordering to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.prod(normalized_obj <= normalized_obj, axis=1)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * (1 - dominance_scores) + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    if n > 3:\n        inv_start = np.random.randint(0, n-1)\n        inv_end = np.random.randint(inv_start+1, n)\n        segment_length = inv_end - inv_start\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[inv_start], new_solution[inv_start+1]] + distance_matrix_1[new_solution[inv_end-1], new_solution[inv_end]]\n        original_cost2 = distance_matrix_2[new_solution[inv_start], new_solution[inv_start+1]] + distance_matrix_2[new_solution[inv_end-1], new_solution[inv_end]]\n        inverted_cost1 = distance_matrix_1[new_solution[inv_start], new_solution[inv_end]] + distance_matrix_1[new_solution[inv_start+1], new_solution[inv_end-1]]\n        inverted_cost2 = distance_matrix_2[new_solution[inv_start], new_solution[inv_end]] + distance_matrix_2[new_solution[inv_start+1], new_solution[inv_end-1]]\n\n        if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (inverted_cost1 <= original_cost1 or inverted_cost2 <= original_cost2)):\n            new_solution[inv_start+1:inv_end] = new_solution[inv_start+1:inv_end][::-1]\n\n    # Guided node clustering\n    if n > 4:\n        cluster_size = min(3, n // 4)\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster_nodes = new_solution[cluster_start:cluster_start+cluster_size]\n        cluster_center = np.mean(instance[cluster_nodes], axis=0)\n\n        # Find nodes closest to the cluster center in both spaces\n        all_nodes = np.arange(n)\n        remaining_nodes = np.setdiff1d(all_nodes, cluster_nodes)\n        distances1 = np.linalg.norm(instance[remaining_nodes, :2] - cluster_center[:2], axis=1)\n        distances2 = np.linalg.norm(instance[remaining_nodes, 2:] - cluster_center[2:], axis=1)\n        combined_distances = 0.5 * distances1 + 0.5 * distances2\n        closest_idx = np.argmin(combined_distances)\n        closest_node = remaining_nodes[closest_idx]\n\n        # Insert closest node into the cluster\n        insert_pos = np.random.randint(cluster_start, cluster_start + cluster_size)\n        new_solution = np.insert(new_solution, insert_pos, closest_node)\n        new_solution = np.delete(new_solution, np.where(new_solution == closest_node)[0][0])\n\n    # Probabilistic segment reordering\n    if n > 5 and np.random.rand() < 0.4:\n        seg_length = np.random.randint(2, min(4, n//3))\n        seg1_start = np.random.randint(0, n - seg_length)\n        seg2_start = np.random.randint(0, n - seg_length)\n        while abs(seg1_start - seg2_start) < seg_length:\n            seg2_start = np.random.randint(0, n - seg_length)\n\n        seg1 = new_solution[seg1_start:seg1_start+seg_length]\n        seg2 = new_solution[seg2_start:seg2_start+seg_length]\n        new_solution[seg1_start:seg1_start+seg_length] = seg2\n        new_solution[seg2_start:seg2_start+seg_length] = seg1\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8459196283948107,
            1.5333041548728943
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) == 0:\n        raise ValueError(\"Archive is empty\")\n\n    # Selection based on objective dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    dominance_scores = np.prod(normalized_obj <= normalized_obj, axis=1)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * (1 - dominance_scores) + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive path inversion\n    if n > 3:\n        inv_start = np.random.randint(0, n-1)\n        inv_end = np.random.randint(inv_start+1, n)\n        segment_length = inv_end - inv_start\n\n        # Calculate potential improvement\n        original_cost1 = distance_matrix_1[new_solution[inv_start], new_solution[inv_start+1]] + distance_matrix_1[new_solution[inv_end-1], new_solution[inv_end]]\n        original_cost2 = distance_matrix_2[new_solution[inv_start], new_solution[inv_start+1]] + distance_matrix_2[new_solution[inv_end-1], new_solution[inv_end]]\n        inverted_cost1 = distance_matrix_1[new_solution[inv_start], new_solution[inv_end]] + distance_matrix_1[new_solution[inv_start+1], new_solution[inv_end-1]]\n        inverted_cost2 = distance_matrix_2[new_solution[inv_start], new_solution[inv_end]] + distance_matrix_2[new_solution[inv_start+1], new_solution[inv_end-1]]\n\n        if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n           (np.random.rand() < 0.3 and (inverted_cost1 <= original_cost1 or inverted_cost2 <= original_cost2)):\n            new_solution[inv_start+1:inv_end] = new_solution[inv_start+1:inv_end][::-1]\n\n    # Guided node clustering\n    if n > 4:\n        cluster_size = min(3, n // 4)\n        cluster_start = np.random.randint(0, n - cluster_size)\n        cluster_nodes = new_solution[cluster_start:cluster_start+cluster_size]\n        cluster_center = np.mean(instance[cluster_nodes], axis=0)\n\n        # Find nodes closest to the cluster center in both spaces\n        all_nodes = np.arange(n)\n        remaining_nodes = np.setdiff1d(all_nodes, cluster_nodes)\n        distances1 = np.linalg.norm(instance[remaining_nodes, :2] - cluster_center[:2], axis=1)\n        distances2 = np.linalg.norm(instance[remaining_nodes, 2:] - cluster_center[2:], axis=1)\n        combined_distances = 0.5 * distances1 + 0.5 * distances2\n        closest_idx = np.argmin(combined_distances)\n        closest_node = remaining_nodes[closest_idx]\n\n        # Insert closest node into the cluster\n        insert_pos = np.random.randint(cluster_start, cluster_start + cluster_size)\n        new_solution = np.insert(new_solution, insert_pos, closest_node)\n        new_solution = np.delete(new_solution, np.where(new_solution == closest_node)[0][0])\n\n    # Probabilistic segment reordering\n    if n > 5 and np.random.rand() < 0.4:\n        seg_length = np.random.randint(2, min(4, n//3))\n        seg1_start = np.random.randint(0, n - seg_length)\n        seg2_start = np.random.randint(0, n - seg_length)\n        while abs(seg1_start - seg2_start) < seg_length:\n            seg2_start = np.random.randint(0, n - seg_length)\n\n        seg1 = new_solution[seg1_start:seg1_start+seg_length]\n        seg2 = new_solution[seg2_start:seg2_start+seg_length]\n        new_solution[seg1_start:seg1_start+seg_length] = seg2\n        new_solution[seg2_start:seg2_start+seg_length] = seg1\n\n    # Ensure validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective weighting that prioritizes solutions with balanced improvement potential, then applies a hybrid local search combining adaptive segment relinking and probabilistic edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Dynamic objective weighting based on historical improvement\n        obj1_avg = np.mean([s[1][0] for s in archive])\n        obj2_avg = np.mean([s[1][1] for s in archive])\n        weights = np.random.uniform(0.4, 0.6)\n        ranked_solutions = sorted(archive, key=lambda x: weights * (x[1][0] / obj1_avg) + (1 - weights) * (x[1][1] / obj2_avg))\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 2)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment relinking\n        segment_length = random.randint(2, min(4, n // 4))\n        a, b = random.sample(range(n), 2)\n        start = min(a, b)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.7:\n            insert_pos = random.randint(0, n - segment_length)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + segment_length:]])\n\n        # Edge reversal with probability\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7500148120141036,
            0.356437087059021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Dynamic objective weighting based on historical improvement\n        obj1_avg = np.mean([s[1][0] for s in archive])\n        obj2_avg = np.mean([s[1][1] for s in archive])\n        weights = np.random.uniform(0.4, 0.6)\n        ranked_solutions = sorted(archive, key=lambda x: weights * (x[1][0] / obj1_avg) + (1 - weights) * (x[1][1] / obj2_avg))\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 2)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment relinking\n        segment_length = random.randint(2, min(4, n // 4))\n        a, b = random.sample(range(n), 2)\n        start = min(a, b)\n        end = start + segment_length\n        segment = new_solution[start:end]\n\n        # Probabilistic edge insertion\n        if random.random() < 0.7:\n            insert_pos = random.randint(0, n - segment_length)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos + segment_length:]])\n\n        # Edge reversal with probability\n        if random.random() < 0.4:\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware selection criterion, then applies a hybrid local search combining adaptive segment rotation and guided edge insertion to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            d = np.sum(solutions[i] != solutions[j])\n            distances[i] += d\n            distances[j] += d\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8373655979046694,
            9.787502467632294
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            d = np.sum(solutions[i] != solutions[j])\n            distances[i] += d\n            distances[j] += d\n    selected_idx = np.argmax(distances)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_insert = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8345361605740647,
            0.14241671562194824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8345361605740647,
            0.14241671562194824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a novel hybrid local search combining adaptive segment inversion with guided node relocation and probabilistic edge contraction to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on combined quality and structural diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_scores = np.exp(-np.sum(objectives, axis=1))\n        diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) for sol, _ in archive])\n        combined_scores = 0.6 * quality_scores + 0.4 * diversity_scores\n        selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        seg_size = min(5, n // 2)\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        # Guided node relocation\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n\n            if new_cost < current_cost or (np.random.rand() < 0.1 and new_cost <= current_cost * 1.1):\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Probabilistic edge contraction\n        if np.random.rand() < 0.3 and n > 4:\n            i = np.random.randint(0, n)\n            j = (i + 2) % n\n            if (distance_matrix_1[new_solution[i], new_solution[j]] +\n                distance_matrix_2[new_solution[i], new_solution[j]]) < \\\n               (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[(i+1)%n], new_solution[j]] +\n                distance_matrix_2[new_solution[(i+1)%n], new_solution[j]]):\n                new_solution = np.delete(new_solution, (i + 1) % n)\n\n    return new_solution\n\n",
        "score": [
            -0.9198229320957642,
            0.4191122055053711
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on combined quality and structural diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_scores = np.exp(-np.sum(objectives, axis=1))\n        diversity_scores = np.array([np.sum(np.abs(np.diff(sol))) for sol, _ in archive])\n        combined_scores = 0.6 * quality_scores + 0.4 * diversity_scores\n        selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment inversion\n        seg_size = min(5, n // 2)\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        # Guided node relocation\n        for _ in range(2):\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n\n            current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                           distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n            new_cost = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                       distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                       distance_matrix_2[new_solution[j], new_solution[(i+1)%n]])\n\n            if new_cost < current_cost or (np.random.rand() < 0.1 and new_cost <= current_cost * 1.1):\n                node = new_solution[i]\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Probabilistic edge contraction\n        if np.random.rand() < 0.3 and n > 4:\n            i = np.random.randint(0, n)\n            j = (i + 2) % n\n            if (distance_matrix_1[new_solution[i], new_solution[j]] +\n                distance_matrix_2[new_solution[i], new_solution[j]]) < \\\n               (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_1[new_solution[(i+1)%n], new_solution[j]] +\n                distance_matrix_2[new_solution[(i+1)%n], new_solution[j]]):\n                new_solution = np.delete(new_solution, (i + 1) % n)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and diversity, then applies a novel hybrid local search combining adaptive tour segmentation, guided node substitution, and probabilistic edge inversion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            diversity[i] += np.sum(archive[i][0] != archive[j][0])\n            diversity[j] += np.sum(archive[i][0] != archive[j][0])\n\n    diversity = diversity / (len(archive) - 1) if len(archive) > 1 else 1.0\n    normalized_diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.3 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        if np.random.rand() < 0.5:\n            new_solution[a:a+seg_size] = segment[::-1]\n        else:\n            shift = np.random.randint(1, seg_size)\n            new_solution[a:a+seg_size] = np.roll(segment, shift)\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            if np.random.rand() < 0.4:\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n                reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n                if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8393115205692592,
            1.8725889325141907
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(i+1, len(archive)):\n            diversity[i] += np.sum(archive[i][0] != archive[j][0])\n            diversity[j] += np.sum(archive[i][0] != archive[j][0])\n\n    diversity = diversity / (len(archive) - 1) if len(archive) > 1 else 1.0\n    normalized_diversity = (diversity - diversity.min()) / (diversity.max() - diversity.min() + 1e-8)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.3 * normalized_diversity\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        if np.random.rand() < 0.5:\n            new_solution[a:a+seg_size] = segment[::-1]\n        else:\n            shift = np.random.randint(1, seg_size)\n            new_solution[a:a+seg_size] = np.roll(segment, shift)\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            if np.random.rand() < 0.4:\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n                reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n                reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n                if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                    new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n or abs(j - i) < 3:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8369651257449732,
            0.2474578619003296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n or abs(j - i) < 3:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This algorithm selects a solution from the archive using a novel combination of objective-based selection, adaptive segment insertion, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment insertion\n        seg_size = max(2, min(4, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution = np.delete(new_solution, np.arange(a, a+seg_size))\n        insert_pos = np.random.randint(0, n - seg_size)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8613970175297574,
            0.3590589761734009
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment insertion\n        seg_size = max(2, min(4, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution = np.delete(new_solution, np.arange(a, a+seg_size))\n        insert_pos = np.random.randint(0, n - seg_size)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid local search combining adaptive node clustering and guided partial tour reversal with probabilistic edge flipping to generate a high-quality neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on objective diversity and quality\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        diversity_scores = np.sum(objectives / (diversity + 1e-6), axis=1)\n        selection_weights = diversity_scores / np.sum(diversity_scores)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive node clustering\n        cluster_size = max(2, min(4, n // 4))\n        num_clusters = n // cluster_size\n        clusters = [new_solution[i*cluster_size:(i+1)*cluster_size] for i in range(num_clusters)]\n\n        # Guided partial tour reversal\n        for i in range(len(clusters)):\n            if np.random.rand() < 0.4:\n                clusters[i] = clusters[i][::-1]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(clusters)\n\n        # Probabilistic edge flipping\n        for i in range(n-2):\n            if np.random.rand() < 0.3:\n                j = np.random.randint(i+1, n-1)\n                new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7737653936207716,
            0.339427649974823
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on objective diversity and quality\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n        diversity_scores = np.sum(objectives / (diversity + 1e-6), axis=1)\n        selection_weights = diversity_scores / np.sum(diversity_scores)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive node clustering\n        cluster_size = max(2, min(4, n // 4))\n        num_clusters = n // cluster_size\n        clusters = [new_solution[i*cluster_size:(i+1)*cluster_size] for i in range(num_clusters)]\n\n        # Guided partial tour reversal\n        for i in range(len(clusters)):\n            if np.random.rand() < 0.4:\n                clusters[i] = clusters[i][::-1]\n\n        # Reconstruct solution\n        new_solution = np.concatenate(clusters)\n\n        # Probabilistic edge flipping\n        for i in range(n-2):\n            if np.random.rand() < 0.3:\n                j = np.random.randint(i+1, n-1)\n                new_solution[i+1], new_solution[j] = new_solution[j], new_solution[i+1]\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A novel hybrid local search operator that combines a probabilistic segment inversion with a dominance-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    if np.random.rand() < 0.25:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Dominance-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random node swap for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n",
        "score": [
            -0.8417868573211355,
            0.901977002620697
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Probabilistic segment inversion\n    seg_size = max(2, min(5, n // 3))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    if np.random.rand() < 0.25:\n        new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Dominance-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random node swap for diversity\n    if np.random.rand() < 0.2:\n        p, q = np.random.choice(n, 2, replace=False)\n        new_solution[p], new_solution[q] = new_solution[q], new_solution[p]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of objective-based selection and diversity, then applies a novel hybrid local search combining adaptive segment inversion with probabilistic edge contraction and expansion to generate diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_distances = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * crowding_distances\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic edge contraction\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n - 2)\n        j = (i + 2) % n\n        if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Probabilistic edge expansion\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n        if (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7987464408132957,
            0.4717474579811096
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    crowding_distances = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * crowding_distances\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Probabilistic edge contraction\n    if np.random.rand() < 0.4:\n        i = np.random.randint(0, n - 2)\n        j = (i + 2) % n\n        if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Probabilistic edge expansion\n    if np.random.rand() < 0.3:\n        i = np.random.randint(0, n - 1)\n        j = np.random.randint(i + 1, n)\n        if (distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) > \\\n           (distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]):\n            new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid score combining Pareto dominance, normalized objective values, and solution diversity, then applies a novel local search with adaptive segment reversal and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Hybrid selection score combining Pareto dominance and diversity\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        dominance_scores[i] = 1 / (1 + dominated)\n\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = []\n        for j in range(len(archive)):\n            if i != j:\n                distances.append(np.sum(np.abs(solutions[i] - solutions[j])))\n        diversity_scores[i] = np.mean(distances) if distances else 0\n\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.4 * dominance_scores + 0.3 * (1 - normalized_obj[:, 0]) + 0.3 * (1 - normalized_obj[:, 1]) + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware length\n    segment_length = min(max(3, int(n * 0.1)), n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Evaluate segment reversal based on both objectives\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    reversed_cost1 = sum(distance_matrix_1[segment[(i+1)%segment_length], segment[i]] for i in range(segment_length))\n    reversed_cost2 = sum(distance_matrix_2[segment[(i+1)%segment_length], segment[i]] for i in range(segment_length))\n\n    if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n       (np.random.random() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n        new_solution[start:end] = segment[::-1]\n\n    # Guided node insertion based on both objectives\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    candidates = []\n    for j in range(n):\n        if j != i and j != (i + 1) % n and j != (i - 1) % n:\n            # Evaluate insertion cost for both objectives\n            cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[(i-1)%n], node_to_move] - distance_matrix_1[node_to_move, new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[(i-1)%n], node_to_move] - distance_matrix_2[node_to_move, new_solution[(i+1)%n]]\n            candidates.append((j, cost1 + cost2))\n\n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        best_j = candidates[0][0]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_j], [node_to_move], new_solution[best_j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7897659586163069,
            5.697735071182251
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Hybrid selection score combining Pareto dominance and diversity\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated += 1\n        dominance_scores[i] = 1 / (1 + dominated)\n\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = []\n        for j in range(len(archive)):\n            if i != j:\n                distances.append(np.sum(np.abs(solutions[i] - solutions[j])))\n        diversity_scores[i] = np.mean(distances) if distances else 0\n\n    diversity_scores = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    scores = 0.4 * dominance_scores + 0.3 * (1 - normalized_obj[:, 0]) + 0.3 * (1 - normalized_obj[:, 1]) + 0.1 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with objective-aware length\n    segment_length = min(max(3, int(n * 0.1)), n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Evaluate segment reversal based on both objectives\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    reversed_cost1 = sum(distance_matrix_1[segment[(i+1)%segment_length], segment[i]] for i in range(segment_length))\n    reversed_cost2 = sum(distance_matrix_2[segment[(i+1)%segment_length], segment[i]] for i in range(segment_length))\n\n    if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n       (np.random.random() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n        new_solution[start:end] = segment[::-1]\n\n    # Guided node insertion based on both objectives\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    candidates = []\n    for j in range(n):\n        if j != i and j != (i + 1) % n and j != (i - 1) % n:\n            # Evaluate insertion cost for both objectives\n            cost1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_1[new_solution[(i-1)%n], node_to_move] - distance_matrix_1[node_to_move, new_solution[(i+1)%n]]\n            cost2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[(i+1)%n]] - distance_matrix_2[new_solution[(i-1)%n], node_to_move] - distance_matrix_2[node_to_move, new_solution[(i+1)%n]]\n            candidates.append((j, cost1 + cost2))\n\n    if candidates:\n        candidates.sort(key=lambda x: x[1])\n        best_j = candidates[0][0]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_j], [node_to_move], new_solution[best_j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using different parameter settings\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator with different parameters\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with different segment length\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with different selection criteria\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning, while also incorporating a probabilistic edge swap mechanism to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using weighted objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with variable length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with probabilistic selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Step 3: Probabilistic edge swap for further improvement\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7669158128251476,
            0.22668302059173584
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using weighted objectives\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment reversal with variable length\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Step 2: Guided node repositioning with probabilistic selection\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Step 3: Probabilistic edge swap for further improvement\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if np.random.random() < 0.3:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if repositioning breaks the tour\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{A novel multi-objective local search operator that combines a Pareto-dominance guided node insertion with a dynamic sub-tour reversal strategy to explore high-quality regions of the solution space while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Pareto-dominance guided node insertion\n    for _ in range(min(3, n // 2)):\n        # Select a random node to remove\n        remove_idx = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_idx]\n\n        # Find the best insertion position based on Pareto-dominance\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for i in range(n-1):\n            if i == remove_idx or i == remove_idx - 1:\n                continue\n\n            # Try inserting the removed node between i and i+1\n            prev_node = new_solution[i]\n            next_node = new_solution[(i+1) % n]\n\n            # Calculate the change in objectives\n            delta_cost1 = (distance_matrix_1[prev_node, removed_node] +\n                          distance_matrix_1[removed_node, next_node] -\n                          distance_matrix_1[prev_node, next_node])\n            delta_cost2 = (distance_matrix_2[prev_node, removed_node] +\n                          distance_matrix_2[removed_node, next_node] -\n                          distance_matrix_2[prev_node, next_node])\n\n            # Check if this insertion dominates the current best\n            if (delta_cost1 < best_improvement[0] and delta_cost2 <= best_improvement[1]) or \\\n               (delta_cost1 <= best_improvement[0] and delta_cost2 < best_improvement[1]):\n                best_pos = i\n                best_improvement = (delta_cost1, delta_cost2)\n\n        # Perform the insertion if it improves at least one objective\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos+1],\n                [removed_node],\n                new_solution[best_pos+1:remove_idx],\n                new_solution[remove_idx+1:]\n            ])\n\n    # Dynamic sub-tour reversal\n    if np.random.rand() < 0.3:\n        # Select a random sub-tour to reverse\n        sub_size = np.random.randint(2, min(6, n // 2))\n        start_idx = np.random.randint(0, n - sub_size)\n        new_solution[start_idx:start_idx+sub_size] = np.flip(new_solution[start_idx:start_idx+sub_size])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n",
        "score": [
            -0.6938147447013789,
            1.6842184662818909
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Pareto-dominance guided node insertion\n    for _ in range(min(3, n // 2)):\n        # Select a random node to remove\n        remove_idx = np.random.randint(1, n-1)\n        removed_node = new_solution[remove_idx]\n\n        # Find the best insertion position based on Pareto-dominance\n        best_pos = -1\n        best_improvement = (0, 0)\n\n        for i in range(n-1):\n            if i == remove_idx or i == remove_idx - 1:\n                continue\n\n            # Try inserting the removed node between i and i+1\n            prev_node = new_solution[i]\n            next_node = new_solution[(i+1) % n]\n\n            # Calculate the change in objectives\n            delta_cost1 = (distance_matrix_1[prev_node, removed_node] +\n                          distance_matrix_1[removed_node, next_node] -\n                          distance_matrix_1[prev_node, next_node])\n            delta_cost2 = (distance_matrix_2[prev_node, removed_node] +\n                          distance_matrix_2[removed_node, next_node] -\n                          distance_matrix_2[prev_node, next_node])\n\n            # Check if this insertion dominates the current best\n            if (delta_cost1 < best_improvement[0] and delta_cost2 <= best_improvement[1]) or \\\n               (delta_cost1 <= best_improvement[0] and delta_cost2 < best_improvement[1]):\n                best_pos = i\n                best_improvement = (delta_cost1, delta_cost2)\n\n        # Perform the insertion if it improves at least one objective\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos+1],\n                [removed_node],\n                new_solution[best_pos+1:remove_idx],\n                new_solution[remove_idx+1:]\n            ])\n\n    # Dynamic sub-tour reversal\n    if np.random.rand() < 0.3:\n        # Select a random sub-tour to reverse\n        sub_size = np.random.randint(2, min(6, n // 2))\n        start_idx = np.random.randint(0, n - sub_size)\n        new_solution[start_idx:start_idx+sub_size] = np.flip(new_solution[start_idx:start_idx+sub_size])\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        return base_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of Pareto dominance and solution diversity, then applies a novel hybrid local search combining adaptive node clustering and guided path inversion to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominated_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * (1 / (dominated_counts + 1)) + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering and path inversion\n    cluster_size = max(2, min(4, n // 4))\n    start_pos = np.random.randint(0, n - cluster_size)\n    end_pos = start_pos + cluster_size\n\n    # Cluster nodes based on spatial proximity in both objective spaces\n    cluster_nodes = new_solution[start_pos:end_pos]\n    node_coords = instance[cluster_nodes]\n    centroid1 = np.mean(node_coords[:, :2], axis=0)\n    centroid2 = np.mean(node_coords[:, 2:], axis=0)\n\n    # Sort nodes within cluster by distance to centroids\n    dist_to_centroid1 = np.linalg.norm(node_coords[:, :2] - centroid1, axis=1)\n    dist_to_centroid2 = np.linalg.norm(node_coords[:, 2:] - centroid2, axis=1)\n    sorted_indices = np.lexsort((dist_to_centroid2, dist_to_centroid1))\n    new_solution[start_pos:end_pos] = cluster_nodes[sorted_indices]\n\n    # Guided path inversion\n    if np.random.rand() < 0.5:\n        inv_start = np.random.randint(0, n - 2)\n        inv_end = np.random.randint(inv_start + 1, n)\n\n        # Calculate cost change\n        before_cost1 = (distance_matrix_1[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                       distance_matrix_1[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n        before_cost2 = (distance_matrix_2[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                       distance_matrix_2[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n\n        new_solution[inv_start+1:inv_end+1] = new_solution[inv_start+1:inv_end+1][::-1]\n\n        after_cost1 = (distance_matrix_1[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                      distance_matrix_1[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n        after_cost2 = (distance_matrix_2[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                      distance_matrix_2[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n\n        # Revert if not beneficial in both objectives\n        if (after_cost1 >= before_cost1 and after_cost2 >= before_cost2) and np.random.rand() > 0.3:\n            new_solution[inv_start+1:inv_end+1] = new_solution[inv_start+1:inv_end+1][::-1]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8745226737877646,
            5.730605959892273
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and diversity\n    objectives = np.array([obj for _, obj in archive])\n    dominated_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated_counts[i] += 1\n\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * (1 / (dominated_counts + 1)) + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering and path inversion\n    cluster_size = max(2, min(4, n // 4))\n    start_pos = np.random.randint(0, n - cluster_size)\n    end_pos = start_pos + cluster_size\n\n    # Cluster nodes based on spatial proximity in both objective spaces\n    cluster_nodes = new_solution[start_pos:end_pos]\n    node_coords = instance[cluster_nodes]\n    centroid1 = np.mean(node_coords[:, :2], axis=0)\n    centroid2 = np.mean(node_coords[:, 2:], axis=0)\n\n    # Sort nodes within cluster by distance to centroids\n    dist_to_centroid1 = np.linalg.norm(node_coords[:, :2] - centroid1, axis=1)\n    dist_to_centroid2 = np.linalg.norm(node_coords[:, 2:] - centroid2, axis=1)\n    sorted_indices = np.lexsort((dist_to_centroid2, dist_to_centroid1))\n    new_solution[start_pos:end_pos] = cluster_nodes[sorted_indices]\n\n    # Guided path inversion\n    if np.random.rand() < 0.5:\n        inv_start = np.random.randint(0, n - 2)\n        inv_end = np.random.randint(inv_start + 1, n)\n\n        # Calculate cost change\n        before_cost1 = (distance_matrix_1[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                       distance_matrix_1[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n        before_cost2 = (distance_matrix_2[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                       distance_matrix_2[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n\n        new_solution[inv_start+1:inv_end+1] = new_solution[inv_start+1:inv_end+1][::-1]\n\n        after_cost1 = (distance_matrix_1[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                      distance_matrix_1[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n        after_cost2 = (distance_matrix_2[new_solution[inv_start], new_solution[(inv_start+1)%n]] +\n                      distance_matrix_2[new_solution[inv_end], new_solution[(inv_end+1)%n]])\n\n        # Revert if not beneficial in both objectives\n        if (after_cost1 >= before_cost1 and after_cost2 >= before_cost2) and np.random.rand() > 0.3:\n            new_solution[inv_start+1:inv_end+1] = new_solution[inv_start+1:inv_end+1][::-1]\n\n    # Ensure solution remains valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion with higher probability\n        if random.random() < 0.85:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9284719284032386,
            0.21799170970916748
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion with higher probability\n        if random.random() < 0.85:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution structure, then applies a hybrid local search combining adaptive k-opt moves with guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    structure_scores = np.array([np.sum(np.abs(np.diff(sol[0]))) for sol in archive])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * structure_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive k-opt move (k=3)\n    k = 3\n    if n >= k + 1:\n        indices = sorted(np.random.choice(range(n), k, replace=False))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Step 2: Guided node insertion\n    if n > 2:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n        insert_pos = np.random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(range(n), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8656658575244576,
            0.4976971745491028
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    structure_scores = np.array([np.sum(np.abs(np.diff(sol[0]))) for sol in archive])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * structure_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive k-opt move (k=3)\n    k = 3\n    if n >= k + 1:\n        indices = sorted(np.random.choice(range(n), k, replace=False))\n        segment = new_solution[indices]\n        np.random.shuffle(segment)\n        new_solution[indices] = segment\n\n    # Step 2: Guided node insertion\n    if n > 2:\n        node = np.random.choice(new_solution)\n        mask = new_solution != node\n        remaining = new_solution[mask]\n        insert_pos = np.random.randint(0, len(remaining))\n        new_solution = np.insert(remaining, insert_pos, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(range(n), 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a novel hybrid local search that combines adaptive segment reversal with guided node repositioning, focusing on improving both objectives through a multi-criteria evaluation of potential moves.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    old_segment = new_solution[start:end]\n    old_cost1 = sum(distance_matrix_1[old_segment[i], old_segment[(i+1)%(end-start)]] for i in range(end-start))\n    old_cost2 = sum(distance_matrix_2[old_segment[i], old_segment[(i+1)%(end-start)]] for i in range(end-start))\n\n    new_segment = old_segment[::-1]\n    new_cost1 = sum(distance_matrix_1[new_segment[i], new_segment[(i+1)%(end-start)]] for i in range(end-start))\n    new_cost2 = sum(distance_matrix_2[new_segment[i], new_segment[(i+1)%(end-start)]] for i in range(end-start))\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.rand() < 0.3):\n        new_solution[start:end] = new_segment\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    node_to_move = new_solution[i]\n    temp_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]]\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.rand() < 0.2):\n        new_solution = temp_solution\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7958806903937864,
            0.6063686609268188
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    old_segment = new_solution[start:end]\n    old_cost1 = sum(distance_matrix_1[old_segment[i], old_segment[(i+1)%(end-start)]] for i in range(end-start))\n    old_cost2 = sum(distance_matrix_2[old_segment[i], old_segment[(i+1)%(end-start)]] for i in range(end-start))\n\n    new_segment = old_segment[::-1]\n    new_cost1 = sum(distance_matrix_1[new_segment[i], new_segment[(i+1)%(end-start)]] for i in range(end-start))\n    new_cost2 = sum(distance_matrix_2[new_segment[i], new_segment[(i+1)%(end-start)]] for i in range(end-start))\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.rand() < 0.3):\n        new_solution[start:end] = new_segment\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n\n    old_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    old_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    node_to_move = new_solution[i]\n    temp_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    new_cost1 = distance_matrix_1[temp_solution[i-1], temp_solution[i]] + distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_1[temp_solution[j-1], temp_solution[j]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[temp_solution[i-1], temp_solution[i]] + distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_2[temp_solution[j-1], temp_solution[j]] + distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]]\n\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (np.random.rand() < 0.2):\n        new_solution = temp_solution\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive segment extraction and intelligent node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        if np.random.random() < 0.5:\n            node_to_move = new_solution[np.random.randint(0, len(new_solution))]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.792436011042478,
            0.21125668287277222
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_length:]])\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n        if np.random.random() < 0.5:\n            node_to_move = new_solution[np.random.randint(0, len(new_solution))]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, len(new_solution))\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm selects a solution from the archive based on a diversity-aware Pareto front ranking, then applies a novel hybrid local search combining adaptive segment insertion and objective-biased edge swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for diversity\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Combine crowding distance with Pareto rank (simplified)\n        scores = crowding + 1.0 / (1 + np.sum(objectives, axis=1))\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment insertion\n        seg_size = random.randint(2, min(4, n // 3))\n        a = random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Find insertion point based on objective bias\n        obj_weights = np.random.uniform(0.3, 0.7)\n        best_pos = -1\n        best_improvement = -np.inf\n\n        for pos in range(n - seg_size + 1):\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, np.arange(a, a+seg_size))\n            ])\n\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            combined_cost = obj_weights * cost1 + (1 - obj_weights) * cost2\n\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_combined = obj_weights * current_cost1 + (1 - obj_weights) * current_cost2\n\n            improvement = current_combined - combined_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, np.arange(a, a+seg_size))\n            ])\n\n        # Objective-biased edge swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[i], new_solution[i+1]),\n                (new_solution[j-1], new_solution[j]),\n                (new_solution[j], new_solution[j+1])\n            ]\n            new_edges = [\n                (new_solution[i-1], new_solution[j]),\n                (new_solution[j], new_solution[i+1]),\n                (new_solution[j-1], new_solution[i]),\n                (new_solution[i], new_solution[j+1])\n            ]\n\n            old_cost1 = sum(distance_matrix_1[a, b] for a, b in old_edges)\n            old_cost2 = sum(distance_matrix_2[a, b] for a, b in old_edges)\n            new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n            new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n            # Accept if better in at least one objective without worsening the other too much\n            if ((new_cost1 < old_cost1 and new_cost2 <= 1.1 * old_cost2) or\n                (new_cost2 < old_cost2 and new_cost1 <= 1.1 * old_cost1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.845557728675724,
            1.5409387946128845
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Calculate crowding distance for diversity\n        objectives = np.array([obj for _, obj in archive])\n        crowding = np.zeros(len(archive))\n\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        # Combine crowding distance with Pareto rank (simplified)\n        scores = crowding + 1.0 / (1 + np.sum(objectives, axis=1))\n        selected_idx = np.argmax(scores)\n        base_solution = archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment insertion\n        seg_size = random.randint(2, min(4, n // 3))\n        a = random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Find insertion point based on objective bias\n        obj_weights = np.random.uniform(0.3, 0.7)\n        best_pos = -1\n        best_improvement = -np.inf\n\n        for pos in range(n - seg_size + 1):\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                np.delete(new_solution, np.arange(a, a+seg_size))\n            ])\n\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            combined_cost = obj_weights * cost1 + (1 - obj_weights) * cost2\n\n            current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            current_combined = obj_weights * current_cost1 + (1 - obj_weights) * current_cost2\n\n            improvement = current_combined - combined_cost\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                np.delete(new_solution, np.arange(a, a+seg_size))\n            ])\n\n        # Objective-biased edge swapping\n        for _ in range(2):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[i-1], new_solution[i]),\n                (new_solution[i], new_solution[i+1]),\n                (new_solution[j-1], new_solution[j]),\n                (new_solution[j], new_solution[j+1])\n            ]\n            new_edges = [\n                (new_solution[i-1], new_solution[j]),\n                (new_solution[j], new_solution[i+1]),\n                (new_solution[j-1], new_solution[i]),\n                (new_solution[i], new_solution[j+1])\n            ]\n\n            old_cost1 = sum(distance_matrix_1[a, b] for a, b in old_edges)\n            old_cost2 = sum(distance_matrix_2[a, b] for a, b in old_edges)\n            new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n            new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n            # Accept if better in at least one objective without worsening the other too much\n            if ((new_cost1 < old_cost1 and new_cost2 <= 1.1 * old_cost2) or\n                (new_cost2 < old_cost2 and new_cost1 <= 1.1 * old_cost1)):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of Pareto dominance analysis and clustering-based selection, then applies a novel hybrid local search that combines adaptive k-opt moves with guided path inversion and probabilistic edge flipping to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance and clustering-based selection\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if len(non_dominated) > 1:\n        # Cluster solutions and select from largest cluster\n        from sklearn.cluster import KMeans\n        solutions = np.array([sol for sol, _ in archive])\n        kmeans = KMeans(n_clusters=min(3, len(non_dominated)), random_state=42)\n        clusters = kmeans.fit_predict(solutions[non_dominated])\n        selected_cluster = np.argmax(np.bincount(clusters))\n        selected_idx = non_dominated[np.where(clusters == selected_cluster)[0][0]]\n    else:\n        selected_idx = non_dominated[0] if non_dominated else 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k=3,4,5 with probability)\n    k = np.random.choice([3, 4, 5], p=[0.5, 0.3, 0.2])\n    if n >= k:\n        indices = np.random.choice(n, k, replace=False)\n        segment = new_solution[indices]\n        new_solution[indices] = np.random.permutation(segment)\n\n    # Guided path inversion with objective awareness\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        segment = new_solution[i:j+1]\n        cost1_before = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        cost2_before = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_rev = segment[::-1]\n        cost1_after = sum(distance_matrix_1[segment_rev[k], segment_rev[(k+1)%len(segment)]] for k in range(len(segment)))\n        cost2_after = sum(distance_matrix_2[segment_rev[k], segment_rev[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (np.random.rand() < 0.3 and (cost1_after <= cost1_before or cost2_after <= cost2_before)):\n            new_solution[i:j+1] = segment_rev\n\n    # Probabilistic edge flipping\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if abs(i - j) > 1 and np.random.rand() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.933034482720053,
            3.8952112197875977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Pareto dominance and clustering-based selection\n    objectives = np.array([obj for _, obj in archive])\n    dominated = np.zeros(len(archive), dtype=bool)\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j and (objectives[i, 0] >= objectives[j, 0] and objectives[i, 1] >= objectives[j, 1]):\n                dominated[i] = True\n                break\n\n    non_dominated = [i for i in range(len(archive)) if not dominated[i]]\n    if len(non_dominated) > 1:\n        # Cluster solutions and select from largest cluster\n        from sklearn.cluster import KMeans\n        solutions = np.array([sol for sol, _ in archive])\n        kmeans = KMeans(n_clusters=min(3, len(non_dominated)), random_state=42)\n        clusters = kmeans.fit_predict(solutions[non_dominated])\n        selected_cluster = np.argmax(np.bincount(clusters))\n        selected_idx = non_dominated[np.where(clusters == selected_cluster)[0][0]]\n    else:\n        selected_idx = non_dominated[0] if non_dominated else 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive k-opt move (k=3,4,5 with probability)\n    k = np.random.choice([3, 4, 5], p=[0.5, 0.3, 0.2])\n    if n >= k:\n        indices = np.random.choice(n, k, replace=False)\n        segment = new_solution[indices]\n        new_solution[indices] = np.random.permutation(segment)\n\n    # Guided path inversion with objective awareness\n    for _ in range(2):\n        i = np.random.randint(0, n)\n        j = np.random.randint(i, n)\n        segment = new_solution[i:j+1]\n        cost1_before = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        cost2_before = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        segment_rev = segment[::-1]\n        cost1_after = sum(distance_matrix_1[segment_rev[k], segment_rev[(k+1)%len(segment)]] for k in range(len(segment)))\n        cost2_after = sum(distance_matrix_2[segment_rev[k], segment_rev[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        if (cost1_after < cost1_before and cost2_after < cost2_before) or \\\n           (np.random.rand() < 0.3 and (cost1_after <= cost1_before or cost2_after <= cost2_before)):\n            new_solution[i:j+1] = segment_rev\n\n    # Probabilistic edge flipping\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if abs(i - j) > 1 and np.random.rand() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive segment reversal and node reinsertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Node reinsertion with position selection\n        if np.random.random() < 0.6:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7725245408990961,
            0.16702628135681152
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n        # Node reinsertion with position selection\n        if np.random.random() < 0.6:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-based selection to prioritize solutions in less crowded regions of the Pareto front, then applies a hybrid local search combining adaptive 3-opt and guided edge insertion with probabilistic move acceptance for improved solution quality across both objectives while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    n_fronts = len(archive)\n\n    if n_fronts == 1:\n        selected_idx = 0\n    else:\n        crowding_distances = np.zeros(n_fronts)\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, n_fronts - 1):\n                crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:\n        a, b, c = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([a, b, c])\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    else:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node_to_insert = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6389179746719381,
            0.4706007242202759
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    n_fronts = len(archive)\n\n    if n_fronts == 1:\n        selected_idx = 0\n    else:\n        crowding_distances = np.zeros(n_fronts)\n        for i in range(2):\n            sorted_idx = np.argsort(objectives[:, i])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n            for j in range(1, n_fronts - 1):\n                crowding_distances[sorted_idx[j]] += (objectives[sorted_idx[j+1], i] - objectives[sorted_idx[j-1], i]) / (objectives[sorted_idx[-1], i] - objectives[sorted_idx[0], i] + 1e-8)\n        selected_idx = np.argmax(crowding_distances)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if np.random.random() < 0.7:\n        a, b, c = np.random.choice(n, 3, replace=False)\n        i, j, k = sorted([a, b, c])\n        segment1 = new_solution[i:j]\n        segment2 = new_solution[j:k]\n        new_solution = np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]])\n    else:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node_to_insert = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_insert], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive segment inversion and guided node relocation with dynamic parameter adaptation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:end] = np.roll(new_solution[start:end], np.random.randint(1, segment_length))\n\n    if np.random.random() < 0.6:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8921679923068359,
            0.20859885215759277
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    if np.random.random() < 0.5:\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        new_solution[start:end] = np.roll(new_solution[start:end], np.random.randint(1, segment_length))\n\n    if np.random.random() < 0.6:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel weighted objective combination that considers both objective values and their relative improvement potential, then applies a hybrid local search combining adaptive segment rotation and targeted node relocation to generate high-quality neighbor solutions while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel selection based on objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_scores = 1 / (1 + normalized_obj)\n    scores = 0.6 * improvement_scores[:, 0] + 0.4 * improvement_scores[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation with dynamic segment size\n        segment_length = min(7, max(3, n // 3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Targeted node relocation with distance-based selection\n        if np.random.random() < 0.8:\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            current_pos = node_idx\n            new_pos = np.random.randint(0, n)\n            if new_pos != current_pos:\n                new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:]])\n                new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8406568922196072,
            0.27226972579956055
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Novel selection based on objective improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    improvement_scores = 1 / (1 + normalized_obj)\n    scores = 0.6 * improvement_scores[:, 0] + 0.4 * improvement_scores[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation with dynamic segment size\n        segment_length = min(7, max(3, n // 3))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Targeted node relocation with distance-based selection\n        if np.random.random() < 0.8:\n            node_idx = np.random.randint(0, n)\n            node = new_solution[node_idx]\n            current_pos = node_idx\n            new_pos = np.random.randint(0, n)\n            if new_pos != current_pos:\n                new_solution = np.concatenate([new_solution[:current_pos], new_solution[current_pos+1:]])\n                new_solution = np.concatenate([new_solution[:new_pos], [node], new_solution[new_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel weighted objective combination and solution quality, then applies a hybrid local search combining segment reversal and intelligent node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on novel weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * (1 - normalized_obj[:, 0] * normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with adaptive selection\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        reversed_segment = segment[::-1]\n        new_solution[start:end] = reversed_segment\n\n        # Intelligent node relocation\n        if np.random.random() < 0.6:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            current_pos = np.where(new_solution == node_to_move)[0][0]\n            new_pos = (current_pos + np.random.randint(1, min(5, n))) % n\n            new_solution = np.roll(new_solution, -new_pos)\n            new_solution[0] = node_to_move\n            new_solution = np.roll(new_solution, new_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9289414644949329,
            0.3961215019226074
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on novel weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1] + 0.2 * (1 - normalized_obj[:, 0] * normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with adaptive selection\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        reversed_segment = segment[::-1]\n        new_solution[start:end] = reversed_segment\n\n        # Intelligent node relocation\n        if np.random.random() < 0.6:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            current_pos = np.where(new_solution == node_to_move)[0][0]\n            new_pos = (current_pos + np.random.randint(1, min(5, n))) % n\n            new_solution = np.roll(new_solution, -new_pos)\n            new_solution[0] = node_to_move\n            new_solution = np.roll(new_solution, new_pos)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion with higher probability\n        if random.random() < 0.85:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment reversal and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node insertion with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7257987099873303,
            0.1666862964630127
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node insertion with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining adaptive segment inversion with guided node insertion and rotation, while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    rotation = np.random.randint(1, n)\n    new_solution = np.roll(new_solution, rotation)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7882823752299558,
            0.29126644134521484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 4)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    rotation = np.random.randint(1, n)\n    new_solution = np.roll(new_solution, rotation)\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution diversity, then applies a novel hybrid local search combining adaptive segment insertion and Pareto-guided node replacement to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on weighted objective combination and diversity\n        weights = np.random.uniform(0.4, 0.6)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 2)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment insertion\n        seg_size = random.randint(1, min(4, n // 2))\n        a = random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Insert segment at a new position\n        new_pos = random.randint(0, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:a],\n            new_solution[a+seg_size:]\n        ])\n\n        # Pareto-guided node replacement\n        for i in range(n):\n            j = (i + 1) % n\n            k = random.randint(0, n - 1)\n            while k == i or k == j:\n                k = random.randint(0, n - 1)\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n               (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                new_solution[j] = new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8256346501584867,
            0.2828078866004944
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on weighted objective combination and diversity\n        weights = np.random.uniform(0.4, 0.6)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 2)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment insertion\n        seg_size = random.randint(1, min(4, n // 2))\n        a = random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Insert segment at a new position\n        new_pos = random.randint(0, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:new_pos],\n            segment,\n            new_solution[new_pos:a],\n            new_solution[a+seg_size:]\n        ])\n\n        # Pareto-guided node replacement\n        for i in range(n):\n            j = (i + 1) % n\n            k = random.randint(0, n - 1)\n            while k == i or k == j:\n                k = random.randint(0, n - 1)\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n               (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                new_solution[j] = new_solution[k]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{A novel hybrid local search operator that combines a multi-segment crossover with a Pareto-frontier guided edge swapping strategy to generate diverse high-quality neighbors while maintaining feasibility through a novel segment reassembly mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate Pareto dominance and crowding distance\n    dominance_counts = np.zeros(len(archive))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[i] += 1\n        sorted_idx = np.argsort(objectives[:, 0])\n        for m in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[m]] += objectives[sorted_idx[m+1], 0] - objectives[sorted_idx[m-1], 0]\n        sorted_idx = np.argsort(objectives[:, 1])\n        for m in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[m]] += objectives[sorted_idx[m+1], 1] - objectives[sorted_idx[m-1], 1]\n\n    # Combine selection criteria\n    selection_scores = dominance_counts + crowding_distances\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment crossover with reassembly\n        num_segments = min(3, n // 4)\n        segment_lengths = np.random.randint(2, n // num_segments, size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - np.sum(segment_lengths) + 1, num_segments, replace=False))\n\n        segments = []\n        for i in range(num_segments):\n            start = segment_starts[i]\n            end = start + segment_lengths[i]\n            segments.append(new_solution[start:end])\n\n        # Reassemble segments with new connections\n        new_order = np.concatenate(segments)\n        remaining_nodes = np.setdiff1d(base_solution, new_order)\n        new_order = np.concatenate([new_order, remaining_nodes])\n\n        # Validate and fix if necessary\n        if len(np.unique(new_order)) != n:\n            new_order = base_solution.copy()\n            i, j = np.random.choice(n, 2, replace=False)\n            new_order[i], new_order[j] = new_order[j], new_order[i]\n\n        new_solution = new_order\n\n        # Pareto-frontier guided edge swapping\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n               (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n",
        "score": [
            -0.8588742444879257,
            0.8196287751197815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on Pareto dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Calculate Pareto dominance and crowding distance\n    dominance_counts = np.zeros(len(archive))\n    crowding_distances = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] < objectives[j][1]) or \\\n                   (objectives[i][0] < objectives[j][0] and objectives[i][1] <= objectives[j][1]):\n                    dominance_counts[i] += 1\n        sorted_idx = np.argsort(objectives[:, 0])\n        for m in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[m]] += objectives[sorted_idx[m+1], 0] - objectives[sorted_idx[m-1], 0]\n        sorted_idx = np.argsort(objectives[:, 1])\n        for m in range(1, len(archive)-1):\n            crowding_distances[sorted_idx[m]] += objectives[sorted_idx[m+1], 1] - objectives[sorted_idx[m-1], 1]\n\n    # Combine selection criteria\n    selection_scores = dominance_counts + crowding_distances\n    selected_idx = np.argmax(selection_scores)\n    base_solution = solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Multi-segment crossover with reassembly\n        num_segments = min(3, n // 4)\n        segment_lengths = np.random.randint(2, n // num_segments, size=num_segments)\n        segment_starts = np.sort(np.random.choice(n - np.sum(segment_lengths) + 1, num_segments, replace=False))\n\n        segments = []\n        for i in range(num_segments):\n            start = segment_starts[i]\n            end = start + segment_lengths[i]\n            segments.append(new_solution[start:end])\n\n        # Reassemble segments with new connections\n        new_order = np.concatenate(segments)\n        remaining_nodes = np.setdiff1d(base_solution, new_order)\n        new_order = np.concatenate([new_order, remaining_nodes])\n\n        # Validate and fix if necessary\n        if len(np.unique(new_order)) != n:\n            new_order = base_solution.copy()\n            i, j = np.random.choice(n, 2, replace=False)\n            new_order[i], new_order[j] = new_order[j], new_order[i]\n\n        new_solution = new_order\n\n        # Pareto-frontier guided edge swapping\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n               (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{The new algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a hybrid local search combining adaptive node insertion with guided 3-opt moves to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        non_dominated = list(range(len(archive)))\n\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = np.array([diversity_scores[i] if i in non_dominated else 0 for i in range(len(archive))])\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Guided 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        if (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]) > \\\n           (distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8448299206283219,
            0.5837339758872986
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated = []\n    for i in range(len(archive)):\n        dominated = False\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(i)\n\n    if not non_dominated:\n        non_dominated = list(range(len(archive)))\n\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = np.array([diversity_scores[i] if i in non_dominated else 0 for i in range(len(archive))])\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive node insertion\n    if n > 3:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n    # Step 2: Guided 3-opt move\n    if n > 4:\n        a, b, c = sorted(np.random.choice(n, 3, replace=False))\n        if (distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[(a+1)%n]]) > \\\n           (distance_matrix_1[new_solution[a], new_solution[c]] + distance_matrix_1[new_solution[c], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]]):\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This algorithm selects a solution from the archive using a score based on the product of normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = (1 - normalized_obj[:, 0]) * (1 - normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = np.random.randint(3, min(8, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7553075119776929,
            0.17862069606781006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = (1 - normalized_obj[:, 0]) * (1 - normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = np.random.randint(3, min(8, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid of objective quality and diversity, then applies a novel combination of adaptive segment inversion with guided node swapping and probabilistic edge flipping to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n        diversity_score = np.mean(diversity) if len(diversity) > 0 else 1.0\n        quality_weights = np.exp(-np.sum(objectives, axis=1)) * (1 + diversity_score)\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 5))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n               (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.rand() < 0.3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7985879082972671,
            2.0303250551223755
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        diversity = np.array([np.sum(np.abs(archive[i][0] - archive[j][0])) for i in range(len(archive)) for j in range(i+1, len(archive))])\n        diversity_score = np.mean(diversity) if len(diversity) > 0 else 1.0\n        quality_weights = np.exp(-np.sum(objectives, axis=1)) * (1 + diversity_score)\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 5))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        for _ in range(2):\n            i, j = np.random.choice(n, 2, replace=False)\n            if (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) < \\\n               (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        if np.random.rand() < 0.3:\n            i = np.random.randint(0, n)\n            j = np.random.randint(0, n)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = np.random.randint(0, n)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel local search operator that combines adaptive segment rotation with guided edge swapping and node insertion, ensuring feasibility through careful validation and fallback mechanisms.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i, j = np.random.choice(n, 2, replace=False)\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.871016989278983,
            0.28987550735473633
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    i, j = np.random.choice(n, 2, replace=False)\n    if abs(i - j) > 1:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.7 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(7, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm selects a solution from the archive using a score function that prioritizes diversity and objective trade-off with adaptive weights, then applies a hybrid local search with variable-length segment reversal and guided node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity = 0\n        for j in range(len(archive)):\n            if i != j:\n                diversity += np.sum(archive[i][0] != archive[j][0])\n        diversity_scores[i] = diversity / (len(archive) - 1)\n\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    alpha = 0.6\n    scores = alpha * normalized_diversity + (1 - alpha) * (0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = np.random.randint(3, min(10, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7910347242497348,
            4.58210027217865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        diversity = 0\n        for j in range(len(archive)):\n            if i != j:\n                diversity += np.sum(archive[i][0] != archive[j][0])\n        diversity_scores[i] = diversity / (len(archive) - 1)\n\n    normalized_diversity = (diversity_scores - diversity_scores.min()) / (diversity_scores.max() - diversity_scores.min() + 1e-8)\n    alpha = 0.6\n    scores = alpha * normalized_diversity + (1 - alpha) * (0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1])\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = np.random.randint(3, min(10, n // 2))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution diversity, then applies a novel hybrid local search combining adaptive segment rotation and guided node insertion with probabilistic edge flipping to generate a diverse neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on Pareto dominance and diversity\n        pareto_front = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = False\n            for j, (_, other_obj) in enumerate(archive):\n                if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n\n        if pareto_front:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            # If no Pareto-optimal solutions, select based on crowding distance\n            objectives = np.array([obj for _, obj in archive])\n            normalized = objectives / np.sum(objectives, axis=0)\n            distances = np.zeros(len(archive))\n            for i in range(len(archive)):\n                for j in range(len(archive)):\n                    if i != j:\n                        distances[i] += np.sqrt(np.sum((normalized[i] - normalized[j])**2))\n            selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        seg_size = max(2, min(4, n // 4))\n        start = np.random.randint(0, n - seg_size)\n        rotation = np.random.randint(1, seg_size)\n        segment = new_solution[start:start+seg_size]\n        rotated = np.roll(segment, rotation)\n        new_solution[start:start+seg_size] = rotated\n\n        # Guided node insertion with probabilistic acceptance\n        if np.random.rand() < 0.5:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Edge flipping with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            flipped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            flipped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (flipped_cost1 < current_cost1 and flipped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (flipped_cost1 <= current_cost1 or flipped_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9078758282657653,
            0.4017831087112427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on Pareto dominance and diversity\n        pareto_front = []\n        for i, (sol, obj) in enumerate(archive):\n            dominated = False\n            for j, (_, other_obj) in enumerate(archive):\n                if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n\n        if pareto_front:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            # If no Pareto-optimal solutions, select based on crowding distance\n            objectives = np.array([obj for _, obj in archive])\n            normalized = objectives / np.sum(objectives, axis=0)\n            distances = np.zeros(len(archive))\n            for i in range(len(archive)):\n                for j in range(len(archive)):\n                    if i != j:\n                        distances[i] += np.sqrt(np.sum((normalized[i] - normalized[j])**2))\n            selected_idx = np.argmax(distances)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment rotation\n        seg_size = max(2, min(4, n // 4))\n        start = np.random.randint(0, n - seg_size)\n        rotation = np.random.randint(1, seg_size)\n        segment = new_solution[start:start+seg_size]\n        rotated = np.roll(segment, rotation)\n        new_solution[start:start+seg_size] = rotated\n\n        # Guided node insertion with probabilistic acceptance\n        if np.random.rand() < 0.5:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n        # Edge flipping with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            flipped_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            flipped_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (flipped_cost1 < current_cost1 and flipped_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (flipped_cost1 <= current_cost1 or flipped_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution structure diversity, then applies a novel hybrid local search combining adaptive segment insertion and guided node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and structural quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    structural_diversity = np.array([np.sum(np.abs(np.diff(sol[0]))) for sol in archive])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * structural_diversity\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    insert_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Guided node relocation\n    if n > 5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == i + 1 or j == i - 1:\n            j = np.random.randint(0, n)\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost += distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost += distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if new_cost < current_cost:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8308901915270578,
            0.5570412874221802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective diversity and structural quality\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    structural_diversity = np.array([np.sum(np.abs(np.diff(sol[0]))) for sol in archive])\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * structural_diversity\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment insertion\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    insert_pos = np.random.randint(0, n - segment_length)\n    segment = new_solution[start:end]\n    new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Guided node relocation\n    if n > 5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == i + 1 or j == i - 1:\n            j = np.random.randint(0, n)\n        current_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        current_cost += distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n        new_cost = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        new_cost += distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        if new_cost < current_cost:\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This algorithm selects a high-quality solution from the archive using a combination of Pareto front filtering, adaptive segment reversal, and guided node relocation with probabilistic edge swapping to create diverse high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        pareto_front = []\n        for i in range(len(objectives)):\n            dominated = False\n            for j in range(len(objectives)):\n                if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n        if pareto_front:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution[a:a+seg_size] = segment[::-1]\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.2 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.968960741941786,
            0.5739948749542236
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        pareto_front = []\n        for i in range(len(objectives)):\n            dominated = False\n            for j in range(len(objectives)):\n                if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                    dominated = True\n                    break\n            if not dominated:\n                pareto_front.append(i)\n        if pareto_front:\n            selected_idx = np.random.choice(pareto_front)\n        else:\n            selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n        new_solution[a:a+seg_size] = segment[::-1]\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.2 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of quality-based and diversity-aware selection, then applies a hybrid local search that includes adaptive segment reversal, guided edge swapping, and probabilistic node relocation to generate high-quality neighbors while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        diversity_weights = np.array([np.sum([np.linalg.norm(obj - objectives[j]) for j in range(len(objectives)) if j != i]) for i, obj in enumerate(objectives)])\n        combined_weights = 0.7 * quality_weights + 0.3 * diversity_weights\n        combined_weights = combined_weights / np.sum(combined_weights)\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        else:\n            shift = np.random.randint(1, seg_size)\n            segment = np.roll(segment, shift)\n\n        new_solution[a:a+seg_size] = segment\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            if np.random.rand() < 0.4:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[k]\n                new_solution[k] = temp\n\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8867203001215905,
            0.8802999258041382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        diversity_weights = np.array([np.sum([np.linalg.norm(obj - objectives[j]) for j in range(len(objectives)) if j != i]) for i, obj in enumerate(objectives)])\n        combined_weights = 0.7 * quality_weights + 0.3 * diversity_weights\n        combined_weights = combined_weights / np.sum(combined_weights)\n        selected_idx = np.random.choice(len(archive), p=combined_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        seg_size = max(3, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        if np.random.rand() < 0.5:\n            segment = segment[::-1]\n        else:\n            shift = np.random.randint(1, seg_size)\n            segment = np.roll(segment, shift)\n\n        new_solution[a:a+seg_size] = segment\n\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            if np.random.rand() < 0.4:\n                temp = new_solution[i]\n                new_solution[i] = new_solution[k]\n                new_solution[k] = temp\n\n        if np.random.rand() < 0.3:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{This algorithm selects a solution from the archive using a combination of objective-based ranking and diversity-aware selection, then applies a novel hybrid local search combining adaptive segment inversion with Pareto-guided node swapping and dynamic edge optimization to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj[:, np.newaxis] - normalized_obj, axis=2).sum(axis=1)\n    combined_scores = 0.7 * (1 - normalized_obj).sum(axis=1) + 0.3 * (diversity_scores / diversity_scores.sum())\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    seg_length = min(4, max(2, n // 3))\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Pareto-guided node swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic edge optimization\n    for _ in range(1):\n        k = np.random.randint(0, n)\n        neighbors = [new_solution[(k-1)%n], new_solution[(k+1)%n]]\n        best_node = None\n        best_improvement = 0\n\n        for candidate in range(n):\n            if candidate in [k, (k-1)%n, (k+1)%n]:\n                continue\n            total_improvement = 0\n            for neighbor in neighbors:\n                current_edge1 = distance_matrix_1[neighbor, new_solution[k]]\n                current_edge2 = distance_matrix_2[neighbor, new_solution[k]]\n                new_edge1 = distance_matrix_1[neighbor, candidate]\n                new_edge2 = distance_matrix_2[neighbor, candidate]\n                improvement1 = current_edge1 - new_edge1\n                improvement2 = current_edge2 - new_edge2\n                if improvement1 > 0 and improvement2 > 0:\n                    total_improvement += (improvement1 + improvement2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_node = candidate\n\n        if best_node is not None:\n            new_solution[k] = best_node\n\n    return new_solution\n\n",
        "score": [
            -0.8694404964438371,
            0.5705657601356506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.linalg.norm(normalized_obj[:, np.newaxis] - normalized_obj, axis=2).sum(axis=1)\n    combined_scores = 0.7 * (1 - normalized_obj).sum(axis=1) + 0.3 * (diversity_scores / diversity_scores.sum())\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    seg_length = min(4, max(2, n // 3))\n    start = np.random.randint(0, n - seg_length)\n    end = start + seg_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Pareto-guided node swapping\n    for _ in range(2):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Dynamic edge optimization\n    for _ in range(1):\n        k = np.random.randint(0, n)\n        neighbors = [new_solution[(k-1)%n], new_solution[(k+1)%n]]\n        best_node = None\n        best_improvement = 0\n\n        for candidate in range(n):\n            if candidate in [k, (k-1)%n, (k+1)%n]:\n                continue\n            total_improvement = 0\n            for neighbor in neighbors:\n                current_edge1 = distance_matrix_1[neighbor, new_solution[k]]\n                current_edge2 = distance_matrix_2[neighbor, new_solution[k]]\n                new_edge1 = distance_matrix_1[neighbor, candidate]\n                new_edge2 = distance_matrix_2[neighbor, candidate]\n                improvement1 = current_edge1 - new_edge1\n                improvement2 = current_edge2 - new_edge2\n                if improvement1 > 0 and improvement2 > 0:\n                    total_improvement += (improvement1 + improvement2)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_node = candidate\n\n        if best_node is not None:\n            new_solution[k] = best_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment reversal and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node insertion with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a hybrid local search combining adaptive segment inversion and intelligent node relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion with variable segment size\n        segment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+segment_size] = inverted_segment\n\n        # Intelligent node relocation based on distance matrices\n        if random.random() < 0.6:\n            i = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            # Find best insertion position based on both objectives\n            min_cost = float('inf')\n            best_pos = i\n            for j in range(n):\n                if j != i and j != (i + 1) % n and j != (i - 1) % n:\n                    temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n                    cost1 = distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                    cost2 = distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                    for k in range(n - 1):\n                        cost1 += distance_matrix_1[temp_sol[k], temp_sol[k+1]]\n                        cost2 += distance_matrix_2[temp_sol[k], temp_sol[k+1]]\n                    total_cost = cost1 + cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_pos = j\n            if best_pos != i:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8758029585737553,
            0.5096401572227478
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion with variable segment size\n        segment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+segment_size] = inverted_segment\n\n        # Intelligent node relocation based on distance matrices\n        if random.random() < 0.6:\n            i = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            # Find best insertion position based on both objectives\n            min_cost = float('inf')\n            best_pos = i\n            for j in range(n):\n                if j != i and j != (i + 1) % n and j != (i - 1) % n:\n                    temp_sol = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n                    cost1 = distance_matrix_1[temp_sol[-1], temp_sol[0]]\n                    cost2 = distance_matrix_2[temp_sol[-1], temp_sol[0]]\n                    for k in range(n - 1):\n                        cost1 += distance_matrix_1[temp_sol[k], temp_sol[k+1]]\n                        cost2 += distance_matrix_2[temp_sol[k], temp_sol[k+1]]\n                    total_cost = cost1 + cost2\n                    if total_cost < min_cost:\n                        min_cost = total_cost\n                        best_pos = j\n            if best_pos != i:\n                new_solution = np.concatenate([new_solution[:i], new_solution[i+1:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion with higher probability\n        if random.random() < 0.85:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution diversity, then applies a novel hybrid local search combining segment reversal and adaptive node swapping to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with higher probability for better solutions in a weighted manner\n        weighted_scores = []\n        for sol, obj in archive:\n            weighted_score = 0.6 * obj[0] + 0.4 * obj[1]  # Weighted combination of objectives\n            weighted_scores.append(weighted_score)\n        min_score = min(weighted_scores)\n        max_score = max(weighted_scores)\n        normalized_scores = [(max_score - score) / (max_score - min_score + 1e-6) for score in weighted_scores]\n        selected = random.choices(archive, weights=normalized_scores)[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node swapping with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n - 1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9037715423443651,
            0.2555839419364929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions with higher probability for better solutions in a weighted manner\n        weighted_scores = []\n        for sol, obj in archive:\n            weighted_score = 0.6 * obj[0] + 0.4 * obj[1]  # Weighted combination of objectives\n            weighted_scores.append(weighted_score)\n        min_score = min(weighted_scores)\n        max_score = max(weighted_scores)\n        normalized_scores = [(max_score - score) / (max_score - min_score + 1e-6) for score in weighted_scores]\n        selected = random.choices(archive, weights=normalized_scores)[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(2, min(5, n // 3))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node swapping with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while abs(i - j) <= 1:\n                j = random.randint(0, n - 1)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This new algorithm selects a solution from the archive based on a weighted combination of objective values and diversity, then applies a hybrid local search combining adaptive segment reversal, probabilistic edge swapping, and guided node insertion to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / (np.sum(objectives, axis=0) + 1e-6)\n        selection_weights = np.exp(-np.sum(normalized, axis=1))\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        seg_size = max(2, min(4, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        # Probabilistic edge swapping\n        for _ in range(n // 2):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if abs(i - j) > 1:\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.15 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Guided node insertion\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n-1):\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                combined_cost = cost1 + cost2\n                if combined_cost < min_cost:\n                    min_cost = combined_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.934961718844207,
            0.3995254635810852
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / (np.sum(objectives, axis=0) + 1e-6)\n        selection_weights = np.exp(-np.sum(normalized, axis=1))\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment reversal\n        seg_size = max(2, min(4, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        new_solution[a:a+seg_size] = new_solution[a:a+seg_size][::-1]\n\n        # Probabilistic edge swapping\n        for _ in range(n // 2):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if abs(i - j) > 1:\n                current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n                swapped_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n                swapped_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n                if (swapped_cost1 < current_cost1 and swapped_cost2 < current_cost2) or \\\n                   (np.random.rand() < 0.15 and (swapped_cost1 <= current_cost1 or swapped_cost2 <= current_cost2)):\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Guided node insertion\n        if np.random.rand() < 0.4:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            best_pos = 0\n            min_cost = float('inf')\n            for pos in range(n-1):\n                cost1 = distance_matrix_1[new_solution[pos-1], node] + distance_matrix_1[node, new_solution[pos]]\n                cost2 = distance_matrix_2[new_solution[pos-1], node] + distance_matrix_2[node, new_solution[pos]]\n                combined_cost = cost1 + cost2\n                if combined_cost < min_cost:\n                    min_cost = combined_cost\n                    best_pos = pos\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment reversal and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node insertion with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment reversal and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node insertion with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7727349362097734,
            0.2183680534362793
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment reversal with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        reversed_segment = segment[::-1]\n        new_solution[start:start+segment_size] = reversed_segment\n\n        # Adaptive node insertion with higher probability\n        if random.random() < 0.75:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective quality and structural diversity, then applies a novel hybrid local search combining adaptive segment swapping, guided node relocation, and probabilistic edge contraction to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on quality and structural diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_scores = np.exp(-np.sum(objectives, axis=1))\n        diversity_scores = np.zeros(len(archive))\n\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                diff = np.sum(archive[i][0] != archive[j][0])\n                diversity_scores[i] += diff\n                diversity_scores[j] += diff\n\n        combined_scores = quality_scores * (1 + diversity_scores)\n        combined_scores = combined_scores / np.sum(combined_scores)\n        selected_idx = np.random.choice(len(archive), p=combined_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment swapping\n        seg_size = random.randint(2, min(5, n // 3))\n        a = random.randint(0, n - seg_size)\n        b = random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided node relocation\n        for _ in range(min(3, n // 2)):\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n\n            node = new_solution[i]\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], node] + distance_matrix_1[node, new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], node] + distance_matrix_2[node, new_solution[(j+1)%n]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (random.random() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Probabilistic edge contraction\n        if random.random() < 0.5:\n            i = random.randint(0, n - 2)\n            j = i + 1\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            contracted_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            contracted_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            if (contracted_cost1 < current_cost1 and contracted_cost2 < current_cost2) or (random.random() < 0.3 and (contracted_cost1 <= current_cost1 or contracted_cost2 <= current_cost2)):\n                new_solution = np.delete(new_solution, j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8894539975007596,
            1.1656782627105713
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on quality and structural diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_scores = np.exp(-np.sum(objectives, axis=1))\n        diversity_scores = np.zeros(len(archive))\n\n        for i in range(len(archive)):\n            for j in range(i+1, len(archive)):\n                diff = np.sum(archive[i][0] != archive[j][0])\n                diversity_scores[i] += diff\n                diversity_scores[j] += diff\n\n        combined_scores = quality_scores * (1 + diversity_scores)\n        combined_scores = combined_scores / np.sum(combined_scores)\n        selected_idx = np.random.choice(len(archive), p=combined_scores)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment swapping\n        seg_size = random.randint(2, min(5, n // 3))\n        a = random.randint(0, n - seg_size)\n        b = random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided node relocation\n        for _ in range(min(3, n // 2)):\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n\n            node = new_solution[i]\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], node] + distance_matrix_1[node, new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], node] + distance_matrix_2[node, new_solution[(j+1)%n]]\n\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or (random.random() < 0.4 and (new_cost1 <= current_cost1 or new_cost2 <= current_cost2)):\n                new_solution = np.delete(new_solution, i)\n                new_solution = np.insert(new_solution, j, node)\n\n        # Probabilistic edge contraction\n        if random.random() < 0.5:\n            i = random.randint(0, n - 2)\n            j = i + 1\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            contracted_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n            contracted_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n            if (contracted_cost1 < current_cost1 and contracted_cost2 < current_cost2) or (random.random() < 0.3 and (contracted_cost1 <= current_cost1 or contracted_cost2 <= current_cost2)):\n                new_solution = np.delete(new_solution, j)\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{This algorithm selects a solution from the archive based on a normalized objective score and applies a hybrid local search combining dynamic segment insertion and adaptive node rotation to generate a neighbor solution while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives and select based on combined score\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        scores = np.sum(normalized, axis=1)\n        selected = archive[np.argmin(scores)]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic segment insertion\n        if random.random() < 0.5:\n            seg_length = random.randint(2, min(4, n // 2))\n            start = random.randint(0, n - seg_length - 1)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:], segment])\n\n        # Adaptive node rotation\n        if random.random() < 0.7:\n            k = random.randint(2, min(4, n // 2))\n            indices = random.sample(range(n), k)\n            temp = new_solution[indices]\n            new_solution[indices] = np.roll(temp, random.randint(1, k-1))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7982237466660145,
            0.3848208785057068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Normalize objectives and select based on combined score\n        objectives = np.array([x[1] for x in archive])\n        normalized = (objectives - np.min(objectives, axis=0)) / (np.max(objectives, axis=0) - np.min(objectives, axis=0) + 1e-8)\n        scores = np.sum(normalized, axis=1)\n        selected = archive[np.argmin(scores)]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Dynamic segment insertion\n        if random.random() < 0.5:\n            seg_length = random.randint(2, min(4, n // 2))\n            start = random.randint(0, n - seg_length - 1)\n            segment = new_solution[start:start+seg_length]\n            new_solution = np.concatenate([new_solution[:start], new_solution[start+seg_length:], segment])\n\n        # Adaptive node rotation\n        if random.random() < 0.7:\n            k = random.randint(2, min(4, n // 2))\n            indices = random.sample(range(n), k)\n            temp = new_solution[indices]\n            new_solution[indices] = np.roll(temp, random.randint(1, k-1))\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions\n            selected = random.choice(non_dominated)\n        else:\n            # If no non-dominated, select randomly from top 50%\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 2)]\n            selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation\n        segment_size = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion\n        if random.random() < 0.7:  # Higher probability for edge insertion\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{This algorithm selects a solution from the archive based on a novel combination of objective diversity and spatial clustering, then applies a hybrid local search strategy that combines adaptive segment inversion with guided node relocation, ensuring feasibility while exploring both objective spaces for potential improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on objective diversity and spatial clustering\n        objectives = np.array([obj for _, obj in archive])\n        centroid = np.mean(objectives, axis=0)\n        distances = np.linalg.norm(objectives - centroid, axis=1)\n        selection_weights = distances / np.sum(distances)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion\n        seg_size = random.randint(2, min(6, n // 2))\n        start = random.randint(0, n - seg_size)\n        segment = new_solution[start:start+seg_size]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+seg_size] = inverted_segment\n\n        # Guided node relocation\n        for _ in range(2):\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Check improvement in both objectives\n            if i > 0 and j > 0:\n                prev_i = (i - 1) % n\n                next_i = (i + 1) % n\n                prev_j = (j - 1) % n\n                next_j = (j + 1) % n\n\n                old_cost1 = (distance_matrix_1[new_solution[prev_i], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[next_i]] +\n                            distance_matrix_1[new_solution[prev_j], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[next_j]])\n\n                new_cost1 = (distance_matrix_1[new_solution[prev_j], node] +\n                            distance_matrix_1[node, new_solution[next_j]] +\n                            distance_matrix_1[new_solution[prev_i], new_solution[next_i]])\n\n                old_cost2 = (distance_matrix_2[new_solution[prev_i], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[next_i]] +\n                            distance_matrix_2[new_solution[prev_j], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[next_j]])\n\n                new_cost2 = (distance_matrix_2[new_solution[prev_j], node] +\n                            distance_matrix_2[node, new_solution[next_j]] +\n                            distance_matrix_2[new_solution[prev_i], new_solution[next_i]])\n\n                if (new_cost1 > old_cost1 and new_cost2 > old_cost2):\n                    new_solution = np.delete(new_solution, j)\n                    new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8140672841987882,
            0.3504106402397156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Select based on objective diversity and spatial clustering\n        objectives = np.array([obj for _, obj in archive])\n        centroid = np.mean(objectives, axis=0)\n        distances = np.linalg.norm(objectives - centroid, axis=1)\n        selection_weights = distances / np.sum(distances)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment inversion\n        seg_size = random.randint(2, min(6, n // 2))\n        start = random.randint(0, n - seg_size)\n        segment = new_solution[start:start+seg_size]\n        inverted_segment = segment[::-1]\n        new_solution[start:start+seg_size] = inverted_segment\n\n        # Guided node relocation\n        for _ in range(2):\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n\n            node = new_solution[i]\n            new_solution = np.delete(new_solution, i)\n            new_solution = np.insert(new_solution, j, node)\n\n            # Check improvement in both objectives\n            if i > 0 and j > 0:\n                prev_i = (i - 1) % n\n                next_i = (i + 1) % n\n                prev_j = (j - 1) % n\n                next_j = (j + 1) % n\n\n                old_cost1 = (distance_matrix_1[new_solution[prev_i], new_solution[i]] +\n                            distance_matrix_1[new_solution[i], new_solution[next_i]] +\n                            distance_matrix_1[new_solution[prev_j], new_solution[j]] +\n                            distance_matrix_1[new_solution[j], new_solution[next_j]])\n\n                new_cost1 = (distance_matrix_1[new_solution[prev_j], node] +\n                            distance_matrix_1[node, new_solution[next_j]] +\n                            distance_matrix_1[new_solution[prev_i], new_solution[next_i]])\n\n                old_cost2 = (distance_matrix_2[new_solution[prev_i], new_solution[i]] +\n                            distance_matrix_2[new_solution[i], new_solution[next_i]] +\n                            distance_matrix_2[new_solution[prev_j], new_solution[j]] +\n                            distance_matrix_2[new_solution[j], new_solution[next_j]])\n\n                new_cost2 = (distance_matrix_2[new_solution[prev_j], node] +\n                            distance_matrix_2[node, new_solution[next_j]] +\n                            distance_matrix_2[new_solution[prev_i], new_solution[next_i]])\n\n                if (new_cost1 > old_cost1 and new_cost2 > old_cost2):\n                    new_solution = np.delete(new_solution, j)\n                    new_solution = np.insert(new_solution, i, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive segment reversal with guided node relinking to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with guided selection\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Guided segment reversal based on combined distance improvement\n    current_cost = (distance_matrix_1[new_solution[start], new_solution[start-1]] +\n                    distance_matrix_1[new_solution[end-1], new_solution[end%len(new_solution)]] +\n                    distance_matrix_2[new_solution[start], new_solution[start-1]] +\n                    distance_matrix_2[new_solution[end-1], new_solution[end%len(new_solution)]])\n\n    reversed_cost = (distance_matrix_1[new_solution[start], new_solution[end-1]] +\n                     distance_matrix_1[new_solution[start-1], new_solution[end%len(new_solution)]] +\n                     distance_matrix_2[new_solution[start], new_solution[end-1]] +\n                     distance_matrix_2[new_solution[start-1], new_solution[end%len(new_solution)]])\n\n    if reversed_cost < current_cost:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided node relinking with position selection\n    if n > 4 and np.random.random() < 0.6:\n        node_to_move = new_solution[np.random.randint(0, n)]\n        new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n        best_pos = None\n        min_cost = float('inf')\n\n        for pos in range(n):\n            temp_solution = np.concatenate([new_solution[:pos], [node_to_move], new_solution[pos:]])\n            cost = (distance_matrix_1[temp_solution[pos-1], node_to_move] +\n                    distance_matrix_1[node_to_move, temp_solution[(pos+1)%n]] +\n                    distance_matrix_2[temp_solution[pos-1], node_to_move] +\n                    distance_matrix_2[node_to_move, temp_solution[(pos+1)%n]])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6583500991814895,
            0.5921830534934998
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment reversal with guided selection\n    segment_length = min(6, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Guided segment reversal based on combined distance improvement\n    current_cost = (distance_matrix_1[new_solution[start], new_solution[start-1]] +\n                    distance_matrix_1[new_solution[end-1], new_solution[end%len(new_solution)]] +\n                    distance_matrix_2[new_solution[start], new_solution[start-1]] +\n                    distance_matrix_2[new_solution[end-1], new_solution[end%len(new_solution)]])\n\n    reversed_cost = (distance_matrix_1[new_solution[start], new_solution[end-1]] +\n                     distance_matrix_1[new_solution[start-1], new_solution[end%len(new_solution)]] +\n                     distance_matrix_2[new_solution[start], new_solution[end-1]] +\n                     distance_matrix_2[new_solution[start-1], new_solution[end%len(new_solution)]])\n\n    if reversed_cost < current_cost:\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided node relinking with position selection\n    if n > 4 and np.random.random() < 0.6:\n        node_to_move = new_solution[np.random.randint(0, n)]\n        new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n        best_pos = None\n        min_cost = float('inf')\n\n        for pos in range(n):\n            temp_solution = np.concatenate([new_solution[:pos], [node_to_move], new_solution[pos:]])\n            cost = (distance_matrix_1[temp_solution[pos-1], node_to_move] +\n                    distance_matrix_1[node_to_move, temp_solution[(pos+1)%n]] +\n                    distance_matrix_2[temp_solution[pos-1], node_to_move] +\n                    distance_matrix_2[node_to_move, temp_solution[(pos+1)%n]])\n\n            if cost < min_cost:\n                min_cost = cost\n                best_pos = pos\n\n        if best_pos is not None:\n            new_solution = np.concatenate([new_solution[:best_pos], [node_to_move], new_solution[best_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective dominance and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive edge insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions that are non-dominated in either objective\n        non_dominated = []\n        for i, (sol_i, obj_i) in enumerate(archive):\n            dominated = False\n            for j, (sol_j, obj_j) in enumerate(archive):\n                if i != j and (obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1]) and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                    dominated = True\n                    break\n            if not dominated:\n                non_dominated.append((sol_i, obj_i))\n\n        if non_dominated:\n            # Randomly select from non-dominated solutions with higher probability for better solutions\n            sorted_non_dominated = sorted(non_dominated, key=lambda x: sum(x[1]))\n            selected = random.choices(sorted_non_dominated, weights=[1/(i+1) for i in range(len(sorted_non_dominated))])[0]\n        else:\n            # If no non-dominated, select from top 30% with higher probability for better solutions\n            sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n            top_solutions = sorted_archive[:max(1, len(sorted_archive) // 3)]\n            selected = random.choices(top_solutions, weights=[1/(i+1) for i in range(len(top_solutions))])[0]\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with larger segments\n        segment_size = random.randint(3, min(7, n // 2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        rotation = random.randint(1, segment_size - 1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[start:start+segment_size] = rotated_segment\n\n        # Adaptive edge insertion with higher probability\n        if random.random() < 0.85:\n            i = random.randint(0, n - 1)\n            j = random.randint(0, n - 1)\n            while j == i or j == (i + 1) % n or j == (i - 1) % n:\n                j = random.randint(0, n - 1)\n            node_to_move = new_solution[i]\n            new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective diversity and solution quality, then applies a novel hybrid local search combining segment inversion with adaptive node swapping and guided edge perturbation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n\n    for i, (sol_i, _) in enumerate(archive):\n        diversity = 0\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(sol_i != sol_j)\n        diversity_scores[i] = diversity\n\n    normalized_diversity = diversity_scores / (diversity_scores.max() + 1e-8)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.4 * normalized_diversity + 0.3 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    if np.random.random() < 0.7:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.random() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8793016794974171,
            1.9726929068565369
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    diversity_scores = np.zeros(len(archive))\n\n    for i, (sol_i, _) in enumerate(archive):\n        diversity = 0\n        for j, (sol_j, _) in enumerate(archive):\n            if i != j:\n                diversity += np.sum(sol_i != sol_j)\n        diversity_scores[i] = diversity\n\n    normalized_diversity = diversity_scores / (diversity_scores.max() + 1e-8)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.4 * normalized_diversity + 0.3 * normalized_obj[:, 0] + 0.3 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=combined_scores / combined_scores.sum())\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    if np.random.random() < 0.7:\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    if np.random.random() < 0.5:\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = np.random.randint(0, n)\n        node_to_move = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{The new algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a hybrid local search combining adaptive segment rotation with guided edge swapping to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.array([np.sum(np.abs(objectives - obj)) for obj in objectives])\n    combined_scores = 0.7 * normalized_obj[:, 0] + 0.3 * diversity_scores\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Adaptive segment rotation\n    segment_length = min(4, n // 3)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    rotation = np.random.randint(1, segment_length)\n    new_solution[start:end] = np.roll(new_solution[start:end], rotation)\n\n    # Step 2: Guided edge swapping\n    i = np.random.randint(0, n - 1)\n    j = np.random.randint(i + 1, n)\n    if (distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) > \\\n       (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]):\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if rotation breaks the tour\n        new_solution = base_solution.copy()\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while j == i:\n            j = np.random.randint(0, n)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm intelligently selects a solution from the archive based on both objective quality and diversity, then applies a novel hybrid local search combining adaptive segment rotation, guided edge reversal, and probabilistic node insertion to generate high-quality neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select solutions based on both quality and diversity\n        objectives = np.array([obj for _, obj in archive])\n        quality_weights = np.exp(-np.sum(objectives, axis=1))\n        quality_weights = quality_weights / np.sum(quality_weights)\n        selected_idx = np.random.choice(len(archive), p=quality_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment rotation\n        seg_size = max(3, min(7, n // 4))\n        a = np.random.randint(0, n - seg_size)\n        segment = new_solution[a:a+seg_size]\n\n        # Rotate segment by random amount\n        rot_amount = np.random.randint(1, seg_size)\n        rotated_segment = np.roll(segment, rot_amount)\n        new_solution[a:a+seg_size] = rotated_segment\n\n        # Guided edge reversal\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            # Reverse the edge\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.3 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node insertion\n        if np.random.rand() < 0.2:\n            node = np.random.choice(new_solution)\n            pos = np.random.randint(0, n)\n            new_solution = np.delete(new_solution, np.where(new_solution == node)[0][0])\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and structural diversity, then applies a novel hybrid local search combining adaptive node clustering with guided path inversion and probabilistic segment reversal to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate structural diversity (difference in node ordering)\n    structural_diversity = []\n    for sol, _ in archive:\n        diff = 0\n        for i in range(len(sol)):\n            pos_in_base = np.where(archive[0][0] == sol[i])[0][0]\n            diff += abs(i - pos_in_base)\n        structural_diversity.append(diff)\n    structural_diversity = np.array(structural_diversity)\n\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * (structural_diversity / np.max(structural_diversity + 1e-8))\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering and path inversion\n    cluster_size = max(3, min(5, n // 5))\n    start = np.random.randint(0, n - cluster_size)\n    cluster = new_solution[start:start+cluster_size]\n\n    # Calculate cluster quality\n    cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n    cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n\n    # Invert cluster with probability based on quality\n    if np.random.rand() < 0.4 or (cluster_cost1 > np.median(distance_matrix_1) and cluster_cost2 > np.median(distance_matrix_2)):\n        new_solution[start:start+cluster_size] = cluster[::-1]\n\n    # Probabilistic segment reversal\n    if np.random.rand() < 0.3:\n        seg_length = np.random.randint(2, min(6, n//2))\n        a = np.random.randint(0, n - seg_length)\n        segment = new_solution[a:a+seg_length]\n\n        # Reverse segment if it improves at least one objective\n        current_cost1 = sum(distance_matrix_1[new_solution[(a+i-1)%n], new_solution[a+i]] for i in range(seg_length))\n        current_cost2 = sum(distance_matrix_2[new_solution[(a+i-1)%n], new_solution[a+i]] for i in range(seg_length))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[(a+i-1)%n], new_solution[a+seg_length-1-i]] for i in range(seg_length))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[(a+i-1)%n], new_solution[a+seg_length-1-i]] for i in range(seg_length))\n\n        if (reversed_cost1 < current_cost1 or reversed_cost2 < current_cost2):\n            new_solution[a:a+seg_length] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if operation breaks tour\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9527701544344453,
            2.147747218608856
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on combined objective and structural diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n\n    # Calculate structural diversity (difference in node ordering)\n    structural_diversity = []\n    for sol, _ in archive:\n        diff = 0\n        for i in range(len(sol)):\n            pos_in_base = np.where(archive[0][0] == sol[i])[0][0]\n            diff += abs(i - pos_in_base)\n        structural_diversity.append(diff)\n    structural_diversity = np.array(structural_diversity)\n\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * (structural_diversity / np.max(structural_diversity + 1e-8))\n    selected_idx = np.random.choice(len(archive), p=combined_scores / np.sum(combined_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering and path inversion\n    cluster_size = max(3, min(5, n // 5))\n    start = np.random.randint(0, n - cluster_size)\n    cluster = new_solution[start:start+cluster_size]\n\n    # Calculate cluster quality\n    cluster_cost1 = sum(distance_matrix_1[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n    cluster_cost2 = sum(distance_matrix_2[cluster[i], cluster[(i+1)%cluster_size]] for i in range(cluster_size))\n\n    # Invert cluster with probability based on quality\n    if np.random.rand() < 0.4 or (cluster_cost1 > np.median(distance_matrix_1) and cluster_cost2 > np.median(distance_matrix_2)):\n        new_solution[start:start+cluster_size] = cluster[::-1]\n\n    # Probabilistic segment reversal\n    if np.random.rand() < 0.3:\n        seg_length = np.random.randint(2, min(6, n//2))\n        a = np.random.randint(0, n - seg_length)\n        segment = new_solution[a:a+seg_length]\n\n        # Reverse segment if it improves at least one objective\n        current_cost1 = sum(distance_matrix_1[new_solution[(a+i-1)%n], new_solution[a+i]] for i in range(seg_length))\n        current_cost2 = sum(distance_matrix_2[new_solution[(a+i-1)%n], new_solution[a+i]] for i in range(seg_length))\n\n        reversed_cost1 = sum(distance_matrix_1[new_solution[(a+i-1)%n], new_solution[a+seg_length-1-i]] for i in range(seg_length))\n        reversed_cost2 = sum(distance_matrix_2[new_solution[(a+i-1)%n], new_solution[a+seg_length-1-i]] for i in range(seg_length))\n\n        if (reversed_cost1 < current_cost1 or reversed_cost2 < current_cost2):\n            new_solution[a:a+seg_length] = segment[::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if operation breaks tour\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a weighted combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive node swapping and segment reversal to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on weighted objective combination\n        weights = np.random.uniform(0.3, 0.7)\n        ranked_solutions = sorted(archive, key=lambda x: weights * x[1][0] + (1 - weights) * x[1][1])\n        top_solutions = ranked_solutions[:max(1, len(ranked_solutions) // 3)]\n        selected = random.choice(top_solutions)\n    else:\n        selected = archive[0]\n\n    base_solution = selected[0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive node swapping\n        swap_size = random.randint(1, min(3, n // 3))\n        indices = random.sample(range(n), swap_size * 2)\n        for i in range(0, swap_size * 2, 2):\n            new_solution[indices[i]], new_solution[indices[i+1]] = new_solution[indices[i+1]], new_solution[indices[i]]\n\n        # Segment reversal\n        if random.random() < 0.6:\n            start = random.randint(0, n - 3)\n            end = random.randint(start + 2, min(n - 1, start + 5))\n            new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining adaptive segment reordering and dynamic node repositioning to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment reordering\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Dynamic node repositioning\n        if np.random.random() < 0.8:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.648195435894652,
            0.17624229192733765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.4, 0.6)\n    scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive segment reordering\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        np.random.shuffle(segment)\n        new_solution[start:end] = segment\n\n        # Dynamic node repositioning\n        if np.random.random() < 0.8:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a high-quality solution from the archive using a novel combination of objective-based selection, adaptive segment swapping, and guided edge reversal with probabilistic node reinsertion to create diverse high-quality neighbors while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if len(archive) > 1:\n        # Select based on normalized objective values and diversity\n        objectives = np.array([obj for _, obj in archive])\n        normalized = objectives / np.sum(objectives, axis=0)\n        selection_weights = 1 / (np.sum(normalized, axis=1) + 1e-6)\n        selection_weights = selection_weights / np.sum(selection_weights)\n        selected_idx = np.random.choice(len(archive), p=selection_weights)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive segment swapping\n        seg_size = max(2, min(5, n // 3))\n        a = np.random.randint(0, n - seg_size)\n        b = np.random.randint(0, n - seg_size)\n        while abs(a - b) < seg_size:\n            b = np.random.randint(0, n - seg_size)\n\n        segment_a = new_solution[a:a+seg_size]\n        segment_b = new_solution[b:b+seg_size]\n        new_solution[a:a+seg_size] = segment_b\n        new_solution[b:b+seg_size] = segment_a\n\n        # Guided edge reversal with probabilistic acceptance\n        for i in range(n):\n            j = (i + 1) % n\n            k = (i + 2) % n\n\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[k]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[k]]\n\n            reversed_cost1 = distance_matrix_1[new_solution[i], new_solution[k]] + distance_matrix_1[new_solution[k], new_solution[j]]\n            reversed_cost2 = distance_matrix_2[new_solution[i], new_solution[k]] + distance_matrix_2[new_solution[k], new_solution[j]]\n\n            if (reversed_cost1 < current_cost1 and reversed_cost2 < current_cost2) or \\\n               (np.random.rand() < 0.25 and (reversed_cost1 <= current_cost1 or reversed_cost2 <= current_cost2)):\n                new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n        # Probabilistic node reinsertion\n        if np.random.rand() < 0.3:\n            node_pos = np.random.randint(0, n)\n            node = new_solution[node_pos]\n            new_solution = np.delete(new_solution, node_pos)\n            insert_pos = np.random.randint(0, n-1)\n            new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid approach combining Pareto-dominance based selection, adaptive path relinking with guided edge insertion, and probabilistic segment inversion to generate high-quality neighbors while ensuring feasibility through careful validity checks.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        dominated = np.zeros(len(archive), dtype=bool)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                    dominated[i] = True\n                    break\n        non_dominated = np.where(~dominated)[0]\n        if len(non_dominated) > 0:\n            selected_idx = np.random.choice(non_dominated)\n        else:\n            # If no non-dominated solutions, select based on crowding distance\n            crowding = np.zeros(len(archive))\n            sorted_indices = np.argsort(objectives[:, 0])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n            sorted_indices = np.argsort(objectives[:, 1])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n            selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive path relinking with guided edge insertion\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while abs(a - b) < 2:\n            b = np.random.randint(0, n)\n\n        # Find the shortest path between a and b in the base solution\n        start = min(a, b)\n        end = max(a, b)\n        segment = new_solution[start:end+1]\n\n        # Insert this segment elsewhere in the tour\n        insert_pos = np.random.randint(0, n)\n        while insert_pos == start or insert_pos == end:\n            insert_pos = np.random.randint(0, n)\n\n        if insert_pos < start:\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end+1:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Probabilistic segment inversion\n        if np.random.rand() < 0.4:\n            seg_start = np.random.randint(0, n)\n            seg_length = np.random.randint(2, min(6, n//2))\n            seg_end = (seg_start + seg_length) % n\n            if seg_start < seg_end:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                new_solution[seg_start:] = new_solution[seg_start:][::-1]\n                new_solution[:seg_end] = new_solution[:seg_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.878745899056547,
            0.6694232821464539
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        objectives = np.array([obj for _, obj in archive])\n        dominated = np.zeros(len(archive), dtype=bool)\n        for i in range(len(archive)):\n            for j in range(len(archive)):\n                if i != j and (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                    dominated[i] = True\n                    break\n        non_dominated = np.where(~dominated)[0]\n        if len(non_dominated) > 0:\n            selected_idx = np.random.choice(non_dominated)\n        else:\n            # If no non-dominated solutions, select based on crowding distance\n            crowding = np.zeros(len(archive))\n            sorted_indices = np.argsort(objectives[:, 0])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 0] - objectives[sorted_indices[i-1], 0]) / (objectives[sorted_indices[-1], 0] - objectives[sorted_indices[0], 0])\n            sorted_indices = np.argsort(objectives[:, 1])\n            crowding[sorted_indices[0]] = crowding[sorted_indices[-1]] = np.inf\n            for i in range(1, len(archive)-1):\n                crowding[sorted_indices[i]] += (objectives[sorted_indices[i+1], 1] - objectives[sorted_indices[i-1], 1]) / (objectives[sorted_indices[-1], 1] - objectives[sorted_indices[0], 1])\n            selected_idx = np.argmax(crowding)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        # Adaptive path relinking with guided edge insertion\n        a = np.random.randint(0, n)\n        b = np.random.randint(0, n)\n        while abs(a - b) < 2:\n            b = np.random.randint(0, n)\n\n        # Find the shortest path between a and b in the base solution\n        start = min(a, b)\n        end = max(a, b)\n        segment = new_solution[start:end+1]\n\n        # Insert this segment elsewhere in the tour\n        insert_pos = np.random.randint(0, n)\n        while insert_pos == start or insert_pos == end:\n            insert_pos = np.random.randint(0, n)\n\n        if insert_pos < start:\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:start], new_solution[end+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:start], new_solution[end+1:insert_pos], segment, new_solution[insert_pos:]])\n\n        # Probabilistic segment inversion\n        if np.random.rand() < 0.4:\n            seg_start = np.random.randint(0, n)\n            seg_length = np.random.randint(2, min(6, n//2))\n            seg_end = (seg_start + seg_length) % n\n            if seg_start < seg_end:\n                new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n            else:\n                new_solution[seg_start:] = new_solution[seg_start:][::-1]\n                new_solution[:seg_end] = new_solution[:seg_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This algorithm selects a solution from the archive based on a combination of objective values and solution quality, then applies a novel hybrid local search combining segment rotation and adaptive node insertion to generate a neighbor solution while ensuring feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Segment rotation with adaptive rotation angle\n        segment_length = min(5, n // 2)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        rotation_angle = np.random.randint(1, segment_length)\n        segment = new_solution[start:end]\n        rotated_segment = np.roll(segment, rotation_angle)\n        new_solution[start:end] = rotated_segment\n\n        # Adaptive node insertion with position selection\n        if np.random.random() < 0.7:\n            node_to_move = new_solution[np.random.randint(0, n)]\n            new_solution = np.concatenate([new_solution[new_solution != node_to_move], [node_to_move]])\n            insert_pos = np.random.randint(0, n)\n            new_solution = np.concatenate([new_solution[:insert_pos], [node_to_move], new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive based on a combination of objective values and diversity, then applies a novel hybrid local search combining edge inversion and adaptive segment relocation to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge inversion with adaptive segment selection\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Adaptive segment relocation\n        if np.random.random() < 0.6:\n            segment_length = min(3, n // 4)\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8393619481633331,
            0.31798332929611206
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on weighted objective combination and diversity\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.4 * normalized_obj[:, 0] + 0.6 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Edge inversion with adaptive segment selection\n        segment_length = min(4, n // 3)\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n        segment = new_solution[start:end]\n        new_solution[start:end] = segment[::-1]\n\n        # Adaptive segment relocation\n        if np.random.random() < 0.6:\n            segment_length = min(3, n // 4)\n            start = np.random.randint(0, n - segment_length)\n            end = start + segment_length\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([new_solution[:start], new_solution[end:]])\n            insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n            new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive using a weighted score combining normalized objective values and solution diversity, then applies a hybrid local search with adaptive segment reversal and guided node repositioning with different parameter settings to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = 0.5 * normalized_obj[:, 0] + 0.5 * normalized_obj[:, 1]\n    selected_idx = np.random.choice(len(archive), p=scores / scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    segment_length = min(5, n // 2)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n    new_solution[start:end] = new_solution[start:end][::-1]\n\n    i = np.random.randint(0, n)\n    j = np.random.randint(0, n)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j], [node_to_move], new_solution[j:]])\n\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search operator that combines a dynamic segment relocation with a Pareto-guided edge replacement strategy to generate diverse high-quality neighbors while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n <= 3:\n        return new_solution\n\n    # Dynamic segment relocation\n    seg_size = max(2, min(4, n // 4))\n    a = np.random.randint(0, n - seg_size)\n    b = a + seg_size - 1\n    segment = new_solution[a:b+1]\n\n    # Insert segment at a new position\n    new_pos = np.random.randint(0, n - seg_size)\n    new_solution = np.concatenate([\n        new_solution[:new_pos],\n        segment,\n        new_solution[new_pos:a],\n        new_solution[b+1:]\n    ])\n\n    # Pareto-guided edge replacement\n    for i in range(n):\n        j = (i + 1) % n\n        k = (i + 2) % n\n\n        current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[k]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[k]]\n\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[j], new_solution[k] = new_solution[k], new_solution[j]\n\n    # Random edge flip for diversity\n    if np.random.rand() < 0.15:\n        p, q = np.random.choice(n, 2, replace=False)\n        if p > q:\n            p, q = q, p\n        new_solution[p:q+1] = np.flip(new_solution[p:q+1])\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 306,
        "algorithm": "{This algorithm selects a solution from the archive using a diversity-aware tournament selection that considers both objective values and solution structure, then applies a novel hybrid local search combining adaptive segment inversion with guided node insertion based on Pareto dominance and spatial proximity in both objective spaces to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware tournament selection\n    tournament_size = min(5, len(archive))\n    selected = np.random.choice(len(archive), tournament_size, replace=False)\n    selected_solutions = [archive[i][0] for i in selected]\n    selected_objectives = [archive[i][1] for i in selected]\n\n    # Calculate diversity scores based on node positions in both spaces\n    diversity_scores = []\n    for i in range(tournament_size):\n        sol = selected_solutions[i]\n        diversity = 0\n        for j in range(len(sol)):\n            node = sol[j]\n            coords = instance[node]\n            diversity += np.linalg.norm(coords[:2] - coords[2:])  # Distance between spaces\n        diversity_scores.append(diversity)\n\n    # Combine objective and diversity scores\n    objectives = np.array(selected_objectives)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * np.array(diversity_scores)\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = selected_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion with Pareto consideration\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Check if inversion improves Pareto front\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    inverted_segment = segment[::-1]\n    temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end:]])\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n       (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    # Guided node insertion based on spatial proximity\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n\n    # Find insertion position that minimizes both objectives\n    best_pos = i\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n):\n        if pos == i or pos == (i + 1) % n or pos == (i - 1) % n:\n            continue\n\n        temp_solution = np.concatenate([\n            new_solution[:i], new_solution[i+1:pos], [node_to_move], new_solution[pos:]\n        ])\n\n        cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or \\\n           (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_pos = pos\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    if best_pos != i:\n        new_solution = np.concatenate([\n            new_solution[:i], new_solution[i+1:best_pos], [node_to_move], new_solution[best_pos:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.8167980929249831,
            1.1214045286178589
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Diversity-aware tournament selection\n    tournament_size = min(5, len(archive))\n    selected = np.random.choice(len(archive), tournament_size, replace=False)\n    selected_solutions = [archive[i][0] for i in selected]\n    selected_objectives = [archive[i][1] for i in selected]\n\n    # Calculate diversity scores based on node positions in both spaces\n    diversity_scores = []\n    for i in range(tournament_size):\n        sol = selected_solutions[i]\n        diversity = 0\n        for j in range(len(sol)):\n            node = sol[j]\n            coords = instance[node]\n            diversity += np.linalg.norm(coords[:2] - coords[2:])  # Distance between spaces\n        diversity_scores.append(diversity)\n\n    # Combine objective and diversity scores\n    objectives = np.array(selected_objectives)\n    normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    combined_scores = 0.6 * normalized_obj[:, 0] + 0.4 * normalized_obj[:, 1] + 0.2 * np.array(diversity_scores)\n    selected_idx = np.argmax(combined_scores)\n\n    base_solution = selected_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion with Pareto consideration\n    segment_size = max(2, min(5, n // 3))\n    start = np.random.randint(0, n - segment_size)\n    end = start + segment_size\n    segment = new_solution[start:end]\n\n    # Check if inversion improves Pareto front\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    inverted_segment = segment[::-1]\n    temp_solution = np.concatenate([new_solution[:start], inverted_segment, new_solution[end:]])\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n       (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n        new_solution = temp_solution\n\n    # Guided node insertion based on spatial proximity\n    i = np.random.randint(0, n)\n    node_to_move = new_solution[i]\n\n    # Find insertion position that minimizes both objectives\n    best_pos = i\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n):\n        if pos == i or pos == (i + 1) % n or pos == (i - 1) % n:\n            continue\n\n        temp_solution = np.concatenate([\n            new_solution[:i], new_solution[i+1:pos], [node_to_move], new_solution[pos:]\n        ])\n\n        cost1 = sum(distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[j], temp_solution[(j+1)%n]] for j in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2) or \\\n           (cost1 <= best_cost1 and cost2 < best_cost2):\n            best_pos = pos\n            best_cost1 = cost1\n            best_cost2 = cost2\n\n    if best_pos != i:\n        new_solution = np.concatenate([\n            new_solution[:i], new_solution[i+1:best_pos], [node_to_move], new_solution[best_pos:]\n        ])\n\n    return new_solution\n\n"
    }
]