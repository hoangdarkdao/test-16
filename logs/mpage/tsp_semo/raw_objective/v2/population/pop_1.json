[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    import random\n\n    # Select a solution with good potential for improvement (e.g., not the best but not the worst)\n    if len(archive) > 2:\n        # Exclude the top 20% and bottom 20% to focus on middle-range solutions\n        sorted_archive = sorted(archive, key=lambda x: sum(x[1]))\n        start_idx = int(0.2 * len(sorted_archive))\n        end_idx = int(0.8 * len(sorted_archive))\n        selected_solution = random.choice(sorted_archive[start_idx:end_idx])[0].copy()\n    else:\n        selected_solution = random.choice(archive)[0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel segment-based perturbation\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Step 1: Randomly select 3 non-adjacent edges to perform a 3-opt move\n    a, b, c = sorted(random.sample(range(1, n-1), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Reconnect the segments in a new order\n    candidates = [\n        np.concatenate([segment1, segment3, segment2, segment4]),\n        np.concatenate([segment1, segment3[::-1], segment2, segment4]),\n        np.concatenate([segment1, segment2, segment3[::-1], segment4]),\n        np.concatenate([segment1, segment2[::-1], segment3, segment4]),\n        np.concatenate([segment1, segment2, segment3, segment4[::-1]]),\n        np.concatenate([segment1, segment2[::-1], segment3[::-1], segment4])\n    ]\n\n    # Evaluate all candidates based on both objectives\n    best_neighbor = None\n    best_score = float('inf')\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n        total_cost = cost1 + cost2\n\n        if total_cost < best_score:\n            best_score = total_cost\n            best_neighbor = candidate.copy()\n\n    # Step 2: Apply novel segment-based perturbation if 3-opt didn't improve\n    if best_neighbor is None or np.array_equal(best_neighbor, new_solution):\n        # Randomly select a segment and reverse it, then insert elsewhere\n        segment_size = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_size)\n        segment = new_solution[start:start+segment_size]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n        insert_pos = random.randint(0, len(remaining))\n        best_neighbor = np.concatenate([remaining[:insert_pos], segment[::-1], remaining[insert_pos:]])\n\n    return best_neighbor\n\n",
          "score": [
               6.711106193981905,
               5.67906101484736
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Step 2: Hybrid local search (edge insertion + node reordering)\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reorder\n    start = np.random.randint(0, n - 2)\n    end = np.random.randint(start + 1, n - 1)\n\n    # Reverse the segment (node reordering)\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Randomly insert a node elsewhere (edge insertion)\n    node_to_insert = new_solution[end]\n    new_solution = np.delete(new_solution, end)\n    insert_pos = np.random.randint(0, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    return new_solution\n\n",
          "score": [
               6.0500135980359975,
               6.09537249265896
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (high ratio of objective values)\n    objectives = np.array([obj for _, obj in archive])\n    ratios = objectives[:, 0] / (objectives[:, 1] + 1e-6)  # Avoid division by zero\n    selected_idx = np.argmax(ratios)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: Edge exchange followed by segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge exchange: Swap two edges if it improves both objectives\n    for _ in range(10):  # Limit attempts to avoid excessive computation\n        i, j = np.random.choice(n, 2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create candidate by swapping edges\n        candidate = new_solution.copy()\n        candidate[i:j+1] = candidate[i:j+1][::-1]  # Reverse segment\n\n        # Calculate new objectives\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n        # Accept if both objectives improve or one improves significantly\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n           (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n           (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n            new_solution = candidate\n            break\n\n    # Segment reversal: Reverse a random segment if it improves the solution\n    i, j = np.random.choice(n, 2, replace=False)\n    if i > j:\n        i, j = j, i\n    candidate = new_solution.copy()\n    candidate[i:j+1] = candidate[i:j+1][::-1]\n\n    # Calculate new objectives\n    old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n    old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n    # Accept if both objectives improve or one improves significantly\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or \\\n       (new_cost1 < old_cost1 * 0.95 and new_cost2 < old_cost2 * 1.05) or \\\n       (new_cost1 < old_cost1 * 1.05 and new_cost2 < old_cost2 * 0.95):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               7.938052437621909,
               4.974250410098344
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with the best Pareto front dominance or highest diversity\n    def dominance_score(sol_obj):\n        # Simple dominance score: higher if solution is better in both objectives\n        # or has higher diversity (sum of objectives)\n        return -(sol_obj[0] + sol_obj[1])  # Negative for minimization\n\n    # Select the solution with the highest score\n    selected_sol = max(archive, key=lambda x: dominance_score(x[1]))[0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = selected_sol.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: restricted 3-opt with dynamic edge exchange\n    for _ in range(5):  # Limit iterations to avoid excessive computation\n        # Select three random segments\n        i, j, k = sorted(np.random.choice(range(1, n-1), size=3, replace=False))\n\n        # Try different segment orderings to find improvement\n        for perm in [(i, j, k), (i, k, j), (j, i, k), (j, k, i), (k, i, j), (k, j, i)]:\n            # Create new solution with this permutation\n            temp_sol = new_solution.copy()\n            temp_sol[perm[0]:perm[1]] = np.flip(temp_sol[perm[0]:perm[1]])\n            temp_sol[perm[1]:perm[2]] = np.flip(temp_sol[perm[1]:perm[2]])\n\n            # Calculate new objectives\n            new_obj1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n            new_obj2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n\n            # Accept if better in at least one objective\n            current_obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n            current_obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n            if (new_obj1 < current_obj1) or (new_obj2 < current_obj2):\n                new_solution = temp_sol\n                break  # Move to next iteration with improved solution\n\n    # Dynamic edge exchange: swap edges based on their contribution to objectives\n    for _ in range(3):\n        # Select two random edges to swap\n        i = np.random.randint(1, n-2)\n        j = np.random.randint(i+1, n-1)\n\n        # Create candidate solution\n        temp_sol = new_solution.copy()\n        temp_sol[i], temp_sol[j] = temp_sol[j], temp_sol[i]\n\n        # Calculate new objectives\n        new_obj1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n        new_obj2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(len(temp_sol)))\n\n        # Accept if better in at least one objective\n        current_obj1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n        current_obj2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(len(new_solution)))\n\n        if (new_obj1 < current_obj1) or (new_obj2 < current_obj2):\n            new_solution = temp_sol\n\n    return new_solution\n\n",
          "score": [
               6.225234873057076,
               6.449669128850349
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    objectives = [obj for _, obj in archive]\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, other_obj in enumerate(objectives):\n            if i != j and (other_obj[0] <= obj[0] and other_obj[1] <= obj[1]) and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Step 2: Select a base solution with weighted randomness\n    weights = []\n    for sol, obj in non_dominated:\n        # Calculate diversity score (distance to other solutions)\n        diversity = 0.0\n        for other_sol, _ in non_dominated:\n            diversity += np.sum(sol != other_sol)\n        weights.append(1.0 / (1.0 + diversity))\n\n    weights = np.array(weights)\n    weights = weights / np.sum(weights)\n    selected_idx = np.random.choice(len(non_dominated), p=weights)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment size based on current objective values\n    obj1, obj2 = non_dominated[selected_idx][1]\n    max_obj = max(obj1, obj2)\n    segment_size = max(3, min(n // 2, int(n * (max_obj / (max_obj + 1)))))\n\n    # 3-opt with adaptive segment inversion\n    if n >= 3:\n        # Select random segment\n        start = np.random.randint(0, n - segment_size)\n        end = start + segment_size\n\n        # Apply adaptive inversion\n        if np.random.rand() < 0.7:  # Higher probability for inversion\n            new_solution[start:end] = new_solution[start:end][::-1]\n        else:\n            # Random swap within segment\n            i, j = np.random.choice(range(start, end), 2, replace=False)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If infeasible, revert to base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.950788573605236,
               6.759382533501396
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' first intelligently selects a promising solution from the archive by prioritizing those with objective values that are not dominated by others, ensuring diverse exploration. It then applies a hybrid local search strategy that combines edge insertion with a novel adaptive segment reversal, where segments of varying lengths are dynamically chosen based on the solution's current quality and the instance's structure. The segment reversal is guided by a combination of distance improvements in both objective spaces, with a probabilistic acceptance criterion to escape local optima. The function ensures feasibility by maintaining a valid tour structure throughout the operations, and returns the improved neighbor solution with minimized costs in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Filter non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Select a solution with probability inversely proportional to its objective values\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in non_dominated]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = np.random.choice(len(non_dominated), p=probabilities)\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Hybrid local search: Edge insertion + adaptive segment reversal\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Edge insertion\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], new_solution[i:i+1], new_solution[j+1:]])\n\n    # Adaptive segment reversal\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    reversed_segment = new_solution[start:end][::-1]\n    candidate = np.concatenate([new_solution[:start], reversed_segment, new_solution[end:]])\n\n    new_cost1 = sum(distance_matrix_1[candidate[i-1], candidate[i]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[candidate[i-1], candidate[i]] for i in range(n))\n\n    # Accept if improvement in at least one objective\n    if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n        new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.390271291741203,
               6.972964363171967
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify those with the best trade-offs between the two objectives using a non-dominated sorting approach, then selects a solution at random from the top 20% of non-dominated solutions. For local search, it employs a novel hybrid operator that combines a restricted 3-opt move with a segment inversion, where three randomly selected segments of the tour are rearranged in a way that prioritizes reducing the total path length in the objective space with the higher current cost, while ensuring feasibility by maintaining a valid TSP tour structure. The operator dynamically adjusts the segment lengths based on the relative costs of the two objectives, and the inversion step helps escape local optima by introducing diversity. The function validates the new solution to confirm it remains a valid tour before returning it.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Non-dominated sorting to find Pareto front\n    pareto_front = []\n    for sol, obj in archive:\n        dominated = False\n        to_remove = []\n        for i, (_, p_obj) in enumerate(pareto_front):\n            if obj[0] >= p_obj[0] and obj[1] >= p_obj[1]:\n                dominated = True\n                break\n            if obj[0] <= p_obj[0] and obj[1] <= p_obj[1]:\n                to_remove.append(i)\n        if not dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    # Select from top 20% of non-dominated solutions\n    if not pareto_front:\n        base_solution = archive[random.randint(0, len(archive) - 1)][0].copy()\n    else:\n        top_k = max(1, int(0.2 * len(pareto_front)))\n        selected = random.choice(pareto_front[:top_k])\n        base_solution = selected[0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select segments for 3-opt and inversion\n    seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n    seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n    seg3_start, seg3_end = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are distinct and non-overlapping\n    while (seg1_start <= seg2_end and seg1_end >= seg2_start) or \\\n          (seg1_start <= seg3_end and seg1_end >= seg3_start) or \\\n          (seg2_start <= seg3_end and seg2_end >= seg3_start):\n        seg1_start, seg1_end = sorted(random.sample(range(n), 2))\n        seg2_start, seg2_end = sorted(random.sample(range(n), 2))\n        seg3_start, seg3_end = sorted(random.sample(range(n), 2))\n\n    # Extract segments\n    seg1 = new_solution[seg1_start:seg1_end + 1]\n    seg2 = new_solution[seg2_start:seg2_end + 1]\n    seg3 = new_solution[seg3_start:seg3_end + 1]\n\n    # Rearrange segments to prioritize reducing the higher cost objective\n    obj1_cost = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    obj2_cost = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if obj1_cost > obj2_cost:\n        # Prioritize reducing obj1_cost\n        new_order = [seg2, seg1, seg3]\n    else:\n        # Prioritize reducing obj2_cost\n        new_order = [seg3, seg2, seg1]\n\n    # Reconstruct the solution\n    new_segments = []\n    for seg in new_order:\n        new_segments.extend(seg)\n\n    # Insert the remaining nodes in order\n    remaining_nodes = [node for node in new_solution if node not in new_segments]\n    new_segments.extend(remaining_nodes)\n\n    new_solution = np.array(new_segments)\n\n    # Step 3: Validate the new solution\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid tour: Duplicate nodes detected.\")\n\n    return new_solution\n\n",
          "score": [
               7.045282655935035,
               7.729177180490167
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1])):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive\n\n    # Randomly select one non-dominated solution\n    selected_idx = np.random.randint(0, len(non_dominated))\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 2: Apply hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Edge insertion + Variable-length segment relocation\n    for _ in range(10):  # Number of local search iterations\n        # Edge insertion step\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while i == j:\n            j = np.random.randint(0, n)\n\n        # Remove node at position i and reinsert at position j\n        node = new_solution[i]\n        new_solution = np.delete(new_solution, i)\n        new_solution = np.insert(new_solution, j, node)\n\n        # Variable-length segment relocation step\n        segment_length = np.random.randint(2, min(5, n // 2))\n        start = np.random.randint(0, n - segment_length)\n        end = start + segment_length\n\n        # Extract segment\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, range(start, end))\n\n        # Insert segment at a new random position\n        new_pos = np.random.randint(0, n - segment_length + 1)\n        new_solution = np.insert(new_solution, new_pos, segment)\n\n    return new_solution\n\n",
          "score": [
               8.76348646373048,
               8.713459654273953
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest potential for improvement\n    selected_idx = 0\n    max_potential = -1\n    for i, (sol, _) in enumerate(archive):\n        # Calculate potential based on edge diversity in both spaces\n        edges = [(sol[j], sol[(j+1)%len(sol)]) for j in range(len(sol))]\n        diversity = sum(distance_matrix_1[e[0], e[1]] + distance_matrix_2[e[0], e[1]] for e in edges)\n        if diversity > max_potential:\n            max_potential = diversity\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: constrained 3-opt with edge insertion\n    n = len(new_solution)\n    if n < 4:\n        # Fallback to simple swap if tour is too small\n        new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n    else:\n        # Select three distinct positions\n        a, b, c = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n        segment3 = np.concatenate([new_solution[c:], new_solution[:a]])\n\n        # Reconstruct with segments in different order\n        new_order = np.concatenate([segment1, segment3, segment2])\n\n        # Ensure it's a valid tour\n        if len(np.unique(new_order)) == n:\n            new_solution = new_order\n\n        # Local optimization: greedy insertion for the middle segment\n        for i in range(1, len(segment2)-1):\n            node = segment2[i]\n            # Find best insertion position in the remaining tour\n            best_pos = 0\n            min_cost = float('inf')\n            for j in range(len(new_solution)):\n                # Try inserting after position j\n                temp_sol = np.insert(new_solution, j, node)\n                cost = (sum(distance_matrix_1[temp_sol[k], temp_sol[(k+1)%len(temp_sol)]] for k in range(len(temp_sol))) +\n                        sum(distance_matrix_2[temp_sol[k], temp_sol[(k+1)%len(temp_sol)]] for k in range(len(temp_sol))))\n                if cost < min_cost:\n                    min_cost = cost\n                    best_pos = j\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               10.51118295412729,
               10.554815963019655
          ]
     },
     {
          "algorithm": "{The heuristic function `select_neighbor` first evaluates the archive of solutions by computing their Pareto dominance and crowding distance, then intelligently selects a solution with high potential for improvement based on these metrics. It then applies a novel hybrid local search strategy that combines edge exchange with a variable-length segment relocation, guided by a multi-objective evaluation of the current and neighboring solutions. The edge exchange identifies critical edges in both objective spaces, while the segment relocation dynamically adjusts the segment length based on the local topology and objective trade-offs, ensuring feasibility by maintaining a valid tour structure. The function ensures the generated neighbor solution remains feasible by validating the tour structure after each modification, and it prioritizes solutions that show improvement in at least one objective while maintaining or improving the other.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Calculate Pareto dominance and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Compute Pareto dominance and crowding distance\n    dominated = np.zeros(len(archive), dtype=bool)\n    crowding_distance = np.zeros(len(archive))\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] >= objectives[j][0] and objectives[i][1] >= objectives[j][1]) and \\\n                   (objectives[i][0] > objectives[j][0] or objectives[i][1] > objectives[j][1]):\n                    dominated[i] = True\n                elif (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n                     (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                    dominated[j] = True\n\n    # Assign crowding distance\n    for m in range(2):\n        sorted_idx = np.argsort([obj[m] for obj in objectives])\n        crowding_distance[sorted_idx[0]] = np.inf\n        crowding_distance[sorted_idx[-1]] = np.inf\n        for i in range(1, len(archive) - 1):\n            crowding_distance[sorted_idx[i]] += (objectives[sorted_idx[i+1]][m] - objectives[sorted_idx[i-1]][m])\n\n    # Select the solution with highest crowding distance and not dominated\n    non_dominated = np.where(~dominated)[0]\n    if len(non_dominated) > 0:\n        selected_idx = non_dominated[np.argmax(crowding_distance[non_dominated])]\n    else:\n        selected_idx = np.argmax(crowding_distance)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Step 2: Apply hybrid local search\n    n = len(base_solution)\n\n    # Edge exchange based on both objectives\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        i = np.random.randint(n)\n        j = np.random.randint(n)\n        if i == j:\n            continue\n\n        # Get current edges\n        prev_i = base_solution[i-1] if i > 0 else base_solution[-1]\n        next_i = base_solution[(i+1)%n]\n        prev_j = base_solution[j-1] if j > 0 else base_solution[-1]\n        next_j = base_solution[(j+1)%n]\n\n        # Calculate current and potential costs\n        current_cost1 = distance_matrix_1[prev_i, base_solution[i]] + distance_matrix_1[base_solution[i], next_i] + \\\n                        distance_matrix_1[prev_j, base_solution[j]] + distance_matrix_1[base_solution[j], next_j]\n        current_cost2 = distance_matrix_2[prev_i, base_solution[i]] + distance_matrix_2[base_solution[i], next_i] + \\\n                        distance_matrix_2[prev_j, base_solution[j]] + distance_matrix_2[base_solution[j], next_j]\n\n        # Swap edges\n        temp = new_solution[i]\n        new_solution[i] = new_solution[j]\n        new_solution[j] = temp\n\n        # Calculate new edges\n        new_prev_i = new_solution[i-1] if i > 0 else new_solution[-1]\n        new_next_i = new_solution[(i+1)%n]\n        new_prev_j = new_solution[j-1] if j > 0 else new_solution[-1]\n        new_next_j = new_solution[(j+1)%n]\n\n        new_cost1 = distance_matrix_1[new_prev_i, new_solution[i]] + distance_matrix_1[new_solution[i], new_next_i] + \\\n                    distance_matrix_1[new_prev_j, new_solution[j]] + distance_matrix_1[new_solution[j], new_next_j]\n        new_cost2 = distance_matrix_2[new_prev_i, new_solution[i]] + distance_matrix_2[new_solution[i], new_next_i] + \\\n                    distance_matrix_2[new_prev_j, new_solution[j]] + distance_matrix_2[new_solution[j], new_next_j]\n\n        # Accept if at least one objective improves\n        if (new_cost1 < current_cost1 or new_cost2 < current_cost2):\n            base_solution = new_solution.copy()\n        else:\n            # Revert if no improvement\n            new_solution = base_solution.copy()\n\n    # Variable-length segment relocation\n    segment_length = min(3, n // 4)  # Start with a small segment\n    for _ in range(5):\n        start = np.random.randint(n - segment_length)\n        end = start + segment_length\n        segment = base_solution[start:end]\n\n        # Find best insertion point\n        best_pos = -1\n        best_cost1, best_cost2 = np.inf, np.inf\n\n        for pos in range(n):\n            if pos >= start and pos <= end:\n                continue\n\n            # Insert segment at position pos\n            temp_solution = np.concatenate([\n                base_solution[:pos],\n                segment,\n                base_solution[pos:]\n            ])\n\n            # Calculate cost\n            cost1 = 0\n            cost2 = 0\n            for k in range(n):\n                cost1 += distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]]\n                cost2 += distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]]\n\n            if (cost1 < best_cost1 and cost2 <= best_cost2) or (cost1 <= best_cost1 and cost2 < best_cost2):\n                best_cost1, best_cost2 = cost1, cost2\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                base_solution[:best_pos],\n                segment,\n                base_solution[best_pos:]\n            ])\n            base_solution = new_solution.copy()\n\n        # Increase segment length for next iteration\n        segment_length = min(segment_length + 1, n // 2)\n\n    return new_solution\n\n",
          "score": [
               10.519795885551638,
               10.513816092204934
          ]
     }
]