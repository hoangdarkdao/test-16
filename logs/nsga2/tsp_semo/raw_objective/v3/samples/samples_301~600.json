[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment reversal with a segment relocation to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.607579010054458,
            4.509228290479977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            segment = new_solution[i:j+1]\n            new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k], segment, new_solution[k:]])\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{This algorithm selects the solution with the highest combined improvement in both objectives relative to a reference point, then applies a novel local search strategy combining a probabilistic segment insertion and a segment inversion with position-based constraints to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    reference_point = np.max(objectives, axis=0)\n    improvement_scores = reference_point - objectives\n    weighted_scores = np.sum(improvement_scores, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            if k < i or k > j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.493050459692151,
            6.475793977406404
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    reference_point = np.max(objectives, axis=0)\n    improvement_scores = reference_point - objectives\n    weighted_scores = np.sum(improvement_scores, axis=1)\n    selected_idx = np.argmax(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(0, N)\n            if k < i or k > j:\n                segment = new_solution[i:j+1]\n                new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if (i % 2 == 0 and j % 2 == 0) or (i % 2 != 0 and j % 2 != 0):\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This algorithm selects a solution from the archive based on a dominance-aware selection criterion that prioritizes solutions with good trade-offs between objectives, then applies a novel local search operator that combines a probabilistic segment rotation and a node insertion heuristic to generate high-quality neighbors while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    # Select solution with good trade-off between objectives\n    selected_idx = -1\n    max_tradeoff = -1\n    for i in range(len(sorted_objectives)):\n        if i == 0 or i == len(sorted_objectives)-1:\n            continue\n        tradeoff = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n        if tradeoff > max_tradeoff:\n            max_tradeoff = tradeoff\n            selected_idx = i\n\n    if selected_idx == -1:\n        selected_idx = np.random.randint(0, len(archive))\n\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Probabilistic segment rotation\n        if np.random.random() < 0.6:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N-segment_length)\n            rotation = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Node insertion heuristic\n        if np.random.random() < 0.5:\n            node_to_move = np.random.randint(0, N)\n            best_pos = -1\n            best_improvement = 0\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n\n            for pos in range(N):\n                if pos == node_to_move or pos == (node_to_move-1)%N:\n                    continue\n\n                # Try inserting node_to_move at position pos\n                temp_solution = np.concatenate([\n                    new_solution[:pos],\n                    [new_solution[node_to_move]],\n                    new_solution[pos:node_to_move],\n                    new_solution[node_to_move+1:]\n                ])\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(N))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(N))\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1:\n                temp_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    [new_solution[node_to_move]],\n                    new_solution[best_pos:node_to_move],\n                    new_solution[node_to_move+1:]\n                ])\n                new_solution = temp_solution\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.867601840062568,
            6.417180570005313
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    # Select solution with good trade-off between objectives\n    selected_idx = -1\n    max_tradeoff = -1\n    for i in range(len(sorted_objectives)):\n        if i == 0 or i == len(sorted_objectives)-1:\n            continue\n        tradeoff = (sorted_objectives[i+1, 0] - sorted_objectives[i-1, 0]) + (sorted_objectives[i+1, 1] - sorted_objectives[i-1, 1])\n        if tradeoff > max_tradeoff:\n            max_tradeoff = tradeoff\n            selected_idx = i\n\n    if selected_idx == -1:\n        selected_idx = np.random.randint(0, len(archive))\n\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Probabilistic segment rotation\n        if np.random.random() < 0.6:\n            segment_length = np.random.randint(2, min(5, N//2))\n            start = np.random.randint(0, N-segment_length)\n            rotation = np.random.randint(1, segment_length)\n            segment = new_solution[start:start+segment_length]\n            rotated_segment = np.concatenate([segment[rotation:], segment[:rotation]])\n            new_solution[start:start+segment_length] = rotated_segment\n\n        # Node insertion heuristic\n        if np.random.random() < 0.5:\n            node_to_move = np.random.randint(0, N)\n            best_pos = -1\n            best_improvement = 0\n            current_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(N))\n            current_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(N))\n\n            for pos in range(N):\n                if pos == node_to_move or pos == (node_to_move-1)%N:\n                    continue\n\n                # Try inserting node_to_move at position pos\n                temp_solution = np.concatenate([\n                    new_solution[:pos],\n                    [new_solution[node_to_move]],\n                    new_solution[pos:node_to_move],\n                    new_solution[node_to_move+1:]\n                ])\n\n                new_cost1 = sum(distance_matrix_1[temp_solution[i-1], temp_solution[i]] for i in range(N))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i-1], temp_solution[i]] for i in range(N))\n\n                improvement = (current_cost1 + current_cost2) - (new_cost1 + new_cost2)\n                if improvement > best_improvement:\n                    best_improvement = improvement\n                    best_pos = pos\n\n            if best_pos != -1:\n                temp_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    [new_solution[node_to_move]],\n                    new_solution[best_pos:node_to_move],\n                    new_solution[node_to_move+1:]\n                ])\n                new_solution = temp_solution\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 304,
        "algorithm": "{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation with a dynamic segment reversal based on the relative improvement potential of each segment to generate a neighbor while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+1, N-1)\n        segment = new_solution[i:j+1]\n\n        if np.random.random() < 0.6:\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            segment_cost_1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            segment_cost_2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            if segment_cost_2 > segment_cost_1 * 0.7:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            8.235622253536645,
            4.798435947330381
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+1, N-1)\n        segment = new_solution[i:j+1]\n\n        if np.random.random() < 0.6:\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            segment_cost_1 = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            segment_cost_2 = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(1, len(segment)))\n            if segment_cost_2 > segment_cost_1 * 0.7:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive based on a crowding distance metric to identify solutions in less crowded regions, then applies a hybrid local search combining a segment swap and a probabilistic segment reversal to generate neighbors while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    sorted_indices = np.lexsort((objectives[:, 1], objectives[:, 0]))\n    sorted_objectives = objectives[sorted_indices]\n\n    crowding_distances = np.zeros(len(sorted_objectives))\n    for m in range(2):\n        sorted_order = np.argsort(sorted_objectives[:, m])\n        crowding_distances[sorted_order[0]] = np.inf\n        crowding_distances[sorted_order[-1]] = np.inf\n        for i in range(1, len(sorted_objectives)-1):\n            crowding_distances[sorted_order[i]] += (sorted_objectives[sorted_order[i+1], m] - sorted_objectives[sorted_order[i-1], m]) / (sorted_objectives[-1, m] - sorted_objectives[0, m] + 1e-8)\n\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[sorted_indices[selected_idx]][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        if np.random.random() < 0.7:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            k = np.random.randint(0, N-1)\n            l = np.random.randint(k+1, N)\n            if abs(i-j) > 1 and abs(k-l) > 1:\n                new_solution[i], new_solution[j], new_solution[k], new_solution[l] = new_solution[k], new_solution[l], new_solution[i], new_solution[j]\n\n        if np.random.random() < 0.4:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+2, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This algorithm selects a solution from the archive by prioritizing those with the highest improvement in the second objective, then applies a novel local search strategy that combines a probabilistic segment rotation and a segment inversion to generate a neighbor while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    weights = np.array([0.3, 0.7])\n    weighted_scores = np.sum(normalized_scores * weights, axis=1)\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        if np.random.random() < 0.6:\n            i = np.random.randint(0, N-2)\n            j = np.random.randint(i+1, N-1)\n            k = np.random.randint(j+1, N)\n            segment = new_solution[i:j+1]\n            rotated_segment = np.concatenate([segment[1:], [segment[0]]])\n            new_solution[i:j+1] = rotated_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 305,
        "algorithm": "{This algorithm selects a solution from the archive based on a hybrid dominance and diversity metric, then applies a novel segment insertion with adaptive reversal to generate neighbors while ensuring feasibility through a two-phase validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated_count += 1\n        dominance_scores[i] = dominated_count\n\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = np.linalg.norm(normalized_scores - normalized_scores[i], axis=1)\n        diversity_scores[i] = np.mean(distances)\n\n    combined_scores = 0.6 * dominance_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n\n        if np.random.random() < 0.8:\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            new_segment = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            if len(new_segment) == N:\n                new_solution = new_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if np.random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            10.452261960422799,
            10.579378778446058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for (_, obj) in archive])\n    min_vals = np.min(objectives, axis=0)\n    max_vals = np.max(objectives, axis=0)\n    normalized_scores = (objectives - min_vals) / (max_vals - min_vals + 1e-8)\n\n    dominance_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        dominated_count = 0\n        for j in range(len(archive)):\n            if i != j and (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1] and\n                          (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1])):\n                dominated_count += 1\n        dominance_scores[i] = dominated_count\n\n    diversity_scores = np.zeros(len(archive))\n    for i in range(len(archive)):\n        distances = np.linalg.norm(normalized_scores - normalized_scores[i], axis=1)\n        diversity_scores[i] = np.mean(distances)\n\n    combined_scores = 0.6 * dominance_scores + 0.4 * diversity_scores\n    selected_idx = np.argmax(combined_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 4:\n        i = np.random.randint(0, N-2)\n        j = np.random.randint(i+1, N)\n        segment = new_solution[i:j]\n\n        if np.random.random() < 0.8:\n            k = np.random.randint(0, N)\n            while k == i or k == j:\n                k = np.random.randint(0, N)\n            new_segment = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n            if len(new_segment) == N:\n                new_solution = new_segment\n\n        if np.random.random() < 0.5:\n            i = np.random.randint(0, N-1)\n            j = np.random.randint(i+1, N)\n            if np.random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]