[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the lowest sum of normalized objectives (promising for improvement)\n    normalized_objectives = [(obj[0] / (obj[0] + obj[1] + 1e-10), obj[1] / (obj[0] + obj[1] + 1e-10)) for _, obj in archive]\n    scores = [sum(norm_obj) for norm_obj in normalized_objectives]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n    if n < 4:\n        return new_solution\n\n    # Randomly select two segments to modify\n    i, j = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n    k = np.random.randint(1, n-1)\n\n    # Novel move: reverse segment between i and j, then insert segment between k and k+1\n    segment = new_solution[i:j+1]\n    new_solution = np.concatenate([new_solution[:i], new_solution[j+1:k+1], segment, new_solution[k+1:]])\n\n    # Ensure feasibility by checking for duplicates (shouldn't happen due to segment insertion)\n    if len(np.unique(new_solution)) != n:\n        # Fallback to simple swap if the move is invalid\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.343084386472292,
               6.398679333078661
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution with probability proportional to its potential for improvement\n    scores = []\n    for sol, _ in archive:\n        # Calculate diversity score (number of unique edges not in other solutions)\n        diversity = 0\n        edges = set(zip(sol, np.roll(sol, -1)))\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges - other_edges)\n        scores.append(diversity)\n\n    if all(s == 0 for s in scores):\n        # If all solutions are identical, select randomly\n        base_solution = random.choice(archive)[0].copy()\n    else:\n        # Normalize scores and select with probability\n        total = sum(scores)\n        probs = [s / total for s in scores]\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    if random.random() < 0.7:  # 70% chance for segment relocation\n        # Select segment length based on instance size\n        max_segment = min(5, n // 4)\n        segment_length = random.randint(2, max_segment)\n\n        # Select random segment\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Find best insertion position that improves both objectives\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n - segment_length + 1):\n            if pos >= start and pos < start + segment_length:\n                continue  # Skip current position\n\n            # Create candidate solution\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:start],\n                new_solution[start+segment_length:]\n            ])\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[candidate[-1], candidate[0]]  # Complete the tour\n\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1 and best_cost < float('inf'):\n            # Apply the best move\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:start],\n                new_solution[start+segment_length:]\n            ])\n    else:  # Edge insertion\n        # Select random edge to remove\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Select random node to insert between\n        k = random.randint(0, n-1)\n        while k == i or k == j or k == (i-1)%n:\n            k = random.randint(0, n-1)\n\n        # Create candidate solution\n        candidate = new_solution.copy()\n        candidate[i], candidate[j] = candidate[j], candidate[i]  # Reverse the edge\n        candidate = np.roll(candidate, -i)  # Make i the first element\n        candidate = np.concatenate([candidate[:1], candidate[2:k+1], candidate[1:2], candidate[k+1:]])\n        candidate = np.roll(candidate, i)  # Restore original order\n\n        # Check if the move is valid (visits all nodes exactly once)\n        if len(set(candidate)) == n:\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.602584769458544,
               5.827298074802924
          ]
     },
     {
          "algorithm": "{The new algorithm begins by selecting a base solution from the archive using a multi-criteria approach that combines objective values, diversity, and structural features, then employs a novel hybrid local search strategy that integrates adaptive segment swapping with probabilistic edge reversal, followed by a constrained node reinsertion phase to ensure feasibility while exploring the solution space more effectively than standard methods, ultimately generating a high-quality neighbor solution that balances exploration and exploitation through dynamic parameter adaptation and objective-aware move selection.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select base solution based on combined objective and structural diversity\n    scores = []\n    for sol, (obj1, obj2) in archive:\n        # Calculate combined objective score (normalized)\n        obj_score = (obj1 + obj2) / (sum(x[1][0] + x[1][1] for x in archive) / len(archive))\n\n        # Calculate structural diversity\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity = 0\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges.symmetric_difference(other_edges))\n\n        # Combine scores with adaptive weights\n        alpha = 0.7 if len(archive) > 10 else 0.5\n        scores.append(alpha * obj_score + (1 - alpha) * diversity)\n\n    # Select solution with highest combined score\n    base_solution = archive[np.argmax(scores)][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search strategy\n    # Phase 1: Adaptive segment swapping\n    segment_length = max(3, min(7, n // 5))\n    for _ in range(2):\n        start1 = np.random.randint(0, n - segment_length)\n        start2 = np.random.randint(0, n - segment_length)\n        while abs(start1 - start2) < segment_length:\n            start2 = np.random.randint(0, n - segment_length)\n\n        # Swap segments with probability based on objective improvement\n        seg1 = new_solution[start1:start1+segment_length]\n        seg2 = new_solution[start2:start2+segment_length]\n\n        # Calculate potential improvement\n        old_cost = (sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[new_solution[-1], new_solution[0]] +\n                    sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        candidate = new_solution.copy()\n        candidate[start1:start1+segment_length] = seg2\n        candidate[start2:start2+segment_length] = seg1\n\n        new_cost = (sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_1[candidate[-1], candidate[0]] +\n                    sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) +\n                    distance_matrix_2[candidate[-1], candidate[0]])\n\n        if new_cost < old_cost or np.random.random() < 0.3:\n            new_solution = candidate\n\n    # Phase 2: Probabilistic edge reversal with objective awareness\n    for _ in range(3):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        while abs(i - j) < 2:\n            j = np.random.randint(0, n)\n\n        # Calculate potential improvement\n        old_edges = [(new_solution[i-1], new_solution[i]), (new_solution[j-1], new_solution[j])]\n        new_edges = [(new_solution[i-1], new_solution[j]), (new_solution[i], new_solution[j-1])]\n\n        old_cost = (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]] +\n                    distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n        new_cost = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]] +\n                    distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]])\n\n        if new_cost < old_cost or np.random.random() < 0.2:\n            # Reverse the segment between i and j\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    # Phase 3: Constrained node reinsertion\n    for _ in range(2):\n        # Select a random node to remove\n        idx = np.random.randint(1, n-1)\n        node = new_solution[idx]\n\n        # Remove the node\n        candidate = np.concatenate([new_solution[:idx], new_solution[idx+1:]])\n\n        # Find best insertion position that minimizes both objectives\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n-1):\n            if pos == idx or pos == idx-1:\n                continue\n\n            # Insert node at position pos\n            temp = np.insert(candidate, pos, node)\n\n            # Calculate cost\n            cost1 = sum(distance_matrix_1[temp[i], temp[i+1]] for i in range(n-1))\n            cost1 += distance_matrix_1[temp[-1], temp[0]]\n\n            cost2 = sum(distance_matrix_2[temp[i], temp[i+1]] for i in range(n-1))\n            cost2 += distance_matrix_2[temp[-1], temp[0]]\n\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(candidate, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               5.982530730904809,
               6.4238842089255845
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a novel adaptive path decomposition and recombination strategy that dynamically partitions the tour into segments based on both objective spaces' characteristics, then reconstructs the tour by interleaving these segments in a way that maximizes the trade-off between the two objectives. The selection process prioritizes solutions that exhibit non-dominated segments in the Pareto front, while the local search operator uses a probabilistic segment recombination mechanism guided by a multi-objective utility function that considers the segment's contribution to both objectives. The function ensures feasibility by maintaining the permutation property through a series of carefully designed segment swaps and rotations, with the segment length and recombination pattern determined by an adaptive probability model that learns from the current solution's structure and the distance matrices.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using adaptive segment analysis\n    selected_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Adaptive path decomposition based on both objectives\n    segment_length = np.random.randint(3, min(7, n // 2))\n    start_pos = np.random.randint(0, n - segment_length)\n\n    # Extract segment and analyze its contribution to both objectives\n    segment = new_solution[start_pos:start_pos + segment_length]\n    segment_cost1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(segment_length))\n\n    # Determine segment's Pareto dominance relative to the rest of the tour\n    total_cost1 = sum(distance_matrix_1[new_solution[i-1], new_solution[i]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i-1], new_solution[i]] for i in range(n))\n\n    # Probabilistic recombination based on segment's characteristics\n    if segment_cost1 / total_cost1 < 0.3 or segment_cost2 / total_cost2 < 0.3:\n        # If segment is significantly worse in one objective, consider removing it\n        new_solution = np.concatenate([new_solution[:start_pos], new_solution[start_pos + segment_length:]])\n        # Insert the segment in a different position\n        insert_pos = np.random.randint(0, len(new_solution) - segment_length + 1)\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n    else:\n        # If segment is balanced, consider rotating it\n        rotation = np.random.randint(1, segment_length)\n        segment = np.roll(segment, rotation)\n        new_solution[start_pos:start_pos + segment_length] = segment\n\n    # Ensure feasibility by checking for duplicates\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to restore feasibility\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               6.4586950415254565,
               5.903120343468656
          ]
     },
     {
          "algorithm": "{The new algorithm builds upon the common backbone idea of selecting a promising solution from the archive and applying a hybrid local search strategy, but it introduces a novel approach by combining adaptive segment relocation with a guided path inversion mechanism. The algorithm first evaluates solutions based on their objective diversity and local search potential, then selects a base solution with high potential for improvement. The selected solution undergoes a multi-stage local search process: first, it adaptively identifies and relocates promising segments of varying lengths based on their contribution to reducing both objectives, while dynamically adjusting segment lengths based on the solution's structure and the distance matrices. Next, it applies a guided path inversion where paths between critical nodes are inverted based on their weighted contribution to both objectives, with inversion length determined by a probabilistic model that considers the current solution's structure and the distance matrices. The algorithm ensures feasibility by maintaining the permutation property of TSP tours throughout the process and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Adaptive segment relocation\n    num_segments = np.random.randint(1, min(3, n // 3))\n    segment_lengths = []\n\n    for _ in range(num_segments):\n        # Determine segment length based on local structure\n        i = np.random.randint(0, n)\n        j = (i + 1) % n\n        k = (j + 1) % n\n\n        # Calculate edge weights in both objectives\n        w1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[j], base_solution[k]]\n        w2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[j], base_solution[k]]\n\n        # Use weighted combination to determine segment length\n        length = max(2, min(5, int(3 * (w1 + w2) / (distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[i], base_solution[k]]))))\n        segment_lengths.append(length)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    # Relocate segments\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        # Find best insertion position\n        best_pos = current_pos\n        best_cost = float('inf')\n\n        for pos in range(n - length + 1):\n            if pos >= current_pos and pos < current_pos + length:\n                continue\n\n            candidate = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:current_pos],\n                new_solution[current_pos + length:]\n            ])\n\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != current_pos:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:current_pos],\n                new_solution[current_pos + length:]\n            ])\n\n        current_pos += length\n\n    # Guided path inversion\n    for _ in range(min(2, n // 3)):\n        # Select critical nodes based on both objectives\n        critical_nodes = []\n        for i in range(n):\n            j = (i + 1) % n\n            cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n            if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n                critical_nodes.append(i)\n\n        if len(critical_nodes) >= 2:\n            i, j = np.random.choice(critical_nodes, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n\n            # Calculate inversion length based on node distances\n            inversion_length = max(2, min(5, int(3 * (distance_matrix_1[new_solution[i], new_solution[j]] +\n                                                   distance_matrix_2[new_solution[i], new_solution[j]]) /\n                                                   (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)))))\n\n            # Perform inversion\n            if j - i + 1 <= inversion_length:\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n            else:\n                mid = i + inversion_length // 2\n                new_solution[i:mid] = new_solution[i:mid][::-1]\n                new_solution[mid:j+1] = new_solution[mid:j+1][::-1]\n\n    return new_solution\n\n",
          "score": [
               6.455092419352846,
               6.242420963522866
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' first evaluates the archive of solutions by computing their Pareto dominance relationships, then selects a promising solution with high potential for improvement using a custom selection criterion that balances objective diversity and local search potential. The selected solution undergoes a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge exchange mechanism, where segments of varying lengths are inverted and edges are exchanged based on their contribution to reducing the total tour length in both objective spaces. The inversion length is dynamically determined using a probabilistic model that considers both the distance matrices and the current solution's structure, while the edge exchange is guided by a weighted combination of the two objectives. The function ensures feasibility by maintaining the permutation property of TSP tours throughout the local search process, and returns the improved neighbor solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator\n    n = len(base_solution)\n    if n < 3:\n        return new_solution\n\n    # Multi-segment inversion\n    num_segments = np.random.randint(1, min(4, n // 2))\n    segment_lengths = np.random.randint(2, min(5, n // num_segments), size=num_segments)\n\n    # Ensure total length doesn't exceed n\n    total_length = np.sum(segment_lengths)\n    if total_length > n:\n        segment_lengths = (segment_lengths * (n / total_length)).astype(int)\n        segment_lengths[segment_lengths < 2] = 2\n        segment_lengths[-1] = n - np.sum(segment_lengths[:-1])\n\n    start_pos = np.random.randint(0, n - total_length + 1)\n    current_pos = start_pos\n\n    for length in segment_lengths:\n        segment = new_solution[current_pos:current_pos + length]\n        new_solution[current_pos:current_pos + length] = segment[::-1]\n        current_pos += length\n\n    # Guided edge exchange\n    for _ in range(min(3, n // 2)):\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n\n        # Weighted decision based on both objectives\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2) or (new_cost1 <= current_cost1 and new_cost2 < current_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               6.372959628179613,
               6.543599011883715
          ]
     },
     {
          "algorithm": "{The new algorithm combines a multi-objective aware path decomposition strategy with a probabilistic segment reassembly technique. It first decomposes the current solution into variable-length paths by identifying segments with balanced contributions to both objectives, then probabilistically reassembles these segments by considering their spatial proximity in both objective spaces, followed by a guided edge swapping operation that prioritizes edges with complementary improvements in both objectives while maintaining tour feasibility, and finally refines the solution with a novel node relocation heuristic that dynamically adjusts the relocation probability based on the current solution's structure and the relative improvement potential in both objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Multi-objective path decomposition\n    segments = []\n    current_segment = [new_solution[0]]\n    for i in range(1, n):\n        # Calculate cost difference for both objectives\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]]\n        prev_cost1 = distance_matrix_1[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n        prev_cost2 = distance_matrix_2[new_solution[i-2], new_solution[i-1]] if i > 1 else 0\n\n        # Check if segment should be split\n        if (current_cost1 > 1.2 * prev_cost1 and current_cost2 > 1.2 * prev_cost2) or np.random.random() < 0.1:\n            segments.append(current_segment)\n            current_segment = [new_solution[i]]\n        else:\n            current_segment.append(new_solution[i])\n    if current_segment:\n        segments.append(current_segment)\n\n    # Probabilistic segment reassembly\n    if len(segments) > 1:\n        # Calculate segment scores based on spatial proximity in both objectives\n        segment_scores = []\n        for seg in segments:\n            # Calculate centroids in both objective spaces\n            centroid1 = np.mean(instance[seg, :2], axis=0)\n            centroid2 = np.mean(instance[seg, 2:], axis=0)\n\n            # Calculate average distance to other segments\n            avg_dist1 = np.mean([np.linalg.norm(centroid1 - np.mean(instance[other_seg, :2], axis=0))\n                                for other_seg in segments if other_seg != seg])\n            avg_dist2 = np.mean([np.linalg.norm(centroid2 - np.mean(instance[other_seg, 2:], axis=0))\n                               for other_seg in segments if other_seg != seg])\n\n            # Combined score (weighted average)\n            score = 0.5 * avg_dist1 + 0.5 * avg_dist2\n            segment_scores.append(score)\n\n        # Reassemble segments in order of decreasing score\n        sorted_indices = np.argsort(segment_scores)[::-1]\n        new_solution = np.concatenate([segments[i] for i in sorted_indices])\n\n    # Guided edge swapping\n    for _ in range(min(5, n//2)):\n        i, j = np.random.choice(n, 2, replace=False)\n        if abs(i - j) <= 1 or abs(i - j) >= n - 1:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                         distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                         distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                         distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try swapping edges\n        candidate = new_solution.copy()\n        if i < j:\n            candidate[i:j+1] = np.concatenate([candidate[j:j+1], candidate[i+1:j], candidate[i:i+1]])\n        else:\n            candidate[j:i+1] = np.concatenate([candidate[i:i+1], candidate[j+1:i], candidate[j:j+1]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly while the other doesn't worsen too much\n        if ((new_cost1 < current_cost1 and new_cost2 < current_cost2) or\n            (new_cost1 < current_cost1 * 0.9 and new_cost2 <= current_cost2 * 1.1) or\n            (new_cost1 <= current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9)):\n            new_solution = candidate\n\n    # Node relocation heuristic\n    for _ in range(min(3, n//3)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate current costs\n        current_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n        current_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                        distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                        distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Try relocating node i after node j\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:j+1], [candidate[i]], candidate[j+1:i], candidate[i+1:]])\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[candidate[i-1], candidate[i]] +\n                    distance_matrix_1[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_1[candidate[j-1], candidate[j]] +\n                    distance_matrix_1[candidate[j], candidate[(j+1)%n]])\n        new_cost2 = (distance_matrix_2[candidate[i-1], candidate[i]] +\n                    distance_matrix_2[candidate[i], candidate[(i+1)%n]] +\n                    distance_matrix_2[candidate[j-1], candidate[j]] +\n                    distance_matrix_2[candidate[j], candidate[(j+1)%n]])\n\n        # Dynamic relocation probability based on improvement potential\n        improvement_ratio = (current_cost1 - new_cost1) / current_cost1 + (current_cost2 - new_cost2) / current_cost2\n        prob = min(1.0, 0.5 + 0.5 * improvement_ratio)\n        if np.random.random() < prob:\n            new_solution = candidate\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               6.2572821231179985,
               6.7334989692074805
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' introduces a novel adaptive tour partitioning and multi-objective guided crossover strategy that dynamically decomposes the TSP tour into segments based on their relative importance in both objective spaces, then reconstructs the solution by probabilistically selecting segments from the archive's most diverse solutions and recombining them in a way that balances the trade-off between the two objectives, guided by a multi-objective utility function that considers both the segment's contribution to each objective and its potential for synergy with other segments from different solutions. The selection process prioritizes solutions with high diversity in their edge sets, while the local search operator uses a probabilistic segment exchange mechanism that allows for both inter-solution and intra-solution segment transfers, with the segment selection and recombination pattern determined by an adaptive probability model that learns from the archive's current Pareto front structure and the distance matrices. The function ensures feasibility by maintaining the permutation property through a series of carefully designed segment transfers and rotations, with the transfer probability and segment length determined by the current solution's objective values and their relative dominance in the archive.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a diverse solution with high potential for improvement\n    diversity_scores = []\n    objective_scores = []\n    for sol, obj in archive:\n        # Calculate diversity score\n        edges = set(zip(sol, np.roll(sol, -1)))\n        diversity = 0\n        for other_sol, _ in archive:\n            other_edges = set(zip(other_sol, np.roll(other_sol, -1)))\n            diversity += len(edges.symmetric_difference(other_edges))\n        diversity_scores.append(diversity)\n\n        # Calculate objective score (normalized)\n        normalized_obj = (obj[0]/sum(o[0] for _, o in archive),\n                         obj[1]/sum(o[1] for _, o in archive))\n        objective_scores.append(normalized_obj)\n\n    # Combine scores for selection\n    combined_scores = []\n    for d, o in zip(diversity_scores, objective_scores):\n        combined_scores.append(d * (1 - (o[0] + o[1])/2))\n\n    if all(s == 0 for s in combined_scores):\n        base_solution = archive[0][0].copy()\n    else:\n        probs = np.array(combined_scores) / sum(combined_scores)\n        idx = np.random.choice(len(archive), p=probs)\n        base_solution = archive[idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment transfer strategy\n    if random.random() < 0.6:  # 60% chance for segment transfer\n        # Select segment from another solution\n        other_idx = random.choice([i for i in range(len(archive)) if i != idx])\n        other_sol = archive[other_idx][0]\n\n        # Find common segments between solutions\n        common_segments = []\n        for i in range(n):\n            for j in range(i+2, min(i+6, n)):\n                segment = tuple(base_solution[i:j])\n                if tuple(segment) in [tuple(other_sol[k:k+(j-i)]) for k in range(n)]:\n                    common_segments.append((i, j))\n\n        if common_segments:\n            # Select a random common segment\n            start, end = random.choice(common_segments)\n            segment = new_solution[start:end]\n\n            # Find best position to insert in other solution\n            best_cost = float('inf')\n            best_pos = -1\n\n            for pos in range(n - (end-start) + 1):\n                if pos >= start and pos < end:\n                    continue\n\n                # Create candidate solution\n                candidate = np.concatenate([\n                    new_solution[:pos],\n                    segment,\n                    new_solution[pos:start],\n                    new_solution[end:]\n                ])\n\n                # Calculate cost\n                cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1))\n                cost1 += distance_matrix_1[candidate[-1], candidate[0]]\n\n                cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1))\n                cost2 += distance_matrix_2[candidate[-1], candidate[0]]\n\n                total_cost = cost1 + cost2\n\n                if total_cost < best_cost:\n                    best_cost = total_cost\n                    best_pos = pos\n\n            if best_pos != -1:\n                new_solution = np.concatenate([\n                    new_solution[:best_pos],\n                    segment,\n                    new_solution[best_pos:start],\n                    new_solution[end:]\n                ])\n        else:\n            # If no common segments, perform a simple edge swap\n            i, j = random.sample(range(1, n-1), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Edge-based local search with multi-objective consideration\n        i = random.randint(0, n-1)\n        j = (i + 1) % n\n\n        # Find best edge to swap with considering both objectives\n        best_gain = -float('inf')\n        best_k = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue\n\n            # Calculate gain for both objectives\n            gain1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                    distance_matrix_1[new_solution[j], new_solution[(k+1)%n]] -\n                    distance_matrix_1[new_solution[i], new_solution[j]] -\n                    distance_matrix_1[new_solution[k], new_solution[(k+1)%n]])\n\n            gain2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_2[new_solution[j], new_solution[(k+1)%n]] -\n                    distance_matrix_2[new_solution[i], new_solution[j]] -\n                    distance_matrix_2[new_solution[k], new_solution[(k+1)%n]])\n\n            # Combine gains with weights based on current objectives\n            current_obj = archive[idx][1]\n            total_obj = sum(o[0] + o[1] for _, o in archive)\n            weight1 = current_obj[0] / total_obj\n            weight2 = current_obj[1] / total_obj\n\n            combined_gain = weight1 * gain1 + weight2 * gain2\n\n            if combined_gain > best_gain:\n                best_gain = combined_gain\n                best_k = k\n\n        if best_k != -1:\n            # Apply the best edge swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            new_solution = np.roll(new_solution, -i)\n            new_solution = np.concatenate([\n                new_solution[:1],\n                new_solution[2:best_k+1],\n                new_solution[1:2],\n                new_solution[best_k+1:]\n            ])\n            new_solution = np.roll(new_solution, i)\n\n    # Ensure feasibility\n    if len(set(new_solution)) != n:\n        # If invalid, perform a simple repair\n        missing = [i for i in range(n) if i not in new_solution]\n        extra = [i for i in range(n) if list(new_solution).count(i) > 1]\n        if missing and extra:\n            pos = np.where(new_solution == extra[0])[0][0]\n            new_solution[pos] = missing[0]\n\n    return new_solution\n\n",
          "score": [
               6.915718444634539,
               6.31270271370532
          ]
     },
     {
          "algorithm": "{The proposed heuristic function 'select_neighbor' employs a novel multi-objective tour decomposition and guided node insertion strategy that first partitions the tour into segments based on a combined objective score, then reconstructs the tour by strategically inserting nodes from one segment into another segment in a way that maximizes the trade-off between the two objectives. The selection process prioritizes solutions that exhibit balanced segment contributions to both objectives, while the local search operator uses a guided insertion mechanism where nodes are selected for insertion based on their potential to improve both objectives simultaneously, with the insertion position determined by a probabilistic model that considers the node's contribution to the overall tour cost in both spaces. The function ensures feasibility by maintaining the permutation property through a series of carefully designed node insertions and segment rotations, with the segment length and insertion pattern determined by an adaptive probability model that learns from the current solution's structure and the distance matrices, while also incorporating a dynamic balancing mechanism that adjusts the trade-off between the two objectives based on their relative importance in the current solution.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with balanced objective contributions\n    combined_scores = [obj[0] + obj[1] for _, obj in archive]\n    normalized_scores = np.array(combined_scores) / np.sum(combined_scores)\n    selected_idx = np.random.choice(len(archive), p=normalized_scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 4:\n        return new_solution\n\n    # Calculate combined objective scores for each node\n    node_scores = []\n    for i in range(n):\n        prev_node = base_solution[i-1]\n        curr_node = base_solution[i]\n        next_node = base_solution[(i+1) % n]\n        score1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        score2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        node_scores.append(score1 + score2)\n\n    # Find the worst node based on combined score\n    worst_node_idx = np.argmax(node_scores)\n    worst_node = base_solution[worst_node_idx]\n\n    # Find potential insertion points\n    potential_positions = []\n    for i in range(n):\n        if i == worst_node_idx or i == (worst_node_idx - 1) % n:\n            continue\n        # Calculate potential improvement if inserted here\n        prev_node = base_solution[i-1]\n        next_node = base_solution[i]\n        current_cost1 = distance_matrix_1[prev_node, worst_node] + distance_matrix_1[worst_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, worst_node] + distance_matrix_2[worst_node, next_node]\n        new_cost1 = distance_matrix_1[prev_node, next_node]\n        new_cost2 = distance_matrix_2[prev_node, next_node]\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n        if improvement1 > 0 and improvement2 > 0:\n            potential_positions.append((i, improvement1 + improvement2))\n\n    if potential_positions:\n        # Select position with highest combined improvement\n        best_pos = max(potential_positions, key=lambda x: x[1])[0]\n        # Remove the worst node\n        new_solution = np.delete(new_solution, worst_node_idx)\n        # Insert it at the best position\n        new_solution = np.insert(new_solution, best_pos, worst_node)\n\n    # Adaptive balancing mechanism\n    obj1, obj2 = archive[selected_idx][1]\n    if obj1 > obj2:\n        # If first objective is worse, try to improve it more aggressively\n        for _ in range(2):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n            new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j-1], new_solution[i]]\n            if new_cost1 < current_cost1:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If second objective is worse, try to improve it more aggressively\n        for _ in range(2):\n            i, j = np.random.choice(n, size=2, replace=False)\n            if i > j:\n                i, j = j, i\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n            new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j-1], new_solution[i]]\n            if new_cost2 < current_cost2:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != n:\n        # If invalid, perform a simple swap to restore feasibility\n        a, b = np.random.choice(range(1, n-1), 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
          "score": [
               7.851263249623818,
               6.383212327343102
          ]
     },
     {
          "algorithm": "{The new algorithm employs a dynamic clustering-based approach to identify promising regions in the solution space, where each cluster represents a distinct segment of the tour that could benefit from coordinated optimization across both objectives. It first partitions the current solution into variable-length segments based on the spatial proximity of nodes in both objective spaces, then applies a guided segment crossover operation where segments are exchanged between clusters while maintaining feasibility, followed by a probabilistic segment inversion that considers the relative improvement potential of each segment in both objectives, and finally refines the solution with a novel edge insertion heuristic that prioritizes edges with balanced contributions to both objectives while preserving the tour's connectivity. The algorithm dynamically adjusts the segment size and selection probability based on the current solution's structure and the distance matrices, ensuring a diverse exploration of the search space while maintaining feasibility throughout the process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = np.random.choice(len(archive), p=np.linspace(0.1, 1.0, len(archive)) / np.sum(np.linspace(0.1, 1.0, len(archive))))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    if n < 3:\n        return new_solution\n\n    # Dynamic clustering-based segment identification\n    cluster_sizes = np.random.randint(2, min(6, n//2), size=np.random.randint(2, min(4, n//3)))\n    cluster_sizes = np.clip(cluster_sizes, 2, n - np.sum(cluster_sizes[:-1]) - 1)\n    cluster_sizes[-1] = n - np.sum(cluster_sizes[:-1])\n\n    clusters = []\n    current_pos = 0\n    for size in cluster_sizes:\n        clusters.append(new_solution[current_pos:current_pos+size])\n        current_pos += size\n\n    # Guided segment crossover\n    if len(clusters) > 1:\n        i, j = np.random.choice(len(clusters), 2, replace=False)\n        temp = clusters[i].copy()\n        clusters[i] = clusters[j].copy()\n        clusters[j] = temp\n\n    # Reconstruct solution from clusters\n    new_solution = np.concatenate(clusters)\n\n    # Probabilistic segment inversion\n    for cluster in clusters:\n        if len(cluster) > 2 and np.random.random() < 0.3:\n            cluster_start = np.where(new_solution == cluster[0])[0][0]\n            new_solution[cluster_start:cluster_start+len(cluster)] = cluster[::-1]\n\n    # Novel edge insertion heuristic\n    for _ in range(min(3, n//2)):\n        i = np.random.randint(0, n)\n        j = np.random.randint(0, n)\n        if i == j or (i+1)%n == j or (j+1)%n == i:\n            continue\n\n        # Calculate cost difference\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]]\n\n        # Try inserting node j between i and i+1\n        candidate = new_solution.copy()\n        candidate = np.concatenate([candidate[:i+1], [candidate[j]], candidate[i+1:j], candidate[j+1:]])\n\n        new_cost1 = sum(distance_matrix_1[candidate[k-1], candidate[k]] for k in range(1, n))\n        new_cost2 = sum(distance_matrix_2[candidate[k-1], candidate[k]] for k in range(1, n))\n\n        # Weighted decision\n        if (new_cost1 < current_cost1 and new_cost2 <= current_cost2*1.1) or (new_cost1 <= current_cost1*1.1 and new_cost2 < current_cost2):\n            new_solution = candidate\n\n    return new_solution\n\n",
          "score": [
               6.408399447509758,
               6.971989664069907
          ]
     }
]