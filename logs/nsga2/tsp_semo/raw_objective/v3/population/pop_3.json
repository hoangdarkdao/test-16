[
    {
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of objective values, then applies a novel local search operator that combines node swapping with path segment reversal to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution: prioritize solutions with better weighted objective\n    objectives = np.array([obj for (_, obj) in archive])\n    weights = np.random.uniform(0.3, 0.7)\n    weighted_scores = weights * objectives[:, 0] + (1 - weights) * objectives[:, 1]\n    selected_idx = np.argmin(weighted_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using novel local search: node swap with segment reversal\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    if N > 3:\n        # Randomly select two nodes to swap\n        i, j = np.random.choice(N, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        # Reverse a random segment between the swapped nodes\n        start, end = sorted([i, j])\n        if end - start > 1:\n            segment = np.random.randint(start + 1, end)\n            new_solution[segment:end] = new_solution[segment:end][::-1]\n\n    # Ensure the solution is feasible (no duplicates)\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.297973162170725,
            6.433642942613873
        ]
    },
    {
        "algorithm": "{The algorithm selects a solution from the archive based on a crowding distance metric to prioritize solutions in less crowded regions, then applies a novel local search operator that combines edge swaps with adaptive path inversions to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Crowding distance-based selection\n    objectives = np.array([obj for _, obj in archive])\n    fronts = []\n\n    # Non-dominated sorting\n    dominated_count = [0] * len(archive)\n    dominating_sets = [[] for _ in range(len(archive))]\n\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[i, 0] <= objectives[j, 0] and objectives[i, 1] <= objectives[j, 1]) and (objectives[i, 0] < objectives[j, 0] or objectives[i, 1] < objectives[j, 1]):\n                dominating_sets[i].append(j)\n            elif (objectives[j, 0] <= objectives[i, 0] and objectives[j, 1] <= objectives[i, 1]) and (objectives[j, 0] < objectives[i, 0] or objectives[j, 1] < objectives[i, 1]):\n                dominated_count[i] += 1\n        if dominated_count[i] == 0:\n            fronts.append(i)\n\n    if not fronts:\n        selected_idx = np.random.randint(len(archive))\n    else:\n        # Select from non-dominated front\n        front_solutions = [archive[i] for i in fronts]\n        front_objectives = objectives[fronts]\n\n        # Calculate crowding distances\n        crowding_distances = np.zeros(len(front_solutions))\n\n        for m in range(2):  # For each objective\n            sorted_idx = np.argsort(front_objectives[:, m])\n            crowding_distances[sorted_idx[0]] = np.inf\n            crowding_distances[sorted_idx[-1]] = np.inf\n\n            for i in range(1, len(front_solutions)-1):\n                crowding_distances[sorted_idx[i]] += (front_objectives[sorted_idx[i+1], m] - front_objectives[sorted_idx[i-1], m]) / (front_objectives[sorted_idx[-1], m] - front_objectives[sorted_idx[0], m] + 1e-10)\n\n        # Select solution with minimum crowding distance (less crowded region)\n        selected_idx = fronts[np.argmin(crowding_distances)]\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    N = len(new_solution)\n\n    # Adaptive edge swap with path inversion\n    i = np.random.randint(0, N)\n    j = np.random.randint(0, N)\n    while j == i:\n        j = np.random.randint(0, N)\n\n    # Determine segment to invert\n    start, end = sorted([i, j])\n    new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    # Ensure feasibility\n    if len(np.unique(new_solution)) != N:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            6.723328986566678,
            6.126496113043
        ]
    }
]