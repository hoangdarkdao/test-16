[
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            new_solution[start:end] = new_solution[end-1:start-1:-1]\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8460879456176522,
            0.07456672191619873
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            new_solution[start:end] = new_solution[end-1:start-1:-1]\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8460879456176522,
            0.07456672191619873
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            new_solution[start:end] = new_solution[end-1:start-1:-1]\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8460879456176522,
            0.07456672191619873
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            new_solution[start:end] = new_solution[end-1:start-1:-1]\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8460879456176522,
            0.07456672191619873
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            segment = new_solution[start:end]\n            new_solution = np.concatenate([\n                new_solution[:start],\n                new_solution[end:],\n                segment[::-1]\n            ])\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9245803941653445,
            0.07514792680740356
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm employs a hybrid selection mechanism that prioritizes solutions with balanced objective values, followed by a novel \"adaptive segment crossover and reinsertion\" operator that dynamically selects between segment inversion and insertion based on the current solution's balance, ensuring diverse neighborhood exploration while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive.sort(key=lambda x: abs(x[1][0] - x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 3:\n        current_cost1 = distance_matrix_1[new_solution[:-1], new_solution[1:]].sum()\n        current_cost2 = distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()\n        balance_factor = abs(current_cost1 - current_cost2) / (current_cost1 + current_cost2)\n\n        if balance_factor > 0.3:\n            start = np.random.randint(1, n-2)\n            end = np.random.randint(start+1, n)\n            new_solution[start:end] = new_solution[end-1:start-1:-1]\n        else:\n            seg_size = max(2, int(n * 0.3))\n            seg_start = np.random.randint(1, n-seg_size)\n            segment = new_solution[seg_start:seg_start+seg_size]\n            new_solution = np.concatenate([\n                new_solution[:seg_start],\n                new_solution[seg_start+seg_size:],\n                segment\n            ])\n            insert_pos = np.random.randint(1, n-seg_size+1)\n            new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8460879456176522,
            0.07456672191619873
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a quality-diversity trade-off strategy, then applies a novel \"objective-balanced path fusion\" operator that merges paths from multiple solutions while dynamically adjusting segment sizes based on the relative improvement potential in each objective space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1 and n > 4:\n        # Select diverse solutions for fusion\n        diverse_sols = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)[:2]\n        sol1, sol2 = diverse_sols[0][0], diverse_sols[1][0]\n\n        # Calculate objective improvement potential\n        obj1 = (distance_matrix_1[sol1[:-1], sol1[1:]].sum() + distance_matrix_2[sol1[:-1], sol1[1:]].sum()) / 2\n        obj2 = (distance_matrix_1[sol2[:-1], sol2[1:]].sum() + distance_matrix_2[sol2[:-1], sol2[1:]].sum()) / 2\n        total_obj = obj1 + obj2\n\n        # Determine fusion parameters\n        fusion_size = max(2, int(n * 0.25 * (obj1 / total_obj)))\n        pos1 = np.random.randint(1, n - fusion_size)\n        pos2 = np.random.randint(1, n - fusion_size)\n\n        # Create fused path\n        segment1 = sol1[pos1:pos1+fusion_size]\n        segment2 = sol2[pos2:pos2+fusion_size]\n\n        # Alternate between segments to create balanced fusion\n        fused_path = []\n        for i in range(fusion_size):\n            if i % 2 == 0:\n                fused_path.append(segment1[i])\n            else:\n                fused_path.append(segment2[i])\n\n        # Insert fused path into solution\n        new_solution = np.concatenate([\n            new_solution[:pos1],\n            np.array(fused_path),\n            new_solution[pos1+fusion_size:]\n        ])\n\n        # Ensure feasibility\n        if len(np.unique(new_solution)) != n:\n            # If duplicates exist, perform a simple swap to fix\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9742422714866608,
            0.13972818851470947
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a crowding-distance-aware selection strategy to prioritize solutions with better spread in the objective space, then applies a novel \"adaptive segment insertion\" operator that intelligently inserts segments from high-quality solutions while maintaining balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    sorted_archive = sorted(archive, key=lambda x: (x[1][0] * 0.7 + x[1][1] * 0.3) if len(archive) > 1 else 0)\n    base_solution = sorted_archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if len(archive) > 1 and n > 3:\n        # Select a high-quality solution with good crowding distance\n        high_quality_sol = sorted_archive[1][0] if len(sorted_archive) > 1 else base_solution\n\n        # Adaptive segment size based on solution quality\n        quality = (distance_matrix_1[high_quality_sol[:-1], high_quality_sol[1:]].sum() +\n                  distance_matrix_2[high_quality_sol[:-1], high_quality_sol[1:]].sum()) / (2 * n)\n        segment_size = max(2, int(n * 0.2 * (1 - quality / (quality + 1))))\n\n        # Find insertion point based on edge weights\n        insertion_point = np.argmax(distance_matrix_1[new_solution[:-1], new_solution[1:]]) + 1\n        segment_start = np.random.randint(1, n - segment_size)\n\n        # Insert segment from high-quality solution\n        segment = high_quality_sol[segment_start:segment_start+segment_size]\n\n        new_solution = np.concatenate([\n            new_solution[:insertion_point],\n            segment,\n            new_solution[insertion_point+segment_size:]\n        ])\n\n        # Ensure no duplicates\n        if len(np.unique(new_solution)) != n:\n            # If duplicates exist, perform a simple reversal to fix\n            a, b = sorted(np.random.choice(range(1, n-1), 2, replace=False))\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9595682375010659,
            0.11288154125213623
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines objective value balance and solution diversity, then applies a novel \"adaptive path inversion\" operator that dynamically adjusts inversion lengths based on the solution's current quality, followed by a \"multi-objective path rotation\" that rotates segments while considering both distance matrices to maintain balance between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    if len(archive) > 1:\n        diversity_sol = sorted(archive, key=lambda x: (x[1][0] - x[1][1])**2)[-1][0]\n        base_solution = np.concatenate([archive[0][0][:len(archive[0][0])//2], diversity_sol[len(diversity_sol)//2:]])\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        # Adaptive path inversion operator\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        inv_length = max(2, int(n * 0.2 * (1 - quality / (quality + 1))))\n\n        start = np.random.randint(1, n - inv_length)\n        end = start + inv_length\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    if n > 5:\n        # Multi-objective path rotation operator\n        rot_start = np.random.randint(1, n - 2)\n        rot_end = np.random.randint(rot_start + 1, n)\n        segment = new_solution[rot_start:rot_end]\n\n        def segment_cost(sol):\n            return (distance_matrix_1[sol[:-1], sol[1:]].sum() +\n                    distance_matrix_2[sol[:-1], sol[1:]].sum())\n\n        original_cost = segment_cost(segment)\n        rotated_cost = segment_cost(np.roll(segment, 1))\n\n        if rotated_cost < original_cost:\n            new_solution[rot_start:rot_end] = np.roll(segment, 1)\n\n    return new_solution\n\n",
        "score": [
            -0.9695137535969484,
            0.13841289281845093
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive based on the balance between its objectives' ratio and diversity, then applies a \"multi-objective segment insertion\" operator that intelligently inserts segments from the best solutions in each objective space while ensuring feasibility and maintaining a good trade-off between the objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution based on objective ratio and diversity\n    archive_sorted = sorted(archive, key=lambda x: (x[1][0] / x[1][1]) if x[1][1] != 0 else float('inf'))\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Find best solutions in each objective space\n    best_obj1 = min(archive, key=lambda x: x[1][0])[0]\n    best_obj2 = min(archive, key=lambda x: x[1][1])[0]\n\n    if n > 4:\n        # Multi-objective segment insertion\n        seg_size = max(2, n // 4)\n        seg_start = np.random.randint(1, n - seg_size)\n        seg_end = seg_start + seg_size\n\n        # Choose segment from best solutions with probability based on objective importance\n        if np.random.random() < 0.6:\n            segment = best_obj1[seg_start:seg_end]\n        else:\n            segment = best_obj2[seg_start:seg_end]\n\n        # Insert segment at random position\n        insert_pos = np.random.randint(1, n - seg_size)\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment,\n            new_solution[insert_pos:]\n        ])\n\n        # Remove duplicates by swapping with non-conflicting nodes\n        unique_nodes = set(new_solution)\n        if len(unique_nodes) != n:\n            for i in range(1, n-1):\n                if new_solution[i] in new_solution[:i] or new_solution[i] in new_solution[i+1:]:\n                    available_nodes = [node for node in range(n) if node not in unique_nodes]\n                    if available_nodes:\n                        new_solution[i] = np.random.choice(available_nodes)\n                        unique_nodes.add(new_solution[i])\n\n    return new_solution\n\n",
        "score": [
            -0.9533564934434349,
            0.09863150119781494
        ]
    },
    {
        "algorithm": "{This algorithm selects a solution from the archive using a hybrid selection strategy that combines Pareto dominance and crowding distance to prioritize solutions with good potential for improvement, then applies a novel \"adaptive segment relocation\" operator that dynamically adjusts segment sizes based on the solution's current quality, followed by a \"distance-aware segment reversal\" that reverses segments while considering the distance matrices to maintain balance between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    dominated = []\n    for i, (sol1, obj1) in enumerate(archive):\n        is_dominated = False\n        for j, (sol2, obj2) in enumerate(archive):\n            if i != j and obj2[0] <= obj1[0] and obj2[1] <= obj1[1] and (obj2[0] < obj1[0] or obj2[1] < obj1[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            dominated.append((sol1, obj1))\n\n    if not dominated:\n        dominated = archive.copy()\n\n    dominated.sort(key=lambda x: x[1][0])\n    for i in range(len(dominated)):\n        if i == 0 or i == len(dominated)-1:\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], float('inf')))\n        else:\n            dist = dominated[i+1][1][0] - dominated[i-1][1][0]\n            dominated[i] = (dominated[i][0], (dominated[i][1][0], dominated[i][1][1], dist))\n\n    dominated.sort(key=lambda x: -x[1][2])\n    base_solution = dominated[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if n > 4:\n        quality = (distance_matrix_1[new_solution[:-1], new_solution[1:]].sum() +\n                   distance_matrix_2[new_solution[:-1], new_solution[1:]].sum()) / (2 * n)\n        max_seg_size = max(2, int(n * 0.3 * (1 - quality / (quality + 1))))\n\n        seg_start = np.random.randint(1, n-max_seg_size)\n        seg_end = np.random.randint(seg_start+1, min(seg_start+max_seg_size, n))\n        insert_pos = np.random.randint(1, n)\n        segment = new_solution[seg_start:seg_end]\n\n        new_solution = np.concatenate([\n            new_solution[:seg_start],\n            new_solution[seg_end:],\n            segment\n        ])\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n        if len(np.unique(new_solution)) != n:\n            a, b = np.random.choice(range(1, n-1), 2, replace=False)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    if n > 5:\n        def segment_cost(start, end):\n            cost1 = distance_matrix_1[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            cost2 = distance_matrix_2[new_solution[start:end], new_solution[start+1:end+1]].sum()\n            return (cost1 + cost2) / 2\n\n        seg1_start = np.random.randint(1, n-3)\n        seg1_end = np.random.randint(seg1_start+1, n-2)\n        seg2_start = np.random.randint(seg1_end+1, n-1)\n        seg2_end = np.random.randint(seg2_start+1, n)\n\n        cost_before = segment_cost(seg1_start, seg1_end) + segment_cost(seg2_start, seg2_end)\n        cost_after = segment_cost(seg1_start, seg1_end-1) + segment_cost(seg2_start, seg2_end-1)\n\n        if cost_after < cost_before:\n            new_solution[seg1_start:seg1_end] = new_solution[seg1_start:seg1_end][::-1]\n            new_solution[seg2_start:seg2_end] = new_solution[seg2_start:seg2_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -1.010568590190644,
            0.27119147777557373
        ]
    }
]