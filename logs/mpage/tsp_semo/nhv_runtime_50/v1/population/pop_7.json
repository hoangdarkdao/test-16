[
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for other_sol, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive.copy()\n\n    # Step 2: Select a solution probabilistically based on non-domination rank and crowding distance\n    selected = random.choices(non_dominated, k=1)[0][0].copy()\n\n    # Step 3: Apply hybrid local search operator\n    new_solution = selected.copy()\n    n = len(new_solution)\n\n    # Variable-length segment relocation\n    if n > 3:\n        seg_length = random.randint(2, min(5, n-1))\n        start = random.randint(0, n - seg_length)\n        segment = new_solution[start:start+seg_length]\n        remaining = np.concatenate([new_solution[:start], new_solution[start+seg_length:]])\n        insert_pos = random.randint(0, len(remaining))\n        new_solution = np.concatenate([remaining[:insert_pos], segment, remaining[insert_pos:]])\n\n    # Biased 3-opt move\n    if n > 3:\n        i, j, k = sorted(random.sample(range(n), 3))\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[k-1], new_solution[k]]\n        current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n\n        # Try all possible 3-opt configurations\n        options = [\n            (new_solution[i:j][::-1], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j], new_solution[j:k][::-1], new_solution[k:]),\n            (new_solution[i:j][::-1], new_solution[j:k], new_solution[k:]),\n        ]\n\n        best_option = None\n        best_improvement = 0\n\n        for opt in options:\n            temp_sol = np.concatenate([new_solution[:i], opt[0], opt[1], opt[2]])\n            new_cost1 = sum(distance_matrix_1[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[i-1], temp_sol[i]] for i in range(1, n)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n\n            improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_option = opt\n\n        if best_option is not None:\n            new_solution = np.concatenate([new_solution[:i], best_option[0], best_option[1], best_option[2]])\n\n    # Ensure the solution is valid\n    if len(np.unique(new_solution)) != n:\n        # Repair mechanism: reorder nodes to form a valid tour\n        missing = set(range(n)) - set(new_solution)\n        new_solution = np.concatenate([new_solution, list(missing)])\n        new_solution = np.random.permutation(new_solution)\n\n    return new_solution\n\n",
          "score": [
               -0.9209101573486693,
               0.6316920518875122
          ]
     },
     {
          "algorithm": "{This new algorithm will select a solution from the archive based on a hybrid selection criterion that combines objective values and solution diversity, then apply a novel \"objective-aware segment rotation\" operator that rotates a randomly selected segment of the tour by a variable number of positions, with acceptance based on Pareto dominance or significant improvement in one objective while allowing controlled worsening in the other, ensuring feasibility by maintaining node uniqueness and completeness throughout the operation.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Hybrid selection: balance between objective values and solution diversity\n    archive.sort(key=lambda x: -(x[1][0] * 0.6 + x[1][1] * 0.4 + random.random() * 0.1))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Objective-aware segment rotation\n    for _ in range(5):\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(1, j - i) if j - i > 1 else 1\n\n        # Calculate cost before rotation\n        cost1_before = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n        cost2_before = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(i, j+1))\n\n        # Rotate the segment\n        temp_sol = new_solution.copy()\n        segment = temp_sol[i:j+1]\n        rotated = np.concatenate([segment[k:], segment[:k]])\n        temp_sol[i:j+1] = rotated\n\n        # Calculate cost after rotation\n        cost1_after = sum(distance_matrix_1[temp_sol[k-1], temp_sol[k]] for k in range(i, j+1))\n        cost2_after = sum(distance_matrix_2[temp_sol[k-1], temp_sol[k]] for k in range(i, j+1))\n\n        # Accept if Pareto dominates or significant improvement in one objective with controlled worsening in the other\n        if (cost1_after < cost1_before and cost2_after <= cost2_before) or \\\n           (cost1_after <= cost1_before and cost2_after < cost2_before) or \\\n           (cost1_after < 0.9 * cost1_before and cost2_after < 1.1 * cost2_before) or \\\n           (cost2_after < 0.9 * cost2_before and cost1_after < 1.1 * cost1_before):\n            new_solution = temp_sol\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.9910556685809437,
               0.7008278965950012
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive based on a novel multi-objective dominance metric that balances improvement potential in both objectives, then applies a hybrid local search operator that combines a dynamic path decomposition approach with a guided multi-segment relocation strategy, which intelligently reallocates segments of the tour between critical path components while maintaining feasibility, and finally incorporates an adaptive edge insertion mechanism that selectively inserts new edges between high-potential nodes while considering the trade-off between the two objectives through a probabilistic acceptance criterion.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select the most promising solution using a dominance-based metric\n    def dominance_metric(obj):\n        return -np.sqrt(obj[0]**2 + obj[1]**2)  # Negative for minimization\n\n    archive.sort(key=lambda x: dominance_metric(x[1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Dynamic path decomposition and segment relocation\n    if n > 3:\n        # Identify critical path components\n        critical_nodes = set()\n        for i in range(n):\n            node = base_solution[i]\n            prev_node = base_solution[i-1]\n            next_node = base_solution[(i+1)%n]\n\n            # Identify nodes that are critical in either objective\n            if (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] > np.mean(distance_matrix_1) or\n                distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] > np.mean(distance_matrix_2)):\n                critical_nodes.add(node)\n\n        # Decompose the path into segments\n        segments = []\n        current_segment = [base_solution[0]]\n        for i in range(1, n):\n            if base_solution[i] in critical_nodes and len(current_segment) > 1:\n                segments.append(current_segment)\n                current_segment = [base_solution[i]]\n            else:\n                current_segment.append(base_solution[i])\n        segments.append(current_segment)\n\n        # Relocate segments between critical components\n        if len(segments) > 1:\n            seg_idx = random.randint(0, len(segments)-1)\n            segment = segments.pop(seg_idx)\n            insert_pos = random.randint(0, len(segments)-1)\n            segments.insert(insert_pos, segment)\n\n            # Reconstruct the solution\n            new_solution = np.concatenate(segments)\n\n    # Step 3: Adaptive edge insertion mechanism\n    if n > 3:\n        # Identify high-potential insertion points\n        insertion_points = []\n        for i in range(n):\n            node = new_solution[i]\n            next_node = new_solution[(i+1)%n]\n\n            # Potential insertion points are between non-critical nodes\n            if node not in critical_nodes and next_node not in critical_nodes:\n                insertion_points.append((i, (i+1)%n))\n\n        if insertion_points:\n            # Select a random insertion point\n            i, j = random.choice(insertion_points)\n\n            # Find a high-potential node to insert\n            candidate_nodes = list(set(range(n)) - set(new_solution))\n            if candidate_nodes:\n                new_node = random.choice(candidate_nodes)\n\n                # Calculate potential improvement\n                current_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n                current_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n                new_cost1 = (distance_matrix_1[new_solution[i], new_node] +\n                             distance_matrix_1[new_node, new_solution[j]])\n                new_cost2 = (distance_matrix_2[new_solution[i], new_node] +\n                             distance_matrix_2[new_node, new_solution[j]])\n\n                # Accept with probability based on improvement\n                improvement1 = current_cost1 - new_cost1\n                improvement2 = current_cost2 - new_cost2\n\n                if (improvement1 > 0 and improvement2 > 0) or \\\n                   (random.random() < 0.5 and (improvement1 > 0 or improvement2 > 0)):\n                    new_solution = np.insert(new_solution, j, new_node)\n\n    # Ensure solution validity\n    if len(np.unique(new_solution)) != n:\n        # Simple repair: reinsert missing nodes at random positions\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            pos = random.randint(0, len(new_solution))\n            new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
          "score": [
               -1.0196944403878097,
               0.9443355202674866
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.8923786610963782,
               0.49988752603530884
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.8438410300868746,
               0.4513029456138611
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on non-dominated sorting\n    front = []\n    for i, (sol, obj) in enumerate(archive):\n        dominated = False\n        for j, (other_sol, other_obj) in enumerate(archive):\n            if i != j and other_obj[0] <= obj[0] and other_obj[1] <= obj[1] and (other_obj[0] < obj[0] or other_obj[1] < obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            front.append(i)\n\n    if not front:\n        front = [0]  # Fallback to first solution if no non-dominated solutions\n\n    best_idx = random.choice(front)\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover with objective-aware segment selection\n    if n > 3:\n        obj1, obj2 = archive[best_idx][1]\n        total_obj = obj1 + obj2\n        if total_obj == 0:\n            weight1, weight2 = 0.5, 0.5\n        else:\n            weight1 = obj1 / total_obj\n            weight2 = obj2 / total_obj\n\n        seg_length = max(2, min(5, int(weight1 * n)))\n        start = random.randint(0, n - seg_length)\n\n        # Create a new segment by combining nodes from both objectives\n        new_segment = []\n        for i in range(seg_length):\n            if random.random() < weight1:\n                new_segment.append(new_solution[(start + i) % n])\n            else:\n                new_segment.append(new_solution[(start + i + seg_length) % n])\n\n        new_solution[start:start+seg_length] = new_segment\n\n    # Step 3: Multi-objective edge insertion heuristic\n    if n > 3:\n        # Select a random edge to remove\n        i = random.randint(0, n-1)\n        removed_node = new_solution[i]\n\n        # Find best insertion position considering both objectives\n        best_pos = 0\n        best_score = float('inf')\n\n        for j in range(n-1):\n            if j == i or j == (i-1) % n:\n                continue\n\n            prev_node = new_solution[j]\n            next_node = new_solution[(j+1) % n]\n\n            cost1 = distance_matrix_1[prev_node, removed_node] + distance_matrix_1[removed_node, next_node] - distance_matrix_1[prev_node, next_node]\n            cost2 = distance_matrix_2[prev_node, removed_node] + distance_matrix_2[removed_node, next_node] - distance_matrix_2[prev_node, next_node]\n\n            score = weight1 * cost1 + weight2 * cost2\n\n            if score < best_score:\n                best_score = score\n                best_pos = j + 1\n\n        # Insert the removed node at the best position\n        new_solution = np.insert(new_solution, best_pos, removed_node)\n        if best_pos <= i:\n            new_solution = np.delete(new_solution, i+1)\n        else:\n            new_solution = np.delete(new_solution, i)\n\n    # Step 4: Feasibility check and repair\n    if len(np.unique(new_solution)) != n:\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            best_pos = random.randint(0, n-1)\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.44041365474180505,
               0.18295890092849731
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel hierarchical segment relocation operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-objective edge reversal heuristic that selectively reverses edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space, while also introducing a novel hierarchical segment relocation operator that dynamically determines segment lengths based on the relative costs of the two objectives.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Hierarchical segment relocation operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Relocate segments\n        segment1 = new_solution[start1:start1+seg_length1].copy()\n        segment2 = new_solution[start2:start2+seg_length2].copy()\n\n        new_solution = np.concatenate([\n            new_solution[:start1],\n            new_solution[start1+seg_length1:start2],\n            segment2,\n            new_solution[start2+seg_length2:],\n            segment1\n        ])\n\n    # Step 3: Guided multi-objective edge reversal heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try reversing edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1:j1+1] = temp_sol[i1:j1+1][::-1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.8016932942693178,
               0.21665549278259277
          ]
     },
     {
          "algorithm": "{The new algorithm first identifies the most promising solution in the archive by evaluating both objective values and selecting the one with the highest combined improvement potential, then applies a novel adaptive segment crossover operator that dynamically determines segment lengths based on the relative costs of the two objectives, followed by a guided multi-edge swap heuristic that selectively exchanges edges between the two tours while maintaining feasibility, and finally incorporates a probabilistic repair mechanism to ensure solution validity by intelligently reinserting missing nodes or resolving conflicts based on the relative importance of each objective space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select the most promising solution based on combined improvement potential\n    best_idx = 0\n    best_potential = float('-inf')\n    for i, (sol, obj) in enumerate(archive):\n        potential = -(obj[0] + obj[1])  # Negative for minimization\n        if potential > best_potential:\n            best_potential = potential\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive segment crossover operator\n    if n > 3:\n        # Determine segment lengths based on relative objective weights\n        weight1 = archive[best_idx][1][0] / (archive[best_idx][1][0] + archive[best_idx][1][1] + 1e-10)\n        weight2 = 1 - weight1\n\n        seg_length1 = max(2, min(5, int(weight1 * n)))\n        seg_length2 = max(2, min(5, int(weight2 * n)))\n\n        # Randomly select segments\n        start1 = random.randint(0, n - seg_length1)\n        start2 = random.randint(0, n - seg_length2)\n\n        # Swap segments\n        new_solution[start1:start1+seg_length1], new_solution[start2:start2+seg_length2] = \\\n            new_solution[start2:start2+seg_length2].copy(), new_solution[start1:start1+seg_length1].copy()\n\n    # Step 3: Guided multi-edge swap heuristic\n    if n > 3:\n        # Select two random edges from each tour\n        i1, j1 = sorted(random.sample(range(n), 2))\n        i2, j2 = sorted(random.sample(range(n), 2))\n\n        # Calculate potential improvements\n        current_cost1 = distance_matrix_1[new_solution[i1-1], new_solution[i1]] + distance_matrix_1[new_solution[j1-1], new_solution[j1]]\n        current_cost2 = distance_matrix_2[new_solution[i1-1], new_solution[i1]] + distance_matrix_2[new_solution[j1-1], new_solution[j1]]\n\n        # Try swapping edges\n        temp_sol = new_solution.copy()\n        temp_sol[i1], temp_sol[j1] = temp_sol[j1], temp_sol[i1]\n\n        new_cost1 = distance_matrix_1[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_1[temp_sol[j1-1], temp_sol[j1]]\n        new_cost2 = distance_matrix_2[temp_sol[i1-1], temp_sol[i1]] + distance_matrix_2[temp_sol[j1-1], temp_sol[j1]]\n\n        # Accept if both objectives improve or if one improves significantly\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 * 0.9 and new_cost2 < current_cost2 * 1.1) or \\\n           (new_cost1 < current_cost1 * 1.1 and new_cost2 < current_cost2 * 0.9):\n            new_solution = temp_sol\n\n    # Step 4: Probabilistic repair mechanism\n    if len(np.unique(new_solution)) != n:\n        # Identify missing nodes\n        missing = set(range(n)) - set(new_solution)\n        for node in missing:\n            # Find insertion position based on both objectives\n            best_pos = 0\n            best_score = float('inf')\n\n            for i in range(n):\n                # Calculate insertion cost considering both objectives\n                prev_node = new_solution[i-1]\n                next_node = new_solution[i]\n\n                cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] - distance_matrix_1[prev_node, next_node]\n                cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] - distance_matrix_2[prev_node, next_node]\n\n                # Weighted score based on relative objective importance\n                score = weight1 * cost1 + weight2 * cost2\n\n                if score < best_score:\n                    best_score = score\n                    best_pos = i\n\n            # Insert the missing node\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
          "score": [
               -0.5971599357255759,
               0.4110575318336487
          ]
     },
     {
          "algorithm": "{The new algorithm first employs a multi-objective Pareto front analysis to identify the most diverse solution in the archive, then applies a novel adaptive path relinking operator that constructs a new solution by combining segments from the selected solution and other archive members while balancing both objectives, followed by a dynamic node clustering heuristic that groups nodes based on their multi-objective proximity, and finally incorporates a probabilistic edge inversion mechanism that selectively reverses segments of the tour with a probability proportional to their relative improvement potential in both objective spaces.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify most diverse solution using Pareto front analysis\n    def dominates(a, b):\n        return (a[0] <= b[0] and a[1] <= b[1] and (a[0] < b[0] or a[1] < b[1]))\n\n    pareto_front = []\n    for sol, obj in archive:\n        is_dominated = False\n        to_remove = []\n        for i, (_, front_obj) in enumerate(pareto_front):\n            if dominates(front_obj, obj):\n                is_dominated = True\n                break\n            elif dominates(obj, front_obj):\n                to_remove.append(i)\n        if not is_dominated:\n            pareto_front = [pf for i, pf in enumerate(pareto_front) if i not in to_remove]\n            pareto_front.append((sol, obj))\n\n    if not pareto_front:\n        pareto_front = archive\n\n    # Select the most diverse solution (farthest from others in objective space)\n    if len(pareto_front) > 1:\n        max_dist = -1\n        selected_idx = 0\n        for i, (_, obj_i) in enumerate(pareto_front):\n            dist = 0\n            for j, (_, obj_j) in enumerate(pareto_front):\n                if i != j:\n                    dist += (obj_i[0] - obj_j[0])**2 + (obj_i[1] - obj_j[1])**2\n            if dist > max_dist:\n                max_dist = dist\n                selected_idx = i\n        base_solution = pareto_front[selected_idx][0].copy()\n    else:\n        base_solution = pareto_front[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Step 2: Adaptive path relinking operator\n    if n > 3 and len(archive) > 1:\n        # Select another solution from archive\n        other_idx = random.choice([i for i in range(len(archive)) if not np.array_equal(archive[i][0], base_solution)])\n        other_sol = archive[other_idx][0]\n\n        # Find common segments\n        for i in range(n):\n            if base_solution[i] == other_sol[i]:\n                # Try to extend the common segment\n                j = i + 1\n                while j < n and base_solution[j] == other_sol[j]:\n                    j += 1\n                if j - i > 2:  # Only consider segments longer than 2\n                    # Try to insert this segment into new_solution\n                    start = random.randint(0, n - (j-i))\n                    new_solution[start:start+(j-i)] = base_solution[i:j]\n\n    # Step 3: Dynamic node clustering heuristic\n    if n > 4:\n        # Cluster nodes based on multi-objective proximity\n        clusters = []\n        used = set()\n\n        while len(used) < n:\n            # Select a random unassigned node\n            current = random.choice([i for i in range(n) if i not in used])\n            cluster = [current]\n            used.add(current)\n\n            # Find nodes closest in both objective spaces\n            for _ in range(2):  # Limit cluster size\n                if len(used) >= n:\n                    break\n                last_node = cluster[-1]\n                best_node = None\n                best_score = float('inf')\n\n                for i in range(n):\n                    if i not in used:\n                        # Calculate multi-objective distance\n                        dist1 = distance_matrix_1[last_node, i]\n                        dist2 = distance_matrix_2[last_node, i]\n                        score = dist1 + dist2  # Simple sum for clustering\n\n                        if score < best_score:\n                            best_score = score\n                            best_node = i\n\n                if best_node is not None:\n                    cluster.append(best_node)\n                    used.add(best_node)\n\n            clusters.append(cluster)\n\n        # Rebuild solution by visiting clusters in order\n        new_order = []\n        for cluster in clusters:\n            # Randomly order nodes within cluster\n            new_order.extend(random.sample(cluster, len(cluster)))\n        new_solution = np.array(new_order)\n\n    # Step 4: Probabilistic edge inversion mechanism\n    for _ in range(3):  # Limit inversion attempts\n        # Select a random segment\n        seg_start = random.randint(0, n - 3)\n        seg_end = random.randint(seg_start + 2, min(seg_start + 5, n - 1))\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_end))\n        current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(seg_start, seg_end))\n\n        # Invert the segment\n        temp_sol = new_solution.copy()\n        temp_sol[seg_start:seg_end+1] = temp_sol[seg_start:seg_end+1][::-1]\n\n        # Calculate new segment cost\n        new_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[i+1]] for i in range(seg_start, seg_end))\n        new_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[i+1]] for i in range(seg_start, seg_end))\n\n        # Accept with probability based on improvement\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if improvement1 > 0 and improvement2 > 0:\n            new_solution = temp_sol\n        elif improvement1 > 0 or improvement2 > 0:\n            # Probabilistic acceptance\n            prob = min(1.0, 0.5 * (improvement1 / (current_cost1 + 1e-10) + improvement2 / (current_cost2 + 1e-10)))\n            if random.random() < prob:\n                new_solution = temp_sol\n\n    return new_solution\n\n",
          "score": [
               -0.9216141370597893,
               1.0688355565071106
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Select a promising solution (e.g., one with the lowest combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: segment inversion + multi-objective edge exchange\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        # Segment inversion\n        start = random.randint(0, n - 2)\n        end = random.randint(start + 1, n - 1)\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n        # Multi-objective edge exchange\n        for _ in range(5):\n            i, j = random.sample(range(n), 2)\n            if i > j:\n                i, j = j, i\n            # Swap edges (i, i+1) and (j, j+1) with (i, j) and (i+1, j+1)\n            new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n        # Ensure feasibility (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            break\n\n    return new_solution\n\n",
          "score": [
               -0.7895915616322705,
               0.45019596815109253
          ]
     }
]