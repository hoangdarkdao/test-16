[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 1,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658723702355473,
            0.5310291647911072
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 2,
        "algorithm": "{The heuristic selects a solution from the archive with the highest sum of normalized objective values, then applies a hybrid local search combining 3-opt with a novel adaptive segment reversal operator to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with adaptive segment reversal\n    for _ in range(10):  # Number of attempts\n        # Randomly select segments\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n\n        # Adaptive reversal decision\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Try different configurations\n        for config in [(segment1, segment2), (segment1[::-1], segment2), (segment1, segment2[::-1])]:\n            temp_solution = np.concatenate([new_solution[:a], config[0], config[1], new_solution[c:]])\n            cost_after = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] +\n                         distance_matrix_1[temp_solution[b-1], temp_solution[b]] +\n                         distance_matrix_1[temp_solution[c-1], temp_solution[c]] +\n                         distance_matrix_2[temp_solution[a-1], temp_solution[a]] +\n                         distance_matrix_2[temp_solution[b-1], temp_solution[b]] +\n                         distance_matrix_2[temp_solution[c-1], temp_solution[c]])\n\n            if cost_after < cost_before:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n",
        "score": [
            -0.6848665326133769,
            2.109489142894745
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: 3-opt with adaptive segment reversal\n    for _ in range(10):  # Number of attempts\n        # Randomly select segments\n        a, b, c = sorted(random.sample(range(1, n), 3))\n        segment1 = new_solution[a:b]\n        segment2 = new_solution[b:c]\n\n        # Adaptive reversal decision\n        cost_before = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_1[new_solution[c-1], new_solution[c]] +\n                      distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                      distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                      distance_matrix_2[new_solution[c-1], new_solution[c]])\n\n        # Try different configurations\n        for config in [(segment1, segment2), (segment1[::-1], segment2), (segment1, segment2[::-1])]:\n            temp_solution = np.concatenate([new_solution[:a], config[0], config[1], new_solution[c:]])\n            cost_after = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] +\n                         distance_matrix_1[temp_solution[b-1], temp_solution[b]] +\n                         distance_matrix_1[temp_solution[c-1], temp_solution[c]] +\n                         distance_matrix_2[temp_solution[a-1], temp_solution[a]] +\n                         distance_matrix_2[temp_solution[b-1], temp_solution[b]] +\n                         distance_matrix_2[temp_solution[c-1], temp_solution[c]])\n\n            if cost_after < cost_before:\n                new_solution = temp_solution\n                break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9616101432470179,
            0.2687221169471741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9616101432470179,
            0.2687221169471741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 3,
        "algorithm": "{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9616101432470179,
            0.2687221169471741
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}. \n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 4,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify (3-opt-like move)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a novel move that considers both distance matrices\n    # Instead of just reversing segments, we swap segments and consider the effect on both objectives\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Calculate the cost of the current and alternative configurations\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1 + cost2\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try different configurations\n    candidates = [\n        np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]])\n    ]\n\n    best_candidate = min(candidates, key=lambda x: calculate_cost(x))\n\n    if calculate_cost(best_candidate) < current_cost:\n        new_solution = best_candidate\n\n    # Additional move: swap two nodes based on the combined distance improvement\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost difference for both objectives\n        cost_diff = (\n            (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]])\n            - (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            + (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]])\n            - (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n        )\n\n        if cost_diff < 0:  # If improvement is found\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8554928095864702,
            0.7201950550079346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n\n    # Hybrid local search: combine 3-opt with a novel move that considers both objectives\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to modify (3-opt-like move)\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Apply a novel move that considers both distance matrices\n    # Instead of just reversing segments, we swap segments and consider the effect on both objectives\n    segment1 = new_solution[i:j]\n    segment2 = new_solution[j:k]\n\n    # Calculate the cost of the current and alternative configurations\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i-1], solution[i]] for i in range(len(solution)))\n        cost2 = sum(distance_matrix_2[solution[i-1], solution[i]] for i in range(len(solution)))\n        return cost1 + cost2\n\n    current_cost = calculate_cost(new_solution)\n\n    # Try different configurations\n    candidates = [\n        np.concatenate([new_solution[:i], segment2, segment1, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment2[::-1], segment1, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment1, segment2, new_solution[k:]]),\n        np.concatenate([new_solution[:i], segment1[::-1], segment2, new_solution[k:]])\n    ]\n\n    best_candidate = min(candidates, key=lambda x: calculate_cost(x))\n\n    if calculate_cost(best_candidate) < current_cost:\n        new_solution = best_candidate\n\n    # Additional move: swap two nodes based on the combined distance improvement\n    for _ in range(10):  # Limit iterations to avoid excessive computation\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n\n        # Calculate the cost difference for both objectives\n        cost_diff = (\n            (distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b], new_solution[(a+1)%n]])\n            - (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n            + (distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b], new_solution[(a+1)%n]])\n            - (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n        )\n\n        if cost_diff < 0:  # If improvement is found\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic path inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    inverted_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    inverted_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If inversion doesn't improve both objectives, revert to the original segment\n    if not (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2):\n        new_solution[a:b+1] = base_solution[a:b+1]\n\n    # Apply a random 2-opt move to further explore the neighborhood\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8674259110383332,
            0.25493323802948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    inverted_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    inverted_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If inversion doesn't improve both objectives, revert to the original segment\n    if not (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2):\n        new_solution[a:b+1] = base_solution[a:b+1]\n\n    # Apply a random 2-opt move to further explore the neighborhood\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 5,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic path inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    inverted_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    inverted_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If inversion doesn't improve both objectives, revert to the original segment\n    if not (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2):\n        new_solution[a:b+1] = base_solution[a:b+1]\n\n    # Apply a random 2-opt move to further explore the neighborhood\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8674259110383332,
            0.25493323802948
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    inverted_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    inverted_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If inversion doesn't improve both objectives, revert to the original segment\n    if not (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2):\n        new_solution[a:b+1] = base_solution[a:b+1]\n\n    # Apply a random 2-opt move to further explore the neighborhood\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 6,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment in both objectives\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the reversed segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], temp_solution[a:b+1], temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], new_solution[a:b+1], new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8032377952302406,
            0.3646097779273987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment in both objectives\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the reversed segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], temp_solution[a:b+1], temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], new_solution[a:b+1], new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 7,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate the current cost of the tour in both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify nodes with high potential for improvement\n    improvement_candidates = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement if this node is moved\n        potential_cost1 = current_cost1 - distance_matrix_1[prev_node, node] - distance_matrix_1[node, next_node]\n        potential_cost2 = current_cost2 - distance_matrix_2[prev_node, node] - distance_matrix_2[node, next_node]\n\n        # Find alternative nodes to insert this node between\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n            alt_prev_node = new_solution[j]\n            alt_next_node = new_solution[(j+1)%n]\n\n            new_cost1 = potential_cost1 + distance_matrix_1[alt_prev_node, node] + distance_matrix_1[node, alt_next_node]\n            new_cost2 = potential_cost2 + distance_matrix_2[alt_prev_node, node] + distance_matrix_2[node, alt_next_node]\n\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                improvement_candidates.append((i, j, new_cost1, new_cost2))\n\n    # Apply the best improvement if available\n    if improvement_candidates:\n        # Sort by combined improvement (weighted sum of both objectives)\n        improvement_candidates.sort(key=lambda x: (x[2] + x[3]))\n        best_i, best_j, _, _ = improvement_candidates[0]\n\n        # Perform the move\n        node = new_solution[best_i]\n        new_solution = np.concatenate([\n            new_solution[:best_i],\n            new_solution[best_i+1:best_j+1],\n            new_solution[best_j+1:],\n            [node]\n        ])\n    else:\n        # If no improvement found, perform a random 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[a:b+1][::-1],\n            new_solution[b+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7621278977554716,
            0.5971089601516724
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate the current cost of the tour in both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify nodes with high potential for improvement\n    improvement_candidates = []\n    for i in range(n):\n        node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate potential improvement if this node is moved\n        potential_cost1 = current_cost1 - distance_matrix_1[prev_node, node] - distance_matrix_1[node, next_node]\n        potential_cost2 = current_cost2 - distance_matrix_2[prev_node, node] - distance_matrix_2[node, next_node]\n\n        # Find alternative nodes to insert this node between\n        for j in range(n):\n            if j == i or j == (i-1)%n or j == (i+1)%n:\n                continue\n            alt_prev_node = new_solution[j]\n            alt_next_node = new_solution[(j+1)%n]\n\n            new_cost1 = potential_cost1 + distance_matrix_1[alt_prev_node, node] + distance_matrix_1[node, alt_next_node]\n            new_cost2 = potential_cost2 + distance_matrix_2[alt_prev_node, node] + distance_matrix_2[node, alt_next_node]\n\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                improvement_candidates.append((i, j, new_cost1, new_cost2))\n\n    # Apply the best improvement if available\n    if improvement_candidates:\n        # Sort by combined improvement (weighted sum of both objectives)\n        improvement_candidates.sort(key=lambda x: (x[2] + x[3]))\n        best_i, best_j, _, _ = improvement_candidates[0]\n\n        # Perform the move\n        node = new_solution[best_i]\n        new_solution = np.concatenate([\n            new_solution[:best_i],\n            new_solution[best_i+1:best_j+1],\n            new_solution[best_j+1:],\n            [node]\n        ])\n    else:\n        # If no improvement found, perform a random 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([\n            new_solution[:a],\n            new_solution[a:b+1][::-1],\n            new_solution[b+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 8,
        "algorithm": "{This algorithm employs a multi-stage approach that combines adaptive segment reversal with objective-aware edge replacement, where solutions are selected based on their non-dominated front status and then perturbed by reversing high-cost segments while strategically replacing edges with those showing potential for cost improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined cost (sum of both objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost1 + cost2 for _, (cost1, cost2) in archive]\n    selected_idx = np.argmin(archive_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Stage 1: Identify and reverse high-cost segments\n    max_segment_length = min(5, n // 2)  # Limit segment length to prevent excessive disruption\n    segment_start = random.randint(0, n - max_segment_length)\n    segment_end = segment_start + random.randint(1, max_segment_length)\n\n    # Calculate segment cost in both objectives\n    segment = new_solution[segment_start:segment_end]\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment if it's high cost in either objective\n    if segment_cost1 > np.mean(distance_matrix_1) or segment_cost2 > np.mean(distance_matrix_2):\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n    # Stage 2: Edge replacement based on potential improvement\n    for i in range(n):\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Find potential replacement edges\n        candidates = []\n        for j in range(n):\n            if j != i and j != (i+1)%n:\n                candidate_cost1 = distance_matrix_1[current_node, new_solution[j]] + distance_matrix_1[new_solution[j], next_node]\n                original_cost1 = distance_matrix_1[current_node, next_node]\n                candidate_cost2 = distance_matrix_2[current_node, new_solution[j]] + distance_matrix_2[new_solution[j], next_node]\n                original_cost2 = distance_matrix_2[current_node, next_node]\n\n                if (candidate_cost1 < original_cost1 and candidate_cost2 < original_cost2):\n                    candidates.append((j, candidate_cost1 + candidate_cost2))\n\n        if candidates:\n            # Select the best candidate based on combined cost improvement\n            best_candidate = min(candidates, key=lambda x: x[1])\n            # Perform the edge replacement\n            new_solution[(i+1)%n] = new_solution[best_candidate[0]]\n            # Ensure the tour remains valid by removing duplicates\n            mask = np.ones(n, dtype=bool)\n            _, idx = np.unique(new_solution, return_index=True)\n            mask[idx] = False\n            # Fill missing nodes by inserting them at random positions\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            for node in missing_nodes:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n",
        "score": [
            -0.748851731878384,
            1.1129538416862488
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined cost (sum of both objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_costs = [cost1 + cost2 for _, (cost1, cost2) in archive]\n    selected_idx = np.argmin(archive_costs)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Stage 1: Identify and reverse high-cost segments\n    max_segment_length = min(5, n // 2)  # Limit segment length to prevent excessive disruption\n    segment_start = random.randint(0, n - max_segment_length)\n    segment_end = segment_start + random.randint(1, max_segment_length)\n\n    # Calculate segment cost in both objectives\n    segment = new_solution[segment_start:segment_end]\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment if it's high cost in either objective\n    if segment_cost1 > np.mean(distance_matrix_1) or segment_cost2 > np.mean(distance_matrix_2):\n        new_solution[segment_start:segment_end] = segment[::-1]\n\n    # Stage 2: Edge replacement based on potential improvement\n    for i in range(n):\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Find potential replacement edges\n        candidates = []\n        for j in range(n):\n            if j != i and j != (i+1)%n:\n                candidate_cost1 = distance_matrix_1[current_node, new_solution[j]] + distance_matrix_1[new_solution[j], next_node]\n                original_cost1 = distance_matrix_1[current_node, next_node]\n                candidate_cost2 = distance_matrix_2[current_node, new_solution[j]] + distance_matrix_2[new_solution[j], next_node]\n                original_cost2 = distance_matrix_2[current_node, next_node]\n\n                if (candidate_cost1 < original_cost1 and candidate_cost2 < original_cost2):\n                    candidates.append((j, candidate_cost1 + candidate_cost2))\n\n        if candidates:\n            # Select the best candidate based on combined cost improvement\n            best_candidate = min(candidates, key=lambda x: x[1])\n            # Perform the edge replacement\n            new_solution[(i+1)%n] = new_solution[best_candidate[0]]\n            # Ensure the tour remains valid by removing duplicates\n            mask = np.ones(n, dtype=bool)\n            _, idx = np.unique(new_solution, return_index=True)\n            mask[idx] = False\n            # Fill missing nodes by inserting them at random positions\n            missing_nodes = np.setdiff1d(np.arange(n), new_solution)\n            for node in missing_nodes:\n                pos = random.randint(0, n-1)\n                new_solution = np.insert(new_solution, pos, node)[:n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 9,
        "algorithm": "{This novel algorithm employs a multi-objective guided edge swapping mechanism that dynamically selects and exchanges edges based on their potential to improve both objectives simultaneously, while maintaining feasibility through a probabilistic validation step that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = random.sample(range(n), 2)\n\n    # Get the edges to swap\n    edge1 = (new_solution[i], new_solution[(i+1)%n])\n    edge2 = (new_solution[j], new_solution[(j+1)%n])\n\n    # Calculate the cost of the current edges in both objectives\n    cost1 = distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]]\n    cost2 = distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]]\n\n    # Calculate the cost of the swapped edges\n    swapped_edge1 = (edge1[0], edge2[1])\n    swapped_edge2 = (edge2[0], edge1[1])\n    swapped_cost1 = distance_matrix_1[swapped_edge1[0], swapped_edge1[1]] + distance_matrix_1[swapped_edge2[0], swapped_edge2[1]]\n    swapped_cost2 = distance_matrix_2[swapped_edge1[0], swapped_edge1[1]] + distance_matrix_2[swapped_edge2[0], swapped_edge2[1]]\n\n    # Apply the swap if it improves both objectives\n    if swapped_cost1 < cost1 and swapped_cost2 < cost2:\n        # Perform the edge swap\n        new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n    else:\n        # If no improvement, perform a probabilistic swap based on cost reduction\n        if random.random() < 0.5:  # 50% chance to swap anyway for exploration\n            new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n\n    return new_solution\n\n",
        "score": [
            -0.9065634897084227,
            0.32492685317993164
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct edges to swap\n    i, j = random.sample(range(n), 2)\n\n    # Get the edges to swap\n    edge1 = (new_solution[i], new_solution[(i+1)%n])\n    edge2 = (new_solution[j], new_solution[(j+1)%n])\n\n    # Calculate the cost of the current edges in both objectives\n    cost1 = distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]]\n    cost2 = distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]]\n\n    # Calculate the cost of the swapped edges\n    swapped_edge1 = (edge1[0], edge2[1])\n    swapped_edge2 = (edge2[0], edge1[1])\n    swapped_cost1 = distance_matrix_1[swapped_edge1[0], swapped_edge1[1]] + distance_matrix_1[swapped_edge2[0], swapped_edge2[1]]\n    swapped_cost2 = distance_matrix_2[swapped_edge1[0], swapped_edge1[1]] + distance_matrix_2[swapped_edge2[0], swapped_edge2[1]]\n\n    # Apply the swap if it improves both objectives\n    if swapped_cost1 < cost1 and swapped_cost2 < cost2:\n        # Perform the edge swap\n        new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n    else:\n        # If no improvement, perform a probabilistic swap based on cost reduction\n        if random.random() < 0.5:  # 50% chance to swap anyway for exploration\n            new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 10,
        "algorithm": "{This novel algorithm combines multi-objective solution selection with a dynamic node reordering strategy that identifies critical nodes in both objective spaces, then systematically reorders them to balance the trade-off between objectives while preserving tour feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes in both objectives\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Check if this node is critical in either objective\n        if (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] >\n            distance_matrix_1[prev_node, next_node]):\n            critical_nodes.add(i)\n\n        if (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] >\n            distance_matrix_2[prev_node, next_node]):\n            critical_nodes.add(i)\n\n    if not critical_nodes:\n        # If no critical nodes found, perform a random 3-opt\n        a, b, c = random.sample(range(n), 3)\n        a, b, c = sorted([a, b, c])\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        return new_solution\n\n    # Select a critical node to reorder\n    critical_idx = random.choice(list(critical_nodes))\n    node = base_solution[critical_idx]\n\n    # Find the best position to insert this node to balance objectives\n    best_pos = -1\n    best_balance = float('inf')\n\n    for pos in range(n):\n        if pos == critical_idx or pos == (critical_idx - 1) % n or pos == (critical_idx + 1) % n:\n            continue  # Skip adjacent nodes to maintain stability\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:critical_idx], temp_solution[critical_idx+1:]])\n\n        # Calculate the new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate balance metric (difference between objectives)\n        balance = abs(new_cost1 - new_cost2)\n\n        if balance < best_balance:\n            best_balance = balance\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:critical_idx], new_solution[critical_idx+1:]])\n    else:\n        # If no better position found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8642918939253617,
            0.6560525298118591
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes in both objectives\n    critical_nodes = set()\n    for i in range(n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n        next_node = base_solution[(i+1)%n]\n\n        # Check if this node is critical in either objective\n        if (distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node] >\n            distance_matrix_1[prev_node, next_node]):\n            critical_nodes.add(i)\n\n        if (distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node] >\n            distance_matrix_2[prev_node, next_node]):\n            critical_nodes.add(i)\n\n    if not critical_nodes:\n        # If no critical nodes found, perform a random 3-opt\n        a, b, c = random.sample(range(n), 3)\n        a, b, c = sorted([a, b, c])\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        new_solution[b:c+1] = new_solution[b:c+1][::-1]\n        return new_solution\n\n    # Select a critical node to reorder\n    critical_idx = random.choice(list(critical_nodes))\n    node = base_solution[critical_idx]\n\n    # Find the best position to insert this node to balance objectives\n    best_pos = -1\n    best_balance = float('inf')\n\n    for pos in range(n):\n        if pos == critical_idx or pos == (critical_idx - 1) % n or pos == (critical_idx + 1) % n:\n            continue  # Skip adjacent nodes to maintain stability\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:critical_idx], temp_solution[critical_idx+1:]])\n\n        # Calculate the new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate balance metric (difference between objectives)\n        balance = abs(new_cost1 - new_cost2)\n\n        if balance < best_balance:\n            best_balance = balance\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:critical_idx], new_solution[critical_idx+1:]])\n    else:\n        # If no better position found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 11,
        "algorithm": "{This novel algorithm combines a multi-objective edge selection criterion with a dynamic path reversal operator that prioritizes edges with high potential for cost reduction in both objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the original segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Reverse the segment\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment\n    reversed_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n    reversed_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Check if the reversal improves both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        new_solution = temp_solution\n    else:\n        # If not, try to find the best edge to swap\n        best_cost1, best_cost2 = float('inf'), float('inf')\n        best_swap = None\n\n        for i in range(a, b+1):\n            for j in range(n):\n                if j >= a and j <= b:\n                    continue\n\n                # Try swapping nodes i and j\n                temp_swap = new_solution.copy()\n                temp_swap[i], temp_swap[j] = temp_swap[j], temp_swap[i]\n\n                # Calculate the new cost\n                new_cost1 = sum(distance_matrix_1[temp_swap[k], temp_swap[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_swap[k], temp_swap[(k+1)%n]] for k in range(n))\n\n                # Check if this is better in both objectives\n                if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n                    best_cost1, best_cost2 = new_cost1, new_cost2\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n        else:\n            # If no better swap found, perform a random reversal\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8874368500851214,
            1.8807995915412903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the original segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Reverse the segment\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment\n    reversed_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n    reversed_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Check if the reversal improves both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        new_solution = temp_solution\n    else:\n        # If not, try to find the best edge to swap\n        best_cost1, best_cost2 = float('inf'), float('inf')\n        best_swap = None\n\n        for i in range(a, b+1):\n            for j in range(n):\n                if j >= a and j <= b:\n                    continue\n\n                # Try swapping nodes i and j\n                temp_swap = new_solution.copy()\n                temp_swap[i], temp_swap[j] = temp_swap[j], temp_swap[i]\n\n                # Calculate the new cost\n                new_cost1 = sum(distance_matrix_1[temp_swap[k], temp_swap[(k+1)%n]] for k in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_swap[k], temp_swap[(k+1)%n]] for k in range(n))\n\n                # Check if this is better in both objectives\n                if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n                    best_cost1, best_cost2 = new_cost1, new_cost2\n                    best_swap = (i, j)\n\n        if best_swap is not None:\n            new_solution[best_swap[0]], new_solution[best_swap[1]] = new_solution[best_swap[1]], new_solution[best_swap[0]]\n        else:\n            # If no better swap found, perform a random reversal\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 12,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node clustering operator that identifies and reorganizes high-potential node clusters in both objective spaces, using a weighted distance metric to prioritize cost reduction while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify clusters of nodes that are close in both objective spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Calculate weighted distance between consecutive nodes\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n        weighted_dist = 0.5 * dist1 + 0.5 * dist2  # Equal weight for both objectives\n\n        # If the distance is below a threshold, add to current cluster\n        if weighted_dist < 1.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)) / 2:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # If no clusters found, perform a random swap\n    if not clusters:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a random cluster to perturb\n    cluster_idx = random.randint(0, len(clusters) - 1)\n    cluster = clusters[cluster_idx]\n\n    # Find the best position to reinsert the cluster\n    best_cost = float('inf')\n    best_insert_pos = -1\n    cluster_len = len(cluster)\n\n    for pos in range(n - cluster_len + 1):\n        # Skip if the cluster is already in this position\n        if pos == cluster.index(cluster[0]):\n            continue\n\n        # Try inserting the cluster at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], cluster, temp_solution[pos+cluster_len:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        weighted_cost = 0.5 * new_cost1 + 0.5 * new_cost2\n\n        if weighted_cost < best_cost:\n            best_cost = weighted_cost\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], cluster, new_solution[best_insert_pos+cluster_len:]])\n    else:\n        # If no better insertion found, reverse the cluster\n        cluster_start = new_solution.tolist().index(cluster[0])\n        cluster_end = cluster_start + len(cluster)\n        new_solution[cluster_start:cluster_end] = cluster[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9313344304561648,
            1.6820234060287476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify clusters of nodes that are close in both objective spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        node = base_solution[i]\n        prev_node = base_solution[i-1]\n\n        # Calculate weighted distance between consecutive nodes\n        dist1 = distance_matrix_1[prev_node, node]\n        dist2 = distance_matrix_2[prev_node, node]\n        weighted_dist = 0.5 * dist1 + 0.5 * dist2  # Equal weight for both objectives\n\n        # If the distance is below a threshold, add to current cluster\n        if weighted_dist < 1.5 * (np.mean(distance_matrix_1) + np.mean(distance_matrix_2)) / 2:\n            current_cluster.append(node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # If no clusters found, perform a random swap\n    if not clusters:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a random cluster to perturb\n    cluster_idx = random.randint(0, len(clusters) - 1)\n    cluster = clusters[cluster_idx]\n\n    # Find the best position to reinsert the cluster\n    best_cost = float('inf')\n    best_insert_pos = -1\n    cluster_len = len(cluster)\n\n    for pos in range(n - cluster_len + 1):\n        # Skip if the cluster is already in this position\n        if pos == cluster.index(cluster[0]):\n            continue\n\n        # Try inserting the cluster at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], cluster, temp_solution[pos+cluster_len:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        weighted_cost = 0.5 * new_cost1 + 0.5 * new_cost2\n\n        if weighted_cost < best_cost:\n            best_cost = weighted_cost\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], cluster, new_solution[best_insert_pos+cluster_len:]])\n    else:\n        # If no better insertion found, reverse the cluster\n        cluster_start = new_solution.tolist().index(cluster[0])\n        cluster_end = cluster_start + len(cluster)\n        new_solution[cluster_start:cluster_end] = cluster[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 13,
        "algorithm": "{This algorithm uses a multi-objective selection criterion to choose a solution from the archive, then applies a dynamic edge exchange operator that prioritizes edges with high potential for cost reduction in both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a multi-objective criterion\n    selected_solution, (cost1, cost2) = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Dynamic edge exchange operator\n    for _ in range(2):\n        # Select two random edges to exchange\n        i, j = random.sample(range(n), 2)\n        a, b = sorted([i, j])\n\n        # Extract the two edges\n        edge1 = (base_solution[a], base_solution[(a+1)%n])\n        edge2 = (base_solution[b], base_solution[(b+1)%n])\n\n        # Calculate the cost of the edges in both objectives\n        cost1_edge1 = distance_matrix_1[edge1[0], edge1[1]]\n        cost2_edge1 = distance_matrix_2[edge1[0], edge1[1]]\n        cost1_edge2 = distance_matrix_1[edge2[0], edge2[1]]\n        cost2_edge2 = distance_matrix_2[edge2[0], edge2[1]]\n\n        # Calculate the potential cost reduction\n        delta_cost1 = cost1_edge1 + cost1_edge2 - distance_matrix_1[edge1[0], edge2[1]] - distance_matrix_1[edge2[0], edge1[1]]\n        delta_cost2 = cost2_edge1 + cost2_edge2 - distance_matrix_2[edge1[0], edge2[1]] - distance_matrix_2[edge2[0], edge1[1]]\n\n        # If the exchange reduces both costs, apply it\n        if delta_cost1 < 0 and delta_cost2 < 0:\n            new_solution[(a+1)%n], new_solution[(b+1)%n] = new_solution[(b+1)%n], new_solution[(a+1)%n]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7737424031432457,
            0.8200111389160156
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a multi-objective criterion\n    selected_solution, (cost1, cost2) = max(archive, key=lambda x: (x[1][0] + x[1][1]) / (x[1][0] * x[1][1] if x[1][0] * x[1][1] != 0 else 1))\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n\n    # Dynamic edge exchange operator\n    for _ in range(2):\n        # Select two random edges to exchange\n        i, j = random.sample(range(n), 2)\n        a, b = sorted([i, j])\n\n        # Extract the two edges\n        edge1 = (base_solution[a], base_solution[(a+1)%n])\n        edge2 = (base_solution[b], base_solution[(b+1)%n])\n\n        # Calculate the cost of the edges in both objectives\n        cost1_edge1 = distance_matrix_1[edge1[0], edge1[1]]\n        cost2_edge1 = distance_matrix_2[edge1[0], edge1[1]]\n        cost1_edge2 = distance_matrix_1[edge2[0], edge2[1]]\n        cost2_edge2 = distance_matrix_2[edge2[0], edge2[1]]\n\n        # Calculate the potential cost reduction\n        delta_cost1 = cost1_edge1 + cost1_edge2 - distance_matrix_1[edge1[0], edge2[1]] - distance_matrix_1[edge2[0], edge1[1]]\n        delta_cost2 = cost2_edge1 + cost2_edge2 - distance_matrix_2[edge1[0], edge2[1]] - distance_matrix_2[edge2[0], edge1[1]]\n\n        # If the exchange reduces both costs, apply it\n        if delta_cost1 < 0 and delta_cost2 < 0:\n            new_solution[(a+1)%n], new_solution[(b+1)%n] = new_solution[(b+1)%n], new_solution[(a+1)%n]\n\n    # Ensure the solution remains feasible\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 14,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to break and reconnect\n    a = random.randint(0, n - 1)\n    b = (a + random.randint(2, n - 2)) % n  # Ensure b is not adjacent to a\n\n    # Extract the segment between a and b\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9059627892844242,
            0.6883365511894226
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to break and reconnect\n    a = random.randint(0, n - 1)\n    b = (a + random.randint(2, n - 2)) % n  # Ensure b is not adjacent to a\n\n    # Extract the segment between a and b\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 15,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment rotation with multi-objective node insertion, where critical segments are dynamically rotated based on both objective costs, while promising nodes are selectively inserted to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_costs, axis=1)\n    potential_scores = diversity_scores * (1 - np.mean(normalized_costs, axis=1))\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[i:j+1] = rotated_segment\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        if a != 0 and b != n-1:\n            inserted_node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, inserted_node)\n\n    return new_solution\n\n",
        "score": [
            -0.879592077254018,
            0.39339351654052734
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    diversity_scores = np.std(normalized_costs, axis=1)\n    potential_scores = diversity_scores * (1 - np.mean(normalized_costs, axis=1))\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        rotation = random.randint(1, len(segment)-1)\n        rotated_segment = np.roll(segment, rotation)\n        new_solution[i:j+1] = rotated_segment\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        if a != 0 and b != n-1:\n            inserted_node = new_solution[a]\n            new_solution = np.delete(new_solution, a)\n            new_solution = np.insert(new_solution, b, inserted_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 16,
        "algorithm": "{This novel hybrid local search strategy combines adaptive segment relocation with dynamic multi-objective edge prioritization, where segments are intelligently relocated based on their potential to reduce both objectives, while critical edges are selectively prioritized and exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with probability inversely proportional to its normalized cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selection_probs = 1 / (1 + np.sum(normalized_costs, axis=1))\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Find best relocation position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= i and pos <= j:\n                continue\n\n            # Try inserting segment at position 'pos'\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Calculate improvement\n            improvement = (seg_cost1 - sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(pos, pos+len(segment)))) + \\\n                         (seg_cost2 - sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(pos, pos+len(segment))))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic edge prioritization\n    else:\n        # Identify critical edges based on both objectives\n        edge_scores = []\n        for k in range(n):\n            i, j = new_solution[k], new_solution[(k+1)%n]\n            score = distance_matrix_1[i,j] + distance_matrix_2[i,j]\n            edge_scores.append((score, k))\n\n        # Sort edges by priority (highest score first)\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n        # Select top 30% edges for potential exchange\n        num_edges = max(1, int(0.3 * n))\n        critical_edges = [idx for (score, idx) in edge_scores[:num_edges]]\n\n        if critical_edges:\n            # Select two edges to exchange\n            a, b = random.sample(critical_edges, 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.632770492331934,
            0.46052950620651245
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with probability inversely proportional to its normalized cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selection_probs = 1 / (1 + np.sum(normalized_costs, axis=1))\n    selection_probs /= selection_probs.sum()\n    selected_idx = np.random.choice(len(archive), p=selection_probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n        # Find best relocation position\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= i and pos <= j:\n                continue\n\n            # Try inserting segment at position 'pos'\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Calculate improvement\n            improvement = (seg_cost1 - sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(pos, pos+len(segment)))) + \\\n                         (seg_cost2 - sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(pos, pos+len(segment))))\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Dynamic edge prioritization\n    else:\n        # Identify critical edges based on both objectives\n        edge_scores = []\n        for k in range(n):\n            i, j = new_solution[k], new_solution[(k+1)%n]\n            score = distance_matrix_1[i,j] + distance_matrix_2[i,j]\n            edge_scores.append((score, k))\n\n        # Sort edges by priority (highest score first)\n        edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n        # Select top 30% edges for potential exchange\n        num_edges = max(1, int(0.3 * n))\n        critical_edges = [idx for (score, idx) in edge_scores[:num_edges]]\n\n        if critical_edges:\n            # Select two edges to exchange\n            a, b = random.sample(critical_edges, 2)\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 17,
        "algorithm": "{A novel hybrid local search algorithm combines multi-objective path relinking with adaptive node reinsertion, where segments are dynamically extracted from high-quality solutions and reinserted at positions that show promise in both objective spaces, while critical nodes are strategically repositioned to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Path relinking with adaptive reinsertion\n    if random.random() < 0.6:\n        # Path relinking: Extract a segment from another solution\n        other_idx = (selected_idx + 1) % len(archive)\n        other_solution = archive[other_idx][0]\n        i, j = sorted(random.sample(range(n), 2))\n        segment = other_solution[i:j+1]\n\n        # Find best insertion point in new_solution\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n):\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # Adaptive node reinsertion\n        node = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n):\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.29795046227534705,
            1.0108014941215515
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator: Path relinking with adaptive reinsertion\n    if random.random() < 0.6:\n        # Path relinking: Extract a segment from another solution\n        other_idx = (selected_idx + 1) % len(archive)\n        other_solution = archive[other_idx][0]\n        i, j = sorted(random.sample(range(n), 2))\n        segment = other_solution[i:j+1]\n\n        # Find best insertion point in new_solution\n        best_cost = float('inf')\n        best_pos = -1\n\n        for pos in range(n):\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # Adaptive node reinsertion\n        node = random.choice(new_solution)\n        new_solution = new_solution[new_solution != node]\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(n):\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            total_cost = cost1 + cost2\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 18,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective node swapping, where segments are dynamically rotated based on objective trade-offs and critical nodes are selectively swapped to optimize both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(1, j - i)\n        segment = new_solution[i:j+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[i:j+1] = rotated_segment\n\n        original_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        rotated_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        if rotated_cost > original_cost:\n            new_solution[i:j+1] = segment\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if random.random() < 0.3:\n            c, d = sorted(random.sample(range(n), 2))\n            if c != a and d != b:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n",
        "score": [
            -0.8834449571593221,
            0.2721986770629883
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        k = random.randint(1, j - i)\n        segment = new_solution[i:j+1]\n        rotated_segment = np.concatenate([segment[k:], segment[:k]])\n        new_solution[i:j+1] = rotated_segment\n\n        original_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        rotated_cost = (sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(1, n)) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        if rotated_cost > original_cost:\n            new_solution[i:j+1] = segment\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n        if random.random() < 0.3:\n            c, d = sorted(random.sample(range(n), 2))\n            if c != a and d != b:\n                new_solution[c], new_solution[d] = new_solution[d], new_solution[c]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9020782326259976,
            0.21703463792800903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 19,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9020782326259976,
            0.21703463792800903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains a valid tour\n    if not np.array_equal(np.sort(new_solution), np.sort(base_solution)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 20,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment reversal with multi-objective edge selection, dynamically evaluates potential improvements in both objective spaces while ensuring feasibility through a validation mechanism that checks for duplicate nodes and maintains tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_segment = None\n\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:i+len(segment)] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1 = new_cost1\n            best_cost2 = new_cost2\n            best_segment = reversed_segment\n\n    if best_segment is not None:\n        new_solution[a:b+1] = best_segment\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8721914673330821,
            0.4127125144004822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_segment = None\n\n    for i in range(n - len(segment) + 1):\n        if i >= a and i <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution[i:i+len(segment)] = reversed_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1 = new_cost1\n            best_cost2 = new_cost2\n            best_segment = reversed_segment\n\n    if best_segment is not None:\n        new_solution[a:b+1] = best_segment\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 21,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9260116614857054,
            0.4857117533683777
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 22,
        "algorithm": "{This novel hybrid local search algorithm combines adaptive segment relocation with multi-objective edge prioritization, where segments are dynamically identified and repositioned based on their potential to reduce both objectives, while critical edges are selectively exchanged using a Pareto-dominance inspired selection criterion to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (normalized by both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with multi-objective edge prioritization\n    if random.random() < 0.6:\n        # Select a segment with high potential for improvement\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Try inserting segment at position 'pos'\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Calculate improvement (weighted sum of normalized improvements)\n            imp1 = (seg_cost1 - (new_cost1 - seg_cost1)) / seg_cost1 if seg_cost1 > 0 else 0\n            imp2 = (seg_cost2 - (new_cost2 - seg_cost2)) / seg_cost2 if seg_cost2 > 0 else 0\n            total_improvement = imp1 + imp2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Multi-objective edge prioritization exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Calculate edge costs before exchange\n        old_cost1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                    distance_matrix_1[new_solution[c], new_solution[d]])\n        old_cost2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                    distance_matrix_2[new_solution[c], new_solution[d]])\n\n        # Try exchanging edges (a-b) and (c-d) with (a-c) and (b-d)\n        temp_solution = new_solution.copy()\n        temp_solution[b], temp_solution[c] = temp_solution[c], temp_solution[b]\n\n        new_cost1 = (distance_matrix_1[temp_solution[a], temp_solution[c]] +\n                    distance_matrix_1[temp_solution[b], temp_solution[d]])\n        new_cost2 = (distance_matrix_2[temp_solution[a], temp_solution[c]] +\n                    distance_matrix_2[temp_solution[b], temp_solution[d]])\n\n        # Accept if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.7935653331951291,
            3.771630108356476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential improvement (normalized by both objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation with multi-objective edge prioritization\n    if random.random() < 0.6:\n        # Select a segment with high potential for improvement\n        segment_length = random.randint(2, min(5, n//2))\n        start = random.randint(0, n - segment_length)\n        segment = new_solution[start:start+segment_length]\n\n        # Calculate segment cost in both objectives\n        seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find best insertion point considering both objectives\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= start and pos < start + segment_length:\n                continue\n\n            # Try inserting segment at position 'pos'\n            temp_solution = np.concatenate([\n                new_solution[:pos],\n                segment,\n                new_solution[pos:]\n            ])\n\n            # Calculate new costs\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Calculate improvement (weighted sum of normalized improvements)\n            imp1 = (seg_cost1 - (new_cost1 - seg_cost1)) / seg_cost1 if seg_cost1 > 0 else 0\n            imp2 = (seg_cost2 - (new_cost2 - seg_cost2)) / seg_cost2 if seg_cost2 > 0 else 0\n            total_improvement = imp1 + imp2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.concatenate([\n                new_solution[:best_pos],\n                segment,\n                new_solution[best_pos:]\n            ])\n    else:\n        # Multi-objective edge prioritization exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n\n        # Calculate edge costs before exchange\n        old_cost1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                    distance_matrix_1[new_solution[c], new_solution[d]])\n        old_cost2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                    distance_matrix_2[new_solution[c], new_solution[d]])\n\n        # Try exchanging edges (a-b) and (c-d) with (a-c) and (b-d)\n        temp_solution = new_solution.copy()\n        temp_solution[b], temp_solution[c] = temp_solution[c], temp_solution[b]\n\n        new_cost1 = (distance_matrix_1[temp_solution[a], temp_solution[c]] +\n                    distance_matrix_1[temp_solution[b], temp_solution[d]])\n        new_cost2 = (distance_matrix_2[temp_solution[a], temp_solution[c]] +\n                    distance_matrix_2[temp_solution[b], temp_solution[d]])\n\n        # Accept if at least one objective improves\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 23,
        "algorithm": "{A novel local search algorithm that combines adaptive node clustering with multi-objective path reordering, where nodes are dynamically grouped based on their proximity in both objective spaces, and then the order of these clusters is optimized through a hybrid of segment rotation and edge swapping to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 / (1 + np.mean(normalized_costs, axis=1))\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objective spaces\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Multi-objective path reordering\n    if random.random() < 0.6:  # Segment rotation\n        i, j = sorted(random.sample(range(len(clusters)), 2))\n        clusters[i:j+1] = clusters[i:j+1][::-1]\n        new_solution = np.concatenate(clusters)\n    else:  # Edge swapping\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:  # Swap nodes\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:  # Swap adjacent edges\n            if b - a > 1:\n                new_solution[a], new_solution[a+1] = new_solution[a+1], new_solution[a]\n                new_solution[b-1], new_solution[b] = new_solution[b], new_solution[b-1]\n\n    return new_solution\n\n",
        "score": [
            -0.932172185808688,
            0.28450727462768555
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its normalized cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 / (1 + np.mean(normalized_costs, axis=1))\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive node clustering based on both objective spaces\n    cluster_size = max(2, n // 5)\n    clusters = []\n    for i in range(0, n, cluster_size):\n        cluster = new_solution[i:i+cluster_size]\n        clusters.append(cluster)\n\n    # Multi-objective path reordering\n    if random.random() < 0.6:  # Segment rotation\n        i, j = sorted(random.sample(range(len(clusters)), 2))\n        clusters[i:j+1] = clusters[i:j+1][::-1]\n        new_solution = np.concatenate(clusters)\n    else:  # Edge swapping\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:  # Swap nodes\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n        else:  # Swap adjacent edges\n            if b - a > 1:\n                new_solution[a], new_solution[a+1] = new_solution[a+1], new_solution[a]\n                new_solution[b-1], new_solution[b] = new_solution[b], new_solution[b-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 24,
        "algorithm": "{This novel hybrid local search algorithm combines adaptive segment relocation with multi-objective edge prioritization, where segments are dynamically repositioned based on their potential to improve both objectives, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment removal\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Find best insertion point for the segment\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        temp_solution = np.concatenate([temp_solution[:i], temp_solution[j+1:]])\n\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        improvement = (original_cost1 - cost1) + (original_cost2 - cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    else:\n        # Multi-objective edge prioritization\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:\n            # Exchange edges to balance objectives\n            cost1_before = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n            cost2_before = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n            cost1_after = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n            cost2_after = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n            if (cost1_after > cost1_before and cost2_after > cost2_before) or (cost1_after < cost1_before and cost2_after < cost2_before):\n                new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:\n            # Invert segment if beneficial\n            segment = new_solution[a:b+1]\n            cost1_before = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(len(segment)) if k != 0 or k != len(segment)-1) + distance_matrix_1[segment[-1], segment[0]]\n            cost2_before = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(len(segment)) if k != 0 or k != len(segment)-1) + distance_matrix_2[segment[-1], segment[0]]\n\n            inverted_segment = segment[::-1]\n            cost1_after = sum(distance_matrix_1[inverted_segment[k-1], inverted_segment[k]] for k in range(len(inverted_segment)) if k != 0 or k != len(inverted_segment)-1) + distance_matrix_1[inverted_segment[-1], inverted_segment[0]]\n            cost2_after = sum(distance_matrix_2[inverted_segment[k-1], inverted_segment[k]] for k in range(len(inverted_segment)) if k != 0 or k != len(inverted_segment)-1) + distance_matrix_2[inverted_segment[-1], inverted_segment[0]]\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or (cost1_after + cost2_after < cost1_before + cost2_before):\n                new_solution[a:b+1] = inverted_segment\n\n    return new_solution\n\n",
        "score": [
            -0.7618884267500604,
            0.6151729226112366
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    i, j = sorted(random.sample(range(n), 2))\n    segment = new_solution[i:j+1]\n\n    # Evaluate segment removal\n    original_cost1 = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]]\n    original_cost2 = sum(distance_matrix_2[new_solution[k-1], new_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n    # Find best insertion point for the segment\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= i and pos <= j:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        temp_solution = np.concatenate([temp_solution[:i], temp_solution[j+1:]])\n\n        cost1 = sum(distance_matrix_1[temp_solution[k-1], temp_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[temp_solution[-1], temp_solution[0]]\n        cost2 = sum(distance_matrix_2[temp_solution[k-1], temp_solution[k]] for k in range(n) if k != 0 or k != n-1) + distance_matrix_2[temp_solution[-1], temp_solution[0]]\n\n        improvement = (original_cost1 - cost1) + (original_cost2 - cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n    else:\n        # Multi-objective edge prioritization\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:\n            # Exchange edges to balance objectives\n            cost1_before = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n            cost2_before = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n            cost1_after = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[c], new_solution[d]]\n            cost2_after = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[c], new_solution[d]]\n\n            if (cost1_after > cost1_before and cost2_after > cost2_before) or (cost1_after < cost1_before and cost2_after < cost2_before):\n                new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:\n            # Invert segment if beneficial\n            segment = new_solution[a:b+1]\n            cost1_before = sum(distance_matrix_1[segment[k-1], segment[k]] for k in range(len(segment)) if k != 0 or k != len(segment)-1) + distance_matrix_1[segment[-1], segment[0]]\n            cost2_before = sum(distance_matrix_2[segment[k-1], segment[k]] for k in range(len(segment)) if k != 0 or k != len(segment)-1) + distance_matrix_2[segment[-1], segment[0]]\n\n            inverted_segment = segment[::-1]\n            cost1_after = sum(distance_matrix_1[inverted_segment[k-1], inverted_segment[k]] for k in range(len(inverted_segment)) if k != 0 or k != len(inverted_segment)-1) + distance_matrix_1[inverted_segment[-1], inverted_segment[0]]\n            cost2_after = sum(distance_matrix_2[inverted_segment[k-1], inverted_segment[k]] for k in range(len(inverted_segment)) if k != 0 or k != len(inverted_segment)-1) + distance_matrix_2[inverted_segment[-1], inverted_segment[0]]\n\n            if (cost1_after < cost1_before and cost2_after < cost2_before) or (cost1_after + cost2_after < cost1_before + cost2_before):\n                new_solution[a:b+1] = inverted_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 25,
        "algorithm": "{A new hybrid local search algorithm that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified based on both objective costs and selectively exchanged to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its current cost\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    selection_probs = 1 / (total_costs + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=selection_probs / selection_probs.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator with different parameters\n    if random.random() < 0.5:  # Adaptive segment inversion with different criteria\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate based on both objectives with different weights\n        original_cost = (0.6 * distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         0.4 * distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = (0.6 * distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         0.4 * distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        if inverted_cost > original_cost:  # Revert if worse in weighted evaluation\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange with different segment selection\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.7:  # More frequent edge exchanges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Segment inversion with different probability\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9278140748703381,
            0.22739273309707642
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its current cost\n    objectives = np.array([obj for _, obj in archive])\n    total_costs = objectives.sum(axis=1)\n    selection_probs = 1 / (total_costs + 1e-8)\n    selected_idx = np.random.choice(len(archive), p=selection_probs / selection_probs.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator with different parameters\n    if random.random() < 0.5:  # Adaptive segment inversion with different criteria\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate based on both objectives with different weights\n        original_cost = (0.6 * distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         0.4 * distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = (0.6 * distance_matrix_1[new_solution[-1], new_solution[0]] +\n                         0.4 * distance_matrix_2[new_solution[-1], new_solution[0]])\n\n        if inverted_cost > original_cost:  # Revert if worse in weighted evaluation\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange with different segment selection\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.7:  # More frequent edge exchanges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Segment inversion with different probability\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic segment relocation with objective-aware edge flipping, where segments are strategically moved based on their contribution to both objectives, while critical edges are selectively flipped to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        k = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        if distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] > \\\n           distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6988888967348511,
            0.2002527117729187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        k = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        if distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] > \\\n           distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 26,
        "algorithm": "{An adaptive multi-objective local search algorithm that combines dynamic segment relocation with objective-aware edge flipping, where segments are strategically moved based on their contribution to both objectives, while critical edges are selectively flipped to balance the trade-off between the two objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        k = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        if distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] > \\\n           distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.6988888967348511,
            0.2002527117729187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:], segment])\n\n        k = random.randint(0, len(new_solution))\n        new_solution = np.concatenate([new_solution[:k], segment, new_solution[k:]])\n    else:\n        a, b = sorted(random.sample(range(n), 2))\n        if distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[a-1], new_solution[a]] > \\\n           distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[b]]:\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n",
        "score": [
            -0.9770200330726048,
            0.2773295044898987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 27,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n",
        "score": [
            -0.9770200330726048,
            0.2773295044898987
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 28,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i:\n        j = random.randint(0, n - 1)\n\n    # Perform a 2-opt like swap but with additional validation\n    if i > j:\n        i, j = j, i\n\n    # Check if the swap would improve both objectives\n    original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        # Apply the swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # If not better, perform a random insertion\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9621688152956858,
            0.200253427028656
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i:\n        j = random.randint(0, n - 1)\n\n    # Perform a 2-opt like swap but with additional validation\n    if i > j:\n        i, j = j, i\n\n    # Check if the swap would improve both objectives\n    original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        # Apply the swap\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        # If not better, perform a random insertion\n        k = random.randint(0, n - 1)\n        node = new_solution[k]\n        new_solution = np.delete(new_solution, k)\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 29,
        "algorithm": "{This novel algorithm combines adaptive segment relocation with multi-objective crossover, where segments are intelligently moved to balance objective trade-offs, while critical edges are selectively recombined from promising parents to explore diverse solution spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        # Adaptive segment relocation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Multi-objective crossover\n        parent1_idx = np.random.choice(len(archive))\n        parent2_idx = np.random.choice(len(archive))\n        parent1 = archive[parent1_idx][0]\n        parent2 = archive[parent2_idx][0]\n\n        crossover_point = random.randint(1, n-1)\n        child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n\n        # Select the better child based on combined objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(1, n)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(1, n)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        if calculate_cost(child1) < calculate_cost(child2):\n            new_solution = child1\n        else:\n            new_solution = child2\n\n    return new_solution\n\n",
        "score": [
            -0.8258327092232354,
            0.24894744157791138
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.6:\n        # Adaptive segment relocation\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n        insert_pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Multi-objective crossover\n        parent1_idx = np.random.choice(len(archive))\n        parent2_idx = np.random.choice(len(archive))\n        parent1 = archive[parent1_idx][0]\n        parent2 = archive[parent2_idx][0]\n\n        crossover_point = random.randint(1, n-1)\n        child1 = np.concatenate([parent1[:crossover_point], parent2[crossover_point:]])\n        child2 = np.concatenate([parent2[:crossover_point], parent1[crossover_point:]])\n\n        # Select the better child based on combined objectives\n        def calculate_cost(sol):\n            cost1 = sum(distance_matrix_1[sol[k-1], sol[k]] for k in range(1, n)) + distance_matrix_1[sol[-1], sol[0]]\n            cost2 = sum(distance_matrix_2[sol[k-1], sol[k]] for k in range(1, n)) + distance_matrix_2[sol[-1], sol[0]]\n            return cost1 + cost2\n\n        if calculate_cost(child1) < calculate_cost(child2):\n            new_solution = child1\n        else:\n            new_solution = child2\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 30,
        "algorithm": "{A novel hybrid local search algorithm that combines adaptive segment relocation with multi-objective path inversion, where segments are dynamically relocated based on their contribution to both objectives, while critical paths are selectively inverted to explore diverse trade-offs in the Pareto front.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_pos = random.randint(0, n - len(segment))\n\n        # Calculate cost change\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n        new_cost = (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] + distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] +\n                    distance_matrix_1[new_solution[new_pos+len(segment)-1], new_solution[(new_pos+len(segment))%n]] + distance_matrix_2[new_solution[new_pos+len(segment)-1], new_solution[(new_pos+len(segment))%n]])\n\n        if new_cost > original_cost:\n            # Revert if worse\n            new_solution = base_solution.copy()\n    else:  # Multi-objective path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Evaluate path inversion\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(a, b+1))\n\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(a, b+1))\n\n        if inverted_cost > original_cost:\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.887212653548769,
            0.5113910436630249
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        new_pos = random.randint(0, n - len(segment))\n\n        # Calculate cost change\n        original_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Remove segment\n        new_solution = np.concatenate([new_solution[:i], new_solution[j+1:]])\n\n        # Insert segment at new position\n        new_solution = np.concatenate([new_solution[:new_pos], segment, new_solution[new_pos:]])\n\n        new_cost = (distance_matrix_1[new_solution[new_pos-1], new_solution[new_pos]] + distance_matrix_2[new_solution[new_pos-1], new_solution[new_pos]] +\n                    distance_matrix_1[new_solution[new_pos+len(segment)-1], new_solution[(new_pos+len(segment))%n]] + distance_matrix_2[new_solution[new_pos+len(segment)-1], new_solution[(new_pos+len(segment))%n]])\n\n        if new_cost > original_cost:\n            # Revert if worse\n            new_solution = base_solution.copy()\n    else:  # Multi-objective path inversion\n        a, b = sorted(random.sample(range(n), 2))\n        segment = new_solution[a:b+1]\n\n        # Evaluate path inversion\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(a, b+1))\n\n        inverted_segment = segment[::-1]\n        new_solution[a:b+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(a, b+1))\n\n        if inverted_cost > original_cost:\n            new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 31,
        "algorithm": "{A novel local search strategy combines a multi-objective edge selection criterion with a dynamic node reinsertion operator, prioritizing nodes whose removal and reinsertion could significantly reduce both objective costs while maintaining feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove and reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1 = new_cost1\n            best_cost2 = new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, insert the node at a random position\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7926847281606573,
            1.6251670718193054
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove and reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1 = new_cost1\n            best_cost2 = new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, insert the node at a random position\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 32,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective edge prioritization mechanism with a dynamic segment relocation operator, which intelligently selects and repositions high-potential segments while maintaining feasibility through a constraint-aware validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify high-potential edges in both objectives\n    edge_scores = []\n    for i in range(n):\n        current = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n        score1 = distance_matrix_1[current, next_node]\n        score2 = distance_matrix_2[current, next_node]\n        edge_scores.append(score1 + score2)\n\n    # Select a segment based on edge scores\n    segment_length = min(3, n)\n    segment_scores = [sum(edge_scores[i:i+segment_length]) for i in range(n)]\n    segment_start = segment_scores.index(max(segment_scores))\n    segment_end = (segment_start + segment_length - 1) % n\n\n    # Extract the segment\n    if segment_start <= segment_end:\n        segment = new_solution[segment_start:segment_end+1]\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end+1]])\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= segment_start and pos <= segment_end:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        if pos < segment_start:\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:segment_start], temp_solution[segment_end+1:]])\n        else:\n            temp_solution = np.concatenate([temp_solution[:segment_start], temp_solution[segment_end+1:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        if best_insert_pos < segment_start:\n            new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:segment_start], new_solution[segment_end+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end+1:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7060590755119172,
            3.743603527545929
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify high-potential edges in both objectives\n    edge_scores = []\n    for i in range(n):\n        current = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n        score1 = distance_matrix_1[current, next_node]\n        score2 = distance_matrix_2[current, next_node]\n        edge_scores.append(score1 + score2)\n\n    # Select a segment based on edge scores\n    segment_length = min(3, n)\n    segment_scores = [sum(edge_scores[i:i+segment_length]) for i in range(n)]\n    segment_start = segment_scores.index(max(segment_scores))\n    segment_end = (segment_start + segment_length - 1) % n\n\n    # Extract the segment\n    if segment_start <= segment_end:\n        segment = new_solution[segment_start:segment_end+1]\n    else:\n        segment = np.concatenate([new_solution[segment_start:], new_solution[:segment_end+1]])\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= segment_start and pos <= segment_end:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        if pos < segment_start:\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:segment_start], temp_solution[segment_end+1:]])\n        else:\n            temp_solution = np.concatenate([temp_solution[:segment_start], temp_solution[segment_end+1:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        total_cost = new_cost1 + new_cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        if best_insert_pos < segment_start:\n            new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:segment_start], new_solution[segment_end+1:]])\n        else:\n            new_solution = np.concatenate([new_solution[:segment_start], new_solution[segment_end+1:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = np.concatenate([new_solution[:i], new_solution[i:j+1][::-1], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 33,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment inversion with multi-objective node swapping, where segments are intelligently inverted based on their potential to reduce both objectives, while critical nodes are selectively swapped to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1) / (1 + np.linalg.norm(objectives, axis=1))\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        new_solution[i:j+1] = inverted_segment\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if not ((new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2)):\n            new_solution[i:j+1] = segment\n    else:\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.6:\n            if a != b and b != c:\n                temp = new_solution[a]\n                new_solution[a] = new_solution[b]\n                new_solution[b] = temp\n        else:\n            if a != c:\n                temp = new_solution[a]\n                new_solution[a] = new_solution[c]\n                new_solution[c] = temp\n\n    return new_solution\n\n",
        "score": [
            -0.9081257076475115,
            0.2788275480270386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1) / (1 + np.linalg.norm(objectives, axis=1))\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        inverted_segment = segment[::-1]\n\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        new_solution[i:j+1] = inverted_segment\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if not ((new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost1 <= original_cost1 and new_cost2 < original_cost2)):\n            new_solution[i:j+1] = segment\n    else:\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.6:\n            if a != b and b != c:\n                temp = new_solution[a]\n                new_solution[a] = new_solution[b]\n                new_solution[b] = temp\n        else:\n            if a != c:\n                temp = new_solution[a]\n                new_solution[a] = new_solution[c]\n                new_solution[c] = temp\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 34,
        "algorithm": "{This novel algorithm combines multi-objective adaptive segment relocation with dynamic edge inversion, where segments are intelligently repositioned based on both objective costs while critical edges are selectively inverted to balance the trade-off between the objectives, all while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its current cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selection_scores = 1 / (1 + np.sum(normalized_costs, axis=1))\n    selected_idx = np.random.choice(len(archive), p=selection_scores / selection_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on both objective costs\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= start and pos < end:\n            continue\n\n        # Calculate cost of inserting segment at this position\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n else new_solution[0]\n\n        # Cost of removing the segment\n        remove_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[end-1], next_node]\n        remove_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[end-1], next_node]\n\n        # Cost of inserting the segment\n        insert_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        insert_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Total improvement\n        improvement1 = (remove_cost1 - insert_cost1) / segment_cost1\n        improvement2 = (remove_cost2 - insert_cost2) / segment_cost2\n        total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        # Relocate the segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:],\n            new_solution[start:end]\n        ])\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            new_solution[-segment_length:],\n            new_solution[best_pos:-segment_length]\n        ])\n    else:\n        # If no improvement found, perform edge inversion\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            # Invert the segment between a and b\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Swap edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9524911990149058,
            0.3218538165092468
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability inversely proportional to its current cost\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    selection_scores = 1 / (1 + np.sum(normalized_costs, axis=1))\n    selected_idx = np.random.choice(len(archive), p=selection_scores / selection_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment boundaries based on both objective costs\n    segment_length = max(2, min(n // 3, random.randint(2, n // 2)))\n    start = random.randint(0, n - segment_length)\n    end = start + segment_length\n    segment = new_solution[start:end]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= start and pos < end:\n            continue\n\n        # Calculate cost of inserting segment at this position\n        prev_node = new_solution[pos-1] if pos > 0 else new_solution[-1]\n        next_node = new_solution[pos] if pos < n else new_solution[0]\n\n        # Cost of removing the segment\n        remove_cost1 = distance_matrix_1[prev_node, new_solution[start]] + distance_matrix_1[new_solution[end-1], next_node]\n        remove_cost2 = distance_matrix_2[prev_node, new_solution[start]] + distance_matrix_2[new_solution[end-1], next_node]\n\n        # Cost of inserting the segment\n        insert_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n        insert_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n        # Total improvement\n        improvement1 = (remove_cost1 - insert_cost1) / segment_cost1\n        improvement2 = (remove_cost2 - insert_cost2) / segment_cost2\n        total_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        # Relocate the segment\n        new_solution = np.concatenate([\n            new_solution[:start],\n            new_solution[end:],\n            new_solution[start:end]\n        ])\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            new_solution[-segment_length:],\n            new_solution[best_pos:-segment_length]\n        ])\n    else:\n        # If no improvement found, perform edge inversion\n        a, b = sorted(random.sample(range(n), 2))\n        if random.random() < 0.5:\n            # Invert the segment between a and b\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        else:\n            # Swap edges\n            new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 35,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment inversion with multi-objective edge expansion, where segments are dynamically inverted based on their potential to reduce both objectives, while critical edges are selectively expanded to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate inversion potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n    else:\n        # Multi-objective edge expansion\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            b = (b + 1) % n\n\n        # Insert a new node between a and b\n        remaining_nodes = [node for node in range(n) if node not in new_solution]\n        if remaining_nodes:\n            new_node = random.choice(remaining_nodes)\n            new_solution = np.insert(new_solution, a+1, new_node)\n\n    return new_solution\n\n",
        "score": [
            -0.9104640470790789,
            0.36864203214645386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate inversion potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n    else:\n        # Multi-objective edge expansion\n        a, b = sorted(random.sample(range(n), 2))\n        if a == b:\n            b = (b + 1) % n\n\n        # Insert a new node between a and b\n        remaining_nodes = [node for node in range(n) if node not in new_solution]\n        if remaining_nodes:\n            new_node = random.choice(remaining_nodes)\n            new_solution = np.insert(new_solution, a+1, new_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm is proposed that combines adaptive segment inversion with multi-objective edge exchange, where promising segments are dynamically identified and inverted based on both objective costs, while critical edges are selectively exchanged to balance the trade-off between the two objectives.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with probability proportional to its potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # Adaptive segment inversion\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Evaluate segment inversion based on both objectives\n        original_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                           for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        inverted_segment = segment[::-1]\n        new_solution[i:j+1] = inverted_segment\n\n        inverted_cost = sum(distance_matrix_1[new_solution[k-1], new_solution[k]] + distance_matrix_2[new_solution[k-1], new_solution[k]]\n                          for k in range(n) if k != 0 or k != n-1) + distance_matrix_1[new_solution[-1], new_solution[0]] + distance_matrix_2[new_solution[-1], new_solution[0]]\n\n        if inverted_cost > original_cost:  # Revert if worse\n            new_solution[i:j+1] = segment\n    else:  # Multi-objective edge exchange\n        a, b, c, d = sorted(random.sample(range(n), 4))\n        if random.random() < 0.5:  # Exchange edges\n            new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n        else:  # Exchange segments\n            new_solution[b:c+1] = new_solution[b:c+1][::-1]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 36,
        "algorithm": "{This novel algorithm combines adaptive path decomposition with multi-objective segment merging, where the solution is dynamically divided into critical and non-critical segments based on their contribution to both objectives, then selectively merges or reorders these segments to create balanced improvements in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment importance scores\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+5, n)):\n            seg = new_solution[i:j]\n            cost1 = sum(distance_matrix_1[seg[k], seg[k+1]] for k in range(len(seg)-1))\n            cost2 = sum(distance_matrix_2[seg[k], seg[k+1]] for k in range(len(seg)-1))\n            segment_scores.append((cost1 + cost2, i, j))\n\n    # Select most critical segments\n    segment_scores.sort(reverse=True)\n    critical_segments = [seg for _, i, j in segment_scores[:max(2, len(segment_scores)//3)]]\n\n    # Process critical segments\n    for i, j in critical_segments:\n        seg = new_solution[i:j]\n        # Try different segment operations\n        operations = [\n            seg[::-1],  # Reverse\n            np.roll(seg, 1),  # Rotate\n            np.concatenate([seg[:len(seg)//2], seg[len(seg)//2:][::-1]])  # Split and reverse\n        ]\n\n        best_operation = None\n        best_improvement = 0\n\n        for op in operations:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = op\n            new_cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            improvement = (objectives[selected_idx][0] - new_cost1) + (objectives[selected_idx][1] - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_operation = op\n\n        if best_operation is not None:\n            new_solution[i:j] = best_operation\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original with small perturbation\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.878622986467773,
            5.1053396463394165
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    normalized_costs = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    potential_scores = 1 - np.mean(normalized_costs, axis=1)\n    selected_idx = np.random.choice(len(archive), p=potential_scores / potential_scores.sum())\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate segment importance scores\n    segment_scores = []\n    for i in range(n):\n        for j in range(i+2, min(i+5, n)):\n            seg = new_solution[i:j]\n            cost1 = sum(distance_matrix_1[seg[k], seg[k+1]] for k in range(len(seg)-1))\n            cost2 = sum(distance_matrix_2[seg[k], seg[k+1]] for k in range(len(seg)-1))\n            segment_scores.append((cost1 + cost2, i, j))\n\n    # Select most critical segments\n    segment_scores.sort(reverse=True)\n    critical_segments = [seg for _, i, j in segment_scores[:max(2, len(segment_scores)//3)]]\n\n    # Process critical segments\n    for i, j in critical_segments:\n        seg = new_solution[i:j]\n        # Try different segment operations\n        operations = [\n            seg[::-1],  # Reverse\n            np.roll(seg, 1),  # Rotate\n            np.concatenate([seg[:len(seg)//2], seg[len(seg)//2:][::-1]])  # Split and reverse\n        ]\n\n        best_operation = None\n        best_improvement = 0\n\n        for op in operations:\n            temp_sol = new_solution.copy()\n            temp_sol[i:j] = op\n            new_cost1 = sum(distance_matrix_1[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_1[temp_sol[-1], temp_sol[0]]\n            new_cost2 = sum(distance_matrix_2[temp_sol[k], temp_sol[k+1]] for k in range(n-1)) + distance_matrix_2[temp_sol[-1], temp_sol[0]]\n            improvement = (objectives[selected_idx][0] - new_cost1) + (objectives[selected_idx][1] - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_operation = op\n\n        if best_operation is not None:\n            new_solution[i:j] = best_operation\n\n    # Final validation\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to original with small perturbation\n        new_solution = base_solution.copy()\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 37,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and incorporates a dynamic segment reversal and insertion mechanism to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and optionally reverse it\n    segment = new_solution[a:b+1]\n    if random.random() < 0.5:  # 50% chance to reverse the segment\n        segment = segment[::-1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a dynamic edge exchange\n        i, j = random.sample(range(n), 2)\n        # Exchange edges in a way that maintains feasibility\n        if i < j:\n            new_solution[i:j+1] = np.concatenate([new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1]])\n        else:\n            new_solution[j:i+1] = np.concatenate([new_solution[i:i+1], new_solution[j+1:i], new_solution[j:j+1]])\n\n    return new_solution\n\n",
        "score": [
            -0.9591524498215842,
            0.48833727836608887
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and optionally reverse it\n    segment = new_solution[a:b+1]\n    if random.random() < 0.5:  # 50% chance to reverse the segment\n        segment = segment[::-1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a dynamic edge exchange\n        i, j = random.sample(range(n), 2)\n        # Exchange edges in a way that maintains feasibility\n        if i < j:\n            new_solution[i:j+1] = np.concatenate([new_solution[j:j+1], new_solution[i+1:j], new_solution[i:i+1]])\n        else:\n            new_solution[j:i+1] = np.concatenate([new_solution[i:i+1], new_solution[j+1:i], new_solution[j:j+1]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 38,
        "algorithm": "{A novel adaptive local search strategy combines a multi-objective edge selection criterion with a dynamic segment relocation operator that prioritizes edges with high potential for cost reduction in both objective spaces, while maintaining feasibility through a validation mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 3-opt move\n        i, j, k = random.sample(range(n), 3)\n        if i > j:\n            i, j = j, i\n        if j > k:\n            j, k = k, j\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9121710055479284,
            0.6038125157356262
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 3-opt move\n        i, j, k = random.sample(range(n), 3)\n        if i > j:\n            i, j = j, i\n        if j > k:\n            j, k = k, j\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:i], reversed_segment, new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 39,
        "algorithm": "{This novel hybrid local search algorithm combines adaptive segment inversion with multi-objective critical node relocation, where segments are dynamically inverted based on their potential to reduce both objectives, while critical nodes are selectively relocated to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate inversion potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n    else:\n        # Multi-objective critical node relocation\n        k = random.randint(0, n-1)\n        neighbors = [new_solution[(k-1)%n], new_solution[(k+1)%n]]\n\n        best_position = k\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for pos in range(n):\n            if pos == k or pos in [k-1, k+1]:\n                continue\n\n            temp_solution = new_solution.copy()\n            node = temp_solution[k]\n            temp_solution = np.delete(temp_solution, k)\n            temp_solution = np.insert(temp_solution, pos, node)\n\n            current_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if (current_cost1 < best_cost1 and current_cost2 < best_cost2) or \\\n               (current_cost1 < best_cost1 and current_cost2 <= best_cost2) or \\\n               (current_cost1 <= best_cost1 and current_cost2 < best_cost2):\n                best_position = pos\n                best_cost1, best_cost2 = current_cost1, current_cost2\n\n        if best_position != k:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_position, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8115309713465169,
            0.4807037115097046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate inversion potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n    else:\n        # Multi-objective critical node relocation\n        k = random.randint(0, n-1)\n        neighbors = [new_solution[(k-1)%n], new_solution[(k+1)%n]]\n\n        best_position = k\n        best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        for pos in range(n):\n            if pos == k or pos in [k-1, k+1]:\n                continue\n\n            temp_solution = new_solution.copy()\n            node = temp_solution[k]\n            temp_solution = np.delete(temp_solution, k)\n            temp_solution = np.insert(temp_solution, pos, node)\n\n            current_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            current_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if (current_cost1 < best_cost1 and current_cost2 < best_cost2) or \\\n               (current_cost1 < best_cost1 and current_cost2 <= best_cost2) or \\\n               (current_cost1 <= best_cost1 and current_cost2 < best_cost2):\n                best_position = pos\n                best_cost1, best_cost2 = current_cost1, current_cost2\n\n        if best_position != k:\n            node = new_solution[k]\n            new_solution = np.delete(new_solution, k)\n            new_solution = np.insert(new_solution, best_position, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic segment exchange\n    n = len(new_solution)\n    segment_size = random.randint(2, min(5, n // 2))  # Random segment size between 2 and 5 or n/2\n\n    # Select two non-overlapping segments\n    a = random.randint(0, n - segment_size)\n    b = random.randint(0, n - segment_size)\n    while abs(a - b) < segment_size:  # Ensure segments don't overlap\n        b = random.randint(0, n - segment_size)\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[b:b+segment_size]\n\n    # Calculate segment costs\n    def segment_cost(seg, dist_matrix):\n        cost = 0\n        for i in range(len(seg)):\n            cost += dist_matrix[seg[i], seg[(i+1)%len(seg)]]\n        return cost\n\n    cost1_seg1 = segment_cost(segment1, distance_matrix_1)\n    cost2_seg1 = segment_cost(segment1, distance_matrix_2)\n    cost1_seg2 = segment_cost(segment2, distance_matrix_1)\n    cost2_seg2 = segment_cost(segment2, distance_matrix_2)\n\n    # Calculate potential improvement\n    improvement1 = (cost1_seg1 + cost1_seg2) - (distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_1[segment2[-1], segment1[0]])\n    improvement2 = (cost2_seg1 + cost2_seg2) - (distance_matrix_2[segment1[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment1[0]])\n\n    # Apply exchange if beneficial in both objectives\n    if improvement1 > 0 and improvement2 > 0:\n        # Swap segments\n        new_solution[a:a+segment_size] = segment2\n        new_solution[b:b+segment_size] = segment1\n    else:\n        # Perform random 2-opt if no improvement found\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6917347359343206,
            0.052630722522735596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic segment exchange\n    n = len(new_solution)\n    segment_size = random.randint(2, min(5, n // 2))  # Random segment size between 2 and 5 or n/2\n\n    # Select two non-overlapping segments\n    a = random.randint(0, n - segment_size)\n    b = random.randint(0, n - segment_size)\n    while abs(a - b) < segment_size:  # Ensure segments don't overlap\n        b = random.randint(0, n - segment_size)\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[b:b+segment_size]\n\n    # Calculate segment costs\n    def segment_cost(seg, dist_matrix):\n        cost = 0\n        for i in range(len(seg)):\n            cost += dist_matrix[seg[i], seg[(i+1)%len(seg)]]\n        return cost\n\n    cost1_seg1 = segment_cost(segment1, distance_matrix_1)\n    cost2_seg1 = segment_cost(segment1, distance_matrix_2)\n    cost1_seg2 = segment_cost(segment2, distance_matrix_1)\n    cost2_seg2 = segment_cost(segment2, distance_matrix_2)\n\n    # Calculate potential improvement\n    improvement1 = (cost1_seg1 + cost1_seg2) - (distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_1[segment2[-1], segment1[0]])\n    improvement2 = (cost2_seg1 + cost2_seg2) - (distance_matrix_2[segment1[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment1[0]])\n\n    # Apply exchange if beneficial in both objectives\n    if improvement1 > 0 and improvement2 > 0:\n        # Swap segments\n        new_solution[a:a+segment_size] = segment2\n        new_solution[b:b+segment_size] = segment1\n    else:\n        # Perform random 2-opt if no improvement found\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 40,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic segment exchange\n    n = len(new_solution)\n    segment_size = random.randint(2, min(5, n // 2))  # Random segment size between 2 and 5 or n/2\n\n    # Select two non-overlapping segments\n    a = random.randint(0, n - segment_size)\n    b = random.randint(0, n - segment_size)\n    while abs(a - b) < segment_size:  # Ensure segments don't overlap\n        b = random.randint(0, n - segment_size)\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[b:b+segment_size]\n\n    # Calculate segment costs\n    def segment_cost(seg, dist_matrix):\n        cost = 0\n        for i in range(len(seg)):\n            cost += dist_matrix[seg[i], seg[(i+1)%len(seg)]]\n        return cost\n\n    cost1_seg1 = segment_cost(segment1, distance_matrix_1)\n    cost2_seg1 = segment_cost(segment1, distance_matrix_2)\n    cost1_seg2 = segment_cost(segment2, distance_matrix_1)\n    cost2_seg2 = segment_cost(segment2, distance_matrix_2)\n\n    # Calculate potential improvement\n    improvement1 = (cost1_seg1 + cost1_seg2) - (distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_1[segment2[-1], segment1[0]])\n    improvement2 = (cost2_seg1 + cost2_seg2) - (distance_matrix_2[segment1[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment1[0]])\n\n    # Apply exchange if beneficial in both objectives\n    if improvement1 > 0 and improvement2 > 0:\n        # Swap segments\n        new_solution[a:a+segment_size] = segment2\n        new_solution[b:b+segment_size] = segment1\n    else:\n        # Perform random 2-opt if no improvement found\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6917347359343206,
            0.052630722522735596
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (lowest cost in either objective)\n    archive.sort(key=lambda x: min(x[1]))\n    selected_idx = random.randint(0, min(3, len(archive) - 1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search operator: Dynamic segment exchange\n    n = len(new_solution)\n    segment_size = random.randint(2, min(5, n // 2))  # Random segment size between 2 and 5 or n/2\n\n    # Select two non-overlapping segments\n    a = random.randint(0, n - segment_size)\n    b = random.randint(0, n - segment_size)\n    while abs(a - b) < segment_size:  # Ensure segments don't overlap\n        b = random.randint(0, n - segment_size)\n\n    # Extract segments\n    segment1 = new_solution[a:a+segment_size]\n    segment2 = new_solution[b:b+segment_size]\n\n    # Calculate segment costs\n    def segment_cost(seg, dist_matrix):\n        cost = 0\n        for i in range(len(seg)):\n            cost += dist_matrix[seg[i], seg[(i+1)%len(seg)]]\n        return cost\n\n    cost1_seg1 = segment_cost(segment1, distance_matrix_1)\n    cost2_seg1 = segment_cost(segment1, distance_matrix_2)\n    cost1_seg2 = segment_cost(segment2, distance_matrix_1)\n    cost2_seg2 = segment_cost(segment2, distance_matrix_2)\n\n    # Calculate potential improvement\n    improvement1 = (cost1_seg1 + cost1_seg2) - (distance_matrix_1[segment1[-1], segment2[0]] + distance_matrix_1[segment2[-1], segment1[0]])\n    improvement2 = (cost2_seg1 + cost2_seg2) - (distance_matrix_2[segment1[-1], segment2[0]] + distance_matrix_2[segment2[-1], segment1[0]])\n\n    # Apply exchange if beneficial in both objectives\n    if improvement1 > 0 and improvement2 > 0:\n        # Swap segments\n        new_solution[a:a+segment_size] = segment2\n        new_solution[b:b+segment_size] = segment1\n    else:\n        # Perform random 2-opt if no improvement found\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 41,
        "algorithm": "{An enhanced hybrid local search algorithm that combines adaptive segment inversion with multi-objective edge expansion, where segments are dynamically inverted based on their potential to reduce both objectives while critical edges are expanded to diversify the search space and improve solution quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1) + np.random.rand(len(objectives)) * 0.1\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_inversion = False\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n            best_inversion = True\n            best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_inversion:\n            new_solution[i:j+1] = inverted_segment\n    else:\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.6:\n            if a != b and b != c and a != c:\n                new_solution = np.insert(new_solution, b, new_solution[a])\n        else:\n            if a != c:\n                new_solution = np.insert(new_solution, a, new_solution[c])\n\n    return new_solution\n\n",
        "score": [
            -0.9395151344814312,
            0.1940009593963623
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1) + np.random.rand(len(objectives)) * 0.1\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_inversion = False\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n            best_inversion = True\n            best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_inversion:\n            new_solution[i:j+1] = inverted_segment\n    else:\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.6:\n            if a != b and b != c and a != c:\n                new_solution = np.insert(new_solution, b, new_solution[a])\n        else:\n            if a != c:\n                new_solution = np.insert(new_solution, a, new_solution[c])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 42,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0013836230650595,
            0.47890734672546387
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 43,
        "algorithm": "{A novel hybrid local search algorithm combines adaptive segment inversion with multi-objective node relocation, where segments are dynamically inverted based on their potential to reduce both objectives, while critical nodes are selectively relocated to improve solution quality while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement using weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=objectives.shape[1])\n    potential_scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate inversion potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i:j+1] = inverted_segment\n    else:\n        # Multi-objective node relocation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Relocate node b to position after a\n            new_solution = np.delete(new_solution, b)\n            new_solution = np.insert(new_solution, (a+1)%n, base_solution[b])\n\n    return new_solution\n\n",
        "score": [
            -0.9321910143026556,
            0.2505834102630615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement using weighted sum\n    objectives = np.array([obj for _, obj in archive])\n    weights = np.random.uniform(0.3, 0.7, size=objectives.shape[1])\n    potential_scores = np.dot(objectives, weights)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment inversion\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate inversion potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or (new_cost2 < original_cost2 and new_cost1 <= original_cost1):\n            new_solution[i:j+1] = inverted_segment\n    else:\n        # Multi-objective node relocation\n        a, b = random.sample(range(n), 2)\n        if a != b:\n            # Relocate node b to position after a\n            new_solution = np.delete(new_solution, b)\n            new_solution = np.insert(new_solution, (a+1)%n, base_solution[b])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search algorithm combines adaptive segment rotation with multi-objective edge contraction, where segments are dynamically rotated based on their potential to reduce both objectives, while critical edges are selectively contracted to improve solution quality while maintaining feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment rotation\n    if random.random() < 0.6:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n        segment_length = len(segment)\n\n        # Calculate rotation potential\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        best_rotation = 0\n        best_cost1, best_cost2 = original_cost1, original_cost2\n\n        for r in range(1, segment_length):\n            rotated_segment = np.roll(segment, r)\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = rotated_segment\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n            if (new_cost1 < best_cost1 or new_cost2 < best_cost2) and (new_cost1 <= original_cost1 or new_cost2 <= original_cost2):\n                best_rotation = r\n                best_cost1, best_cost2 = new_cost1, new_cost2\n\n        if best_rotation > 0:\n            new_solution[i:j+1] = np.roll(segment, best_rotation)\n    else:\n        # Multi-objective edge contraction\n        a, b, c = sorted(random.sample(range(n), 3))\n        if a == 0 and c == n-1:\n            c -= 1\n\n        if random.random() < 0.5:\n            # Contract edges between a-b and b-c\n            if a != b and b != c and a != c:\n                new_solution[b] = new_solution[a]\n                new_solution = np.delete(new_solution, b)\n        else:\n            # Contract edges between a-c\n            if a != c:\n                new_solution[a] = new_solution[c]\n                new_solution = np.delete(new_solution, c)\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 44,
        "algorithm": "{A novel hybrid local search algorithm that combines multi-objective path inversion with dynamic node swapping, where segments are selectively inverted based on their potential to improve both objectives, while critical nodes are dynamically swapped to balance the trade-off between the two objectives while ensuring solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate original costs\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n    else:\n        # Dynamic node swapping\n        a, b = random.sample(range(n), 2)\n\n        # Calculate original costs\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Swap nodes\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] +\n                     distance_matrix_1[temp_solution[a], temp_solution[(a+1)%n]] +\n                     distance_matrix_1[temp_solution[b-1], temp_solution[b]] +\n                     distance_matrix_1[temp_solution[b], temp_solution[(b+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[a-1], temp_solution[a]] +\n                     distance_matrix_2[temp_solution[a], temp_solution[(a+1)%n]] +\n                     distance_matrix_2[temp_solution[b-1], temp_solution[b]] +\n                     distance_matrix_2[temp_solution[b], temp_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8817324932756058,
            0.2610890865325928
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement\n    objectives = np.array([obj for _, obj in archive])\n    potential_scores = np.sum(objectives, axis=1)\n    selected_idx = np.argmax(potential_scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-objective path inversion\n    if random.random() < 0.7:\n        i, j = sorted(random.sample(range(n), 2))\n        segment = new_solution[i:j+1]\n\n        # Calculate original costs\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        # Invert the segment\n        inverted_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[i:j+1] = inverted_segment\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(i-1, j+1))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n    else:\n        # Dynamic node swapping\n        a, b = random.sample(range(n), 2)\n\n        # Calculate original costs\n        original_cost1 = (distance_matrix_1[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_1[new_solution[b], new_solution[(b+1)%n]])\n\n        original_cost2 = (distance_matrix_2[new_solution[a-1], new_solution[a]] +\n                          distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] +\n                          distance_matrix_2[new_solution[b], new_solution[(b+1)%n]])\n\n        # Swap nodes\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n\n        # Calculate new costs\n        new_cost1 = (distance_matrix_1[temp_solution[a-1], temp_solution[a]] +\n                     distance_matrix_1[temp_solution[a], temp_solution[(a+1)%n]] +\n                     distance_matrix_1[temp_solution[b-1], temp_solution[b]] +\n                     distance_matrix_1[temp_solution[b], temp_solution[(b+1)%n]])\n\n        new_cost2 = (distance_matrix_2[temp_solution[a-1], temp_solution[a]] +\n                     distance_matrix_2[temp_solution[a], temp_solution[(a+1)%n]] +\n                     distance_matrix_2[temp_solution[b-1], temp_solution[b]] +\n                     distance_matrix_2[temp_solution[b], temp_solution[(b+1)%n]])\n\n        # Accept if at least one objective improves\n        if (new_cost1 < original_cost1 or new_cost2 < original_cost2):\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 45,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic edge exchange operator, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and incorporates a novel segment inversion operator to explore diverse neighborhood structures.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize solutions with higher cost)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select from the top 20% of solutions\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 5 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment inversion operator\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment and check feasibility\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply inversion if it improves at least one objective\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If inversion doesn't help, try a different operator: edge exchange\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Calculate the cost change\n            old_edges = [\n                (new_solution[i], new_solution[(i+1)%n], distance_matrix_1[new_solution[i], new_solution[(i+1)%n]], distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]),\n                (new_solution[j], new_solution[(j+1)%n], distance_matrix_1[new_solution[j], new_solution[(j+1)%n]], distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[j], distance_matrix_1[new_solution[i], new_solution[j]], distance_matrix_2[new_solution[i], new_solution[j]]),\n                (new_solution[(i+1)%n], new_solution[(j+1)%n], distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]], distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            ]\n\n            old_cost1 = old_edges[0][2] + old_edges[1][2]\n            old_cost2 = old_edges[0][3] + old_edges[1][3]\n            new_cost1 = new_edges[0][2] + new_edges[1][2]\n            new_cost2 = new_edges[0][3] + new_edges[1][3]\n\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                # Perform the edge exchange\n                if i > j:\n                    i, j = j, i\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.934959147317041,
            0.26445895433425903
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by their objective values (prioritize solutions with higher cost)\n        archive_sorted = sorted(archive, key=lambda x: (x[1][0] + x[1][1]), reverse=True)\n        # Select from the top 20% of solutions\n        selected_idx = random.randint(0, max(0, len(archive_sorted) // 5 - 1))\n        base_solution = archive_sorted[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment inversion operator\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment and check feasibility\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply inversion if it improves at least one objective\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If inversion doesn't help, try a different operator: edge exchange\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i != j:\n            # Calculate the cost change\n            old_edges = [\n                (new_solution[i], new_solution[(i+1)%n], distance_matrix_1[new_solution[i], new_solution[(i+1)%n]], distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]),\n                (new_solution[j], new_solution[(j+1)%n], distance_matrix_1[new_solution[j], new_solution[(j+1)%n]], distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n            ]\n            new_edges = [\n                (new_solution[i], new_solution[j], distance_matrix_1[new_solution[i], new_solution[j]], distance_matrix_2[new_solution[i], new_solution[j]]),\n                (new_solution[(i+1)%n], new_solution[(j+1)%n], distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]], distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n            ]\n\n            old_cost1 = old_edges[0][2] + old_edges[1][2]\n            old_cost2 = old_edges[0][3] + old_edges[1][3]\n            new_cost1 = new_edges[0][2] + new_edges[1][2]\n            new_cost2 = new_edges[0][3] + new_edges[1][3]\n\n            if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n                # Perform the edge exchange\n                if i > j:\n                    i, j = j, i\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 46,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic node insertion operator, prioritizing nodes with high potential for cost reduction in both objective spaces while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove and reinsert\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n\n    # Create a temporary solution without the removed node\n    temp_solution = np.delete(new_solution, node_to_remove)\n\n    # Find the best insertion point for the removed node\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(temp_solution, pos, removed_node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_obj1 and new_cost2 < current_obj2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n        # If not better in both, check if it's better in at least one objective\n        elif new_cost1 < current_obj1 or new_cost2 < current_obj2:\n            if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n        # Revert the insertion\n        temp_solution = np.delete(temp_solution, pos)\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, removed_node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.863852762782875,
            0.08395695686340332
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly biased towards better solutions)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove and reinsert\n    node_to_remove = random.randint(0, n - 1)\n    removed_node = new_solution[node_to_remove]\n\n    # Create a temporary solution without the removed node\n    temp_solution = np.delete(new_solution, node_to_remove)\n\n    # Find the best insertion point for the removed node\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(temp_solution, pos, removed_node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_obj1 and new_cost2 < current_obj2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n        # If not better in both, check if it's better in at least one objective\n        elif new_cost1 < current_obj1 or new_cost2 < current_obj2:\n            if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n        # Revert the insertion\n        temp_solution = np.delete(temp_solution, pos)\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, removed_node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 47,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reallocation operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a probabilistic acceptance criterion based on Pareto dominance.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    temp_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        candidate_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[candidate_solution[i], candidate_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[candidate_solution[i], candidate_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a probabilistic swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to accept the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8342978594410696,
            0.3184882402420044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    temp_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        candidate_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[candidate_solution[i], candidate_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[candidate_solution[i], candidate_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a probabilistic swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to accept the swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 48,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n  # Ensure non-adjacent\n\n    # Extract the edges\n    edge1 = (new_solution[i], new_solution[(i + 1) % n])\n    edge2 = (new_solution[j], new_solution[(j + 1) % n])\n\n    # Calculate the cost of the edges in both objectives\n    cost1_edge1 = distance_matrix_1[edge1[0], edge1[1]]\n    cost2_edge1 = distance_matrix_2[edge1[0], edge1[1]]\n    cost1_edge2 = distance_matrix_1[edge2[0], edge2[1]]\n    cost2_edge2 = distance_matrix_2[edge2[0], edge2[1]]\n\n    # Find the best exchange of edges\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_exchange = None\n\n    # Try exchanging the edges\n    temp_solution = new_solution.copy()\n    temp_solution[(i + 1) % n], temp_solution[j] = temp_solution[j], temp_solution[(i + 1) % n]\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n    # Check if this is better in both objectives\n    if new_cost1 < cost1_edge1 + cost1_edge2 and new_cost2 < cost2_edge1 + cost2_edge2:\n        best_cost1, best_cost2 = new_cost1, new_cost2\n        best_exchange = temp_solution.copy()\n\n    if best_exchange is not None:\n        new_solution = best_exchange\n    else:\n        # If no better exchange found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8991693215212375,
            0.2043885588645935
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n  # Ensure non-adjacent\n\n    # Extract the edges\n    edge1 = (new_solution[i], new_solution[(i + 1) % n])\n    edge2 = (new_solution[j], new_solution[(j + 1) % n])\n\n    # Calculate the cost of the edges in both objectives\n    cost1_edge1 = distance_matrix_1[edge1[0], edge1[1]]\n    cost2_edge1 = distance_matrix_2[edge1[0], edge1[1]]\n    cost1_edge2 = distance_matrix_1[edge2[0], edge2[1]]\n    cost2_edge2 = distance_matrix_2[edge2[0], edge2[1]]\n\n    # Find the best exchange of edges\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_exchange = None\n\n    # Try exchanging the edges\n    temp_solution = new_solution.copy()\n    temp_solution[(i + 1) % n], temp_solution[j] = temp_solution[j], temp_solution[(i + 1) % n]\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k + 1) % n]] for k in range(n))\n\n    # Check if this is better in both objectives\n    if new_cost1 < cost1_edge1 + cost1_edge2 and new_cost2 < cost2_edge1 + cost2_edge2:\n        best_cost1, best_cost2 = new_cost1, new_cost2\n        best_exchange = temp_solution.copy()\n\n    if best_exchange is not None:\n        new_solution = best_exchange\n    else:\n        # If no better exchange found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 49,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic node reallocation operator that identifies clusters of nodes in both objective spaces, then reallocates nodes between clusters to create a balanced tour while prioritizing edges with high potential for cost reduction in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify clusters in both objective spaces\n    cluster1 = []\n    cluster2 = []\n    for i in range(n):\n        node = base_solution[i]\n        x1, y1, x2, y2 = instance[node]\n        cluster1.append((x1, y1))\n        cluster2.append((x2, y2))\n\n    # Find centroids of clusters\n    centroid1 = (sum(x for x, y in cluster1)/n, sum(y for x, y in cluster1)/n)\n    centroid2 = (sum(x for x, y in cluster2)/n, sum(y for x, y in cluster2)/n)\n\n    # Find nodes farthest from centroids in each cluster\n    farthest1 = max(range(n), key=lambda i: (cluster1[i][0]-centroid1[0])**2 + (cluster1[i][1]-centroid1[1])**2)\n    farthest2 = max(range(n), key=lambda i: (cluster2[i][0]-centroid2[0])**2 + (cluster2[i][1]-centroid2[1])**2)\n\n    # Swap these nodes to balance the tour\n    if farthest1 != farthest2:\n        new_solution[farthest1], new_solution[farthest2] = new_solution[farthest2], new_solution[farthest1]\n\n    # Additional perturbation: randomly select 3 nodes and reverse their order\n    if n > 2:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7575179139507551,
            0.2399640679359436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify clusters in both objective spaces\n    cluster1 = []\n    cluster2 = []\n    for i in range(n):\n        node = base_solution[i]\n        x1, y1, x2, y2 = instance[node]\n        cluster1.append((x1, y1))\n        cluster2.append((x2, y2))\n\n    # Find centroids of clusters\n    centroid1 = (sum(x for x, y in cluster1)/n, sum(y for x, y in cluster1)/n)\n    centroid2 = (sum(x for x, y in cluster2)/n, sum(y for x, y in cluster2)/n)\n\n    # Find nodes farthest from centroids in each cluster\n    farthest1 = max(range(n), key=lambda i: (cluster1[i][0]-centroid1[0])**2 + (cluster1[i][1]-centroid1[1])**2)\n    farthest2 = max(range(n), key=lambda i: (cluster2[i][0]-centroid2[0])**2 + (cluster2[i][1]-centroid2[1])**2)\n\n    # Swap these nodes to balance the tour\n    if farthest1 != farthest2:\n        new_solution[farthest1], new_solution[farthest2] = new_solution[farthest2], new_solution[farthest1]\n\n    # Additional perturbation: randomly select 3 nodes and reverse their order\n    if n > 2:\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 50,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and incorporates a segment reversal operation to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # If the reversal improves at least one objective, accept it\n    if reversed_cost1 < original_cost1 or reversed_cost2 < original_cost2:\n        return new_solution\n\n    # Otherwise, perform a random edge exchange\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9416236421089716,
            0.1972910761833191
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # If the reversal improves at least one objective, accept it\n    if reversed_cost1 < original_cost1 or reversed_cost2 < original_cost2:\n        return new_solution\n\n    # Otherwise, perform a random edge exchange\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 51,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with an adaptive segment inversion operator that dynamically adjusts the segment size based on objective improvement potential, while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] + obj[1] + 1e-6) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamically determine segment size based on potential improvement\n    segment_size = random.randint(2, min(5, n//2))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    # Extract and invert the segment\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate original and new segment costs\n    orig_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n    orig_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = segment\n\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a-1, b+1))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    # Accept if at least one objective improves\n    if new_cost1 < orig_cost1 or new_cost2 < orig_cost2:\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different segment size\n        segment_size = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - segment_size)\n        b = a + segment_size - 1\n        segment = new_solution[a:b+1][::-1]\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.8768618209198409,
            0.21661359071731567
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] + obj[1] + 1e-6) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamically determine segment size based on potential improvement\n    segment_size = random.randint(2, min(5, n//2))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    # Extract and invert the segment\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate original and new segment costs\n    orig_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n    orig_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = segment\n\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a-1, b+1))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    # Accept if at least one objective improves\n    if new_cost1 < orig_cost1 or new_cost2 < orig_cost2:\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different segment size\n        segment_size = random.randint(2, min(5, n//2))\n        a = random.randint(0, n - segment_size)\n        b = a + segment_size - 1\n        segment = new_solution[a:b+1][::-1]\n        new_solution[a:b+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 52,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment exchange operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to exchange\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n\n    # Extract the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_segment1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_segment1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n\n    cost1_segment2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_segment2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Calculate the cost of the connections between segments\n    if a > 0 and b < n - 1:\n        connection_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b+1]]\n        connection_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b+1]]\n    else:\n        connection_cost1, connection_cost2 = 0, 0\n\n    if c > 0 and d < n - 1:\n        connection_cost1 += distance_matrix_1[new_solution[c-1], new_solution[d+1]]\n        connection_cost2 += distance_matrix_2[new_solution[c-1], new_solution[d+1]]\n\n    # Calculate total cost before exchange\n    total_cost1 = cost1_segment1 + cost1_segment2 + connection_cost1\n    total_cost2 = cost2_segment1 + cost2_segment2 + connection_cost2\n\n    # Try exchanging the segments\n    if a < c:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:a], segment2, new_solution[b+1:]])\n\n    # Calculate new cost after exchange\n    new_cost1_segment1 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    new_cost2_segment1 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    new_cost1_segment2 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    new_cost2_segment2 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n\n    # Calculate new connection cost\n    if a > 0 and b < n - 1:\n        new_connection_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b+1]]\n        new_connection_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b+1]]\n    else:\n        new_connection_cost1, new_connection_cost2 = 0, 0\n\n    if c > 0 and d < n - 1:\n        new_connection_cost1 += distance_matrix_1[new_solution[c-1], new_solution[d+1]]\n        new_connection_cost2 += distance_matrix_2[new_solution[c-1], new_solution[d+1]]\n\n    new_total_cost1 = new_cost1_segment1 + new_cost1_segment2 + new_connection_cost1\n    new_total_cost2 = new_cost2_segment1 + new_cost2_segment2 + new_connection_cost2\n\n    # If the exchange doesn't improve both objectives, revert to the original solution\n    if new_total_cost1 >= total_cost1 or new_total_cost2 >= total_cost2:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7837977114132698,
            0.5426785349845886
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to exchange\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n\n    # Extract the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_segment1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_segment1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n\n    cost1_segment2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_segment2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Calculate the cost of the connections between segments\n    if a > 0 and b < n - 1:\n        connection_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b+1]]\n        connection_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b+1]]\n    else:\n        connection_cost1, connection_cost2 = 0, 0\n\n    if c > 0 and d < n - 1:\n        connection_cost1 += distance_matrix_1[new_solution[c-1], new_solution[d+1]]\n        connection_cost2 += distance_matrix_2[new_solution[c-1], new_solution[d+1]]\n\n    # Calculate total cost before exchange\n    total_cost1 = cost1_segment1 + cost1_segment2 + connection_cost1\n    total_cost2 = cost2_segment1 + cost2_segment2 + connection_cost2\n\n    # Try exchanging the segments\n    if a < c:\n        new_solution = np.concatenate([new_solution[:a], segment2, new_solution[b+1:c], segment1, new_solution[d+1:]])\n    else:\n        new_solution = np.concatenate([new_solution[:c], segment1, new_solution[d+1:a], segment2, new_solution[b+1:]])\n\n    # Calculate new cost after exchange\n    new_cost1_segment1 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    new_cost2_segment1 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    new_cost1_segment2 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    new_cost2_segment2 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n\n    # Calculate new connection cost\n    if a > 0 and b < n - 1:\n        new_connection_cost1 = distance_matrix_1[new_solution[a-1], new_solution[b+1]]\n        new_connection_cost2 = distance_matrix_2[new_solution[a-1], new_solution[b+1]]\n    else:\n        new_connection_cost1, new_connection_cost2 = 0, 0\n\n    if c > 0 and d < n - 1:\n        new_connection_cost1 += distance_matrix_1[new_solution[c-1], new_solution[d+1]]\n        new_connection_cost2 += distance_matrix_2[new_solution[c-1], new_solution[d+1]]\n\n    new_total_cost1 = new_cost1_segment1 + new_cost1_segment2 + new_connection_cost1\n    new_total_cost2 = new_cost2_segment1 + new_cost2_segment2 + new_connection_cost2\n\n    # If the exchange doesn't improve both objectives, revert to the original solution\n    if new_total_cost1 >= total_cost1 or new_total_cost2 >= total_cost2:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 53,
        "algorithm": "{An adaptive hybrid local search strategy combines multi-objective edge prioritization with a dynamic segment relocation operator that evaluates trade-offs between objectives using a weighted score function, ensuring feasibility through a validation mechanism while favoring edges with high potential for combined cost reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_score = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate a weighted score for multi-objective optimization\n        score = 0.7 * (new_cost1 - cost1) + 0.3 * (new_cost2 - cost2)\n\n        # Check if this is better in the weighted score\n        if score < best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8633454596379582,
            0.41469043493270874
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_score = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate a weighted score for multi-objective optimization\n        score = 0.7 * (new_cost1 - cost1) + 0.3 * (new_cost2 - cost2)\n\n        # Check if this is better in the weighted score\n        if score < best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 54,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with an adaptive edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism and incorporating dynamic segment length adjustment.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (dynamic adjustment)\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9790662297494757,
            0.6135044693946838
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment length (dynamic adjustment)\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 55,
        "algorithm": "{A novel hybrid local search strategy that dynamically selects critical edges based on their potential to reduce costs in both objectives, while using a segment relocation operator to explore diverse neighborhoods without violating feasibility constraints.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges based on both objectives\n    edge_scores = []\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        edge_scores.append((score, i))\n\n    # Sort edges by their combined score (higher score = more critical)\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 20% critical edges to consider for modification\n    num_edges_to_consider = max(1, int(0.2 * n))\n    critical_edges = [idx for _, idx in edge_scores[:num_edges_to_consider]]\n\n    # Perform a segment relocation based on critical edges\n    if critical_edges:\n        # Select a random critical edge to work with\n        edge_idx = random.choice(critical_edges)\n        a = edge_idx\n        b = (edge_idx + 1) % n\n\n        # Extract the segment\n        segment = new_solution[a:b+1] if a < b else np.concatenate([new_solution[a:], new_solution[:b+1]])\n\n        # Calculate the cost of the segment in both objectives\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find the best insertion point for the segment\n        best_improvement = 0\n        best_pos = -1\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Try inserting the segment at position 'pos'\n            temp_solution = new_solution.copy()\n            if pos < a:\n                temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:a], temp_solution[b+1:]])\n            else:\n                temp_solution = np.concatenate([temp_solution[:a], temp_solution[b+1:pos], segment, temp_solution[pos:]])\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Calculate improvement in both objectives\n            improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best insertion\n            if best_pos < a:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:a], new_solution[b+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:best_pos], segment, new_solution[best_pos:]])\n        else:\n            # If no better insertion found, perform a random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Fallback to random swap if no critical edges found\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9467882040687444,
            0.694637656211853
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the highest potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges based on both objectives\n    edge_scores = []\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        score = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        edge_scores.append((score, i))\n\n    # Sort edges by their combined score (higher score = more critical)\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top 20% critical edges to consider for modification\n    num_edges_to_consider = max(1, int(0.2 * n))\n    critical_edges = [idx for _, idx in edge_scores[:num_edges_to_consider]]\n\n    # Perform a segment relocation based on critical edges\n    if critical_edges:\n        # Select a random critical edge to work with\n        edge_idx = random.choice(critical_edges)\n        a = edge_idx\n        b = (edge_idx + 1) % n\n\n        # Extract the segment\n        segment = new_solution[a:b+1] if a < b else np.concatenate([new_solution[a:], new_solution[:b+1]])\n\n        # Calculate the cost of the segment in both objectives\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find the best insertion point for the segment\n        best_improvement = 0\n        best_pos = -1\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Try inserting the segment at position 'pos'\n            temp_solution = new_solution.copy()\n            if pos < a:\n                temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:a], temp_solution[b+1:]])\n            else:\n                temp_solution = np.concatenate([temp_solution[:a], temp_solution[b+1:pos], segment, temp_solution[pos:]])\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Calculate improvement in both objectives\n            improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best insertion\n            if best_pos < a:\n                new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:a], new_solution[b+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:a], new_solution[b+1:best_pos], segment, new_solution[best_pos:]])\n        else:\n            # If no better insertion found, perform a random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # Fallback to random swap if no critical edges found\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 56,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent segments to swap\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n    c = random.randint(0, n - 2)\n    d = random.randint(c + 1, n - 1)\n\n    # Ensure segments are not overlapping\n    if (a <= c <= b <= d) or (c <= a <= d <= b):\n        # If overlapping, adjust to create non-overlapping segments\n        c = b + 1 if b + 1 < n else 0\n        d = c + (random.randint(1, n - 1 - (c - b - 1))) if c != 0 else random.randint(1, n - 1)\n\n    # Extract segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Create new solution by swapping the segments\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8487315832677231,
            0.11700451374053955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent segments to swap\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, n - 1)\n    c = random.randint(0, n - 2)\n    d = random.randint(c + 1, n - 1)\n\n    # Ensure segments are not overlapping\n    if (a <= c <= b <= d) or (c <= a <= d <= b):\n        # If overlapping, adjust to create non-overlapping segments\n        c = b + 1 if b + 1 < n else 0\n        d = c + (random.randint(1, n - 1 - (c - b - 1))) if c != 0 else random.randint(1, n - 1)\n\n    # Extract segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Create new solution by swapping the segments\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Validate the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 57,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a novel local search operator\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment and its neighbors\n    segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b))\n\n    # Check if the reversal improves at least one objective\n    if (segment_cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b)) or\n        segment_cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b))):\n        # If improved, keep the reversal\n        pass\n    else:\n        # If not improved, revert the reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a random edge swap to further perturb the solution\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8309557556912373,
            0.21057438850402832
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a novel local search operator\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment and its neighbors\n    segment_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b))\n    segment_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b))\n\n    # Check if the reversal improves at least one objective\n    if (segment_cost1 < sum(distance_matrix_1[new_solution[i], new_solution[i+1]] for i in range(a, b)) or\n        segment_cost2 < sum(distance_matrix_2[new_solution[i], new_solution[i+1]] for i in range(a, b))):\n        # If improved, keep the reversal\n        pass\n    else:\n        # If not improved, revert the reversal\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Apply a random edge swap to further perturb the solution\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 58,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective path relinking mechanism with a dynamic node reinsertion operator, where it selectively reinserts nodes based on their potential to improve both objectives while maintaining feasibility through a probabilistic validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to reinsert\n    node_to_reinsert = random.choice(new_solution)\n\n    # Remove the node from its current position\n    mask = new_solution != node_to_reinsert\n    new_solution = new_solution[mask]\n\n    # Calculate potential insertion positions\n    best_pos = -1\n    best_score = -float('inf')\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node_to_reinsert)\n\n        # Calculate the new cost\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate a combined score considering both objectives\n        current_cost1 = archive[selected_idx][1][0]\n        current_cost2 = archive[selected_idx][1][1]\n        score = (current_cost1 - cost1) * (current_cost2 - cost2)\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node_to_reinsert)\n    else:\n        # If no better position found, insert at a random position\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node_to_reinsert)\n\n    return new_solution\n\n",
        "score": [
            -0.9017775068956562,
            0.9653175473213196
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized_obj = objectives / objectives.max(axis=0)\n    scores = normalized_obj.sum(axis=1)\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to reinsert\n    node_to_reinsert = random.choice(new_solution)\n\n    # Remove the node from its current position\n    mask = new_solution != node_to_reinsert\n    new_solution = new_solution[mask]\n\n    # Calculate potential insertion positions\n    best_pos = -1\n    best_score = -float('inf')\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node_to_reinsert)\n\n        # Calculate the new cost\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate a combined score considering both objectives\n        current_cost1 = archive[selected_idx][1][0]\n        current_cost2 = archive[selected_idx][1][1]\n        score = (current_cost1 - cost1) * (current_cost2 - cost2)\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.insert(new_solution, best_pos, node_to_reinsert)\n    else:\n        # If no better position found, insert at a random position\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node_to_reinsert)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 59,
        "algorithm": "{This algorithm combines multi-objective selection with a novel adaptive segment relocation strategy that dynamically adjusts the segment size based on the relative improvement potential in each objective space, while maintaining feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = sum(o[0] for o in objectives) / len(objectives)\n    avg_obj2 = sum(o[1] for o in objectives) / len(objectives)\n\n    # Prioritize solutions that are above average in at least one objective\n    candidates = [i for i, (obj1, obj2) in enumerate(objectives) if obj1 > avg_obj1 or obj2 > avg_obj2]\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment size selection\n    segment_size = max(2, min(10, random.randint(1, n//3)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    segment = new_solution[a:b+1]\n\n    # Calculate segment cost\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion considering both objectives\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_size + 1):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Multi-objective improvement criterion\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost1 <= cost1 and new_cost2 < cost2):\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a targeted 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.85477467463725,
            0.6405702829360962
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    avg_obj1 = sum(o[0] for o in objectives) / len(objectives)\n    avg_obj2 = sum(o[1] for o in objectives) / len(objectives)\n\n    # Prioritize solutions that are above average in at least one objective\n    candidates = [i for i, (obj1, obj2) in enumerate(objectives) if obj1 > avg_obj1 or obj2 > avg_obj2]\n    if not candidates:\n        candidates = list(range(len(archive)))\n\n    selected_idx = random.choice(candidates)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment size selection\n    segment_size = max(2, min(10, random.randint(1, n//3)))\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    segment = new_solution[a:b+1]\n\n    # Calculate segment cost\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion considering both objectives\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_size + 1):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Multi-objective improvement criterion\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost1 <= cost1 and new_cost2 < cost2):\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a targeted 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        if j - i > 1:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 60,
        "algorithm": "{The new algorithm combines multi-objective selection with a novel adaptive segment relocation strategy that dynamically adjusts segment size based on the current solution's objective values, prioritizing regions with high potential for improvement while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    costs = np.array(objectives)\n    # Normalize objectives\n    norm_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    # Calculate dominance scores (sum of normalized costs)\n    dominance = norm_costs.sum(axis=1)\n    # Inverse selection probability\n    probs = 1 / (dominance + 1e-10)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment size based on current solution's characteristics\n    segment_size = max(2, min(5, int(n * np.random.uniform(0.1, 0.3))))\n\n    # Randomly select a segment of adaptive size\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    # Consider only positions that are not too close to the original segment\n    valid_positions = [pos for pos in range(n) if pos < a - 2 or pos > b + 2]\n\n    for pos in valid_positions:\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Probabilistic acceptance criterion\n        if (new_cost1 < cost1 and new_cost2 <= cost2 * 1.05) or (new_cost2 < cost2 and new_cost1 <= cost1 * 1.05):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        for i in range(n):\n            if random.random() < 0.2:  # 20% chance to swap\n                j = random.randint(0, n - 1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8461060526356565,
            0.5850579142570496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = [obj for _, obj in archive]\n    costs = np.array(objectives)\n    # Normalize objectives\n    norm_costs = (costs - costs.min(axis=0)) / (costs.max(axis=0) - costs.min(axis=0) + 1e-10)\n    # Calculate dominance scores (sum of normalized costs)\n    dominance = norm_costs.sum(axis=1)\n    # Inverse selection probability\n    probs = 1 / (dominance + 1e-10)\n    probs /= probs.sum()\n    selected_idx = np.random.choice(len(archive), p=probs)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment size based on current solution's characteristics\n    segment_size = max(2, min(5, int(n * np.random.uniform(0.1, 0.3))))\n\n    # Randomly select a segment of adaptive size\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    # Consider only positions that are not too close to the original segment\n    valid_positions = [pos for pos in range(n) if pos < a - 2 or pos > b + 2]\n\n    for pos in valid_positions:\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Probabilistic acceptance criterion\n        if (new_cost1 < cost1 and new_cost2 <= cost2 * 1.05) or (new_cost2 < cost2 and new_cost1 <= cost1 * 1.05):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        for i in range(n):\n            if random.random() < 0.2:  # 20% chance to swap\n                j = random.randint(0, n - 1)\n                if i != j:\n                    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 61,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment relocation operator that adaptively balances cost reduction across both objectives by prioritizing segments with high potential for improvement while ensuring feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Adaptive selection criterion: prioritize solutions that improve at least one objective\n        if (new_cost1 < cost1) or (new_cost2 < cost2):\n            if (new_cost1 < best_cost1) and (new_cost2 < best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7818423851440267,
            0.6089363098144531
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Adaptive selection criterion: prioritize solutions that improve at least one objective\n        if (new_cost1 < cost1) or (new_cost2 < cost2):\n            if (new_cost1 < best_cost1) and (new_cost2 < best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 62,
        "algorithm": "{This algorithm implements a dynamic edge exchange strategy that evaluates potential edge swaps based on both objective spaces, using a weighted dominance criterion to prioritize improvements while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted dominance (prioritize solutions with better potential)\n    weights = [1.0 / (1 + i) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge exchange strategy\n    for _ in range(10):  # Perform multiple edge exchanges\n        i, j = random.sample(range(n), 2)\n\n        # Calculate change in both objectives\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - (\n                  distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - (\n                  distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted dominance criterion\n        if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 <= 0 and (delta1 < 0 or delta2 < 0)):\n            # Apply the exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8004801951718352,
            0.43719011545181274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on weighted dominance (prioritize solutions with better potential)\n    weights = [1.0 / (1 + i) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge exchange strategy\n    for _ in range(10):  # Perform multiple edge exchanges\n        i, j = random.sample(range(n), 2)\n\n        # Calculate change in both objectives\n        delta1 = (distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[(j-1)%n], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]) - (\n                  distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_1[new_solution[(j-1)%n], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        delta2 = (distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[(j-1)%n], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]) - (\n                  distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                  distance_matrix_2[new_solution[(j-1)%n], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        # Weighted dominance criterion\n        if (delta1 < 0 and delta2 < 0) or (delta1 <= 0 and delta2 <= 0 and (delta1 < 0 or delta2 < 0)):\n            # Apply the exchange\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 63,
        "algorithm": "{A novel hybrid local search strategy combines multi-objective edge selection with a dynamic path reversal operator that identifies and reverses high-cost segments in both objective spaces while maintaining tour feasibility through a comprehensive validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Identify high-cost segments in both objectives\n    high_cost_indices = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[base_solution[i], base_solution[j]]\n        cost2 = distance_matrix_2[base_solution[i], base_solution[j]]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_indices.append(i)\n\n    if not high_cost_indices:\n        high_cost_indices = list(range(n))\n\n    # Select a random high-cost segment to reverse\n    start_idx = random.choice(high_cost_indices)\n    length = random.randint(2, min(5, n // 2))\n\n    # Ensure we don't go out of bounds\n    end_idx = (start_idx + length) % n\n    if start_idx > end_idx:\n        segment = np.concatenate([base_solution[start_idx:], base_solution[:end_idx]])\n    else:\n        segment = base_solution[start_idx:end_idx]\n\n    # Reverse the selected segment\n    reversed_segment = segment[::-1]\n\n    # Reconstruct the solution\n    new_solution = base_solution.copy()\n    if start_idx > end_idx:\n        new_solution = np.concatenate([\n            base_solution[:end_idx],\n            reversed_segment,\n            base_solution[start_idx:]\n        ])\n    else:\n        new_solution[start_idx:end_idx] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.813324972259637,
            0.32181328535079956
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Identify high-cost segments in both objectives\n    high_cost_indices = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[base_solution[i], base_solution[j]]\n        cost2 = distance_matrix_2[base_solution[i], base_solution[j]]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            high_cost_indices.append(i)\n\n    if not high_cost_indices:\n        high_cost_indices = list(range(n))\n\n    # Select a random high-cost segment to reverse\n    start_idx = random.choice(high_cost_indices)\n    length = random.randint(2, min(5, n // 2))\n\n    # Ensure we don't go out of bounds\n    end_idx = (start_idx + length) % n\n    if start_idx > end_idx:\n        segment = np.concatenate([base_solution[start_idx:], base_solution[:end_idx]])\n    else:\n        segment = base_solution[start_idx:end_idx]\n\n    # Reverse the selected segment\n    reversed_segment = segment[::-1]\n\n    # Reconstruct the solution\n    new_solution = base_solution.copy()\n    if start_idx > end_idx:\n        new_solution = np.concatenate([\n            base_solution[:end_idx],\n            reversed_segment,\n            base_solution[start_idx:]\n        ])\n    else:\n        new_solution[start_idx:end_idx] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 64,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or (i == 0 and j == n - 1) or (j == 0 and i == n - 1):\n        j = random.randint(0, n - 1)\n\n    # Extract the edges\n    if i > j:\n        i, j = j, i\n\n    # Create the new solution by reversing the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate the solution (ensure no duplicates and all nodes are included)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8990902904128132,
            0.18235957622528076
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or (i == 0 and j == n - 1) or (j == 0 and i == n - 1):\n        j = random.randint(0, n - 1)\n\n    # Extract the edges\n    if i > j:\n        i, j = j, i\n\n    # Create the new solution by reversing the segment between i and j\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Validate the solution (ensure no duplicates and all nodes are included)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 65,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective edge prioritization mechanism with a dynamic segment relocation operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9816907909733963,
            0.49506616592407227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 66,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to reconnect\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Reconnect the edges in a way that maintains feasibility\n    if i > j:\n        i, j = j, i\n\n    # Perform a 3-opt move to reconnect the edges\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Calculate the cost of the new solution\n    new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n    # Accept the new solution if it improves at least one objective\n    if new_cost1 < archive[selected_idx][1][0] or new_cost2 < archive[selected_idx][1][1]:\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9836201734403489,
            0.5112215876579285
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to reconnect\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n or j == (i - 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Reconnect the edges in a way that maintains feasibility\n    if i > j:\n        i, j = j, i\n\n    # Perform a 3-opt move to reconnect the edges\n    temp_solution = new_solution.copy()\n    temp_solution[i:j+1] = temp_solution[i:j+1][::-1]  # Reverse the segment\n\n    # Calculate the cost of the new solution\n    new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n    # Accept the new solution if it improves at least one objective\n    if new_cost1 < archive[selected_idx][1][0] or new_cost2 < archive[selected_idx][1][1]:\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 67,
        "algorithm": "{A novel adaptive multi-objective local search strategy that combines a dynamic path reversal operator with a guided edge insertion mechanism, where nodes are selected based on their potential to improve both objectives while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Calculate the cost of the reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    # If the reversal is worse in both objectives, reverse back\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2) and random.random() < 0.7:\n        new_solution[a:b+1] = segment\n\n    # Perform guided edge insertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i == j:\n            continue\n\n        # Calculate potential improvement\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[j], new_solution[(i+1)%n])\n        ]\n\n        old_cost1 = sum(distance_matrix_1[a, b] for a, b in old_edges)\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        old_cost2 = sum(distance_matrix_2[a, b] for a, b in old_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n            # Swap the nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.926683609512041,
            0.22382879257202148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    new_solution[a:b+1] = segment[::-1]\n\n    # Calculate the cost of the reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a-1, b+1))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    # If the reversal is worse in both objectives, reverse back\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2) and random.random() < 0.7:\n        new_solution[a:b+1] = segment\n\n    # Perform guided edge insertion\n    for _ in range(2):\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if i == j:\n            continue\n\n        # Calculate potential improvement\n        old_edges = [\n            (new_solution[i-1], new_solution[i]),\n            (new_solution[j], new_solution[(j+1)%n]),\n            (new_solution[i], new_solution[(i+1)%n]),\n            (new_solution[j-1], new_solution[j])\n        ]\n        new_edges = [\n            (new_solution[i-1], new_solution[j]),\n            (new_solution[i], new_solution[(j+1)%n]),\n            (new_solution[j-1], new_solution[i]),\n            (new_solution[j], new_solution[(i+1)%n])\n        ]\n\n        old_cost1 = sum(distance_matrix_1[a, b] for a, b in old_edges)\n        new_cost1 = sum(distance_matrix_1[a, b] for a, b in new_edges)\n        old_cost2 = sum(distance_matrix_2[a, b] for a, b in old_edges)\n        new_cost2 = sum(distance_matrix_2[a, b] for a, b in new_edges)\n\n        if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.3:\n            # Swap the nodes\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 68,
        "algorithm": "{A novel hybrid local search strategy that combines adaptive segment relinking with multi-objective edge prioritization, dynamically selecting and reinserting segments based on their potential to improve both objectives while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + (obj[0] + obj[1])) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on objective improvement potential\n    segment_length = max(2, random.randint(1, min(5, n//2)))\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n    segment = new_solution[a:b+1]\n\n    # Calculate segment cost\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Probabilistic edge prioritization for insertion\n    candidates = []\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n        if improvement > 0:\n            candidates.append((pos, new_cost1, new_cost2, improvement))\n\n    if candidates:\n        # Select insertion with highest combined improvement probability\n        candidates.sort(key=lambda x: -x[3])\n        selected_candidate = candidates[0]\n        new_solution = np.concatenate([new_solution[:selected_candidate[0]], segment, new_solution[selected_candidate[0]:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.7:  # Higher probability for beneficial swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8435445482046644,
            0.7064950466156006
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective diversity)\n    weights = [1.0 / (1.0 + (obj[0] + obj[1])) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on objective improvement potential\n    segment_length = max(2, random.randint(1, min(5, n//2)))\n    a = random.randint(0, n - segment_length)\n    b = a + segment_length - 1\n    segment = new_solution[a:b+1]\n\n    # Calculate segment cost\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Probabilistic edge prioritization for insertion\n    candidates = []\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        improvement = (cost1 - new_cost1) + (cost2 - new_cost2)\n        if improvement > 0:\n            candidates.append((pos, new_cost1, new_cost2, improvement))\n\n    if candidates:\n        # Select insertion with highest combined improvement probability\n        candidates.sort(key=lambda x: -x[3])\n        selected_candidate = candidates[0]\n        new_solution = np.concatenate([new_solution[:selected_candidate[0]], segment, new_solution[selected_candidate[0]:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.7:  # Higher probability for beneficial swaps\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 69,
        "algorithm": "{A novel dynamic segment-based local search strategy with adaptive edge prioritization combines multi-objective cost evaluation and probabilistic edge selection to generate high-quality neighbors, balancing exploration and exploitation through a weighted scoring mechanism that considers both objective spaces and solution diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted score\n    scores = []\n    for sol, obj in archive:\n        # Calculate a score combining both objectives and solution diversity\n        score = (obj[0] + obj[1]) / (len(sol) ** 0.5)  # Weighted by solution length\n        scores.append(score)\n\n    # Select solution with the highest score (potential for improvement)\n    selected_idx = scores.index(max(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic segment selection based on edge potential\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length between 2 and 5 or n/2\n\n    # Select a random segment\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate potential improvement for the segment\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < start + segment_length:\n            continue  # Skip current segment position\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Weighted cost improvement\n        cost_improvement = (new_cost1 - current_cost1) + (new_cost2 - current_cost2)\n\n        if cost_improvement < best_cost:\n            best_cost = cost_improvement\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        swap_prob = 0.3  # Probability of performing a swap\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8213721764800536,
            0.37664496898651123
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted score\n    scores = []\n    for sol, obj in archive:\n        # Calculate a score combining both objectives and solution diversity\n        score = (obj[0] + obj[1]) / (len(sol) ** 0.5)  # Weighted by solution length\n        scores.append(score)\n\n    # Select solution with the highest score (potential for improvement)\n    selected_idx = scores.index(max(scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Dynamic segment selection based on edge potential\n    n = len(base_solution)\n    segment_length = random.randint(2, min(5, n // 2))  # Random segment length between 2 and 5 or n/2\n\n    # Select a random segment\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start + segment_length]\n\n    # Calculate potential improvement for the segment\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < start + segment_length:\n            continue  # Skip current segment position\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Weighted cost improvement\n        cost_improvement = (new_cost1 - current_cost1) + (new_cost2 - current_cost2)\n\n        if cost_improvement < best_cost:\n            best_cost = cost_improvement\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        swap_prob = 0.3  # Probability of performing a swap\n        if random.random() < swap_prob:\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 70,
        "algorithm": "{A novel hybrid local search strategy combines multi-objective Pareto dominance with a dynamic edge exchange operator that prioritizes edges with high potential for cost reduction in both objective spaces, using a weighted sum approach to balance improvements while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected_idx = max(range(len(archive)),\n                      key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a dynamic edge exchange operation\n    i, j = random.sample(range(n), 2)\n    k, l = random.sample(range(n), 2)\n\n    # Ensure feasibility by checking if the new edges are valid\n    if i != j and k != l and i != k and j != l:\n        # Create a temporary solution with the edge exchange\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n        temp_solution[j], temp_solution[l] = temp_solution[l], temp_solution[j]\n\n        # Validate the new solution\n        if len(set(temp_solution)) == n:  # Ensure all nodes are visited exactly once\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9692409661484737,
            0.2667914628982544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Weight for first objective is higher\n    selected_idx = max(range(len(archive)),\n                      key=lambda i: weights[0] * archive[i][1][0] + weights[1] * archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Perform a dynamic edge exchange operation\n    i, j = random.sample(range(n), 2)\n    k, l = random.sample(range(n), 2)\n\n    # Ensure feasibility by checking if the new edges are valid\n    if i != j and k != l and i != k and j != l:\n        # Create a temporary solution with the edge exchange\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n        temp_solution[j], temp_solution[l] = temp_solution[l], temp_solution[j]\n\n        # Validate the new solution\n        if len(set(temp_solution)) == n:  # Ensure all nodes are visited exactly once\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 71,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node insertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove\n    remove_pos = random.randint(0, n - 1)\n    removed_node = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n\n    # Find the best insertion point for the removed node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, removed_node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, removed_node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, removed_node)\n\n    return new_solution\n\n",
        "score": [
            -0.8656964284349107,
            1.407954454421997
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to remove\n    remove_pos = random.randint(0, n - 1)\n    removed_node = new_solution[remove_pos]\n    new_solution = np.delete(new_solution, remove_pos)\n\n    # Find the best insertion point for the removed node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, removed_node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, removed_node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, removed_node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 72,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = random.sample(range(n), 2)\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Check if swapping edges improves both objectives\n    current_cost1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[j], base_solution[l]]\n    current_cost2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[j], base_solution[l]]\n\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[k], base_solution[l]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[k], base_solution[l]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Perform the edge swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If not better, perform a random 2-opt\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9330266786903766,
            0.2686464786529541
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two edges to swap\n    i, j = random.sample(range(n), 2)\n    k = (i + 1) % n\n    l = (j + 1) % n\n\n    # Check if swapping edges improves both objectives\n    current_cost1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[j], base_solution[l]]\n    current_cost2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[j], base_solution[l]]\n\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[k], base_solution[l]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[k], base_solution[l]]\n\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Perform the edge swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If not better, perform a random 2-opt\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 73,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node sequence inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Replace the original segment with the inverted one\n    new_solution[a:b+1] = inverted_segment\n\n    # Calculate the cost of the new solution\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the new solution is worse in both objectives, revert to the original\n    if (new_cost1 >= sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) and\n        new_cost2 >= sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8244118823006303,
            0.4146891236305237
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Replace the original segment with the inverted one\n    new_solution[a:b+1] = inverted_segment\n\n    # Calculate the cost of the new solution\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the new solution is worse in both objectives, revert to the original\n    if (new_cost1 >= sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) and\n        new_cost2 >= sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 74,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment reordering operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reorder\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best reordering of the segment\n    best_segment = segment.copy()\n    best_cost1, best_cost2 = cost1, cost2\n\n    for _ in range(10):  # Try 10 random reorderings\n        temp_segment = segment.copy()\n        random.shuffle(temp_segment)\n\n        temp_cost1 = sum(distance_matrix_1[temp_segment[i], temp_segment[(i+1)%len(temp_segment)]] for i in range(len(temp_segment)))\n        temp_cost2 = sum(distance_matrix_2[temp_segment[i], temp_segment[(i+1)%len(temp_segment)]] for i in range(len(temp_segment)))\n\n        if (temp_cost1 < best_cost1 and temp_cost2 <= best_cost2) or (temp_cost1 <= best_cost1 and temp_cost2 < best_cost2):\n            best_segment = temp_segment\n            best_cost1, best_cost2 = temp_cost1, temp_cost2\n\n    # Apply the best reordering\n    new_solution[a:b+1] = best_segment\n\n    # Validate the solution\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid solution generated\")\n\n    return new_solution\n\n",
        "score": [
            -0.6879679621377086,
            0.9338228702545166
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reorder\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best reordering of the segment\n    best_segment = segment.copy()\n    best_cost1, best_cost2 = cost1, cost2\n\n    for _ in range(10):  # Try 10 random reorderings\n        temp_segment = segment.copy()\n        random.shuffle(temp_segment)\n\n        temp_cost1 = sum(distance_matrix_1[temp_segment[i], temp_segment[(i+1)%len(temp_segment)]] for i in range(len(temp_segment)))\n        temp_cost2 = sum(distance_matrix_2[temp_segment[i], temp_segment[(i+1)%len(temp_segment)]] for i in range(len(temp_segment)))\n\n        if (temp_cost1 < best_cost1 and temp_cost2 <= best_cost2) or (temp_cost1 <= best_cost1 and temp_cost2 < best_cost2):\n            best_segment = temp_segment\n            best_cost1, best_cost2 = temp_cost1, temp_cost2\n\n    # Apply the best reordering\n    new_solution[a:b+1] = best_segment\n\n    # Validate the solution\n    if len(set(new_solution)) != n:\n        raise ValueError(\"Invalid solution generated\")\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 75,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) == 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9090663278141319,
            0.18362420797348022
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) == 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible by checking for duplicates\n    if len(set(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 76,
        "algorithm": "{A novel adaptive segment exchange strategy dynamically selects promising segments based on their potential for Pareto improvement, using a weighted combination of objective improvements to guide the search while maintaining feasibility through a constraint-aware validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest weighted sum of normalized objective improvements\n    weighted_scores = []\n    for sol, obj in archive:\n        # Normalize objectives (assuming archive contains non-dominated solutions)\n        if len(archive) == 1:\n            norm_obj1 = norm_obj2 = 1.0\n        else:\n            objs1 = [o[0] for _, o in archive]\n            objs2 = [o[1] for _, o in archive]\n            norm_obj1 = (obj[0] - min(objs1)) / (max(objs1) - min(objs1) + 1e-6)\n            norm_obj2 = (obj[1] - min(objs2)) / (max(objs2) - min(objs2) + 1e-6)\n        # Weighted score (can be adjusted)\n        weighted_score = 0.6 * norm_obj1 + 0.4 * norm_obj2\n        weighted_scores.append(weighted_score)\n\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive segment exchange\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a segment with high potential for improvement\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current segment cost\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_score = -float('inf')\n    best_pos = -1\n\n    for pos in range(n):\n        if start <= pos < start + segment_length:\n            continue  # Skip current segment\n\n        # Create temporary solution\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement score (weighted)\n        improvement1 = (current_cost1 - (new_cost1 - current_cost1)) / (current_cost1 + 1e-6)\n        improvement2 = (current_cost2 - (new_cost2 - current_cost2)) / (current_cost2 + 1e-6)\n        score = 0.6 * improvement1 + 0.4 * improvement2\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8729887980406972,
            3.009310245513916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest weighted sum of normalized objective improvements\n    weighted_scores = []\n    for sol, obj in archive:\n        # Normalize objectives (assuming archive contains non-dominated solutions)\n        if len(archive) == 1:\n            norm_obj1 = norm_obj2 = 1.0\n        else:\n            objs1 = [o[0] for _, o in archive]\n            objs2 = [o[1] for _, o in archive]\n            norm_obj1 = (obj[0] - min(objs1)) / (max(objs1) - min(objs1) + 1e-6)\n            norm_obj2 = (obj[1] - min(objs2)) / (max(objs2) - min(objs2) + 1e-6)\n        # Weighted score (can be adjusted)\n        weighted_score = 0.6 * norm_obj1 + 0.4 * norm_obj2\n        weighted_scores.append(weighted_score)\n\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate neighbor using adaptive segment exchange\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a segment with high potential for improvement\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate current segment cost\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_score = -float('inf')\n    best_pos = -1\n\n    for pos in range(n):\n        if start <= pos < start + segment_length:\n            continue  # Skip current segment\n\n        # Create temporary solution\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement score (weighted)\n        improvement1 = (current_cost1 - (new_cost1 - current_cost1)) / (current_cost1 + 1e-6)\n        improvement2 = (current_cost2 - (new_cost2 - current_cost2)) / (current_cost2 + 1e-6)\n        score = 0.6 * improvement1 + 0.4 * improvement2\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 77,
        "algorithm": "{A novel adaptive local search strategy that combines a multi-objective edge selection criterion with a dynamic path reversal operator, which selectively reverses segments of the tour to improve both objectives while maintaining feasibility through a validation mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse the selected segments if they improve at least one objective\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n    temp_solution[c:d+1] = temp_solution[c:d+1][::-1]\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate the original cost\n    orig_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n    orig_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n\n    # Apply the change if it improves at least one objective\n    if new_cost1 < orig_cost1 or new_cost2 < orig_cost2:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.943011821153761,
            0.25115853548049927
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: x[1][0] + x[1][1])[0].copy()\n    new_solution = selected_solution.copy()\n\n    n = len(new_solution)\n\n    # Randomly select two segments to reverse\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Reverse the selected segments if they improve at least one objective\n    temp_solution = new_solution.copy()\n    temp_solution[a:b+1] = temp_solution[a:b+1][::-1]\n    temp_solution[c:d+1] = temp_solution[c:d+1][::-1]\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate the original cost\n    orig_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n    orig_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n\n    # Apply the change if it improves at least one objective\n    if new_cost1 < orig_cost1 or new_cost2 < orig_cost2:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 78,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) == 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Perform the edge exchange\n    if i > j:\n        i, j = j, i\n\n    # Extract the two edges to be exchanged\n    edge1 = (new_solution[i], new_solution[(i + 1) % n])\n    edge2 = (new_solution[j], new_solution[(j + 1) % n])\n\n    # Calculate the cost of the current and new edges in both objectives\n    current_cost1 = distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]]\n    current_cost2 = distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]]\n\n    new_edge1 = (edge1[0], edge2[0])\n    new_edge2 = (edge1[1], edge2[1])\n    new_cost1 = distance_matrix_1[new_edge1[0], new_edge1[1]] + distance_matrix_1[new_edge2[0], new_edge2[1]]\n    new_cost2 = distance_matrix_2[new_edge1[0], new_edge1[1]] + distance_matrix_2[new_edge2[0], new_edge2[1]]\n\n    # Apply the exchange if it improves at least one objective\n    if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n        # Create the new solution by reversing the segment between i and j\n        new_solution[i + 1:j + 1] = new_solution[i + 1:j + 1][::-1]\n    else:\n        # If no improvement, perform a random 2-opt move\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k > l:\n            k, l = l, k\n        new_solution[k + 1:l + 1] = new_solution[k + 1:l + 1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7108601802965364,
            0.340853214263916
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    n = len(new_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) == 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Perform the edge exchange\n    if i > j:\n        i, j = j, i\n\n    # Extract the two edges to be exchanged\n    edge1 = (new_solution[i], new_solution[(i + 1) % n])\n    edge2 = (new_solution[j], new_solution[(j + 1) % n])\n\n    # Calculate the cost of the current and new edges in both objectives\n    current_cost1 = distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]]\n    current_cost2 = distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]]\n\n    new_edge1 = (edge1[0], edge2[0])\n    new_edge2 = (edge1[1], edge2[1])\n    new_cost1 = distance_matrix_1[new_edge1[0], new_edge1[1]] + distance_matrix_1[new_edge2[0], new_edge2[1]]\n    new_cost2 = distance_matrix_2[new_edge1[0], new_edge1[1]] + distance_matrix_2[new_edge2[0], new_edge2[1]]\n\n    # Apply the exchange if it improves at least one objective\n    if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n        # Create the new solution by reversing the segment between i and j\n        new_solution[i + 1:j + 1] = new_solution[i + 1:j + 1][::-1]\n    else:\n        # If no improvement, perform a random 2-opt move\n        k = random.randint(0, n - 1)\n        l = random.randint(0, n - 1)\n        if k > l:\n            k, l = l, k\n        new_solution[k + 1:l + 1] = new_solution[k + 1:l + 1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 79,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct segments to exchange\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Extract the segments\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Try inserting segment1 into position b1 and segment2 into position a1\n    temp_solution = new_solution.copy()\n    temp_solution = np.concatenate([temp_solution[:b1], segment1, temp_solution[b1:]])\n    temp_solution = np.concatenate([temp_solution[:a1], segment2, temp_solution[a1:]])\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Accept if at least one objective improves\n    if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n        new_solution = temp_solution\n    else:\n        # If not, perform a random 3-opt move as fallback\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8181720939370846,
            0.1333475112915039
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct segments to exchange\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Extract the segments\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Try inserting segment1 into position b1 and segment2 into position a1\n    temp_solution = new_solution.copy()\n    temp_solution = np.concatenate([temp_solution[:b1], segment1, temp_solution[b1:]])\n    temp_solution = np.concatenate([temp_solution[:a1], segment2, temp_solution[a1:]])\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Accept if at least one objective improves\n    if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n        new_solution = temp_solution\n    else:\n        # If not, perform a random 3-opt move as fallback\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 80,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    temp_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution_inserted = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution_inserted[i], temp_solution_inserted[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost1 += distance_matrix_1[temp_solution_inserted[-1], temp_solution_inserted[0]]  # Add the closing edge\n\n        new_cost2 = sum(distance_matrix_2[temp_solution_inserted[i], temp_solution_inserted[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 += distance_matrix_2[temp_solution_inserted[-1], temp_solution_inserted[0]]  # Add the closing edge\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([temp_solution[:best_insert_pos], [node], temp_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8042178900751089,
            1.671055018901825
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    temp_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution_inserted = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution_inserted[i], temp_solution_inserted[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost1 += distance_matrix_1[temp_solution_inserted[-1], temp_solution_inserted[0]]  # Add the closing edge\n\n        new_cost2 = sum(distance_matrix_2[temp_solution_inserted[i], temp_solution_inserted[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 += distance_matrix_2[temp_solution_inserted[-1], temp_solution_inserted[0]]  # Add the closing edge\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([temp_solution[:best_insert_pos], [node], temp_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 81,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic node reordering operator that prioritizes nodes with high potential for cost reduction in both objectives, while maintaining feasibility through a novel validation mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of nodes to reorder\n    subset_size = random.randint(2, min(5, n))\n    subset_indices = random.sample(range(n), subset_size)\n    subset = [new_solution[i] for i in subset_indices]\n\n    # Calculate the current cost of the subset in both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in subset_indices)\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in subset_indices)\n\n    # Find the best reordering of the subset\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_permutation = None\n\n    for _ in range(5):  # Try a few random permutations\n        permutation = random.sample(subset, len(subset))\n        temp_solution = new_solution.copy()\n        for idx, node in zip(subset_indices, permutation):\n            temp_solution[idx] = node\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_permutation = permutation\n            break  # Early exit if found a clearly better solution\n\n    if best_permutation is not None:\n        # Apply the best permutation\n        for idx, node in zip(subset_indices, best_permutation):\n            new_solution[idx] = node\n    else:\n        # If no better permutation found, perform a random 2-opt\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9200459102284517,
            0.32452523708343506
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a subset of nodes to reorder\n    subset_size = random.randint(2, min(5, n))\n    subset_indices = random.sample(range(n), subset_size)\n    subset = [new_solution[i] for i in subset_indices]\n\n    # Calculate the current cost of the subset in both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in subset_indices)\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in subset_indices)\n\n    # Find the best reordering of the subset\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_permutation = None\n\n    for _ in range(5):  # Try a few random permutations\n        permutation = random.sample(subset, len(subset))\n        temp_solution = new_solution.copy()\n        for idx, node in zip(subset_indices, permutation):\n            temp_solution[idx] = node\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_permutation = permutation\n            break  # Early exit if found a clearly better solution\n\n    if best_permutation is not None:\n        # Apply the best permutation\n        for idx, node in zip(subset_indices, best_permutation):\n            new_solution[idx] = node\n    else:\n        # If no better permutation found, perform a random 2-opt\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 82,
        "algorithm": "{A novel adaptive path relocation strategy that dynamically selects and relocates segments of the tour based on their potential for cost reduction in both objectives, using a weighted combination of objective improvements to guide the search while maintaining feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n\n    # Calculate the current cost of the segment in both objectives\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best relocation position based on weighted objective improvement\n    best_weighted_improvement = -float('inf')\n    best_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try relocating the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate weighted improvement (equal weights for simplicity)\n        improvement1 = current_cost1 - sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        improvement2 = current_cost2 - sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        weighted_improvement = improvement1 + improvement2\n\n        if weighted_improvement > best_weighted_improvement:\n            best_weighted_improvement = weighted_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7843195854504934,
            0.4952128529548645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective value\n    archive.sort(key=lambda x: sum(x[1]))\n    base_solution = archive[0][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to relocate\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n\n    # Calculate the current cost of the segment in both objectives\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best relocation position based on weighted objective improvement\n    best_weighted_improvement = -float('inf')\n    best_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try relocating the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate weighted improvement (equal weights for simplicity)\n        improvement1 = current_cost1 - sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        improvement2 = current_cost2 - sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        weighted_improvement = improvement1 + improvement2\n\n        if weighted_improvement > best_weighted_improvement:\n            best_weighted_improvement = weighted_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 83,
        "algorithm": "{This new algorithm combines a multi-objective edge selection criterion with a dynamic node reinsertion strategy that prioritizes nodes with high potential for cost reduction in both objectives, while maintaining feasibility through a validation mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the cost of removing the node\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    cost1_removed = distance_matrix_1[prev_node, next_node]\n    cost2_removed = distance_matrix_2[prev_node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and its immediate neighbor\n\n        # Calculate the cost of inserting the node at position 'pos'\n        prev_pos = pos\n        next_pos = (pos + 1) % n\n        cost1_inserted = distance_matrix_1[new_solution[prev_pos], node] + distance_matrix_1[node, new_solution[next_pos]]\n        cost2_inserted = distance_matrix_2[new_solution[prev_pos], node] + distance_matrix_2[node, new_solution[next_pos]]\n\n        # Calculate the total cost change\n        delta_cost1 = cost1_inserted - cost1_removed\n        delta_cost2 = cost2_inserted - cost2_removed\n\n        # Check if this is better in both objectives\n        if delta_cost1 < 0 and delta_cost2 < 0:\n            best_cost1, best_cost2 = delta_cost1, delta_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random 2-opt move\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8922013392333197,
            0.2142365574836731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the cost of removing the node\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    cost1_removed = distance_matrix_1[prev_node, next_node]\n    cost2_removed = distance_matrix_2[prev_node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and its immediate neighbor\n\n        # Calculate the cost of inserting the node at position 'pos'\n        prev_pos = pos\n        next_pos = (pos + 1) % n\n        cost1_inserted = distance_matrix_1[new_solution[prev_pos], node] + distance_matrix_1[node, new_solution[next_pos]]\n        cost2_inserted = distance_matrix_2[new_solution[prev_pos], node] + distance_matrix_2[node, new_solution[next_pos]]\n\n        # Calculate the total cost change\n        delta_cost1 = cost1_inserted - cost1_removed\n        delta_cost2 = cost2_inserted - cost2_removed\n\n        # Check if this is better in both objectives\n        if delta_cost1 < 0 and delta_cost2 < 0:\n            best_cost1, best_cost2 = delta_cost1, delta_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random 2-opt move\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 84,
        "algorithm": "{A novel hybrid local search strategy integrates a dynamic edge exchange mechanism that evaluates edge contributions across both objectives, prioritizing edges with high potential for cost reduction while ensuring feasibility through a multi-criteria validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate the current cost of the base solution\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Find the worst edge in each objective\n    worst_edge1 = max(range(n), key=lambda i: distance_matrix_1[base_solution[i], base_solution[(i+1)%n]])\n    worst_edge2 = max(range(n), key=lambda i: distance_matrix_2[base_solution[i], base_solution[(i+1)%n]])\n\n    # Try to replace the worst edges with better ones\n    for edge in [worst_edge1, worst_edge2]:\n        i, j = edge, (edge + 1) % n\n        u, v = base_solution[i], base_solution[j]\n\n        # Find the best replacement edge\n        best_replacement = None\n        min_cost1, min_cost2 = float('inf'), float('inf')\n\n        for k in range(n):\n            if k == i or k == j or k == (j + 1) % n:\n                continue\n\n            # Try connecting i to k and k to j\n            new_cost1 = (distance_matrix_1[u, base_solution[k]] + distance_matrix_1[base_solution[k], v]\n                        - distance_matrix_1[u, v])\n            new_cost2 = (distance_matrix_2[u, base_solution[k]] + distance_matrix_2[base_solution[k], v]\n                        - distance_matrix_2[u, v])\n\n            if new_cost1 < min_cost1 and new_cost2 < min_cost2:\n                min_cost1, min_cost2 = new_cost1, new_cost2\n                best_replacement = k\n\n        if best_replacement is not None:\n            # Apply the replacement\n            k = best_replacement\n            new_solution[i] = base_solution[k]\n            new_solution[j] = base_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8398395771016464,
            0.11535018682479858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate the current cost of the base solution\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Find the worst edge in each objective\n    worst_edge1 = max(range(n), key=lambda i: distance_matrix_1[base_solution[i], base_solution[(i+1)%n]])\n    worst_edge2 = max(range(n), key=lambda i: distance_matrix_2[base_solution[i], base_solution[(i+1)%n]])\n\n    # Try to replace the worst edges with better ones\n    for edge in [worst_edge1, worst_edge2]:\n        i, j = edge, (edge + 1) % n\n        u, v = base_solution[i], base_solution[j]\n\n        # Find the best replacement edge\n        best_replacement = None\n        min_cost1, min_cost2 = float('inf'), float('inf')\n\n        for k in range(n):\n            if k == i or k == j or k == (j + 1) % n:\n                continue\n\n            # Try connecting i to k and k to j\n            new_cost1 = (distance_matrix_1[u, base_solution[k]] + distance_matrix_1[base_solution[k], v]\n                        - distance_matrix_1[u, v])\n            new_cost2 = (distance_matrix_2[u, base_solution[k]] + distance_matrix_2[base_solution[k], v]\n                        - distance_matrix_2[u, v])\n\n            if new_cost1 < min_cost1 and new_cost2 < min_cost2:\n                min_cost1, min_cost2 = new_cost1, new_cost2\n                best_replacement = k\n\n        if best_replacement is not None:\n            # Apply the replacement\n            k = best_replacement\n            new_solution[i] = base_solution[k]\n            new_solution[j] = base_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 85,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic path reversal operator, where segments of the tour are reversed to explore new configurations, while prioritizing edges with high potential for cost reduction in both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the segment to reverse\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the segment before reversal\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the segment after reversal\n    new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # If reversal does not improve both objectives, try a different segment\n    if not (new_cost1 < cost1 and new_cost2 < cost2):\n        # Try a different segment\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n",
        "score": [
            -0.823128441409278,
            0.19891053438186646
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Determine the segment to reverse\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the segment before reversal\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the segment after reversal\n    new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # If reversal does not improve both objectives, try a different segment\n    if not (new_cost1 < cost1 and new_cost2 < cost2):\n        # Try a different segment\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 86,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Perform a 2-opt move if it improves both objectives\n    a = base_solution[i]\n    b = base_solution[(i + 1) % n]\n    c = base_solution[j]\n    d = base_solution[(j + 1) % n]\n\n    # Check if the new edges are better in both objectives\n    if (distance_matrix_1[a, c] + distance_matrix_1[b, d] < distance_matrix_1[a, b] + distance_matrix_1[c, d] and\n        distance_matrix_2[a, c] + distance_matrix_2[b, d] < distance_matrix_2[a, b] + distance_matrix_2[c, d]):\n\n        # Reverse the segment between i and j\n        new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n\n    # If no improvement, perform a random swap\n    else:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n",
        "score": [
            -0.8876230695976525,
            0.22467833757400513
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Perform a 2-opt move if it improves both objectives\n    a = base_solution[i]\n    b = base_solution[(i + 1) % n]\n    c = base_solution[j]\n    d = base_solution[(j + 1) % n]\n\n    # Check if the new edges are better in both objectives\n    if (distance_matrix_1[a, c] + distance_matrix_1[b, d] < distance_matrix_1[a, b] + distance_matrix_1[c, d] and\n        distance_matrix_2[a, c] + distance_matrix_2[b, d] < distance_matrix_2[a, b] + distance_matrix_2[c, d]):\n\n        # Reverse the segment between i and j\n        new_solution[i+1:j+1] = base_solution[i+1:j+1][::-1]\n\n    # If no improvement, perform a random swap\n    else:\n        k, l = random.sample(range(n), 2)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 87,
        "algorithm": "{A novel multi-objective local search strategy combines a dynamic edge exchange operator with a probabilistic selection criterion, prioritizing edges that show potential for improvement in both objective spaces while ensuring feasibility through a validation mechanism that checks for node uniqueness and connectivity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on its potential for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform a probabilistic edge exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Calculate potential improvement\n    original_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    original_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    # Apply if improvement is found in at least one objective\n    if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no improvement, perform a random 2-opt swap\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9558336115434747,
            0.23884570598602295
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution based on its potential for improvement\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Perform a probabilistic edge exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Calculate potential improvement\n    original_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    original_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    # Apply if improvement is found in at least one objective\n    if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no improvement, perform a random 2-opt swap\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 88,
        "algorithm": "{This novel algorithm employs a multi-objective segment relocation strategy that dynamically balances edge cost reduction in both objective spaces by prioritizing segments with high potential for improvement while ensuring feasibility through a stochastic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple non-overlapping segments\n    segments = []\n    remaining_indices = list(range(n))\n    num_segments = random.randint(1, min(3, n//2))\n\n    for _ in range(num_segments):\n        if not remaining_indices:\n            break\n        a = random.choice(remaining_indices)\n        b = random.choice([i for i in remaining_indices if abs(i - a) <= n//4])\n        if a > b:\n            a, b = b, a\n        segments.append((a, b))\n        remaining_indices = [i for i in remaining_indices if i < a or i > b]\n\n    # Process segments in reverse order to avoid index shifting\n    segments.sort(reverse=True)\n\n    for a, b in segments:\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find best insertion point with probabilistic acceptance\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[(pos-1)%n], new_solution[pos]),\n                (new_solution[pos], new_solution[(pos+1)%n])\n            ]\n            new_edges = [\n                (new_solution[(pos-1)%n], segment[0]),\n                (segment[-1], new_solution[(pos+1)%n])\n            ]\n\n            delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                     (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n            delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                     (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n            # Normalize improvements\n            norm_improvement = (delta1 / (cost1 + 1e-8)) + (delta2 / (cost2 + 1e-8))\n\n            # Probabilistically accept better positions\n            if norm_improvement < -0.1 or (norm_improvement < 0 and random.random() < 0.3):\n                if norm_improvement < best_improvement:\n                    best_improvement = norm_improvement\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best insertion\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n        else:\n            # If no good insertion found, try to reverse the segment\n            if random.random() < 0.5:\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8740225463816862,
            0.1781185269355774
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple non-overlapping segments\n    segments = []\n    remaining_indices = list(range(n))\n    num_segments = random.randint(1, min(3, n//2))\n\n    for _ in range(num_segments):\n        if not remaining_indices:\n            break\n        a = random.choice(remaining_indices)\n        b = random.choice([i for i in remaining_indices if abs(i - a) <= n//4])\n        if a > b:\n            a, b = b, a\n        segments.append((a, b))\n        remaining_indices = [i for i in remaining_indices if i < a or i > b]\n\n    # Process segments in reverse order to avoid index shifting\n    segments.sort(reverse=True)\n\n    for a, b in segments:\n        segment = new_solution[a:b+1]\n\n        # Calculate segment cost\n        cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find best insertion point with probabilistic acceptance\n        best_pos = -1\n        best_improvement = 0\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[(pos-1)%n], new_solution[pos]),\n                (new_solution[pos], new_solution[(pos+1)%n])\n            ]\n            new_edges = [\n                (new_solution[(pos-1)%n], segment[0]),\n                (segment[-1], new_solution[(pos+1)%n])\n            ]\n\n            delta1 = (distance_matrix_1[new_edges[0][0], new_edges[0][1]] + distance_matrix_1[new_edges[1][0], new_edges[1][1]]) - \\\n                     (distance_matrix_1[old_edges[0][0], old_edges[0][1]] + distance_matrix_1[old_edges[1][0], old_edges[1][1]])\n            delta2 = (distance_matrix_2[new_edges[0][0], new_edges[0][1]] + distance_matrix_2[new_edges[1][0], new_edges[1][1]]) - \\\n                     (distance_matrix_2[old_edges[0][0], old_edges[0][1]] + distance_matrix_2[old_edges[1][0], old_edges[1][1]])\n\n            # Normalize improvements\n            norm_improvement = (delta1 / (cost1 + 1e-8)) + (delta2 / (cost2 + 1e-8))\n\n            # Probabilistically accept better positions\n            if norm_improvement < -0.1 or (norm_improvement < 0 and random.random() < 0.3):\n                if norm_improvement < best_improvement:\n                    best_improvement = norm_improvement\n                    best_pos = pos\n\n        if best_pos != -1:\n            # Apply the best insertion\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n        else:\n            # If no good insertion found, try to reverse the segment\n            if random.random() < 0.5:\n                new_solution[a:b+1] = segment[::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 89,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic segment reversal operator, prioritizing segments that show potential for cost reduction in both objectives while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_segment = None\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        for seg in [segment, reversed_segment]:\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], seg, temp_solution[pos:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if new_cost1 < cost1 and new_cost2 < cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_segment = seg\n                best_insert_pos = pos\n                break\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], best_segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.869796582260836,
            0.8870501518249512
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_segment = None\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        for seg in [segment, reversed_segment]:\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], seg, temp_solution[pos:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            if new_cost1 < cost1 and new_cost2 < cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_segment = seg\n                best_insert_pos = pos\n                break\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], best_segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 90,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmin([sum(obj) for obj in objectives])\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in both objectives\n    worst_edge_idx = -1\n    max_cost = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge_idx = i\n\n    # Replace the worst edge with a random valid edge\n    if worst_edge_idx != -1:\n        u = new_solution[worst_edge_idx]\n        v = new_solution[(worst_edge_idx + 1) % n]\n        possible_nodes = [node for node in range(n) if node not in new_solution]\n        if possible_nodes:\n            new_node = random.choice(possible_nodes)\n            new_solution[(worst_edge_idx + 1) % n] = new_node\n\n    return new_solution\n\n",
        "score": [
            -0.8570205792360929,
            3.9000390768051147
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value\n    archive_solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n    selected_idx = np.argmin([sum(obj) for obj in objectives])\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify the worst edge in both objectives\n    worst_edge_idx = -1\n    max_cost = -1\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        cost = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n        if cost > max_cost:\n            max_cost = cost\n            worst_edge_idx = i\n\n    # Replace the worst edge with a random valid edge\n    if worst_edge_idx != -1:\n        u = new_solution[worst_edge_idx]\n        v = new_solution[(worst_edge_idx + 1) % n]\n        possible_nodes = [node for node in range(n) if node not in new_solution]\n        if possible_nodes:\n            new_node = random.choice(possible_nodes)\n            new_solution[(worst_edge_idx + 1) % n] = new_node\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 91,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8937986364309348,
            0.5874481797218323
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 92,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8724790641409519,
            0.46171361207962036
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 93,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest cost in either objective\n    selected_idx = min(range(len(archive)), key=lambda i: min(archive[i][1]))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator: \"Multi-Objective Edge Reversal\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost before reversal\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost after reversal\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the reversal improves at least one objective, accept it\n    if new_cost1 <= original_cost1 or new_cost2 <= original_cost2:\n        return new_solution\n    else:\n        # If not improved, try a different approach: swap two edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n",
        "score": [
            -0.4997320280767955,
            0.37228184938430786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest cost in either objective\n    selected_idx = min(range(len(archive)), key=lambda i: min(archive[i][1]))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator: \"Multi-Objective Edge Reversal\"\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost before reversal\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost after reversal\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the reversal improves at least one objective, accept it\n    if new_cost1 <= original_cost1 or new_cost2 <= original_cost2:\n        return new_solution\n    else:\n        # If not improved, try a different approach: swap two edges\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 94,
        "algorithm": "{A novel adaptive multi-objective local search strategy that dynamically combines a segment-based relocation operator with a probabilistic edge swapping mechanism, where the selection of operations is guided by the relative improvement potential in both objective spaces, while ensuring feasibility through a comprehensive validation procedure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine the operation type based on the relative improvement potential\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate the potential improvement if the segment is removed\n    potential_cost1 = current_cost1 - segment_cost1\n    potential_cost2 = current_cost2 - segment_cost2\n\n    # Decide between relocation or edge swap based on potential improvement\n    if random.random() < 0.7:  # Higher probability for relocation\n        # Relocate the segment to a new position\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate the cost of inserting the segment at this position\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[1]] + sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[1]] + sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]] + sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]] + sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n            # Calculate the improvement\n            improvement = (potential_cost1 - new_cost1) + (potential_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the relocation\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            # Remove the original segment\n            new_solution = np.delete(new_solution, np.s_[a:b+1])\n    else:\n        # Perform probabilistic edge swapping\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the cost of the current edges\n        current_edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate the cost of the new edges\n        new_edge1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_edge2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Calculate the improvement\n        improvement = (current_edge1 - new_edge1) + (current_edge2 - new_edge2)\n\n        if improvement > 0 or random.random() < 0.3:  # Accept with some probability if no improvement\n            # Apply the edge swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8630818902828664,
            0.45038896799087524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine the operation type based on the relative improvement potential\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate the potential improvement if the segment is removed\n    potential_cost1 = current_cost1 - segment_cost1\n    potential_cost2 = current_cost2 - segment_cost2\n\n    # Decide between relocation or edge swap based on potential improvement\n    if random.random() < 0.7:  # Higher probability for relocation\n        # Relocate the segment to a new position\n        best_pos = -1\n        best_improvement = -float('inf')\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Calculate the cost of inserting the segment at this position\n            if pos == 0:\n                new_cost1 = distance_matrix_1[new_solution[-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[1]] + sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                new_cost2 = distance_matrix_2[new_solution[-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[1]] + sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n            else:\n                new_cost1 = distance_matrix_1[new_solution[pos-1], segment[0]] + distance_matrix_1[segment[-1], new_solution[pos]] + sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n                new_cost2 = distance_matrix_2[new_solution[pos-1], segment[0]] + distance_matrix_2[segment[-1], new_solution[pos]] + sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n            # Calculate the improvement\n            improvement = (potential_cost1 - new_cost1) + (potential_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_pos = pos\n\n        if best_pos != -1:\n            # Apply the relocation\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n            # Remove the original segment\n            new_solution = np.delete(new_solution, np.s_[a:b+1])\n    else:\n        # Perform probabilistic edge swapping\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n\n        # Calculate the cost of the current edges\n        current_edge1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        current_edge2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        # Calculate the cost of the new edges\n        new_edge1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n        new_edge2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n        # Calculate the improvement\n        improvement = (current_edge1 - new_edge1) + (current_edge2 - new_edge2)\n\n        if improvement > 0 or random.random() < 0.3:  # Accept with some probability if no improvement\n            # Apply the edge swap\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 95,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic segment inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and invert it\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Check if inversion improves at least one objective\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If inversion doesn't help, perform a random 2-opt swap\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9148314408651361,
            0.20684057474136353
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and invert it\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Check if inversion improves at least one objective\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If inversion doesn't help, perform a random 2-opt swap\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 96,
        "algorithm": "{This new algorithm combines a multi-objective selection criterion with a dynamic path inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a novel path inversion strategy to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a novel path inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the selected segment\n    segment = new_solution[a:b+1][::-1]\n    new_solution[a:b+1] = segment\n\n    # Calculate the cost of the inverted segment in both objectives\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate the original cost\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # If the inversion improves at least one objective, keep it; otherwise, revert\n    if cost1 <= original_cost1 and cost2 <= original_cost2:\n        return new_solution\n    else:\n        return base_solution\n\n",
        "score": [
            -0.6799683052749789,
            1.1532534956932068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a novel path inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the selected segment\n    segment = new_solution[a:b+1][::-1]\n    new_solution[a:b+1] = segment\n\n    # Calculate the cost of the inverted segment in both objectives\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate the original cost\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # If the inversion improves at least one objective, keep it; otherwise, revert\n    if cost1 <= original_cost1 and cost2 <= original_cost2:\n        return new_solution\n    else:\n        return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 97,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes based on both objectives\n    n = len(new_solution)\n    critical_nodes = set()\n\n    for i in range(n):\n        current_node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate the contribution to both objectives\n        cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n\n        # If this node is critical in either objective, mark it\n        if cost1 > 1.5 * min(distance_matrix_1[prev_node, next_node], distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]) or \\\n           cost2 > 1.5 * min(distance_matrix_2[prev_node, next_node], distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]):\n            critical_nodes.add(i)\n\n    # Reorder critical nodes to find better sequences\n    if critical_nodes:\n        # Convert to list and sort for consistent processing\n        critical_indices = sorted(list(critical_nodes))\n        best_sequence = None\n        best_improvement = 0\n\n        # Try different permutations of critical nodes\n        for _ in range(min(5, len(critical_indices))):\n            # Create a random permutation of critical nodes\n            perm = random.sample(critical_indices, len(critical_indices))\n            temp_solution = new_solution.copy()\n\n            # Apply the permutation\n            for i, idx in enumerate(perm):\n                if i < len(perm) - 1:\n                    next_idx = perm[i+1]\n                    temp_solution[idx], temp_solution[next_idx] = temp_solution[next_idx], temp_solution[idx]\n\n            # Calculate improvement\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_sequence = temp_solution.copy()\n\n        if best_sequence is not None:\n            new_solution = best_sequence\n\n    # If no improvement found, perform a targeted swap\n    if best_improvement <= 0:\n        # Find the worst node in both objectives\n        worst_node = max(range(n), key=lambda i: distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]])\n        # Find the best insertion point\n        best_pos = min(range(n), key=lambda j: distance_matrix_1[new_solution[j-1], new_solution[worst_node]] + distance_matrix_2[new_solution[j-1], new_solution[worst_node]])\n        # Perform the insertion\n        node_val = new_solution[worst_node]\n        new_solution = np.concatenate([new_solution[:worst_node], new_solution[worst_node+1:]])\n        new_solution = np.insert(new_solution, best_pos, node_val)\n\n    return new_solution\n\n",
        "score": [
            -0.7913642286285896,
            1.5304409861564636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = min(archive, key=lambda x: x[1][0])[0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical nodes based on both objectives\n    n = len(new_solution)\n    critical_nodes = set()\n\n    for i in range(n):\n        current_node = new_solution[i]\n        prev_node = new_solution[i-1]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate the contribution to both objectives\n        cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n\n        # If this node is critical in either objective, mark it\n        if cost1 > 1.5 * min(distance_matrix_1[prev_node, next_node], distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]) or \\\n           cost2 > 1.5 * min(distance_matrix_2[prev_node, next_node], distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]):\n            critical_nodes.add(i)\n\n    # Reorder critical nodes to find better sequences\n    if critical_nodes:\n        # Convert to list and sort for consistent processing\n        critical_indices = sorted(list(critical_nodes))\n        best_sequence = None\n        best_improvement = 0\n\n        # Try different permutations of critical nodes\n        for _ in range(min(5, len(critical_indices))):\n            # Create a random permutation of critical nodes\n            perm = random.sample(critical_indices, len(critical_indices))\n            temp_solution = new_solution.copy()\n\n            # Apply the permutation\n            for i, idx in enumerate(perm):\n                if i < len(perm) - 1:\n                    next_idx = perm[i+1]\n                    temp_solution[idx], temp_solution[next_idx] = temp_solution[next_idx], temp_solution[idx]\n\n            # Calculate improvement\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            old_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n            old_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n            improvement = (old_cost1 - new_cost1) + (old_cost2 - new_cost2)\n\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_sequence = temp_solution.copy()\n\n        if best_sequence is not None:\n            new_solution = best_sequence\n\n    # If no improvement found, perform a targeted swap\n    if best_improvement <= 0:\n        # Find the worst node in both objectives\n        worst_node = max(range(n), key=lambda i: distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i-1], new_solution[i]])\n        # Find the best insertion point\n        best_pos = min(range(n), key=lambda j: distance_matrix_1[new_solution[j-1], new_solution[worst_node]] + distance_matrix_2[new_solution[j-1], new_solution[worst_node]])\n        # Perform the insertion\n        node_val = new_solution[worst_node]\n        new_solution = np.concatenate([new_solution[:worst_node], new_solution[worst_node+1:]])\n        new_solution = np.insert(new_solution, best_pos, node_val)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 98,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Ensure the edges are not adjacent\n    if j == i + 1:\n        j = (j + 1) % n\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8977483928321576,
            0.18135535717010498
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 2)\n    j = random.randint(i + 1, n - 1)\n\n    # Ensure the edges are not adjacent\n    if j == i + 1:\n        j = (j + 1) % n\n\n    # Swap the edges\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 99,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the segment in both objectives\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate the new cost of the inverted segment\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply the inversion if it improves at least one objective\n    if new_cost1 < cost1 or new_cost2 < cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If no improvement, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.863188944859127,
            0.20240366458892822
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the segment in both objectives\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate the new cost of the inverted segment\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply the inversion if it improves at least one objective\n    if new_cost1 < cost1 or new_cost2 < cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If no improvement, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 100,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a segment reversal between two random nodes\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Check if the reversal improves at least one objective\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if new_cost1 > original_cost1 and new_cost2 > original_cost2:\n        # Revert if no improvement in either objective\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8307851720933551,
            1.3980867862701416
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a segment reversal between two random nodes\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Check if the reversal improves at least one objective\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    if new_cost1 > original_cost1 and new_cost2 > original_cost2:\n        # Revert if no improvement in either objective\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 101,
        "algorithm": "{A novel hybrid local search strategy employs a dynamic segment relocation operator that evaluates edge exchanges across both objective spaces, prioritizing moves that improve both objectives while using a weighted dominance criterion to guide selection, ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to exchange\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Extract the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Calculate the total cost of the segments in the new solution\n    temp_solution = new_solution.copy()\n    temp_solution = np.concatenate([temp_solution[:a], segment2, temp_solution[b+1:]])\n    temp_solution = np.concatenate([temp_solution[:c], segment1, temp_solution[d+1:]])\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Apply the exchange if it improves both objectives\n    if new_cost1 < cost1_seg1 + cost1_seg2 and new_cost2 < cost2_seg1 + cost2_seg2:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9010787552202705,
            0.2005842924118042
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to exchange\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Extract the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Calculate the total cost of the segments in the new solution\n    temp_solution = new_solution.copy()\n    temp_solution = np.concatenate([temp_solution[:a], segment2, temp_solution[b+1:]])\n    temp_solution = np.concatenate([temp_solution[:c], segment1, temp_solution[d+1:]])\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Apply the exchange if it improves both objectives\n    if new_cost1 < cost1_seg1 + cost1_seg2 and new_cost2 < cost2_seg1 + cost2_seg2:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 102,
        "algorithm": "{A novel hybrid local search strategy combines multi-objective edge prioritization with a dynamic segment inversion operator that considers both objective spaces, while maintaining feasibility through a validation mechanism and prioritizing segments with high potential for cost reduction in either or both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and invert it\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Calculate the cost of the connections between the segment and its neighbors\n    left_node = new_solution[a-1] if a > 0 else new_solution[-1]\n    right_node = new_solution[b] if b < n-1 else new_solution[0]\n\n    original_left_cost1 = distance_matrix_1[left_node, segment[0]]\n    original_left_cost2 = distance_matrix_2[left_node, segment[0]]\n    original_right_cost1 = distance_matrix_1[segment[-1], right_node]\n    original_right_cost2 = distance_matrix_2[segment[-1], right_node]\n\n    inverted_left_cost1 = distance_matrix_1[left_node, inverted_segment[0]]\n    inverted_left_cost2 = distance_matrix_2[left_node, inverted_segment[0]]\n    inverted_right_cost1 = distance_matrix_1[inverted_segment[-1], right_node]\n    inverted_right_cost2 = distance_matrix_2[inverted_segment[-1], right_node]\n\n    # Calculate the total cost change\n    original_total_cost1 = original_left_cost1 + original_right_cost1 + original_cost1\n    original_total_cost2 = original_left_cost2 + original_right_cost2 + original_cost2\n    inverted_total_cost1 = inverted_left_cost1 + inverted_right_cost1 + inverted_cost1\n    inverted_total_cost2 = inverted_left_cost2 + inverted_right_cost2 + inverted_cost2\n\n    # Apply inversion if it improves either objective\n    if (inverted_total_cost1 < original_total_cost1 or inverted_total_cost2 < original_total_cost2):\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9251346528394376,
            0.241377592086792
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and invert it\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Calculate the cost of the connections between the segment and its neighbors\n    left_node = new_solution[a-1] if a > 0 else new_solution[-1]\n    right_node = new_solution[b] if b < n-1 else new_solution[0]\n\n    original_left_cost1 = distance_matrix_1[left_node, segment[0]]\n    original_left_cost2 = distance_matrix_2[left_node, segment[0]]\n    original_right_cost1 = distance_matrix_1[segment[-1], right_node]\n    original_right_cost2 = distance_matrix_2[segment[-1], right_node]\n\n    inverted_left_cost1 = distance_matrix_1[left_node, inverted_segment[0]]\n    inverted_left_cost2 = distance_matrix_2[left_node, inverted_segment[0]]\n    inverted_right_cost1 = distance_matrix_1[inverted_segment[-1], right_node]\n    inverted_right_cost2 = distance_matrix_2[inverted_segment[-1], right_node]\n\n    # Calculate the total cost change\n    original_total_cost1 = original_left_cost1 + original_right_cost1 + original_cost1\n    original_total_cost2 = original_left_cost2 + original_right_cost2 + original_cost2\n    inverted_total_cost1 = inverted_left_cost1 + inverted_right_cost1 + inverted_cost1\n    inverted_total_cost2 = inverted_left_cost2 + inverted_right_cost2 + inverted_cost2\n\n    # Apply inversion if it improves either objective\n    if (inverted_total_cost1 < original_total_cost1 or inverted_total_cost2 < original_total_cost2):\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 103,
        "algorithm": "{This novel algorithm combines multi-objective selection with a dynamic path inversion operator that reverses segments of the tour while prioritizing cost reduction in both objectives, ensuring feasibility through careful boundary checks and edge validation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_inversion = False\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        inverted_segment = segment[::-1]\n        temp_solution[a:b+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (new_cost1 < best_cost1 or new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_inversion = True\n\n    if best_inversion:\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8552097199431259,
            0.5669354200363159
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_inversion = False\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        inverted_segment = segment[::-1]\n        temp_solution[a:b+1] = inverted_segment\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (new_cost1 < best_cost1 or new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_inversion = True\n\n    if best_inversion:\n        new_solution[a:b+1] = segment[::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 104,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [archive[i][1][0] * 0.7 + archive[i][1][1] * 0.3 for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a segment reversal operation\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.988508777383541,
            0.2560681700706482
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [archive[i][1][0] * 0.7 + archive[i][1][1] * 0.3 for i in range(len(archive))]\n    selected_idx = np.argmin(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a segment reversal operation\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Validate the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 105,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism, and applies a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the original segment\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Reverse the segment\n    reversed_segment = new_solution[a:b+1][::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the reversed segment\n    reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Calculate the total cost change\n    delta_cost1 = reversed_cost1 - original_cost1\n    delta_cost2 = reversed_cost2 - original_cost2\n\n    # Accept the reversal if it improves at least one objective\n    if delta_cost1 < 0 or delta_cost2 < 0:\n        return new_solution\n\n    # If reversal doesn't improve, try a probabilistic acceptance\n    if random.random() < 0.1:  # 10% chance to accept non-improving move\n        return new_solution\n\n    # If not accepted, revert the change\n    new_solution[a:b+1] = reversed_segment[::-1]  # Reverse back\n\n    # As a fallback, perform a random insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8162900425101021,
            0.20658820867538452
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = best_solution.copy()\n\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the original segment\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Reverse the segment\n    reversed_segment = new_solution[a:b+1][::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the reversed segment\n    reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Calculate the total cost change\n    delta_cost1 = reversed_cost1 - original_cost1\n    delta_cost2 = reversed_cost2 - original_cost2\n\n    # Accept the reversal if it improves at least one objective\n    if delta_cost1 < 0 or delta_cost2 < 0:\n        return new_solution\n\n    # If reversal doesn't improve, try a probabilistic acceptance\n    if random.random() < 0.1:  # 10% chance to accept non-improving move\n        return new_solution\n\n    # If not accepted, revert the change\n    new_solution[a:b+1] = reversed_segment[::-1]  # Reverse back\n\n    # As a fallback, perform a random insertion\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    if i != j:\n        node = new_solution[i]\n        new_solution = np.concatenate([new_solution[:i], new_solution[i+1:j+1], [node], new_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 106,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Create a new solution by exchanging the edges\n    if i > j:\n        i, j = j, i\n\n    # Perform the edge exchange\n    new_solution = np.concatenate([\n        base_solution[:i+1],\n        base_solution[j:],\n        base_solution[i+1:j]\n    ])\n\n    # Validate the solution is feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8758085228272052,
            0.2125348448753357
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Create a new solution by exchanging the edges\n    if i > j:\n        i, j = j, i\n\n    # Perform the edge exchange\n    new_solution = np.concatenate([\n        base_solution[:i+1],\n        base_solution[j:],\n        base_solution[i+1:j]\n    ])\n\n    # Validate the solution is feasible (no duplicates)\n    if len(set(new_solution)) != n:\n        # If invalid, revert to a simple swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 107,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a segment inversion with multi-objective consideration\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1][::-1]  # Reverse the segment\n\n    # Evaluate the new solution's objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    original_cost = calculate_cost(new_solution)\n    temp_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n    new_cost = calculate_cost(temp_solution)\n\n    # Accept if at least one objective improves\n    if new_cost[0] < original_cost[0] or new_cost[1] < original_cost[1]:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8030536042134401,
            0.32471102476119995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Perform a segment inversion with multi-objective consideration\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1][::-1]  # Reverse the segment\n\n    # Evaluate the new solution's objectives\n    def calculate_cost(solution):\n        cost1 = sum(distance_matrix_1[solution[i], solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[solution[i], solution[(i+1)%n]] for i in range(n))\n        return cost1, cost2\n\n    original_cost = calculate_cost(new_solution)\n    temp_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n    new_cost = calculate_cost(temp_solution)\n\n    # Accept if at least one objective improves\n    if new_cost[0] < original_cost[0] or new_cost[1] < original_cost[1]:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 108,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent segments to exchange\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Ensure segments are not adjacent\n    while (b == a + 1) or (a == b + 1):\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n\n    # Extract the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b:a-1:-1] if a != 0 else new_solution[b::-1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Try reversing one of the segments\n    reversed_segment = segment1[::-1]\n    new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Apply the reversal if it improves both objectives\n    if new_cost1 < cost1_seg1 and new_cost2 < cost2_seg1:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If not better, perform a random 2-opt move\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9201908820368273,
            0.3269907832145691
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent segments to exchange\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Ensure segments are not adjacent\n    while (b == a + 1) or (a == b + 1):\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n\n    # Extract the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[b:a-1:-1] if a != 0 else new_solution[b::-1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Try reversing one of the segments\n    reversed_segment = segment1[::-1]\n    new_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    new_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Apply the reversal if it improves both objectives\n    if new_cost1 < cost1_seg1 and new_cost2 < cost2_seg1:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If not better, perform a random 2-opt move\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 109,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8861927063081743,
            0.5901753902435303
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 110,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and uses a weighted scoring function to balance improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted score\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate improvement potential based on both objectives\n        avg_cost = (cost1 + cost2) / 2\n        scores.append(avg_cost)\n\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest average cost\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a weighted scoring function to balance improvements\n        weighted_score = 0.7 * (new_cost1 / cost1) + 0.3 * (new_cost2 / cost2)\n\n        if weighted_score < best_cost1 / cost1 or weighted_score < best_cost2 / cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8342809004201021,
            0.42173337936401367
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement using a weighted score\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        # Calculate improvement potential based on both objectives\n        avg_cost = (cost1 + cost2) / 2\n        scores.append(avg_cost)\n\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest average cost\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a weighted scoring function to balance improvements\n        weighted_score = 0.7 * (new_cost1 / cost1) + 0.3 * (new_cost2 / cost2)\n\n        if weighted_score < best_cost1 / cost1 or weighted_score < best_cost2 / cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 111,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic segment relinking operator that adaptively combines segments from multiple solutions to create high-quality neighbors, while ensuring feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n\n    # Find common segments between the two solutions\n    n = len(sol1)\n    common_segments = []\n    i = j = 0\n\n    while i < n and j < n:\n        if sol1[i] == sol2[j]:\n            start = i\n            while i < n and j < n and sol1[i] == sol2[j]:\n                i += 1\n                j += 1\n            common_segments.append((start, i-1))\n        else:\n            i += 1\n            j += 1\n\n    # If no common segments found, perform a segment exchange\n    if not common_segments:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = sol1[a:b+1]\n        new_solution = np.concatenate([sol2[:a], segment, sol2[a:]])\n    else:\n        # Select a random common segment to preserve\n        seg_start, seg_end = random.choice(common_segments)\n        preserved_segment = sol1[seg_start:seg_end+1]\n\n        # Create new solution by combining segments from both solutions\n        new_solution = np.zeros(n, dtype=int)\n        ptr = 0\n        for i in range(n):\n            if seg_start <= i <= seg_end:\n                new_solution[ptr] = preserved_segment[i-seg_start]\n                ptr += 1\n            else:\n                # Alternate between sol1 and sol2 for other segments\n                if ptr < n:\n                    if random.random() < 0.5:\n                        candidate = sol1[i]\n                    else:\n                        candidate = sol2[i]\n                    if candidate not in new_solution[:ptr]:\n                        new_solution[ptr] = candidate\n                        ptr += 1\n\n    # Ensure all nodes are included (fallback to random permutation if needed)\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    # Validate the solution is a proper tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n",
        "score": [
            -0.8713210458779592,
            0.24244099855422974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    idx1, idx2 = random.sample(range(len(archive)), 2)\n    sol1, sol2 = archive[idx1][0], archive[idx2][0]\n\n    # Find common segments between the two solutions\n    n = len(sol1)\n    common_segments = []\n    i = j = 0\n\n    while i < n and j < n:\n        if sol1[i] == sol2[j]:\n            start = i\n            while i < n and j < n and sol1[i] == sol2[j]:\n                i += 1\n                j += 1\n            common_segments.append((start, i-1))\n        else:\n            i += 1\n            j += 1\n\n    # If no common segments found, perform a segment exchange\n    if not common_segments:\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = sol1[a:b+1]\n        new_solution = np.concatenate([sol2[:a], segment, sol2[a:]])\n    else:\n        # Select a random common segment to preserve\n        seg_start, seg_end = random.choice(common_segments)\n        preserved_segment = sol1[seg_start:seg_end+1]\n\n        # Create new solution by combining segments from both solutions\n        new_solution = np.zeros(n, dtype=int)\n        ptr = 0\n        for i in range(n):\n            if seg_start <= i <= seg_end:\n                new_solution[ptr] = preserved_segment[i-seg_start]\n                ptr += 1\n            else:\n                # Alternate between sol1 and sol2 for other segments\n                if ptr < n:\n                    if random.random() < 0.5:\n                        candidate = sol1[i]\n                    else:\n                        candidate = sol2[i]\n                    if candidate not in new_solution[:ptr]:\n                        new_solution[ptr] = candidate\n                        ptr += 1\n\n    # Ensure all nodes are included (fallback to random permutation if needed)\n    if len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    # Validate the solution is a proper tour\n    if len(new_solution) != n or len(np.unique(new_solution)) != n:\n        new_solution = np.random.permutation(n)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 112,
        "algorithm": "{This novel hybrid local search strategy leverages a multi-objective edge selection mechanism that dynamically combines inter-objective edge analysis with a probabilistic segment relocation operator, prioritizing edges that show potential for Pareto improvement while ensuring feasibility through a multi-criteria validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges based on both objectives\n    edge_scores = []\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        score = (distance_matrix_1[u,v] + distance_matrix_2[u,v]) / (distance_matrix_1[u,v] * distance_matrix_2[u,v])\n        edge_scores.append((score, i))\n\n    # Sort edges by their combined score\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top k edges for potential removal\n    k = max(1, n // 10)\n    selected_edges = [i for (_, i) in edge_scores[:k]]\n\n    # Remove selected edges and collect the segments\n    segments = []\n    removed = set()\n    for i in selected_edges:\n        if i not in removed:\n            # Find the segment between this edge\n            u, v = base_solution[i], base_solution[(i+1)%n]\n            segment = []\n            # Find all consecutive nodes that form a segment\n            current = i\n            while current not in removed:\n                removed.add(current)\n                segment.append(base_solution[current])\n                current = (current + 1) % n\n                if base_solution[current] == v:\n                    break\n            segments.append(segment)\n\n    # Try to reinsert segments in different positions\n    for segment in segments:\n        best_cost = float('inf')\n        best_pos = -1\n        best_solution = None\n\n        # Try inserting the segment at different positions\n        for pos in range(n):\n            # Skip if the position is within an existing segment\n            if any(pos in range(i, i+len(seg)) for i, seg in zip(range(n), segments)):\n                continue\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            total_cost = new_cost1 + new_cost2\n\n            # Check if this is better\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n                best_solution = temp_solution\n\n        if best_pos != -1:\n            new_solution = best_solution\n\n    # If no improvement found, perform a probabilistic segment swap\n    if np.array_equal(new_solution, base_solution):\n        # Select two random segments\n        if len(segments) >= 2:\n            seg1, seg2 = random.sample(segments, 2)\n            # Find their positions in the solution\n            idx1 = next(i for i in range(n) if new_solution[i] == seg1[0])\n            idx2 = next(i for i in range(n) if new_solution[i] == seg2[0])\n            # Swap the segments\n            if idx1 < idx2:\n                new_solution = np.concatenate([\n                    new_solution[:idx1],\n                    seg2,\n                    new_solution[idx1+len(seg1):idx2],\n                    seg1,\n                    new_solution[idx2+len(seg2):]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:idx2],\n                    seg1,\n                    new_solution[idx2+len(seg2):idx1],\n                    seg2,\n                    new_solution[idx1+len(seg1):]\n                ])\n\n    return new_solution\n\n",
        "score": [
            -0.8280543808562412,
            1.081509530544281
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges based on both objectives\n    edge_scores = []\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        score = (distance_matrix_1[u,v] + distance_matrix_2[u,v]) / (distance_matrix_1[u,v] * distance_matrix_2[u,v])\n        edge_scores.append((score, i))\n\n    # Sort edges by their combined score\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n\n    # Select top k edges for potential removal\n    k = max(1, n // 10)\n    selected_edges = [i for (_, i) in edge_scores[:k]]\n\n    # Remove selected edges and collect the segments\n    segments = []\n    removed = set()\n    for i in selected_edges:\n        if i not in removed:\n            # Find the segment between this edge\n            u, v = base_solution[i], base_solution[(i+1)%n]\n            segment = []\n            # Find all consecutive nodes that form a segment\n            current = i\n            while current not in removed:\n                removed.add(current)\n                segment.append(base_solution[current])\n                current = (current + 1) % n\n                if base_solution[current] == v:\n                    break\n            segments.append(segment)\n\n    # Try to reinsert segments in different positions\n    for segment in segments:\n        best_cost = float('inf')\n        best_pos = -1\n        best_solution = None\n\n        # Try inserting the segment at different positions\n        for pos in range(n):\n            # Skip if the position is within an existing segment\n            if any(pos in range(i, i+len(seg)) for i, seg in zip(range(n), segments)):\n                continue\n\n            # Create temporary solution\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            total_cost = new_cost1 + new_cost2\n\n            # Check if this is better\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n                best_solution = temp_solution\n\n        if best_pos != -1:\n            new_solution = best_solution\n\n    # If no improvement found, perform a probabilistic segment swap\n    if np.array_equal(new_solution, base_solution):\n        # Select two random segments\n        if len(segments) >= 2:\n            seg1, seg2 = random.sample(segments, 2)\n            # Find their positions in the solution\n            idx1 = next(i for i in range(n) if new_solution[i] == seg1[0])\n            idx2 = next(i for i in range(n) if new_solution[i] == seg2[0])\n            # Swap the segments\n            if idx1 < idx2:\n                new_solution = np.concatenate([\n                    new_solution[:idx1],\n                    seg2,\n                    new_solution[idx1+len(seg1):idx2],\n                    seg1,\n                    new_solution[idx2+len(seg2):]\n                ])\n            else:\n                new_solution = np.concatenate([\n                    new_solution[:idx2],\n                    seg1,\n                    new_solution[idx2+len(seg2):idx1],\n                    seg2,\n                    new_solution[idx1+len(seg1):]\n                ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 113,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective edge selection criterion with a dynamic segment inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(a, min(a + 10, n - 1))  # Limit segment length to 10 nodes\n\n    # Invert the selected segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Calculate the cost of the inverted segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Calculate the total cost of the new solution\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Check if the inversion improves both objectives\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n       (total_cost1 < sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) and\n        total_cost2 < sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))):\n        return new_solution\n    else:\n        # If not better, perform a random 2-opt move as fallback\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.8968768545456772,
            0.22488492727279663
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(a, min(a + 10, n - 1))  # Limit segment length to 10 nodes\n\n    # Invert the selected segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Calculate the cost of the inverted segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Calculate the total cost of the new solution\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Check if the inversion improves both objectives\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n       (total_cost1 < sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) and\n        total_cost2 < sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))):\n        return new_solution\n    else:\n        # If not better, perform a random 2-opt move as fallback\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 114,
        "algorithm": "{A novel local search strategy combines a multi-objective edge prioritization mechanism with a dynamic segment reversal operator that adaptively selects and reverses promising segments based on both objective spaces, ensuring feasibility through a validation mechanism that checks for duplicate nodes and maintains tour continuity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if the reversed segment is better in at least one objective\n    if reversed_cost1 < original_cost1 or reversed_cost2 < original_cost2:\n        new_solution[a:b+1] = reversed_segment\n\n    # Additional improvement: try to find a better insertion point for the reversed segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], reversed_segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], reversed_segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9540147051549258,
            0.329389750957489
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if the reversed segment is better in at least one objective\n    if reversed_cost1 < original_cost1 or reversed_cost2 < original_cost2:\n        new_solution[a:b+1] = reversed_segment\n\n    # Additional improvement: try to find a better insertion point for the reversed segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], reversed_segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], reversed_segment, new_solution[best_insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 115,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective values (normalized)\n    combined_values = []\n    for sol, (obj1, obj2) in archive:\n        combined = (obj1 + obj2) / 2  # Simple average\n        combined_values.append(combined)\n\n    # Select the solution with the best combined objective\n    selected_idx = np.argmin(combined_values)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5231622387975208,
            1.4995653629302979
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective values (normalized)\n    combined_values = []\n    for sol, (obj1, obj2) in archive:\n        combined = (obj1 + obj2) / 2  # Simple average\n        combined_values.append(combined)\n\n    # Select the solution with the best combined objective\n    selected_idx = np.argmin(combined_values)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n - 1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 116,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_solution, _ = archive[random.randint(0, len(archive) - 1)]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Perform a random segment reversal\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Check if the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9373175197600968,
            0.19638776779174805
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_solution, _ = archive[random.randint(0, len(archive) - 1)]\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    # Perform a random segment reversal\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment between a and b\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Check if the solution is valid (no duplicates)\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 117,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic segment inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism that ensures no node is skipped or revisited.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Validate the solution\n    if len(set(new_solution)) != n:\n        raise RuntimeError(\"Generated solution is invalid (duplicate nodes)\")\n\n    # Calculate the cost of the inverted segment in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If the inversion doesn't improve both objectives, try a different segment\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # Try up to 3 random segments\n        for _ in range(3):\n            a = random.randint(0, n - 1)\n            b = random.randint(0, n - 1)\n            if a > b:\n                a, b = b, a\n\n            segment = new_solution[a:b+1]\n            inverted_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = inverted_segment\n\n            if len(set(temp_solution)) == n:\n                temp_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n                temp_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n\n                if temp_cost1 < original_cost1 and temp_cost2 < original_cost2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.926620420198789,
            0.2605641484260559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Validate the solution\n    if len(set(new_solution)) != n:\n        raise RuntimeError(\"Generated solution is invalid (duplicate nodes)\")\n\n    # Calculate the cost of the inverted segment in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If the inversion doesn't improve both objectives, try a different segment\n    if not (new_cost1 < original_cost1 and new_cost2 < original_cost2):\n        # Try up to 3 random segments\n        for _ in range(3):\n            a = random.randint(0, n - 1)\n            b = random.randint(0, n - 1)\n            if a > b:\n                a, b = b, a\n\n            segment = new_solution[a:b+1]\n            inverted_segment = segment[::-1]\n            temp_solution = new_solution.copy()\n            temp_solution[a:b+1] = inverted_segment\n\n            if len(set(temp_solution)) == n:\n                temp_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n                temp_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(a, b+1))\n\n                if temp_cost1 < original_cost1 and temp_cost2 < original_cost2:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 118,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node relocation operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Find the best insertion position considering both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n            continue  # Skip adjacent positions to avoid trivial moves\n\n        # Try inserting the node at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:node_idx], new_solution[node_idx+1:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a weighted sum of both objectives as the score\n        score = 0.5 * new_cost1 + 0.5 * new_cost2\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:node_idx], new_solution[node_idx+1:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.41882558936560776,
            0.49848103523254395
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = min(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Find the best insertion position considering both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n            continue  # Skip adjacent positions to avoid trivial moves\n\n        # Try inserting the node at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:node_idx], new_solution[node_idx+1:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a weighted sum of both objectives as the score\n        score = 0.5 * new_cost1 + 0.5 * new_cost2\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:node_idx], new_solution[node_idx+1:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 119,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a novel segment reversal operator to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    reversed_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Apply the reversal if it improves both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        new_solution[a:b+1] = segment\n    else:\n        # If no improvement, try reinserting a random node at a different position\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9412477017641694,
            0.24833452701568604
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    reversed_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Apply the reversal if it improves both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        new_solution[a:b+1] = segment\n    else:\n        # If no improvement, try reinserting a random node at a different position\n        node_pos = random.randint(0, n - 1)\n        node = new_solution[node_pos]\n        new_solution = np.concatenate([new_solution[:node_pos], new_solution[node_pos+1:]])\n        insert_pos = random.randint(0, n - 2)\n        new_solution = np.concatenate([new_solution[:insert_pos], [node], new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 120,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node relocation operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's connections\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip current position and adjacent positions\n\n        # Calculate the cost of inserting the node at position 'pos'\n        prev_pos = new_solution[pos - 1]\n        next_pos = new_solution[pos]\n        new_cost1 = distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos]\n        new_cost2 = distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos]\n\n        # Check if this is better in at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7869701404957204,
            0.21094536781311035
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's connections\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip current position and adjacent positions\n\n        # Calculate the cost of inserting the node at position 'pos'\n        prev_pos = new_solution[pos - 1]\n        next_pos = new_solution[pos]\n        new_cost1 = distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos]\n        new_cost2 = distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos]\n\n        # Check if this is better in at least one objective\n        if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 121,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] + obj[1] + 1e-6) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n-1)\n    j = (i + random.randint(2, n-2)) % n\n\n    # Perform a 2.5-opt-like move (swap two edges with a partial inversion)\n    if i < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        new_solution[i+1:] = new_solution[i+1:][::-1]\n        new_solution[:j+1] = new_solution[:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.919058781528862,
            0.19849252700805664
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.choices(range(len(archive)), weights=[1/(obj[0] + obj[1] + 1e-6) for _, obj in archive])[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n-1)\n    j = (i + random.randint(2, n-2)) % n\n\n    # Perform a 2.5-opt-like move (swap two edges with a partial inversion)\n    if i < j:\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        new_solution[i+1:] = new_solution[i+1:][::-1]\n        new_solution[:j+1] = new_solution[:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 122,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8491779379396925,
            0.5333120226860046
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 123,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that prioritizes edges with high potential for cost reduction while maintaining feasibility through a validation mechanism and considers both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (sum(obj) + 1e-10) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a dynamic edge exchange operator\n    n = len(new_solution)\n    a, b = random.sample(range(n), 2)\n\n    # Calculate potential cost reduction if we swap edges\n    cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply the swap if it improves at least one objective\n    if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.9359029586202408,
            0.22864019870758057
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = [(obj[0] + obj[1]) / (sum(obj) + 1e-10) for _, obj in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a dynamic edge exchange operator\n    n = len(new_solution)\n    a, b = random.sample(range(n), 2)\n\n    # Calculate potential cost reduction if we swap edges\n    cost1_before = distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b-1], new_solution[b]]\n    cost2_before = distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b-1], new_solution[b]]\n\n    cost1_after = distance_matrix_1[new_solution[a-1], new_solution[b]] + distance_matrix_1[new_solution[b-1], new_solution[a]]\n    cost2_after = distance_matrix_2[new_solution[a-1], new_solution[b]] + distance_matrix_2[new_solution[b-1], new_solution[a]]\n\n    # Apply the swap if it improves at least one objective\n    if (cost1_after < cost1_before) or (cost2_after < cost2_before):\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 124,
        "algorithm": "{A new hybrid local search algorithm that combines a multi-objective selection criterion with a dynamic edge exchange operator, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and using a novel scoring function to guide the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        scores.append(0.6 * cost1 + 0.4 * cost2)  # Weighted sum of objectives\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Generate a neighbor using a novel local search operator\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost improvement potential for the segment\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    best_cost1, best_cost2 = current_cost1, current_cost2\n    best_insert_pos = -1\n\n    # Try different insertion points with a novel scoring function\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Novel scoring function: prioritize solutions that improve both objectives\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if (improvement1 > 0 and improvement2 > 0) or (improvement1 + improvement2 > 0.5 * (current_cost1 + current_cost2)):\n            if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7691683513809341,
            0.6801950335502625
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    scores = []\n    for sol, (cost1, cost2) in archive:\n        scores.append(0.6 * cost1 + 0.4 * cost2)  # Weighted sum of objectives\n    selected_idx = np.argmin(scores)  # Select the solution with the lowest score\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Generate a neighbor using a novel local search operator\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost improvement potential for the segment\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    best_cost1, best_cost2 = current_cost1, current_cost2\n    best_insert_pos = -1\n\n    # Try different insertion points with a novel scoring function\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Novel scoring function: prioritize solutions that improve both objectives\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n\n        if (improvement1 > 0 and improvement2 > 0) or (improvement1 + improvement2 > 0.5 * (current_cost1 + current_cost2)):\n            if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:k+1] = new_solution[i:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 125,
        "algorithm": "{A novel hybrid local search strategy that combines multi-objective selection with a dynamic segment relocation operator, prioritizing edges with high potential for cost reduction in both objective spaces while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    best_score = float('inf')\n    best_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        score = weights[0] * cost1 + weights[1] * cost2\n        if score < best_score:\n            best_score = score\n            best_idx = i\n    base_solution = archive[best_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to swap\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n\n    # Ensure segments are valid and ordered\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Extract the two segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Try swapping the segments\n    temp_solution = new_solution.copy()\n    temp_solution = np.concatenate([temp_solution[:a], segment2, temp_solution[b+1:c], segment1, temp_solution[d+1:]])\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Accept the swap if it improves at least one objective\n    if new_cost1 < (weights[0] * (cost1_seg1 + cost1_seg2)) or new_cost2 < (weights[1] * (cost2_seg1 + cost2_seg2)):\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random 2-opt swap\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.791157488871342,
            0.27613693475723267
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [0.6, 0.4]  # Higher weight for the first objective\n    best_score = float('inf')\n    best_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        score = weights[0] * cost1 + weights[1] * cost2\n        if score < best_score:\n            best_score = score\n            best_idx = i\n    base_solution = archive[best_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to swap\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n\n    # Ensure segments are valid and ordered\n    if a > b:\n        a, b = b, a\n    if c > d:\n        c, d = d, c\n\n    # Extract the two segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Try swapping the segments\n    temp_solution = new_solution.copy()\n    temp_solution = np.concatenate([temp_solution[:a], segment2, temp_solution[b+1:c], segment1, temp_solution[d+1:]])\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Accept the swap if it improves at least one objective\n    if new_cost1 < (weights[0] * (cost1_seg1 + cost1_seg2)) or new_cost2 < (weights[1] * (cost2_seg1 + cost2_seg2)):\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a random 2-opt swap\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 126,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic path reversal operator, which selectively reverses segments of the tour while considering both objective spaces to identify and exploit promising cost reduction opportunities, while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the reversed segment\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if reversal improves at least one objective\n    if reversed_cost1 < cost1 or reversed_cost2 < cost2:\n        # Apply the reversal\n        new_solution[a:b+1] = reversed_segment\n\n        # Check if the new solution is valid (visits each node exactly once)\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If reversal didn't improve or was invalid, perform a random swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9269783798361598,
            0.23336976766586304
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the reversed segment\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if reversal improves at least one objective\n    if reversed_cost1 < cost1 or reversed_cost2 < cost2:\n        # Apply the reversal\n        new_solution[a:b+1] = reversed_segment\n\n        # Check if the new solution is valid (visits each node exactly once)\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If reversal didn't improve or was invalid, perform a random swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 127,
        "algorithm": "{A novel multi-objective local search strategy combines a Pareto-based edge selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing segments with high potential for cost improvement while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance (simplified for this implementation)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select a random segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate original segment cost\n    original_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new segment cost\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If reversal improves at least one objective, keep it\n    if new_cost1 <= original_cost1 or new_cost2 <= original_cost2:\n        return new_solution\n    else:\n        # Otherwise, perform a random 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.8684903830911479,
            0.22744852304458618
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest Pareto dominance (simplified for this implementation)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n    new_solution = selected_solution.copy()\n\n    # Select a random segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate original segment cost\n    original_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new segment cost\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If reversal improves at least one objective, keep it\n    if new_cost1 <= original_cost1 or new_cost2 <= original_cost2:\n        return new_solution\n    else:\n        # Otherwise, perform a random 2-opt swap\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 128,
        "algorithm": "{This algorithm combines a multi-objective selection criterion with a novel segment-wise perturbation operator that adaptively adjusts the segment size based on the solution's current quality, using a hybrid cost function that dynamically balances the two objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment size based on solution quality (smaller segments for better solutions)\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    avg_cost = (current_cost1 + current_cost2) / 2\n\n    # Normalize to get a quality score (lower is better)\n    max_cost = max(distance_matrix_1.sum() + distance_matrix_2.sum(), 1e-6)\n    quality_score = 1 - (avg_cost / max_cost)\n\n    # Segment size is inversely proportional to quality\n    segment_size = max(2, int(n * (1 - quality_score)))\n\n    # Randomly select a segment of adaptive size\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a hybrid cost function that balances both objectives\n        hybrid_cost = (new_cost1 * (1 - quality_score) + new_cost2 * quality_score)\n\n        if hybrid_cost < best_cost1 + best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a node swap with consideration of both objectives\n        i, j = random.sample(range(n), 2)\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if (new_cost1 > original_cost1 and new_cost2 > original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8352155836928453,
            0.49216973781585693
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment size based on solution quality (smaller segments for better solutions)\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    avg_cost = (current_cost1 + current_cost2) / 2\n\n    # Normalize to get a quality score (lower is better)\n    max_cost = max(distance_matrix_1.sum() + distance_matrix_2.sum(), 1e-6)\n    quality_score = 1 - (avg_cost / max_cost)\n\n    # Segment size is inversely proportional to quality\n    segment_size = max(2, int(n * (1 - quality_score)))\n\n    # Randomly select a segment of adaptive size\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a hybrid cost function that balances both objectives\n        hybrid_cost = (new_cost1 * (1 - quality_score) + new_cost2 * quality_score)\n\n        if hybrid_cost < best_cost1 + best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a node swap with consideration of both objectives\n        i, j = random.sample(range(n), 2)\n        original_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        original_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n        new_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n        if (new_cost1 > original_cost1 and new_cost2 > original_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 129,
        "algorithm": "{This algorithm implements a novel multi-objective path relinking strategy that combines a diversity-aware selection mechanism with a dynamic segment crossover operator, which selectively exchanges segments between solutions while maintaining feasibility and prioritizing non-dominated edges across both objective spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_distance = -1\n    selected_idx = 0\n    ref_solution = archive[0][0]\n\n    for i, (sol, _) in enumerate(archive):\n        # Calculate Hamming distance between solutions\n        distance = np.sum(ref_solution != sol)\n        if distance > max_distance:\n            max_distance = distance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Perform dynamic segment crossover\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Select a random segment from the base solution\n    segment = base_solution[a:b+1]\n\n    # Find the best position to insert the segment in the reference solution\n    best_cost = float('inf')\n    best_pos = -1\n\n    for pos in range(n):\n        # Skip if the insertion would create duplicates\n        if pos >= a and pos <= b:\n            continue\n\n        # Create a temporary solution\n        temp_solution = np.concatenate([\n            ref_solution[:pos],\n            segment,\n            ref_solution[pos:]\n        ])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use weighted sum of objectives as selection criterion\n        current_cost = cost1 + cost2\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            ref_solution[:best_pos],\n            segment,\n            ref_solution[best_pos:]\n        ])\n    else:\n        # If no better position found, perform a random mutation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8604841882093197,
            0.6180033087730408
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    max_distance = -1\n    selected_idx = 0\n    ref_solution = archive[0][0]\n\n    for i, (sol, _) in enumerate(archive):\n        # Calculate Hamming distance between solutions\n        distance = np.sum(ref_solution != sol)\n        if distance > max_distance:\n            max_distance = distance\n            selected_idx = i\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Perform dynamic segment crossover\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Select a random segment from the base solution\n    segment = base_solution[a:b+1]\n\n    # Find the best position to insert the segment in the reference solution\n    best_cost = float('inf')\n    best_pos = -1\n\n    for pos in range(n):\n        # Skip if the insertion would create duplicates\n        if pos >= a and pos <= b:\n            continue\n\n        # Create a temporary solution\n        temp_solution = np.concatenate([\n            ref_solution[:pos],\n            segment,\n            ref_solution[pos:]\n        ])\n\n        # Calculate the total cost in both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use weighted sum of objectives as selection criterion\n        current_cost = cost1 + cost2\n        if current_cost < best_cost:\n            best_cost = current_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([\n            ref_solution[:best_pos],\n            segment,\n            ref_solution[best_pos:]\n        ])\n    else:\n        # If no better position found, perform a random mutation\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 130,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9388276317972603,
            0.5581161379814148
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 131,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic objective-aware criterion, then applies a hybrid edge exchange and segment relocation strategy that prioritizes edges with high potential for cost reduction in both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (randomly weighted by objective values)\n    objectives = [obj for _, obj in archive]\n    weights = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with segment relocation\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n\n    # Calculate segment cost\n    segment = new_solution[a:b+1]\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (normalized by original costs)\n        improvement = (seg_cost1 - (new_cost1 - seg_cost1)) + (seg_cost2 - (new_cost2 - seg_cost2))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform edge exchange\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9925818413096127,
            0.41082775592803955
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (randomly weighted by objective values)\n    objectives = [obj for _, obj in archive]\n    weights = [obj[0] + obj[1] for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: edge exchange with segment relocation\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n\n    # Calculate segment cost\n    segment = new_solution[a:b+1]\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement (normalized by original costs)\n        improvement = (seg_cost1 - (new_cost1 - seg_cost1)) + (seg_cost2 - (new_cost2 - seg_cost2))\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform edge exchange\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 132,
        "algorithm": "{This algorithm selects a solution from the archive based on a weighted combination of its objective values, then applies a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of normalized objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives) if objectives else 1.0\n    max_obj2 = max(obj[1] for obj in objectives) if objectives else 1.0\n\n    weighted_scores = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted combination\n        weighted_scores.append(score)\n\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select two edges to swap\n    a, b = random.sample(range(n), 2)\n    c, d = random.sample(range(n), 2)\n\n    # Perform edge swap if feasible\n    if a != b and c != d and {a, b} != {c, d}:\n        # Check if swap maintains feasibility\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n        # Validate the new solution\n        if len(set(temp_solution)) == n:  # All nodes visited exactly once\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8628670444950849,
            0.3013319969177246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest weighted sum of normalized objectives\n    objectives = [obj for _, obj in archive]\n    max_obj1 = max(obj[0] for obj in objectives) if objectives else 1.0\n    max_obj2 = max(obj[1] for obj in objectives) if objectives else 1.0\n\n    weighted_scores = []\n    for sol, obj in archive:\n        norm_obj1 = obj[0] / max_obj1 if max_obj1 > 0 else 0\n        norm_obj2 = obj[1] / max_obj2 if max_obj2 > 0 else 0\n        score = 0.7 * norm_obj1 + 0.3 * norm_obj2  # Weighted combination\n        weighted_scores.append(score)\n\n    selected_idx = weighted_scores.index(max(weighted_scores))\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    # Randomly select two edges to swap\n    a, b = random.sample(range(n), 2)\n    c, d = random.sample(range(n), 2)\n\n    # Perform edge swap if feasible\n    if a != b and c != d and {a, b} != {c, d}:\n        # Check if swap maintains feasibility\n        temp_solution = new_solution.copy()\n        temp_solution[a], temp_solution[b] = temp_solution[b], temp_solution[a]\n        temp_solution[c], temp_solution[d] = temp_solution[d], temp_solution[c]\n\n        # Validate the new solution\n        if len(set(temp_solution)) == n:  # All nodes visited exactly once\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 133,
        "algorithm": "{This algorithm implements a novel multi-objective local search strategy that combines adaptive segment reversal with objective-aware edge selection, dynamically balancing improvements in both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/(obj[0] + obj[1] + 1) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on both objectives\n    segment_length = max(2, min(5, int(n * 0.2)))  # Dynamic segment length\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment costs\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Objective-aware edge selection\n    best_improvement = 0\n    best_pos = -1\n    best_reversed = False\n\n    for pos in range(n - segment_length + 1):\n        if abs(pos - a) < segment_length:\n            continue  # Skip overlapping segments\n\n        # Try both original and reversed segment\n        for reverse in [False, True]:\n            temp_segment = segment[::-1] if reverse else segment.copy()\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[pos-1], new_solution[pos]) if pos > 0 else None,\n                (new_solution[pos+segment_length-1], new_solution[(pos+segment_length)%n]) if pos+segment_length < n else None\n            ]\n            new_edges = [\n                (new_solution[pos-1], temp_segment[0]) if pos > 0 else None,\n                (temp_segment[-1], new_solution[(pos+segment_length)%n]) if pos+segment_length < n else None\n            ]\n\n            improvement1 = sum(\n                (distance_matrix_1[new[0], new[1]] - distance_matrix_1[old[0], old[1]])\n                for old, new in zip(old_edges, new_edges) if old is not None\n            )\n            improvement2 = sum(\n                (distance_matrix_2[new[0], new[1]] - distance_matrix_2[old[0], old[1]])\n                for old, new in zip(old_edges, new_edges) if old is not None\n            )\n\n            # Weighted improvement considering both objectives\n            total_improvement = (improvement1 + improvement2) / (current_obj[0] + current_obj[1] + 1e-6)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n                best_reversed = reverse\n\n    if best_pos != -1:\n        # Apply the best segment insertion/reversal\n        segment = segment[::-1] if best_reversed else segment\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos+segment_length:]\n        ])\n    else:\n        # Fallback: perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[j:k+1],\n            new_solution[i:j],\n            new_solution[k+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.9654613740490084,
            0.1676921248435974
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    weights = [1/(obj[0] + obj[1] + 1) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    current_obj = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on both objectives\n    segment_length = max(2, min(5, int(n * 0.2)))  # Dynamic segment length\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment costs\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Objective-aware edge selection\n    best_improvement = 0\n    best_pos = -1\n    best_reversed = False\n\n    for pos in range(n - segment_length + 1):\n        if abs(pos - a) < segment_length:\n            continue  # Skip overlapping segments\n\n        # Try both original and reversed segment\n        for reverse in [False, True]:\n            temp_segment = segment[::-1] if reverse else segment.copy()\n\n            # Calculate potential improvement\n            old_edges = [\n                (new_solution[pos-1], new_solution[pos]) if pos > 0 else None,\n                (new_solution[pos+segment_length-1], new_solution[(pos+segment_length)%n]) if pos+segment_length < n else None\n            ]\n            new_edges = [\n                (new_solution[pos-1], temp_segment[0]) if pos > 0 else None,\n                (temp_segment[-1], new_solution[(pos+segment_length)%n]) if pos+segment_length < n else None\n            ]\n\n            improvement1 = sum(\n                (distance_matrix_1[new[0], new[1]] - distance_matrix_1[old[0], old[1]])\n                for old, new in zip(old_edges, new_edges) if old is not None\n            )\n            improvement2 = sum(\n                (distance_matrix_2[new[0], new[1]] - distance_matrix_2[old[0], old[1]])\n                for old, new in zip(old_edges, new_edges) if old is not None\n            )\n\n            # Weighted improvement considering both objectives\n            total_improvement = (improvement1 + improvement2) / (current_obj[0] + current_obj[1] + 1e-6)\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n                best_reversed = reverse\n\n    if best_pos != -1:\n        # Apply the best segment insertion/reversal\n        segment = segment[::-1] if best_reversed else segment\n        new_solution = np.concatenate([\n            new_solution[:best_pos],\n            segment,\n            new_solution[best_pos+segment_length:]\n        ])\n    else:\n        # Fallback: perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution = np.concatenate([\n            new_solution[:i],\n            new_solution[j:k+1],\n            new_solution[i:j],\n            new_solution[k+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 134,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism, and applies a probabilistic segment reversal to further explore the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the segment in both objectives\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment with a probability based on potential improvement\n    if random.random() < 0.7:  # Higher probability to reverse if segment is long\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if at least one objective improves\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            new_solution = temp_solution\n\n    # Apply a probabilistic node swap to further explore the solution space\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7252050370306755,
            0.5335313081741333
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate the cost of the segment in both objectives\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment with a probability based on potential improvement\n    if random.random() < 0.7:  # Higher probability to reverse if segment is long\n        reversed_segment = segment[::-1]\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = reversed_segment\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Accept if at least one objective improves\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            new_solution = temp_solution\n\n    # Apply a probabilistic node swap to further explore the solution space\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 135,
        "algorithm": "{This algorithm implements a multi-objective local search by selecting a solution from the archive, identifying critical edges that significantly impact both objectives, and performing a dynamic edge exchange that considers both distance matrices while preserving tour feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = random.randint(0, min(3, len(archive)-1))  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical edges (top 20% with highest combined distance)\n    n = len(base_solution)\n    edges = [(i, (i+1)%n) for i in range(n)]\n    edge_scores = [distance_matrix_1[u][v] + distance_matrix_2[u][v] for u, v in edges]\n    sorted_edges = sorted(edges, key=lambda e: edge_scores[edges.index(e)], reverse=True)\n    critical_edges = sorted_edges[:max(1, len(sorted_edges)//5)]\n\n    # Perform dynamic edge exchange\n    for u, v in critical_edges:\n        # Find alternative paths that could replace this edge\n        for k in range(n):\n            if k == u or k == v or (k+1)%n == u or (k+1)%n == v:\n                continue\n\n            # Try swapping segments to create a new path\n            temp_solution = new_solution.copy()\n            temp_solution[u], temp_solution[k] = temp_solution[k], temp_solution[u]\n\n            # Validate the new solution is a valid tour\n            if len(set(temp_solution)) == n and len(temp_solution) == n:\n                new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n                # Accept if at least one objective improves\n                if new_cost1 < archive[selected_idx][1][0] or new_cost2 < archive[selected_idx][1][1]:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n",
        "score": [
            -0.9035585020790579,
            0.5959731936454773
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = random.randint(0, min(3, len(archive)-1))  # Select from top 3\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical edges (top 20% with highest combined distance)\n    n = len(base_solution)\n    edges = [(i, (i+1)%n) for i in range(n)]\n    edge_scores = [distance_matrix_1[u][v] + distance_matrix_2[u][v] for u, v in edges]\n    sorted_edges = sorted(edges, key=lambda e: edge_scores[edges.index(e)], reverse=True)\n    critical_edges = sorted_edges[:max(1, len(sorted_edges)//5)]\n\n    # Perform dynamic edge exchange\n    for u, v in critical_edges:\n        # Find alternative paths that could replace this edge\n        for k in range(n):\n            if k == u or k == v or (k+1)%n == u or (k+1)%n == v:\n                continue\n\n            # Try swapping segments to create a new path\n            temp_solution = new_solution.copy()\n            temp_solution[u], temp_solution[k] = temp_solution[k], temp_solution[u]\n\n            # Validate the new solution is a valid tour\n            if len(set(temp_solution)) == n and len(temp_solution) == n:\n                new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n                new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n                # Accept if at least one objective improves\n                if new_cost1 < archive[selected_idx][1][0] or new_cost2 < archive[selected_idx][1][1]:\n                    new_solution = temp_solution\n                    break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 136,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a sophisticated reinsertion strategy that considers multiple candidate positions and selects the best one based on a weighted combination of cost improvements in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best reinsertion position for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n    best_weighted_score = float('inf')\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate weighted score (linear combination of cost improvements)\n        weighted_score = 0.5 * (new_cost1 - current_cost1) + 0.5 * (new_cost2 - current_cost2)\n\n        if weighted_score < best_weighted_score:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            best_weighted_score = weighted_score\n\n    if best_insert_pos != -1:\n        # Apply the best reinsertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.5264723109229423,
            2.8758450746536255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best reinsertion position for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n    best_weighted_score = float('inf')\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate weighted score (linear combination of cost improvements)\n        weighted_score = 0.5 * (new_cost1 - current_cost1) + 0.5 * (new_cost2 - current_cost2)\n\n        if weighted_score < best_weighted_score:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            best_weighted_score = weighted_score\n\n    if best_insert_pos != -1:\n        # Apply the best reinsertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 137,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a path reversal operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if the reversed segment is better in both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        # Apply the reversed segment\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If not better, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9980483187816847,
            0.20924699306488037
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a path reversal operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Check if the reversed segment is better in both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        # Apply the reversed segment\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If not better, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 138,
        "algorithm": "{A novel adaptive local search strategy combines a multi-objective dominance-based selection with a dynamic path inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(obj[0] + obj[1]) / (sum(obj) + 1e-8) for _, obj in archive]\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply inversion if it improves at least one objective\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n\n    # Apply a random 2-opt move if inversion didn't help\n    else:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7689335759925789,
            0.28202301263809204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(obj[0] + obj[1]) / (sum(obj) + 1e-8) for _, obj in archive]\n    selected_idx = np.argmin(normalized_objectives)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply inversion if it improves at least one objective\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n\n    # Apply a random 2-opt move if inversion didn't help\n    else:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 139,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with an adaptive edge reversal operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate the total cost of the current solution\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the worst edge in each objective space\n    worst_edge1 = max(range(n), key=lambda i: distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n    worst_edge2 = max(range(n), key=lambda i: distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    # Reverse the worst edge in each space\n    new_solution[worst_edge1], new_solution[(worst_edge1+1)%n] = new_solution[(worst_edge1+1)%n], new_solution[worst_edge1]\n    new_solution[worst_edge2], new_solution[(worst_edge2+1)%n] = new_solution[(worst_edge2+1)%n], new_solution[worst_edge2]\n\n    # Ensure the solution remains valid by checking for duplicates\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Perform a random swap if reversal causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7473152542453224,
            2.113002836704254
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Calculate the total cost of the current solution\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the worst edge in each objective space\n    worst_edge1 = max(range(n), key=lambda i: distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n    worst_edge2 = max(range(n), key=lambda i: distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n    # Reverse the worst edge in each space\n    new_solution[worst_edge1], new_solution[(worst_edge1+1)%n] = new_solution[(worst_edge1+1)%n], new_solution[worst_edge1]\n    new_solution[worst_edge2], new_solution[(worst_edge2+1)%n] = new_solution[(worst_edge2+1)%n], new_solution[worst_edge2]\n\n    # Ensure the solution remains valid by checking for duplicates\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Perform a random swap if reversal causes duplicates\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 140,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective edge selection criterion with a dynamic segment reversal operator to explore promising regions in both objective spaces while ensuring feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Select a random segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution = base_solution.copy()\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        return base_solution  # Return original if infeasible\n\n    # Check if the reversed segment improves both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Accept if better in both objectives, otherwise try another segment\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n\n    # If not better, try a different segment reversal\n    for _ in range(5):  # Try up to 5 times\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n        if len(set(temp_solution)) == n:\n            temp_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            temp_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            if temp_cost1 < original_cost1 and temp_cost2 < original_cost2:\n                return temp_solution\n\n    # If no improvement found, return original solution\n    return base_solution\n\n",
        "score": [
            -0.443708593598115,
            1.3993818163871765
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Select a random segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution = base_solution.copy()\n    new_solution[a:b+1] = np.flip(new_solution[a:b+1])\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        return base_solution  # Return original if infeasible\n\n    # Check if the reversed segment improves both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Accept if better in both objectives, otherwise try another segment\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n\n    # If not better, try a different segment reversal\n    for _ in range(5):  # Try up to 5 times\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        temp_solution = new_solution.copy()\n        temp_solution[a:b+1] = np.flip(temp_solution[a:b+1])\n        if len(set(temp_solution)) == n:\n            temp_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            temp_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            if temp_cost1 < original_cost1 and temp_cost2 < original_cost2:\n                return temp_solution\n\n    # If no improvement found, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 141,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7856448621414696,
            0.48139017820358276
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 142,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective edge selection criterion with a dynamic segment reversal operator, prioritizing edges that show potential for cost reduction in both objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost before and after reversal\n    old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the reversal doesn't improve both objectives, perform a random 2-opt\n    if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9601284032954509,
            0.32204926013946533
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost before and after reversal\n    old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the reversal doesn't improve both objectives, perform a random 2-opt\n    if not (new_cost1 < old_cost1 and new_cost2 < old_cost2):\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 143,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9966670108301116,
            0.47346973419189453
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 144,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the cost of removing the node\n    prev_node = new_solution[node_idx - 1] if node_idx > 0 else new_solution[-1]\n    next_node = new_solution[(node_idx + 1) % n]\n    removed_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    removed_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and its neighbor\n\n        # Calculate the cost of inserting the node at position 'pos'\n        prev_pos = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n        next_pos = new_solution[pos]\n        insert_cost1 = distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos]\n        insert_cost2 = distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos]\n\n        # Calculate the total cost change\n        total_cost1 = insert_cost1 - removed_cost1\n        total_cost2 = insert_cost2 - removed_cost2\n\n        # Check if this is better in at least one objective\n        if total_cost1 < 0 or total_cost2 < 0:\n            best_cost1, best_cost2 = total_cost1, total_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9435511615026619,
            0.3050500154495239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the cost of removing the node\n    prev_node = new_solution[node_idx - 1] if node_idx > 0 else new_solution[-1]\n    next_node = new_solution[(node_idx + 1) % n]\n    removed_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    removed_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and its neighbor\n\n        # Calculate the cost of inserting the node at position 'pos'\n        prev_pos = new_solution[pos - 1] if pos > 0 else new_solution[-1]\n        next_pos = new_solution[pos]\n        insert_cost1 = distance_matrix_1[prev_pos, node] + distance_matrix_1[node, next_pos]\n        insert_cost2 = distance_matrix_2[prev_pos, node] + distance_matrix_2[node, next_pos]\n\n        # Calculate the total cost change\n        total_cost1 = insert_cost1 - removed_cost1\n        total_cost2 = insert_cost2 - removed_cost2\n\n        # Check if this is better in at least one objective\n        if total_cost1 < 0 or total_cost2 < 0:\n            best_cost1, best_cost2 = total_cost1, total_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 145,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment relocation operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism and incorporating a novel adaptive segment selection mechanism that dynamically adjusts segment size based on the solution's current quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with better objectives)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = random.randint(0, min(3, len(archive)-1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_segment_size = max(2, min(5, int(n / (1 + quality/1000))))  # Adjust based on quality\n\n    # Randomly select a segment to perturb\n    segment_size = random.randint(2, max_segment_size)\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best relocation point for the segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_reloc_pos = -1\n\n    for pos in range(n):\n        if pos >= start and pos < start + segment_size:\n            continue  # Skip current segment\n\n        # Try relocating the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n        temp_solution = np.delete(temp_solution, np.s_[start:start+segment_size])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost1 <= cost1 and new_cost2 < cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_reloc_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_reloc_pos != -1:\n        # Apply the best relocation\n        new_solution = np.concatenate([new_solution[:best_reloc_pos], segment, new_solution[best_reloc_pos:]])\n        new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n    else:\n        # If no better relocation found, perform a random 2-opt\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.892974915085919,
            0.629025399684906
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (prioritize those with better objectives)\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]))  # Sort by sum of objectives\n    selected_idx = random.randint(0, min(3, len(archive)-1))  # Select from top 3 solutions\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Adaptive segment selection based on solution quality\n    quality = archive[selected_idx][1][0] + archive[selected_idx][1][1]\n    max_segment_size = max(2, min(5, int(n / (1 + quality/1000))))  # Adjust based on quality\n\n    # Randomly select a segment to perturb\n    segment_size = random.randint(2, max_segment_size)\n    start = random.randint(0, n - segment_size)\n    segment = new_solution[start:start+segment_size]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best relocation point for the segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_reloc_pos = -1\n\n    for pos in range(n):\n        if pos >= start and pos < start + segment_size:\n            continue  # Skip current segment\n\n        # Try relocating the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n        temp_solution = np.delete(temp_solution, np.s_[start:start+segment_size])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost1 <= cost1 and new_cost2 < cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_reloc_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_reloc_pos != -1:\n        # Apply the best relocation\n        new_solution = np.concatenate([new_solution[:best_reloc_pos], segment, new_solution[best_reloc_pos:]])\n        new_solution = np.delete(new_solution, np.s_[start:start+segment_size])\n    else:\n        # If no better relocation found, perform a random 2-opt\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 146,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node sequence reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    max_diff = -float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diff = abs(cost1 - cost2)\n        if diff > max_diff:\n            max_diff = diff\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify nodes with high potential for improvement\n    potential_nodes = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate current edge costs\n        current_cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n\n        # Find potential replacement nodes\n        for candidate in range(n):\n            if candidate in [prev_node, current_node, next_node]:\n                continue\n\n            # Calculate potential new edge costs\n            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n\n            # Check if improvement in at least one objective\n            if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n                potential_nodes.append((i, candidate, new_cost1 - current_cost1, new_cost2 - current_cost2))\n\n    if potential_nodes:\n        # Select the node with the highest improvement potential\n        best_node = max(potential_nodes, key=lambda x: (x[2] + x[3]))\n        pos, candidate, _, _ = best_node\n        new_solution[pos] = candidate\n    else:\n        # If no improvement found, perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:i+1] if i > 0 else new_solution[k+1:]\n\n        # Create all possible 3-opt combinations\n        combinations = [\n            np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n            np.concatenate([new_solution[:i], segment1, np.flip(segment2), segment3]),\n            np.concatenate([new_solution[:i], np.flip(segment1), segment2, segment3]),\n            np.concatenate([new_solution[:i], np.flip(segment1), np.flip(segment2), segment3])\n        ]\n\n        # Select the best combination\n        best_cost = float('inf')\n        best_solution = new_solution\n        for sol in combinations:\n            total_cost = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] + distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_solution = sol\n\n        new_solution = best_solution\n\n    return new_solution\n\n",
        "score": [
            -0.921431956018827,
            0.46010100841522217
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = 0\n    max_diff = -float('inf')\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        diff = abs(cost1 - cost2)\n        if diff > max_diff:\n            max_diff = diff\n            selected_idx = i\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Identify nodes with high potential for improvement\n    potential_nodes = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        current_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n\n        # Calculate current edge costs\n        current_cost1 = distance_matrix_1[prev_node, current_node] + distance_matrix_1[current_node, next_node]\n        current_cost2 = distance_matrix_2[prev_node, current_node] + distance_matrix_2[current_node, next_node]\n\n        # Find potential replacement nodes\n        for candidate in range(n):\n            if candidate in [prev_node, current_node, next_node]:\n                continue\n\n            # Calculate potential new edge costs\n            new_cost1 = distance_matrix_1[prev_node, candidate] + distance_matrix_1[candidate, next_node]\n            new_cost2 = distance_matrix_2[prev_node, candidate] + distance_matrix_2[candidate, next_node]\n\n            # Check if improvement in at least one objective\n            if new_cost1 < current_cost1 or new_cost2 < current_cost2:\n                potential_nodes.append((i, candidate, new_cost1 - current_cost1, new_cost2 - current_cost2))\n\n    if potential_nodes:\n        # Select the node with the highest improvement potential\n        best_node = max(potential_nodes, key=lambda x: (x[2] + x[3]))\n        pos, candidate, _, _ = best_node\n        new_solution[pos] = candidate\n    else:\n        # If no improvement found, perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        segment3 = new_solution[k+1:i+1] if i > 0 else new_solution[k+1:]\n\n        # Create all possible 3-opt combinations\n        combinations = [\n            np.concatenate([new_solution[:i], segment1, segment2, segment3]),\n            np.concatenate([new_solution[:i], segment1, np.flip(segment2), segment3]),\n            np.concatenate([new_solution[:i], np.flip(segment1), segment2, segment3]),\n            np.concatenate([new_solution[:i], np.flip(segment1), np.flip(segment2), segment3])\n        ]\n\n        # Select the best combination\n        best_cost = float('inf')\n        best_solution = new_solution\n        for sol in combinations:\n            total_cost = sum(distance_matrix_1[sol[i], sol[(i+1)%n]] + distance_matrix_2[sol[i], sol[(i+1)%n]] for i in range(n))\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_solution = sol\n\n        new_solution = best_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 147,
        "algorithm": "{This algorithm implements a hybrid local search that prioritizes edge swaps based on their potential to reduce costs in both objectives, using a dynamic selection criterion to identify promising edges while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Identify edges with high potential for cost reduction in both objectives\n    potential_edges = []\n    for i in range(n):\n        u = base_solution[i]\n        v = base_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        for j in range(n):\n            if j == i or j == (i + 1) % n:\n                continue\n            x = base_solution[j]\n            y = base_solution[(j + 1) % n]\n            if distance_matrix_1[u, x] + distance_matrix_1[y, v] < cost1 and distance_matrix_2[u, x] + distance_matrix_2[y, v] < cost2:\n                potential_edges.append((i, j))\n\n    # Apply the best edge swap if found\n    if potential_edges:\n        i, j = random.choice(potential_edges)\n        new_solution = base_solution.copy()\n        # Reverse the segment between i and j\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j+1] = new_solution[:j+1][::-1]\n        return new_solution\n    else:\n        # If no potential edges found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n",
        "score": [
            -0.9089974245615572,
            0.5204489231109619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Identify edges with high potential for cost reduction in both objectives\n    potential_edges = []\n    for i in range(n):\n        u = base_solution[i]\n        v = base_solution[(i + 1) % n]\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        for j in range(n):\n            if j == i or j == (i + 1) % n:\n                continue\n            x = base_solution[j]\n            y = base_solution[(j + 1) % n]\n            if distance_matrix_1[u, x] + distance_matrix_1[y, v] < cost1 and distance_matrix_2[u, x] + distance_matrix_2[y, v] < cost2:\n                potential_edges.append((i, j))\n\n    # Apply the best edge swap if found\n    if potential_edges:\n        i, j = random.choice(potential_edges)\n        new_solution = base_solution.copy()\n        # Reverse the segment between i and j\n        if i < j:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i:] = new_solution[i:][::-1]\n            new_solution[:j+1] = new_solution[:j+1][::-1]\n        return new_solution\n    else:\n        # If no potential edges found, perform a random 2-opt\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution = base_solution.copy()\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 148,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = float('inf')\n    best_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        score = cost1 + cost2  # Simple combined objective score\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a segment inversion with validation\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate original segment cost\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Validate the new solution is feasible\n    if len(set(new_solution)) == n:\n        return new_solution\n\n    # If inversion causes duplicates, revert to a random swap\n    new_solution = base_solution.copy()\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9018549620784935,
            0.23446500301361084
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_score = float('inf')\n    best_idx = 0\n    for i, (sol, (cost1, cost2)) in enumerate(archive):\n        score = cost1 + cost2  # Simple combined objective score\n        if score < best_score:\n            best_score = score\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Perform a segment inversion with validation\n    n = len(new_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = new_solution[a:b+1]\n\n    # Calculate original segment cost\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Validate the new solution is feasible\n    if len(set(new_solution)) == n:\n        return new_solution\n\n    # If inversion causes duplicates, revert to a random swap\n    new_solution = base_solution.copy()\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 149,
        "algorithm": "{This novel hybrid local search strategy integrates a multi-objective edge selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing high-potential edges while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges (those with high cost in either objective)\n    critical_edges = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Select a random critical edge and reverse the path between its endpoints\n        edge_idx = random.choice(critical_edges)\n        start, end = edge_idx, (edge_idx + 1) % n\n\n        # Reverse the segment between start and end\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Validate the solution remains feasible (no duplicates)\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If no critical edges or reversal failed, perform a probabilistic edge swap\n    i, j = random.sample(range(n), 2)\n    if random.random() < 0.7:  # Higher probability to accept beneficial swaps\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check if swap improves at least one objective\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.8059989569701216,
            0.5540196299552917
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges (those with high cost in either objective)\n    critical_edges = []\n    for i in range(n):\n        j = (i + 1) % n\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            critical_edges.append(i)\n\n    if critical_edges:\n        # Select a random critical edge and reverse the path between its endpoints\n        edge_idx = random.choice(critical_edges)\n        start, end = edge_idx, (edge_idx + 1) % n\n\n        # Reverse the segment between start and end\n        segment = new_solution[start:end+1]\n        new_solution[start:end+1] = segment[::-1]\n\n        # Validate the solution remains feasible (no duplicates)\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If no critical edges or reversal failed, perform a probabilistic edge swap\n    i, j = random.sample(range(n), 2)\n    if random.random() < 0.7:  # Higher probability to accept beneficial swaps\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Check if swap improves at least one objective\n        old_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        old_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        if new_cost1 < old_cost1 or new_cost2 < old_cost2:\n            new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 150,
        "algorithm": "{This algorithm combines a multi-objective solution selection with a novel path-swapping operator that dynamically adapts to the trade-off between objectives by prioritizing segments with high potential for improvement in both spaces while ensuring feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by rank)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two non-overlapping segments to swap\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping\n    while (a1 <= b2 and b1 <= a2):\n        a1, a2 = sorted(random.sample(range(n), 2))\n        b1, b2 = sorted(random.sample(range(n), 2))\n\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Calculate original costs\n    original_cost1 = (sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1))) +\n                      sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2))))\n    original_cost2 = (sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1))) +\n                      sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2))))\n\n    # Try both possible swaps\n    candidates = [\n        np.concatenate([new_solution[:a1], segment2, new_solution[a2+1:b1], segment1, new_solution[b2+1:]]),\n        np.concatenate([new_solution[:a1], segment1, new_solution[a2+1:b1], segment2, new_solution[b2+1:]])\n    ]\n\n    best_solution = new_solution\n    best_improvement = 0\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement in both objectives\n        improvement = (original_cost1 - cost1) + (original_cost2 - cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_solution = candidate\n\n    if best_improvement > 0:\n        return best_solution\n\n    # If no improvement, perform a multi-objective edge flip\n    i, j = random.sample(range(n), 2)\n    flip_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n    flip_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n    if flip_cost1 < 0 or flip_cost2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8587826324948249,
            0.334930419921875
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by rank)\n    weights = [1.0 / (i + 1) for i in range(len(archive))]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select two non-overlapping segments to swap\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping\n    while (a1 <= b2 and b1 <= a2):\n        a1, a2 = sorted(random.sample(range(n), 2))\n        b1, b2 = sorted(random.sample(range(n), 2))\n\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Calculate original costs\n    original_cost1 = (sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1))) +\n                      sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2))))\n    original_cost2 = (sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1))) +\n                      sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2))))\n\n    # Try both possible swaps\n    candidates = [\n        np.concatenate([new_solution[:a1], segment2, new_solution[a2+1:b1], segment1, new_solution[b2+1:]]),\n        np.concatenate([new_solution[:a1], segment1, new_solution[a2+1:b1], segment2, new_solution[b2+1:]])\n    ]\n\n    best_solution = new_solution\n    best_improvement = 0\n\n    for candidate in candidates:\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement in both objectives\n        improvement = (original_cost1 - cost1) + (original_cost2 - cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_solution = candidate\n\n    if best_improvement > 0:\n        return best_solution\n\n    # If no improvement, perform a multi-objective edge flip\n    i, j = random.sample(range(n), 2)\n    flip_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_1[new_solution[j], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n    flip_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                  distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]) - \\\n                 (distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                  distance_matrix_2[new_solution[j], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n    if flip_cost1 < 0 or flip_cost2 < 0:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 151,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective edge selection criterion with a dynamic node reinsertion operator, prioritizing nodes with high potential for cost reduction in both objectives while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution in both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.882680002935673,
            0.7934561967849731
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution in both objectives\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        insert_pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, insert_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 152,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node replacement operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to replace\n    node_to_replace = random.randint(0, n - 1)\n    current_node = new_solution[node_to_replace]\n\n    # Find the best replacement node that improves at least one objective\n    best_node = None\n    best_cost1, best_cost2 = current_cost1, current_cost2\n    best_improvement = 0\n\n    for candidate_node in range(n):\n        if candidate_node == current_node:\n            continue\n\n        # Temporarily replace the node\n        temp_solution = new_solution.copy()\n        temp_solution[node_to_replace] = candidate_node\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement in both objectives\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n        total_improvement = improvement1 + improvement2\n\n        # Check if this is better in at least one objective\n        if (improvement1 > 0 or improvement2 > 0) and total_improvement > best_improvement:\n            best_node = candidate_node\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_improvement = total_improvement\n\n    if best_node is not None:\n        new_solution[node_to_replace] = best_node\n    else:\n        # If no better replacement found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.952882133876452,
            0.5630337595939636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_cost1, current_cost2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to replace\n    node_to_replace = random.randint(0, n - 1)\n    current_node = new_solution[node_to_replace]\n\n    # Find the best replacement node that improves at least one objective\n    best_node = None\n    best_cost1, best_cost2 = current_cost1, current_cost2\n    best_improvement = 0\n\n    for candidate_node in range(n):\n        if candidate_node == current_node:\n            continue\n\n        # Temporarily replace the node\n        temp_solution = new_solution.copy()\n        temp_solution[node_to_replace] = candidate_node\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate improvement in both objectives\n        improvement1 = current_cost1 - new_cost1\n        improvement2 = current_cost2 - new_cost2\n        total_improvement = improvement1 + improvement2\n\n        # Check if this is better in at least one objective\n        if (improvement1 > 0 or improvement2 > 0) and total_improvement > best_improvement:\n            best_node = candidate_node\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_improvement = total_improvement\n\n    if best_node is not None:\n        new_solution[node_to_replace] = best_node\n    else:\n        # If no better replacement found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 153,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node exchange operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to move\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Find the best insertion point for the node in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n            continue  # Skip adjacent positions to avoid trivial moves\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n        temp_solution = np.delete(temp_solution, node_idx + (1 if node_idx < pos else 0))\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], [node], new_solution[best_insert_pos:]])\n        new_solution = np.delete(new_solution, node_idx + (1 if node_idx < best_insert_pos else 0))\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9377597106670222,
            0.6233254671096802
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to move\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Find the best insertion point for the node in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n or pos == (node_idx + 1) % n:\n            continue  # Skip adjacent positions to avoid trivial moves\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n        temp_solution = np.delete(temp_solution, node_idx + (1 if node_idx < pos else 0))\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], [node], new_solution[best_insert_pos:]])\n        new_solution = np.delete(new_solution, node_idx + (1 if node_idx < best_insert_pos else 0))\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 154,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a dynamic path reversal operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    new_solution[a:b+1] = segment\n\n    reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    # If the reversal doesn't improve both objectives, try another reversal\n    if not (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n        # Try reversing a different segment\n        c = random.randint(0, n - 1)\n        d = random.randint(0, n - 1)\n        if c > d:\n            c, d = d, c\n        segment = new_solution[c:d+1][::-1]\n        new_solution[c:d+1] = segment\n\n    return new_solution\n\n",
        "score": [
            -0.953211950918305,
            0.26644301414489746
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a dynamic path reversal operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and reversed segment in both objectives\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    new_solution[a:b+1] = segment\n\n    reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a-1, b+1))\n\n    # If the reversal doesn't improve both objectives, try another reversal\n    if not (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n        # Try reversing a different segment\n        c = random.randint(0, n - 1)\n        d = random.randint(0, n - 1)\n        if c > d:\n            c, d = d, c\n        segment = new_solution[c:d+1][::-1]\n        new_solution[c:d+1] = segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 155,
        "algorithm": "{This new algorithm combines a multi-objective selection criterion with a dynamic edge exchange operator that prioritizes edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(sum(obj)/len(archive), idx) for idx, (sol, obj) in enumerate(archive)]\n    selected_idx = max(normalized_objectives, key=lambda x: x[0])[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i-j) == 1 or i == j:\n        j = random.randint(0, n-1)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.996060776928996,
            0.2546209692955017
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = [(sum(obj)/len(archive), idx) for idx, (sol, obj) in enumerate(archive)]\n    selected_idx = max(normalized_objectives, key=lambda x: x[0])[1]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n-1)\n    j = random.randint(0, n-1)\n    while abs(i-j) == 1 or i == j:\n        j = random.randint(0, n-1)\n\n    # Perform edge exchange\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 156,
        "algorithm": "{This algorithm implements a multi-objective local search by first selecting a solution with high potential for improvement based on objective dominance, then applies a dynamic edge exchange operator that considers both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1:  # Ensure edges are not adjacent\n        j = random.randint(0, n - 1)\n\n    # Calculate the cost of the current and potential new edges in both objectives\n    current_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    # Apply the exchange if it improves both objectives\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Reverse the segment between i and j to maintain tour validity\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # If not better, perform a random 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        if abs(a - b) > 1:  # Ensure edges are not adjacent\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9440983796208029,
            0.19805437326431274
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1:  # Ensure edges are not adjacent\n        j = random.randint(0, n - 1)\n\n    # Calculate the cost of the current and potential new edges in both objectives\n    current_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    # Apply the exchange if it improves both objectives\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Reverse the segment between i and j to maintain tour validity\n        new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n    else:\n        # If not better, perform a random 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        if abs(a - b) > 1:  # Ensure edges are not adjacent\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 157,
        "algorithm": "{A novel hybrid local search strategy leverages a multi-objective edge selection criterion to identify critical edges in both spaces, then applies a dynamic segment relocation operator that preserves feasibility while exploring high-potential regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average improvement potential\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical edges in both spaces\n    n = len(base_solution)\n    critical_edges = []\n    for i in range(n):\n        node1 = base_solution[i]\n        node2 = base_solution[(i+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            critical_edges.append((i, (i+1)%n))\n\n    if not critical_edges:\n        # If no critical edges found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a random critical edge to modify\n    edge_start, edge_end = random.choice(critical_edges)\n\n    # Relocate the segment between critical edges\n    segment = new_solution[edge_start:edge_end+1]\n    remaining = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_pos = -1\n\n    for pos in range(len(remaining)):\n        # Insert segment at position pos\n        temp_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        # Calculate total cost\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6373394111668212,
            3.7350075244903564
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest average improvement potential\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Identify critical edges in both spaces\n    n = len(base_solution)\n    critical_edges = []\n    for i in range(n):\n        node1 = base_solution[i]\n        node2 = base_solution[(i+1)%n]\n        cost1 = distance_matrix_1[node1, node2]\n        cost2 = distance_matrix_2[node1, node2]\n        if cost1 > np.mean(distance_matrix_1) or cost2 > np.mean(distance_matrix_2):\n            critical_edges.append((i, (i+1)%n))\n\n    if not critical_edges:\n        # If no critical edges found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a random critical edge to modify\n    edge_start, edge_end = random.choice(critical_edges)\n\n    # Relocate the segment between critical edges\n    segment = new_solution[edge_start:edge_end+1]\n    remaining = np.concatenate([new_solution[:edge_start], new_solution[edge_end+1:]])\n\n    # Find the best insertion point for the segment\n    best_cost = float('inf')\n    best_pos = -1\n\n    for pos in range(len(remaining)):\n        # Insert segment at position pos\n        temp_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        # Calculate total cost\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        total_cost = cost1 + cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 158,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct segments to exchange\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Extract segments\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Calculate the cost of the edges connecting the segments\n    cost1_conn = distance_matrix_1[new_solution[a1-1], new_solution[a2]] + distance_matrix_1[new_solution[b1-1], new_solution[b2]]\n    cost2_conn = distance_matrix_2[new_solution[a1-1], new_solution[a2]] + distance_matrix_2[new_solution[b1-1], new_solution[b2]]\n\n    # Swap the segments if it improves both objectives\n    if (cost1_seg1 + cost1_seg2) > (cost1_conn + distance_matrix_1[new_solution[a1-1], new_solution[b1]] + distance_matrix_1[new_solution[a2], new_solution[b2]]) and \\\n       (cost2_seg1 + cost2_seg2) > (cost2_conn + distance_matrix_2[new_solution[a1-1], new_solution[b1]] + distance_matrix_2[new_solution[a2], new_solution[b2]]):\n        new_solution = np.concatenate([new_solution[:a1], segment2, new_solution[a2+1:b1], segment1, new_solution[b2+1:]])\n    else:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7809917431727628,
            0.06868481636047363
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct segments to exchange\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Extract segments\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Calculate the cost of the edges connecting the segments\n    cost1_conn = distance_matrix_1[new_solution[a1-1], new_solution[a2]] + distance_matrix_1[new_solution[b1-1], new_solution[b2]]\n    cost2_conn = distance_matrix_2[new_solution[a1-1], new_solution[a2]] + distance_matrix_2[new_solution[b1-1], new_solution[b2]]\n\n    # Swap the segments if it improves both objectives\n    if (cost1_seg1 + cost1_seg2) > (cost1_conn + distance_matrix_1[new_solution[a1-1], new_solution[b1]] + distance_matrix_1[new_solution[a2], new_solution[b2]]) and \\\n       (cost2_seg1 + cost2_seg2) > (cost2_conn + distance_matrix_2[new_solution[a1-1], new_solution[b1]] + distance_matrix_2[new_solution[a2], new_solution[b2]]):\n        new_solution = np.concatenate([new_solution[:a1], segment2, new_solution[a2+1:b1], segment1, new_solution[b2+1:]])\n    else:\n        # If no improvement, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 159,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic segment reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a novel segment reversal strategy to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the reversal improves both objectives, keep it; otherwise, try another segment\n    if new_cost1 < sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) and \\\n       new_cost2 < sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)):\n        return new_solution\n    else:\n        # If not better, try another random segment reversal\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Ensure the solution remains valid\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n        return new_solution\n\n",
        "score": [
            -0.8984078108331064,
            0.26110678911209106
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the new cost\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the reversal improves both objectives, keep it; otherwise, try another segment\n    if new_cost1 < sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n)) and \\\n       new_cost2 < sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n)):\n        return new_solution\n    else:\n        # If not better, try another random segment reversal\n        a, b = random.sample(range(n), 2)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n        reversed_segment = segment[::-1]\n        new_solution[a:b+1] = reversed_segment\n\n        # Ensure the solution remains valid\n        if len(np.unique(new_solution)) != n:\n            new_solution = base_solution.copy()\n        return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 160,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node insertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's edges\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and adjacent positions\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n        temp_solution = np.delete(temp_solution, node_idx if node_idx >= pos else node_idx + 1)\n\n        # Calculate the new cost\n        prev_node_new = temp_solution[pos - 1]\n        next_node_new = temp_solution[(pos + 1) % n]\n        new_cost1 = distance_matrix_1[prev_node_new, node] + distance_matrix_1[node, next_node_new]\n        new_cost2 = distance_matrix_2[prev_node_new, node] + distance_matrix_2[node, next_node_new]\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], [node], new_solution[best_insert_pos:]])\n        new_solution = np.delete(new_solution, node_idx if node_idx >= best_insert_pos else node_idx + 1)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.783838870988365,
            0.4947035312652588
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's edges\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and adjacent positions\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n        temp_solution = np.delete(temp_solution, node_idx if node_idx >= pos else node_idx + 1)\n\n        # Calculate the new cost\n        prev_node_new = temp_solution[pos - 1]\n        next_node_new = temp_solution[(pos + 1) % n]\n        new_cost1 = distance_matrix_1[prev_node_new, node] + distance_matrix_1[node, next_node_new]\n        new_cost2 = distance_matrix_2[prev_node_new, node] + distance_matrix_2[node, next_node_new]\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], [node], new_solution[best_insert_pos:]])\n        new_solution = np.delete(new_solution, node_idx if node_idx >= best_insert_pos else node_idx + 1)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 161,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with an adaptive segment relocation operator that dynamically balances cost reduction in both objective spaces while maintaining feasibility through a probabilistic acceptance mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= start and pos < start + segment_length:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a probabilistic acceptance criterion\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (random.random() < 0.1):  # 10% chance to accept worse solutions\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9056816582007072,
            0.41651004552841187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    segment_length = random.randint(2, min(5, n//2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= start and pos < start + segment_length:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Use a probabilistic acceptance criterion\n        if (new_cost1 < cost1 and new_cost2 < cost2) or (random.random() < 0.1):  # 10% chance to accept worse solutions\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 162,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9458772036646953,
            0.4709557294845581
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 163,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective edge selection criterion with a dynamic segment reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current cost of the segment in both objectives\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment and calculate new cost\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Accept reversal if it improves at least one objective\n    if reversed_cost1 < cost1 or reversed_cost2 < cost2:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = random.sample(range(n), 3)\n        if i > j:\n            i, j = j, i\n        if j > k:\n            j, k = k, j\n        if i > j:\n            i, j = j, i\n\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_segment = np.concatenate([segment2, segment1])\n        new_solution[i:k+1] = new_segment\n\n    return new_solution\n\n",
        "score": [
            -0.8260604559577394,
            0.2035999298095703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: (x[1][0] + x[1][1]) / 2)  # Sort by average cost\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    n = len(new_solution)\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate current cost of the segment in both objectives\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Reverse the segment and calculate new cost\n    reversed_segment = segment[::-1]\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Accept reversal if it improves at least one objective\n    if reversed_cost1 < cost1 or reversed_cost2 < cost2:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If no improvement, perform a random 3-opt move\n        i, j, k = random.sample(range(n), 3)\n        if i > j:\n            i, j = j, i\n        if j > k:\n            j, k = k, j\n        if i > j:\n            i, j = j, i\n\n        segment1 = new_solution[i:j+1]\n        segment2 = new_solution[j+1:k+1]\n        new_segment = np.concatenate([segment2, segment1])\n        new_solution[i:k+1] = new_segment\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 164,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9365166296815335,
            0.49005770683288574
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 165,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reallocation operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism and leveraging a novel adaptive segment reversal technique to explore diverse solution spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (new_cost1 < best_cost1 and new_cost2 <= best_cost2) or (new_cost1 <= best_cost1 and new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8849522988533867,
            0.3174036145210266
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    if random.random() < 0.5:\n        segment = segment[::-1]\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (new_cost1 < best_cost1 and new_cost2 <= best_cost2) or (new_cost1 <= best_cost1 and new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 166,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective score\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a segment reversal operation\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the new solution\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the new solution is worse in both objectives, revert to a random swap\n    original_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6398855241800012,
            0.2340559959411621
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with the best combined objective score\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Perform a segment reversal operation\n    a, b = sorted(random.sample(range(n), 2))\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the new solution\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the new solution is worse in both objectives, revert to a random swap\n    original_cost1 = sum(distance_matrix_1[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[selected_solution[i], selected_solution[(i+1)%n]] for i in range(n))\n\n    if (new_cost1 >= original_cost1 and new_cost2 >= original_cost2):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 167,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a novel local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8991726993196418,
            0.49523329734802246
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a novel local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 168,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with an adaptive segment relocation operator that dynamically adjusts segment sizes based on edge dominance in both objective spaces, while maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Calculate edge dominance scores\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        u = base_solution[i]\n        v = base_solution[(i+1)%n]\n        edge_scores[i] = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n\n    # Find the least dominant edge segment\n    min_score = np.min(edge_scores)\n    candidates = np.where(edge_scores == min_score)[0]\n    a = random.choice(candidates)\n    b = (a + random.randint(1, n//2)) % n\n\n    if a > b:\n        a, b = b, a\n\n    # Extract and relocate the segment\n    segment = base_solution[a:b+1]\n    remaining = np.concatenate([base_solution[:a], base_solution[b+1:]])\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_improvement = -float('inf')\n\n    for pos in range(len(remaining)):\n        # Try inserting segment at position pos\n        temp_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        # Calculate improvement in both objectives\n        old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        improvement1 = old_cost1 - new_cost1\n\n        old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        improvement2 = old_cost2 - new_cost2\n\n        # Combine improvements with adaptive weights\n        alpha = 0.5 * (1 + np.random.rand())  # Random weight between 0.5 and 1.0\n        total_improvement = alpha * improvement1 + (1 - alpha) * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n    else:\n        # If no improvement found, perform a random 2-opt\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([base_solution[:i], base_solution[i:j+1][::-1], base_solution[j+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.6718500138078047,
            1.9117931127548218
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Calculate edge dominance scores\n    edge_scores = np.zeros(n)\n    for i in range(n):\n        u = base_solution[i]\n        v = base_solution[(i+1)%n]\n        edge_scores[i] = distance_matrix_1[u, v] + distance_matrix_2[u, v]\n\n    # Find the least dominant edge segment\n    min_score = np.min(edge_scores)\n    candidates = np.where(edge_scores == min_score)[0]\n    a = random.choice(candidates)\n    b = (a + random.randint(1, n//2)) % n\n\n    if a > b:\n        a, b = b, a\n\n    # Extract and relocate the segment\n    segment = base_solution[a:b+1]\n    remaining = np.concatenate([base_solution[:a], base_solution[b+1:]])\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_improvement = -float('inf')\n\n    for pos in range(len(remaining)):\n        # Try inserting segment at position pos\n        temp_solution = np.concatenate([remaining[:pos], segment, remaining[pos:]])\n\n        # Calculate improvement in both objectives\n        old_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        improvement1 = old_cost1 - new_cost1\n\n        old_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        improvement2 = old_cost2 - new_cost2\n\n        # Combine improvements with adaptive weights\n        alpha = 0.5 * (1 + np.random.rand())  # Random weight between 0.5 and 1.0\n        total_improvement = alpha * improvement1 + (1 - alpha) * improvement2\n\n        if total_improvement > best_improvement:\n            best_improvement = total_improvement\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([remaining[:best_pos], segment, remaining[best_pos:]])\n    else:\n        # If no improvement found, perform a random 2-opt\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution = np.concatenate([base_solution[:i], base_solution[i:j+1][::-1], base_solution[j+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 169,
        "algorithm": "{The new algorithm employs a multi-objective-aware segment relocation strategy that dynamically selects and relocates segments based on their potential for improvement in both objectives, while incorporating a probabilistic acceptance criterion to escape local optima and maintain diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1.0 / (obj1 + obj2 + 1e-6) for _, (obj1, obj2) in archive]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=weights, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple segments to perturb\n    num_segments = min(3, n // 2)\n    segments = []\n    for _ in range(num_segments):\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        segments.append((a, b))\n\n    # Sort segments by their length (longer segments first)\n    segments.sort(key=lambda x: x[1] - x[0], reverse=True)\n\n    for a, b in segments:\n        segment = new_solution[a:b+1]\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find potential insertion points with probabilistic acceptance\n        candidate_positions = []\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Probabilistic acceptance based on improvement\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n                candidate_positions.append((pos, new_cost1 + new_cost2))\n\n        if candidate_positions:\n            # Select position with best combined cost\n            best_pos, _ = min(candidate_positions, key=lambda x: x[1])\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Final check for validity\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8950703835422981,
            0.9145717024803162
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1.0 / (obj1 + obj2 + 1e-6) for _, (obj1, obj2) in archive]\n    selected_idx = random.choices(range(len(archive_solutions)), weights=weights, k=1)[0]\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple segments to perturb\n    num_segments = min(3, n // 2)\n    segments = []\n    for _ in range(num_segments):\n        a = random.randint(0, n - 1)\n        b = random.randint(0, n - 1)\n        if a > b:\n            a, b = b, a\n        segments.append((a, b))\n\n    # Sort segments by their length (longer segments first)\n    segments.sort(key=lambda x: x[1] - x[0], reverse=True)\n\n    for a, b in segments:\n        segment = new_solution[a:b+1]\n\n        # Calculate current segment cost\n        current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n        current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n        # Find potential insertion points with probabilistic acceptance\n        candidate_positions = []\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Probabilistic acceptance based on improvement\n            if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or random.random() < 0.3:\n                candidate_positions.append((pos, new_cost1 + new_cost2))\n\n        if candidate_positions:\n            # Select position with best combined cost\n            best_pos, _ = min(candidate_positions, key=lambda x: x[1])\n            new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    # Final check for validity\n    if len(np.unique(new_solution)) != n:\n        # Fallback to random swap if invalid\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 170,
        "algorithm": "{A new hybrid local search strategy combines a multi-objective edge selection criterion with a dynamic segment relocation operator that prioritizes edges with high potential for cost reduction in both objectives while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to potentially swap\n    i, j = random.sample(range(n), 2)\n    a, b = min(i, j), max(i, j)\n\n    # Calculate the cost of the current and potential new edges\n    current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n    # Apply the swap if it improves both objectives\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution = np.concatenate([new_solution[:a+1], new_solution[b:a:-1], new_solution[b+1:]])\n\n    # If no improvement, perform a segment relocation\n    else:\n        # Select a random segment\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Find the best insertion point for the segment\n        best_cost1, best_cost2 = float('inf'), float('inf')\n        best_insert_pos = -1\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Try inserting the segment at position 'pos'\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            temp_solution = np.concatenate([temp_solution[:a], temp_solution[b+1:]])\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Check if this is better in at least one objective\n            if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7700299492550514,
            0.4381667971611023
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges to potentially swap\n    i, j = random.sample(range(n), 2)\n    a, b = min(i, j), max(i, j)\n\n    # Calculate the cost of the current and potential new edges\n    current_cost1 = distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]]\n\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[b]] + distance_matrix_1[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[b]] + distance_matrix_2[new_solution[(a+1)%n], new_solution[(b+1)%n]]\n\n    # Apply the swap if it improves both objectives\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        new_solution = np.concatenate([new_solution[:a+1], new_solution[b:a:-1], new_solution[b+1:]])\n\n    # If no improvement, perform a segment relocation\n    else:\n        # Select a random segment\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        segment = new_solution[a:b+1]\n\n        # Find the best insertion point for the segment\n        best_cost1, best_cost2 = float('inf'), float('inf')\n        best_insert_pos = -1\n\n        for pos in range(n):\n            if pos >= a and pos <= b:\n                continue\n\n            # Try inserting the segment at position 'pos'\n            temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n            temp_solution = np.concatenate([temp_solution[:a], temp_solution[b+1:]])\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Check if this is better in at least one objective\n            if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n        if best_insert_pos != -1:\n            new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n            new_solution = np.concatenate([new_solution[:a], new_solution[b+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 171,
        "algorithm": "{This algorithm employs a multi-objective edge swapping strategy that evaluates the potential cost reduction in both objective spaces while prioritizing edges with the highest combined improvement potential, using a dynamic selection criterion to ensure feasibility and diversity in the search process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    improved = False\n\n    # Evaluate all possible edge swaps\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            potential_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            potential_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n            # Check if swap improves at least one objective\n            if (potential_cost1 < current_cost1) or (potential_cost2 < current_cost2):\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement found, perform a random 2-opt\n    if not improved:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[j-1:i:-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9954679108776815,
            3.333573818206787
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive.sort(key=lambda x: x[1][0] + x[1][1])\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    improved = False\n\n    # Evaluate all possible edge swaps\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate current and potential costs\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            potential_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            potential_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n            # Check if swap improves at least one objective\n            if (potential_cost1 < current_cost1) or (potential_cost2 < current_cost2):\n                # Perform the swap\n                new_solution[i+1:j+1] = new_solution[j:i:-1]\n                improved = True\n                break\n        if improved:\n            break\n\n    # If no improvement found, perform a random 2-opt\n    if not improved:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = new_solution[j-1:i:-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 172,
        "algorithm": "{A novel local search strategy combines a multi-objective edge selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node in the remaining tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.7182930068902824,
            1.0808517932891846
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the solution\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node in the remaining tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < best_cost1 or new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n - 2)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 173,
        "algorithm": "{This new algorithm prioritizes solutions with high potential for improvement by dynamically selecting segments based on edge cost ratios, then applies a hybrid of segment reordering and edge swapping to generate neighbors that explore both objective spaces while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] + archive[i][1][1]) / len(archive[i][0]))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate edge cost ratios\n    edge_ratios = []\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        ratio = distance_matrix_1[u, v] / distance_matrix_2[u, v] if distance_matrix_2[u, v] != 0 else float('inf')\n        edge_ratios.append((ratio, i))\n\n    # Select edges with extreme ratios\n    edge_ratios.sort()\n    selected_edges = [edge_ratios[0][1], edge_ratios[-1][1]]\n\n    # Perform hybrid operation\n    if len(selected_edges) >= 2:\n        a, b = selected_edges[0], selected_edges[1]\n        if a > b:\n            a, b = b, a\n\n        # Reorder segment between selected edges\n        segment = new_solution[a:b+1]\n        if len(segment) > 2:\n            new_segment = np.concatenate([segment[:1], segment[1:-1][::-1], segment[-1:]])\n            new_solution[a:b+1] = new_segment\n    else:\n        # Swap nodes with high potential\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9467091354930852,
            0.22753816843032837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = max(range(len(archive)), key=lambda i: (archive[i][1][0] + archive[i][1][1]) / len(archive[i][0]))\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate edge cost ratios\n    edge_ratios = []\n    for i in range(n):\n        u, v = base_solution[i], base_solution[(i+1)%n]\n        ratio = distance_matrix_1[u, v] / distance_matrix_2[u, v] if distance_matrix_2[u, v] != 0 else float('inf')\n        edge_ratios.append((ratio, i))\n\n    # Select edges with extreme ratios\n    edge_ratios.sort()\n    selected_edges = [edge_ratios[0][1], edge_ratios[-1][1]]\n\n    # Perform hybrid operation\n    if len(selected_edges) >= 2:\n        a, b = selected_edges[0], selected_edges[1]\n        if a > b:\n            a, b = b, a\n\n        # Reorder segment between selected edges\n        segment = new_solution[a:b+1]\n        if len(segment) > 2:\n            new_segment = np.concatenate([segment[:1], segment[1:-1][::-1], segment[-1:]])\n            new_solution[a:b+1] = new_segment\n    else:\n        # Swap nodes with high potential\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 174,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of both objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    selected_idx = np.argmin([sum(obj) for obj in archive_objectives])\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n    # Calculate potential insertion points\n    best_cost = float('inf')\n    best_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n        # Calculate the new cost for both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Use a weighted sum of both objectives as the selection criterion\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n    else:\n        # If no better position found, insert at a random position\n        pos = random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.7742131387760663,
            3.087538182735443
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined objective value (sum of both objectives)\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n    selected_idx = np.argmin([sum(obj) for obj in archive_objectives])\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.concatenate([new_solution[:node_idx], new_solution[node_idx+1:]])\n\n    # Calculate potential insertion points\n    best_cost = float('inf')\n    best_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n        # Calculate the new cost for both objectives\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Use a weighted sum of both objectives as the selection criterion\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], [node], new_solution[best_pos:]])\n    else:\n        # If no better position found, insert at a random position\n        pos = random.randint(0, n - 1)\n        new_solution = np.concatenate([new_solution[:pos], [node], new_solution[pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 175,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism, and introduces a probabilistic segment reversal mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Calculate improvement potential for each solution\n        potentials = []\n        for sol, obj in archive:\n            # Potential is inversely proportional to the product of objectives\n            potential = 1.0 / (obj[0] * obj[1])\n            potentials.append(potential)\n\n        # Normalize probabilities\n        total = sum(potentials)\n        if total > 0:\n            probabilities = [p/total for p in potentials]\n            selected_idx = np.random.choice(len(archive), p=probabilities)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node in the rest of the tour\n    best_cost = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Combine costs using a weighted sum\n        combined_cost = 0.5 * new_cost1 + 0.5 * new_cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    if best_insert_pos != -1:\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    # With 20% probability, reverse a random segment to escape local optima\n    if random.random() < 0.2:\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8381423404575987,
            1.2809964418411255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 0:\n        # Calculate improvement potential for each solution\n        potentials = []\n        for sol, obj in archive:\n            # Potential is inversely proportional to the product of objectives\n            potential = 1.0 / (obj[0] * obj[1])\n            potentials.append(potential)\n\n        # Normalize probabilities\n        total = sum(potentials)\n        if total > 0:\n            probabilities = [p/total for p in potentials]\n            selected_idx = np.random.choice(len(archive), p=probabilities)\n        else:\n            selected_idx = random.randint(0, len(archive) - 1)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Find the best insertion point for the node in the rest of the tour\n    best_cost = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - 1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n        # Combine costs using a weighted sum\n        combined_cost = 0.5 * new_cost1 + 0.5 * new_cost2\n\n        if combined_cost < best_cost:\n            best_cost = combined_cost\n            best_insert_pos = pos\n\n    # Apply the best insertion\n    if best_insert_pos != -1:\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n\n    # With 20% probability, reverse a random segment to escape local optima\n    if random.random() < 0.2:\n        a = random.randint(0, n - 2)\n        b = random.randint(a + 1, n - 1)\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 176,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        combined_value = obj[0] + obj[1]\n        if combined_value < best_value:\n            best_value = combined_value\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Find the most promising edge to flip based on both objectives\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the current and potential cost of the edges\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            potential_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n            potential_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n            # Calculate the improvement in both objectives\n            improvement1 = current_cost1 - potential_cost1\n            improvement2 = current_cost2 - potential_cost2\n\n            # Use a weighted sum to evaluate the combined improvement\n            combined_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n            if combined_improvement > best_improvement:\n                best_improvement = combined_improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Reverse the segment between best_i and best_j\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.5471875998042939,
            3.790110230445862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = 0\n    best_value = float('inf')\n    for i, (sol, obj) in enumerate(archive):\n        combined_value = obj[0] + obj[1]\n        if combined_value < best_value:\n            best_value = combined_value\n            best_idx = i\n\n    base_solution = archive[best_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Find the most promising edge to flip based on both objectives\n    n = len(new_solution)\n    best_improvement = 0\n    best_i, best_j = -1, -1\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Calculate the current and potential cost of the edges\n            current_cost1 = distance_matrix_1[new_solution[i], new_solution[i+1]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i], new_solution[i+1]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n            potential_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[i+1], new_solution[(j+1)%n]]\n            potential_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i+1], new_solution[(j+1)%n]]\n\n            # Calculate the improvement in both objectives\n            improvement1 = current_cost1 - potential_cost1\n            improvement2 = current_cost2 - potential_cost2\n\n            # Use a weighted sum to evaluate the combined improvement\n            combined_improvement = 0.5 * improvement1 + 0.5 * improvement2\n\n            if combined_improvement > best_improvement:\n                best_improvement = combined_improvement\n                best_i, best_j = i, j\n\n    if best_i != -1 and best_j != -1:\n        # Reverse the segment between best_i and best_j\n        new_solution[best_i+1:best_j+1] = new_solution[best_i+1:best_j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 177,
        "algorithm": "{A novel adaptive segment relocation strategy combines multi-objective edge selection with a dynamic segment inversion operator, prioritizing critical edges while ensuring feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    # Randomly select a segment to relocate\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    # Invert the segment to introduce new edges\n    segment = segment[::-1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the inverted segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random inversion of a smaller segment\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8073827835344026,
            0.4944645166397095
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    base_solution = archive_sorted[0][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    # Randomly select a segment to relocate\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    # Invert the segment to introduce new edges\n    segment = segment[::-1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the inverted segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random inversion of a smaller segment\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 178,
        "algorithm": "{This algorithm combines a multi-objective selection criterion with a novel path decomposition and recombination operator that dynamically partitions the tour into segments based on both objective spaces, then reassembles them using a hybrid cost-aware insertion strategy to balance improvements across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic path decomposition based on both objectives\n    decomposition_points = []\n    for i in range(1, n):\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]])\n        next_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n        if current_cost > 1.2 * next_cost or random.random() < 0.1:  # High potential for improvement\n            decomposition_points.append(i)\n\n    if not decomposition_points:\n        decomposition_points = [random.randint(1, n-1)]\n\n    # Select a random decomposition point\n    split_point = random.choice(decomposition_points)\n\n    # Create segments\n    segment1 = new_solution[:split_point]\n    segment2 = new_solution[split_point:]\n\n    # Hybrid cost-aware insertion strategy\n    best_solution = new_solution.copy()\n    best_cost1 = sum(distance_matrix_1[best_solution[i], best_solution[(i+1)%n]] for i in range(n))\n    best_cost2 = sum(distance_matrix_2[best_solution[i], best_solution[(i+1)%n]] for i in range(n))\n\n    # Try different segment orderings\n    for _ in range(3):\n        temp_solution = np.concatenate([segment2, segment1])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n            best_solution = temp_solution\n            best_cost1, best_cost2 = cost1, cost2\n\n        segment1, segment2 = segment2, segment1\n\n    # Local refinement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        temp_solution = best_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n            best_solution = temp_solution\n            best_cost1, best_cost2 = cost1, cost2\n\n    return best_solution\n\n",
        "score": [
            -0.8317995721116711,
            1.0527915358543396
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic path decomposition based on both objectives\n    decomposition_points = []\n    for i in range(1, n):\n        current_cost = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                        distance_matrix_2[new_solution[i-1], new_solution[i]])\n        next_cost = (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                      distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n        if current_cost > 1.2 * next_cost or random.random() < 0.1:  # High potential for improvement\n            decomposition_points.append(i)\n\n    if not decomposition_points:\n        decomposition_points = [random.randint(1, n-1)]\n\n    # Select a random decomposition point\n    split_point = random.choice(decomposition_points)\n\n    # Create segments\n    segment1 = new_solution[:split_point]\n    segment2 = new_solution[split_point:]\n\n    # Hybrid cost-aware insertion strategy\n    best_solution = new_solution.copy()\n    best_cost1 = sum(distance_matrix_1[best_solution[i], best_solution[(i+1)%n]] for i in range(n))\n    best_cost2 = sum(distance_matrix_2[best_solution[i], best_solution[(i+1)%n]] for i in range(n))\n\n    # Try different segment orderings\n    for _ in range(3):\n        temp_solution = np.concatenate([segment2, segment1])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.1) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.1):\n            best_solution = temp_solution\n            best_cost1, best_cost2 = cost1, cost2\n\n        segment1, segment2 = segment2, segment1\n\n    # Local refinement\n    for _ in range(2):\n        i, j = random.sample(range(n), 2)\n        temp_solution = best_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n        cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        if (cost1 < best_cost1 and cost2 <= best_cost2 * 1.05) or (cost2 < best_cost2 and cost1 <= best_cost1 * 1.05):\n            best_solution = temp_solution\n            best_cost1, best_cost2 = cost1, cost2\n\n    return best_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0228806646253488,
            0.3678058981895447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 179,
        "algorithm": "{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0228806646253488,
            0.3678058981895447
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 180,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify nodes with high potential for cost reduction\n    n = len(new_solution)\n    node_costs = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        node_costs.append((cost1 + cost2, i))\n\n    # Sort nodes by their total cost in both objectives\n    node_costs.sort(reverse=True)\n    high_cost_nodes = [i for (cost, i) in node_costs[:max(2, n//5)]]\n\n    # Remove and reinsert high-cost nodes\n    for node_idx in high_cost_nodes:\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.39952364487205416,
            4.94942969083786
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n    new_solution = selected_solution.copy()\n\n    # Identify nodes with high potential for cost reduction\n    n = len(new_solution)\n    node_costs = []\n    for i in range(n):\n        prev_node = new_solution[i-1]\n        curr_node = new_solution[i]\n        next_node = new_solution[(i+1)%n]\n        cost1 = distance_matrix_1[prev_node, curr_node] + distance_matrix_1[curr_node, next_node]\n        cost2 = distance_matrix_2[prev_node, curr_node] + distance_matrix_2[curr_node, next_node]\n        node_costs.append((cost1 + cost2, i))\n\n    # Sort nodes by their total cost in both objectives\n    node_costs.sort(reverse=True)\n    high_cost_nodes = [i for (cost, i) in node_costs[:max(2, n//5)]]\n\n    # Remove and reinsert high-cost nodes\n    for node_idx in high_cost_nodes:\n        node = new_solution[node_idx]\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Find the best insertion position\n        best_pos = 0\n        best_cost = float('inf')\n        for pos in range(len(new_solution)):\n            temp_solution = np.insert(new_solution, pos, node)\n            cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n            cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%len(temp_solution)]] for i in range(len(temp_solution)))\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        new_solution = np.insert(new_solution, best_pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 181,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = random.sample(range(n), 2)\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate the cost of the current edges\n    cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n    cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n    # Calculate the cost of the swapped edges\n    new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n    new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n    # Apply the swap if it improves at least one objective\n    if new_cost1 < cost1 or new_cost2 < cost2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform a segment reversal to further improve the solution\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8400641184814178,
            0.19242644309997559
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to swap\n    i, j = random.sample(range(n), 2)\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate the cost of the current edges\n    cost1 = distance_matrix_1[a, b] + distance_matrix_1[c, d]\n    cost2 = distance_matrix_2[a, b] + distance_matrix_2[c, d]\n\n    # Calculate the cost of the swapped edges\n    new_cost1 = distance_matrix_1[a, c] + distance_matrix_1[b, d]\n    new_cost2 = distance_matrix_2[a, c] + distance_matrix_2[b, d]\n\n    # Apply the swap if it improves at least one objective\n    if new_cost1 < cost1 or new_cost2 < cost2:\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Perform a segment reversal to further improve the solution\n    a, b = random.sample(range(n), 2)\n    if a > b:\n        a, b = b, a\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 182,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective score for each solution\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify the worst node in both objectives\n    node_scores = []\n    for i in range(n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_ = base_solution[(i+1)%n]\n        score1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n        score2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        node_scores.append(score1 + score2)\n\n    worst_node = np.argmax(node_scores)\n\n    # Find the best insertion position for the worst node\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == worst_node or pos == (worst_node - 1) % n:\n            continue\n\n        # Try inserting the worst node at position 'pos'\n        temp_solution = np.concatenate([\n            base_solution[:pos],\n            [base_solution[worst_node]],\n            base_solution[pos:worst_node],\n            base_solution[worst_node+1:]\n        ])\n\n        # Calculate improvement in both objectives\n        prev_prev = temp_solution[pos-1]\n        prev_curr = temp_solution[pos]\n        curr_next = temp_solution[(pos+1)%n]\n        next_next = temp_solution[(pos+2)%n]\n\n        old_cost1 = distance_matrix_1[prev_prev, prev_curr] + distance_matrix_1[prev_curr, curr_next] + distance_matrix_1[curr_next, next_next]\n        new_cost1 = distance_matrix_1[prev_prev, prev_curr] + distance_matrix_1[prev_curr, base_solution[worst_node]] + distance_matrix_1[base_solution[worst_node], curr_next] + distance_matrix_1[curr_next, next_next]\n\n        old_cost2 = distance_matrix_2[prev_prev, prev_curr] + distance_matrix_2[prev_curr, curr_next] + distance_matrix_2[curr_next, next_next]\n        new_cost2 = distance_matrix_2[prev_prev, prev_curr] + distance_matrix_2[prev_curr, base_solution[worst_node]] + distance_matrix_2[base_solution[worst_node], curr_next] + distance_matrix_2[curr_next, next_next]\n\n        improvement1 = old_cost1 - new_cost1\n        improvement2 = old_cost2 - new_cost2\n\n        if improvement1 > 0 and improvement2 > 0:\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            base_solution[:best_pos],\n            [base_solution[worst_node]],\n            base_solution[best_pos:worst_node],\n            base_solution[worst_node+1:]\n        ])\n    else:\n        # If no improvement found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7942507835203823,
            0.37684160470962524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate combined objective score for each solution\n    scores = [obj[0] + obj[1] for _, obj in archive]\n    selected_idx = np.argmin(scores)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify the worst node in both objectives\n    node_scores = []\n    for i in range(n):\n        prev = base_solution[i-1]\n        curr = base_solution[i]\n        next_ = base_solution[(i+1)%n]\n        score1 = distance_matrix_1[prev, curr] + distance_matrix_1[curr, next_]\n        score2 = distance_matrix_2[prev, curr] + distance_matrix_2[curr, next_]\n        node_scores.append(score1 + score2)\n\n    worst_node = np.argmax(node_scores)\n\n    # Find the best insertion position for the worst node\n    best_pos = -1\n    best_improvement = 0\n\n    for pos in range(n):\n        if pos == worst_node or pos == (worst_node - 1) % n:\n            continue\n\n        # Try inserting the worst node at position 'pos'\n        temp_solution = np.concatenate([\n            base_solution[:pos],\n            [base_solution[worst_node]],\n            base_solution[pos:worst_node],\n            base_solution[worst_node+1:]\n        ])\n\n        # Calculate improvement in both objectives\n        prev_prev = temp_solution[pos-1]\n        prev_curr = temp_solution[pos]\n        curr_next = temp_solution[(pos+1)%n]\n        next_next = temp_solution[(pos+2)%n]\n\n        old_cost1 = distance_matrix_1[prev_prev, prev_curr] + distance_matrix_1[prev_curr, curr_next] + distance_matrix_1[curr_next, next_next]\n        new_cost1 = distance_matrix_1[prev_prev, prev_curr] + distance_matrix_1[prev_curr, base_solution[worst_node]] + distance_matrix_1[base_solution[worst_node], curr_next] + distance_matrix_1[curr_next, next_next]\n\n        old_cost2 = distance_matrix_2[prev_prev, prev_curr] + distance_matrix_2[prev_curr, curr_next] + distance_matrix_2[curr_next, next_next]\n        new_cost2 = distance_matrix_2[prev_prev, prev_curr] + distance_matrix_2[prev_curr, base_solution[worst_node]] + distance_matrix_2[base_solution[worst_node], curr_next] + distance_matrix_2[curr_next, next_next]\n\n        improvement1 = old_cost1 - new_cost1\n        improvement2 = old_cost2 - new_cost2\n\n        if improvement1 > 0 and improvement2 > 0:\n            total_improvement = improvement1 + improvement2\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_pos = pos\n\n    if best_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([\n            base_solution[:best_pos],\n            [base_solution[worst_node]],\n            base_solution[best_pos:worst_node],\n            base_solution[worst_node+1:]\n        ])\n    else:\n        # If no improvement found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 183,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic path inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # If the inverted segment is better in at least one objective, apply the inversion\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n\n        # Calculate the new total cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # If the inversion improves both objectives, return immediately\n        if inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2:\n            return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8208832339259211,
            0.21133321523666382
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # If the inverted segment is better in at least one objective, apply the inversion\n    if inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n\n        # Calculate the new total cost\n        new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n        # If the inversion improves both objectives, return immediately\n        if inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2:\n            return new_solution\n\n    # If no improvement found, perform a random 2-opt move\n    i, j = sorted(random.sample(range(n), 2))\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 184,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct positions to perturb\n    a, b, c = random.sample(range(n), 3)\n\n    # Extract and reverse the segment between a and b\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Apply the reversal if it improves both objectives\n    if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n        new_solution[a:b+1] = reversed_segment\n\n    # Perform a swap between positions b and c\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n",
        "score": [
            -0.9311471355515529,
            0.20072942972183228
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select three distinct positions to perturb\n    a, b, c = random.sample(range(n), 3)\n\n    # Extract and reverse the segment between a and b\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Apply the reversal if it improves both objectives\n    if (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n        new_solution[a:b+1] = reversed_segment\n\n    # Perform a swap between positions b and c\n    new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if new_cost1 < cost1 or new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 185,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic segment relocation operator that prioritizes edges with high potential for cost reduction in both objectives while maintaining feasibility through a validation mechanism, and additionally incorporates a probabilistic segment reversal step to explore diverse neighborhood structures.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic segment reversal\n        if random.random() < 0.5:  # 50% chance to reverse the segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8979702894498098,
            0.6605896353721619
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic segment reversal\n        if random.random() < 0.5:  # 50% chance to reverse the segment\n            new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 186,
        "algorithm": "{This novel algorithm combines a multi-objective edge selection criterion with a dynamic path reversal operator that considers both objective spaces, prioritizing high-potential edges while ensuring feasibility through a validation mechanism and maintaining tour continuity through careful path reversal that preserves node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_reverse_start, best_reverse_end = -1, -1\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n\n        for j in range(i+1, min(i+5, n)):\n            if j >= a and j <= b:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < cost1 and new_cost2 < cost2) or (new_cost1 < best_cost1 and new_cost2 < best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_reverse_start, best_reverse_end = i, j\n\n    if best_reverse_start != -1:\n        new_solution[best_reverse_start:best_reverse_end+1] = new_solution[best_reverse_start:best_reverse_end+1][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7301852501292079,
            2.173919677734375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_reverse_start, best_reverse_end = -1, -1\n\n    for i in range(n):\n        if i >= a and i <= b:\n            continue\n\n        for j in range(i+1, min(i+5, n)):\n            if j >= a and j <= b:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            if (new_cost1 < cost1 and new_cost2 < cost2) or (new_cost1 < best_cost1 and new_cost2 < best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_reverse_start, best_reverse_end = i, j\n\n    if best_reverse_start != -1:\n        new_solution[best_reverse_start:best_reverse_end+1] = new_solution[best_reverse_start:best_reverse_end+1][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 187,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic node reinsertion operator, prioritizing nodes with high potential for cost reduction by considering both objective spaces while ensuring feasibility through a validation mechanism and using a dynamic reinsertion strategy that considers the current solution's structure.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.9383345662430385,
            0.8162587285041809
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    new_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, n-1)\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 188,
        "algorithm": "{This new algorithm uses a hybrid segment relocation and probabilistic edge swap strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction while maintaining feasibility through a dynamic validation step and combining it with a probabilistic edge swap to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9600132432785984,
            0.3831787109375
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 189,
        "algorithm": "{This algorithm employs a dynamic edge reversal strategy that evaluates node contributions across both objectives, prioritizing edges with high potential for cost reduction while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    best_score = -float('inf')\n    best_reversal = None\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j - i > 3:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            score = (current_cost1 - cost1) * 0.6 + (current_cost2 - cost2) * 0.4\n\n            if score > best_score:\n                best_score = score\n                best_reversal = (i, j)\n\n    if best_reversal is not None:\n        i, j = best_reversal\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7872740487526455,
            4.146661221981049
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    best_score = -float('inf')\n    best_reversal = None\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            if j - i > 3:\n                continue\n\n            temp_solution = new_solution.copy()\n            temp_solution[i:j] = temp_solution[i:j][::-1]\n\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            current_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            current_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            score = (current_cost1 - cost1) * 0.6 + (current_cost2 - cost2) * 0.4\n\n            if score > best_score:\n                best_score = score\n                best_reversal = (i, j)\n\n    if best_reversal is not None:\n        i, j = best_reversal\n        new_solution[i:j] = new_solution[i:j][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 190,
        "algorithm": "{This novel hybrid local search strategy combines multi-objective selection with a dynamic path reversal operator that selectively flips segments of the tour to improve both objectives, while using a dominance-aware validation mechanism to ensure feasibility and cost reduction.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    if reversed_cost1 < cost1 and reversed_cost2 < cost2:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9434852023959496,
            0.2004294991493225
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    if reversed_cost1 < cost1 and reversed_cost2 < cost2:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 191,
        "algorithm": "{A novel algorithm that combines a dynamic node reinsertion strategy with a multi-objective edge evaluation mechanism, prioritizing nodes with high potential for improving both objectives while using a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by dominance)\n    weights = []\n    for sol, (obj1, obj2) in archive:\n        dominated = sum(1 for _, (o1, o2) in archive if o1 <= obj1 and o2 <= obj2 and (o1 < obj1 or o2 < obj2))\n        weights.append(1 / (dominated + 1e-6))\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to reinsert\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the tour\n    temp_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate insertion points considering both objectives\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        candidate = np.insert(temp_solution, pos, node)\n\n        # Calculate the cost change in both objectives\n        prev_node = candidate[pos-1] if pos > 0 else candidate[-1]\n        next_node = candidate[(pos+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_prev = candidate[pos-1] if pos > 0 else candidate[-1]\n        new_next = candidate[(pos+1)%n]\n\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        # Score function: weighted sum of cost improvements\n        score = (old_cost1 - new_cost1) * 0.6 + (old_cost2 - new_cost2) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n    else:\n        # If no improvement found, perform a probabilistic edge flip\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to flip\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8007490589637682,
            0.6454609632492065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by dominance)\n    weights = []\n    for sol, (obj1, obj2) in archive:\n        dominated = sum(1 for _, (o1, o2) in archive if o1 <= obj1 and o2 <= obj2 and (o1 < obj1 or o2 < obj2))\n        weights.append(1 / (dominated + 1e-6))\n\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random node to reinsert\n    node_idx = random.randint(0, n-1)\n    node = new_solution[node_idx]\n\n    # Remove the node from the tour\n    temp_solution = np.delete(new_solution, node_idx)\n\n    # Evaluate insertion points considering both objectives\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        candidate = np.insert(temp_solution, pos, node)\n\n        # Calculate the cost change in both objectives\n        prev_node = candidate[pos-1] if pos > 0 else candidate[-1]\n        next_node = candidate[(pos+1)%n]\n\n        old_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n        old_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n        new_prev = candidate[pos-1] if pos > 0 else candidate[-1]\n        new_next = candidate[(pos+1)%n]\n\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        # Score function: weighted sum of cost improvements\n        score = (old_cost1 - new_cost1) * 0.6 + (old_cost2 - new_cost2) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n    else:\n        # If no improvement found, perform a probabilistic edge flip\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to flip\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 192,
        "algorithm": "{This new algorithm employs a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, with a modified score function that emphasizes balanced improvement across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9210297555907265,
            0.3698159456253052
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 193,
        "algorithm": "{This new algorithm employs a multi-objective edge swapping strategy that dynamically evaluates edge contributions across both objectives, prioritizing swaps that simultaneously improve both objectives while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    best_score = -float('inf')\n    best_swap = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if random.random() < 0.7:  # 70% chance to consider this swap\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                improvement1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                improvement2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                score = improvement1 * 0.6 + improvement2 * 0.4\n\n                if score > best_score:\n                    best_score = score\n                    best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6473389927983195,
            4.246821224689484
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    best_score = -float('inf')\n    best_swap = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if random.random() < 0.7:  # 70% chance to consider this swap\n                temp_solution = new_solution.copy()\n                temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n                cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n                cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n                improvement1 = distance_matrix_1[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_1[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n                improvement2 = distance_matrix_2[new_solution[(i-1)%n], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]] - distance_matrix_2[new_solution[(i-1)%n], new_solution[j]] - distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n                score = improvement1 * 0.6 + improvement2 * 0.4\n\n                if score > best_score:\n                    best_score = score\n                    best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 194,
        "algorithm": "{This new algorithm employs a dynamic multi-objective path inversion strategy that selectively inverts segments of the tour based on their edge contribution to both objectives, using a weighted scoring function to prioritize inversions that maximize cost reduction while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse objective sum)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    segment_length = random.randint(2, min(7, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate cost of the segment's connections to the rest of the tour\n    before_node = new_solution[a-1] if a > 0 else new_solution[-1]\n    after_node = new_solution[a+segment_length] if a+segment_length < n else new_solution[0]\n    external_cost1 = distance_matrix_1[before_node, segment[0]] + distance_matrix_1[segment[-1], after_node]\n    external_cost2 = distance_matrix_2[before_node, segment[0]] + distance_matrix_2[segment[-1], after_node]\n\n    # Score function: weighted sum of cost improvements\n    score = (segment_cost1 - external_cost1) * 0.6 + (segment_cost2 - external_cost2) * 0.4\n\n    # Decide whether to invert the segment based on the score\n    if score > 0 or random.random() < 0.2:  # Invert if positive score or with 20% probability\n        inverted_segment = segment[::-1]\n        new_solution[a:a+segment_length] = inverted_segment\n\n        # Verify the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n\n    # If inversion didn't work, perform a probabilistic edge swap\n    i, j = random.sample(range(n), 2)\n    if random.random() < 0.4:  # 40% chance to swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9670314844158557,
            0.21275770664215088
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse objective sum)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    segment_length = random.randint(2, min(7, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate cost of the segment's connections to the rest of the tour\n    before_node = new_solution[a-1] if a > 0 else new_solution[-1]\n    after_node = new_solution[a+segment_length] if a+segment_length < n else new_solution[0]\n    external_cost1 = distance_matrix_1[before_node, segment[0]] + distance_matrix_1[segment[-1], after_node]\n    external_cost2 = distance_matrix_2[before_node, segment[0]] + distance_matrix_2[segment[-1], after_node]\n\n    # Score function: weighted sum of cost improvements\n    score = (segment_cost1 - external_cost1) * 0.6 + (segment_cost2 - external_cost2) * 0.4\n\n    # Decide whether to invert the segment based on the score\n    if score > 0 or random.random() < 0.2:  # Invert if positive score or with 20% probability\n        inverted_segment = segment[::-1]\n        new_solution[a:a+segment_length] = inverted_segment\n\n        # Verify the solution remains valid (no duplicates)\n        if len(np.unique(new_solution)) == n:\n            return new_solution\n\n    # If inversion didn't work, perform a probabilistic edge swap\n    i, j = random.sample(range(n), 2)\n    if random.random() < 0.4:  # 40% chance to swap\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 195,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism by using a segment reversal and edge exchange approach with dynamic selection criteria.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment in both objectives\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best edge to exchange with another edge in the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_exchange = None\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Try exchanging edges (i, i+1) and (j, j+1)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Check if this is better in both objectives\n            if new_cost1 < cost1 and new_cost2 < cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_exchange = (i, j)\n                break\n\n    if best_exchange is not None:\n        # Apply the best exchange\n        i, j = best_exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no better exchange found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8886847628927382,
            3.772888422012329
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two segments to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the reversed segment in both objectives\n    cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best edge to exchange with another edge in the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_exchange = None\n\n    for i in range(n):\n        for j in range(i + 2, n):\n            # Try exchanging edges (i, i+1) and (j, j+1)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n            # Calculate the new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Check if this is better in both objectives\n            if new_cost1 < cost1 and new_cost2 < cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_exchange = (i, j)\n                break\n\n    if best_exchange is not None:\n        # Apply the best exchange\n        i, j = best_exchange\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n    else:\n        # If no better exchange found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 196,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 or new_cost2 < cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.889308789258402,
            0.4668406844139099
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 or new_cost2 < cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 197,
        "algorithm": "{This new algorithm employs a dynamic segment inversion strategy that combines multi-objective edge evaluation with a probabilistic segment reversal operator to explore diverse neighborhoods while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse objective sum)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it with probability based on edge quality\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, min(a + 5, n - 1))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate potential cost if segment is inverted\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n\n    # Probabilistically accept inversion based on cost improvement\n    improvement1 = segment_cost1 - inverted_cost1\n    improvement2 = segment_cost2 - inverted_cost2\n    acceptance_prob = min(1.0, max(0.1, (improvement1 + improvement2) / (segment_cost1 + segment_cost2 + 1e-6)))\n\n    if random.random() < acceptance_prob:\n        new_solution[a:b+1] = segment[::-1]  # Invert the segment\n    else:\n        # If inversion not accepted, perform a random segment shift\n        shift = random.randint(1, min(3, n - len(segment)))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], new_solution[a:b+1]])\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8100639605301727,
            0.05544877052307129
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse objective sum)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it with probability based on edge quality\n    a = random.randint(0, n - 2)\n    b = random.randint(a + 1, min(a + 5, n - 1))\n    segment = new_solution[a:b+1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate potential cost if segment is inverted\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n\n    # Probabilistically accept inversion based on cost improvement\n    improvement1 = segment_cost1 - inverted_cost1\n    improvement2 = segment_cost2 - inverted_cost2\n    acceptance_prob = min(1.0, max(0.1, (improvement1 + improvement2) / (segment_cost1 + segment_cost2 + 1e-6)))\n\n    if random.random() < acceptance_prob:\n        new_solution[a:b+1] = segment[::-1]  # Invert the segment\n    else:\n        # If inversion not accepted, perform a random segment shift\n        shift = random.randint(1, min(3, n - len(segment)))\n        new_solution = np.concatenate([new_solution[:a], new_solution[b+1:], new_solution[a:b+1]])\n        insert_pos = random.randint(0, n - len(segment))\n        new_solution = np.concatenate([new_solution[:insert_pos], segment, new_solution[insert_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 198,
        "algorithm": "{This algorithm uses a multi-objective edge selection criterion to prioritize edges with high potential for cost reduction in both objective spaces, combining a dynamic segment relocation strategy with a feasibility-preserving validation mechanism to generate high-quality neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective values\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate the current objective values\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Select two random edges to consider for exchange\n    i, j = random.sample(range(n), 2)\n\n    # Get the nodes involved in the edges\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate the cost of the edges in both objectives\n    cost1_ab = distance_matrix_1[a, b]\n    cost1_cd = distance_matrix_1[c, d]\n    cost2_ab = distance_matrix_2[a, b]\n    cost2_cd = distance_matrix_2[c, d]\n\n    # Calculate the cost of the alternative edges\n    cost1_ac = distance_matrix_1[a, c]\n    cost1_bd = distance_matrix_1[b, d]\n    cost2_ac = distance_matrix_2[a, c]\n    cost2_bd = distance_matrix_2[b, d]\n\n    # Calculate the total cost difference\n    delta_cost1 = (cost1_ac + cost1_bd) - (cost1_ab + cost1_cd)\n    delta_cost2 = (cost2_ac + cost2_bd) - (cost2_ab + cost2_cd)\n\n    # Apply the exchange if it improves both objectives\n    if delta_cost1 < 0 and delta_cost2 < 0:\n        # Perform the edge exchange\n        new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n    else:\n        # If no improvement, perform a random 2-opt move\n        a, b = random.randint(0, n-1), random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.972043614367642,
            0.21198028326034546
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement based on objective values\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate the current objective values\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Select two random edges to consider for exchange\n    i, j = random.sample(range(n), 2)\n\n    # Get the nodes involved in the edges\n    a, b = new_solution[i], new_solution[(i+1)%n]\n    c, d = new_solution[j], new_solution[(j+1)%n]\n\n    # Calculate the cost of the edges in both objectives\n    cost1_ab = distance_matrix_1[a, b]\n    cost1_cd = distance_matrix_1[c, d]\n    cost2_ab = distance_matrix_2[a, b]\n    cost2_cd = distance_matrix_2[c, d]\n\n    # Calculate the cost of the alternative edges\n    cost1_ac = distance_matrix_1[a, c]\n    cost1_bd = distance_matrix_1[b, d]\n    cost2_ac = distance_matrix_2[a, c]\n    cost2_bd = distance_matrix_2[b, d]\n\n    # Calculate the total cost difference\n    delta_cost1 = (cost1_ac + cost1_bd) - (cost1_ab + cost1_cd)\n    delta_cost2 = (cost2_ac + cost2_bd) - (cost2_ab + cost2_cd)\n\n    # Apply the exchange if it improves both objectives\n    if delta_cost1 < 0 and delta_cost2 < 0:\n        # Perform the edge exchange\n        new_solution[(i+1)%n], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[(i+1)%n]\n    else:\n        # If no improvement, perform a random 2-opt move\n        a, b = random.randint(0, n-1), random.randint(0, n-1)\n        if a > b:\n            a, b = b, a\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 199,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic path reversal operator that identifies and reverses high-cost segments in both objective spaces, prioritizing improvements in both objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify the worst segment in both objectives\n    worst_segment = None\n    worst_cost1 = 0\n    worst_cost2 = 0\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            segment = new_solution[i:j+1]\n            cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n            if cost1 > worst_cost1 and cost2 > worst_cost2:\n                worst_cost1 = cost1\n                worst_cost2 = cost2\n                worst_segment = (i, j)\n\n    if worst_segment:\n        i, j = worst_segment\n        # Reverse the worst segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the reversal improves both objectives\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if new_cost1 >= best_cost1 or new_cost2 >= best_cost2:\n            # Revert if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n    else:\n        # If no improvement found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7180385689967963,
            2.892595589160919
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    n = len(new_solution)\n    best_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    best_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify the worst segment in both objectives\n    worst_segment = None\n    worst_cost1 = 0\n    worst_cost2 = 0\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            segment = new_solution[i:j+1]\n            cost1 = sum(distance_matrix_1[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n            cost2 = sum(distance_matrix_2[segment[k], segment[(k+1)%len(segment)]] for k in range(len(segment)))\n\n            if cost1 > worst_cost1 and cost2 > worst_cost2:\n                worst_cost1 = cost1\n                worst_cost2 = cost2\n                worst_segment = (i, j)\n\n    if worst_segment:\n        i, j = worst_segment\n        # Reverse the worst segment\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n        # Check if the reversal improves both objectives\n        new_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if new_cost1 >= best_cost1 or new_cost2 >= best_cost2:\n            # Revert if no improvement\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        else:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n    else:\n        # If no improvement found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 200,
        "algorithm": "{This algorithm uses a Pareto-optimal segment insertion strategy that dynamically selects and reinserts segments based on their Pareto dominance in both objective spaces, combined with a probabilistic edge reversal operation to escape local optima while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_positions = []\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check Pareto dominance\n        dominates = True\n        for sol, obj in archive:\n            if (obj[0] <= cost1 and obj[1] <= cost2) and (obj[0] < cost1 or obj[1] < cost2):\n                dominates = False\n                break\n\n        if dominates:\n            best_positions.append(pos)\n\n    if best_positions:\n        best_pos = random.choice(best_positions)\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no Pareto improvement, perform a probabilistic edge reversal\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(1, n // 2)) % n\n        if random.random() < 0.4:  # 40% chance to reverse\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7225909158658665,
            0.53895103931427
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_positions = []\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check Pareto dominance\n        dominates = True\n        for sol, obj in archive:\n            if (obj[0] <= cost1 and obj[1] <= cost2) and (obj[0] < cost1 or obj[1] < cost2):\n                dominates = False\n                break\n\n        if dominates:\n            best_positions.append(pos)\n\n    if best_positions:\n        best_pos = random.choice(best_positions)\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no Pareto improvement, perform a probabilistic edge reversal\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(1, n // 2)) % n\n        if random.random() < 0.4:  # 40% chance to reverse\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 201,
        "algorithm": "{This new algorithm uses a hybrid edge-swap and segment-reversal strategy that dynamically evaluates edge contributions in both objectives, prioritizing segments with high potential for cost reduction while maintaining feasibility through a probabilistic acceptance criterion based on objective improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with segment reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap and reverse\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if random.random() < 0.5:  # 50% chance to reverse segment between i and j\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9770571392859486,
            0.3953678607940674
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with segment reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap and reverse\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            if random.random() < 0.5:  # 50% chance to reverse segment between i and j\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 202,
        "algorithm": "{This new algorithm uses a multi-objective adaptive segment inversion strategy that dynamically selects and inverts segments of varying lengths while considering both objectives, with a probabilistic acceptance criterion to balance exploration and exploitation of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and invert it\n    segment_length = random.randint(2, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate new segment cost in both objectives\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate total cost change\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate potential new total cost\n    potential_cost1 = total_cost1 - original_cost1 + new_cost1\n    potential_cost2 = total_cost2 - original_cost2 + new_cost2\n\n    # Acceptance criterion: accept if either objective improves or with small probability\n    accept_prob = 0.1 if (potential_cost1 < total_cost1 or potential_cost2 < total_cost2) else 0.05\n\n    if random.random() < accept_prob:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional probabilistic edge flip for diversity\n    if random.random() < 0.2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8126433649004183,
            0.5799265503883362
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and invert it\n    segment_length = random.randint(2, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate new segment cost in both objectives\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate total cost change\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate potential new total cost\n    potential_cost1 = total_cost1 - original_cost1 + new_cost1\n    potential_cost2 = total_cost2 - original_cost2 + new_cost2\n\n    # Acceptance criterion: accept if either objective improves or with small probability\n    accept_prob = 0.1 if (potential_cost1 < total_cost1 or potential_cost2 < total_cost2) else 0.05\n\n    if random.random() < accept_prob:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional probabilistic edge flip for diversity\n    if random.random() < 0.2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 203,
        "algorithm": "{This new algorithm employs a dynamic edge reversal strategy that evaluates segment contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, using a different parameterization of the score function to balance objective improvements differently.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * 0.5 + obj[1] * 0.5 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(2, min(4, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment[::-1], new_solution[pos:]])\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.4 + (segment_cost2 - (cost2 - segment_cost2)) * 0.6\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment[::-1], new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9124112636829081,
            0.43403124809265137
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * 0.5 + obj[1] * 0.5 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(2, min(4, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment[::-1], new_solution[pos:]])\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.4 + (segment_cost2 - (cost2 - segment_cost2)) * 0.6\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment[::-1], new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 204,
        "algorithm": "{This new algorithm combines a dynamic sub-tour inversion strategy with a multi-objective edge evaluation mechanism, where it selectively inverts segments of the tour based on their potential to improve both objectives while using a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate original connection costs\n    before_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] if a > 0 else 0\n    after_cost1 = distance_matrix_1[segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n    before_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] if a > 0 else 0\n    after_cost2 = distance_matrix_2[segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate new segment cost in both objectives\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate new connection costs\n    new_before_cost1 = distance_matrix_1[new_solution[a-1], inverted_segment[0]] if a > 0 else 0\n    new_after_cost1 = distance_matrix_1[inverted_segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n    new_before_cost2 = distance_matrix_2[new_solution[a-1], inverted_segment[0]] if a > 0 else 0\n    new_after_cost2 = distance_matrix_2[inverted_segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n\n    # Calculate total cost changes\n    delta_cost1 = new_cost1 - original_cost1 + (new_before_cost1 - before_cost1) + (new_after_cost1 - after_cost1)\n    delta_cost2 = new_cost2 - original_cost2 + (new_before_cost2 - before_cost2) + (new_after_cost2 - after_cost2)\n\n    # Probabilistic acceptance based on cost improvements\n    if (delta_cost1 < 0 and delta_cost2 < 0) or (random.random() < 0.3 and (delta_cost1 < 0 or delta_cost2 < 0)):\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional edge swap for further improvement\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.832095823257763,
            0.7619003057479858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate original connection costs\n    before_cost1 = distance_matrix_1[new_solution[a-1], segment[0]] if a > 0 else 0\n    after_cost1 = distance_matrix_1[segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n    before_cost2 = distance_matrix_2[new_solution[a-1], segment[0]] if a > 0 else 0\n    after_cost2 = distance_matrix_2[segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate new segment cost in both objectives\n    new_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    new_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate new connection costs\n    new_before_cost1 = distance_matrix_1[new_solution[a-1], inverted_segment[0]] if a > 0 else 0\n    new_after_cost1 = distance_matrix_1[inverted_segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n    new_before_cost2 = distance_matrix_2[new_solution[a-1], inverted_segment[0]] if a > 0 else 0\n    new_after_cost2 = distance_matrix_2[inverted_segment[-1], new_solution[a+segment_length]] if a+segment_length < n else 0\n\n    # Calculate total cost changes\n    delta_cost1 = new_cost1 - original_cost1 + (new_before_cost1 - before_cost1) + (new_after_cost1 - after_cost1)\n    delta_cost2 = new_cost2 - original_cost2 + (new_before_cost2 - before_cost2) + (new_after_cost2 - after_cost2)\n\n    # Probabilistic acceptance based on cost improvements\n    if (delta_cost1 < 0 and delta_cost2 < 0) or (random.random() < 0.3 and (delta_cost1 < 0 or delta_cost2 < 0)):\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional edge swap for further improvement\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 205,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.828747274163031,
            0.49393075704574585
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 206,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node relocation operator that prioritizes nodes with high potential for cost reduction in both objective spaces, while maintaining feasibility through a validation mechanism and considering the trade-off between objectives through a weighted cost function.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's edges\n    prev_node = new_solution[(node_idx - 1) % n]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and its neighbors\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, node_idx)\n        temp_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate the new cost\n        new_prev = temp_solution[(pos - 1) % n]\n        new_next = temp_solution[(pos + 1) % n]\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        # Calculate the total cost change\n        delta_cost1 = new_cost1 - current_cost1\n        delta_cost2 = new_cost2 - current_cost2\n\n        # Use a weighted sum to balance both objectives (50/50 for simplicity)\n        weighted_cost = 0.5 * delta_cost1 + 0.5 * delta_cost2\n\n        if weighted_cost < 0:  # Improvement found\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9019507341094105,
            0.36589735746383667
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's edges\n    prev_node = new_solution[(node_idx - 1) % n]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and its neighbors\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, node_idx)\n        temp_solution = np.insert(temp_solution, pos, node)\n\n        # Calculate the new cost\n        new_prev = temp_solution[(pos - 1) % n]\n        new_next = temp_solution[(pos + 1) % n]\n        new_cost1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n        new_cost2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n        # Calculate the total cost change\n        delta_cost1 = new_cost1 - current_cost1\n        delta_cost2 = new_cost2 - current_cost2\n\n        # Use a weighted sum to balance both objectives (50/50 for simplicity)\n        weighted_cost = 0.5 * delta_cost1 + 0.5 * delta_cost2\n\n        if weighted_cost < 0:  # Improvement found\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.delete(new_solution, node_idx)\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 207,
        "algorithm": "{The new algorithm combines a multi-objective selection criterion with a novel edge reversal and rotation operator that dynamically adjusts the tour structure by reversing segments and rotating sub-tours, while prioritizing edges with high potential for cost reduction in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    if len(segment) > 1:\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            k = random.randint(1, len(segment)-1)\n            segment = np.concatenate([segment[k:], segment[:k]])\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (new_cost1 < best_cost1 and new_cost2 <= best_cost2) or (new_cost1 <= best_cost1 and new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8132994689935924,
            0.3230460286140442
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    if len(segment) > 1:\n        if random.random() < 0.5:\n            segment = segment[::-1]\n        else:\n            k = random.randint(1, len(segment)-1)\n            segment = np.concatenate([segment[k:], segment[:k]])\n\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        if (new_cost1 < best_cost1 and new_cost2 <= best_cost2) or (new_cost1 <= best_cost1 and new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 208,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select two distinct edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Perform edge swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9096098185129022,
            0.18899774551391602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n\n    # Randomly select two distinct edges to swap\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while j == i or j == (i + 1) % n:\n        j = random.randint(0, n - 1)\n\n    # Perform edge swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure the solution remains feasible\n    if not np.array_equal(np.unique(new_solution), np.arange(n)):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 209,
        "algorithm": "{This new algorithm employs a multi-objective segment inversion strategy that combines a dynamic edge evaluation mechanism with a probabilistic segment reversal operator, prioritizing inversions that show potential for cost reduction in both objective spaces while ensuring feasibility through a validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Invert the segment and calculate new cost\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the cost difference\n    delta_cost1 = inverted_cost1 - original_cost1\n    delta_cost2 = inverted_cost2 - original_cost2\n\n    # Probabilistically accept the inversion if it shows improvement in either objective\n    if (delta_cost1 < 0 or delta_cost2 < 0) or (random.random() < 0.2):  # 20% chance to accept even without improvement\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional local search: try to swap edges between adjacent segments\n    if random.random() < 0.5:  # 50% chance to perform this additional operation\n        pos = random.randint(0, n - 2)\n        i, j = new_solution[pos], new_solution[pos+1]\n        if distance_matrix_1[i, j] + distance_matrix_2[i, j] > distance_matrix_1[j, i] + distance_matrix_2[j, i]:\n            new_solution[pos], new_solution[pos+1] = new_solution[pos+1], new_solution[pos]\n\n    return new_solution\n\n",
        "score": [
            -0.8519409841981644,
            0.6288741230964661
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Invert the segment and calculate new cost\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the cost difference\n    delta_cost1 = inverted_cost1 - original_cost1\n    delta_cost2 = inverted_cost2 - original_cost2\n\n    # Probabilistically accept the inversion if it shows improvement in either objective\n    if (delta_cost1 < 0 or delta_cost2 < 0) or (random.random() < 0.2):  # 20% chance to accept even without improvement\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional local search: try to swap edges between adjacent segments\n    if random.random() < 0.5:  # 50% chance to perform this additional operation\n        pos = random.randint(0, n - 2)\n        i, j = new_solution[pos], new_solution[pos+1]\n        if distance_matrix_1[i, j] + distance_matrix_2[i, j] > distance_matrix_1[j, i] + distance_matrix_2[j, i]:\n            new_solution[pos], new_solution[pos+1] = new_solution[pos+1], new_solution[pos]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 210,
        "algorithm": "{This new algorithm uses a hybrid segment inversion and edge rebalancing strategy that dynamically selects segments based on their potential to improve both objectives, with a probabilistic validation step to ensure feasibility while incorporating a novel edge swapping mechanism that considers the combined impact of both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment to create a new configuration\n    inverted_segment = segment[::-1]\n\n    # Calculate segment cost in both objectives before and after inversion\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the change in total cost\n    delta_cost1 = inverted_cost1 - original_cost1\n    delta_cost2 = inverted_cost2 - original_cost2\n\n    # Probabilistically accept the inversion if it improves at least one objective\n    if (delta_cost1 < 0) or (delta_cost2 < 0) or (random.random() < 0.2):\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Perform edge rebalancing between two random edges\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the current and potential new costs for the edges\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    # Try swapping the edges\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[temp_solution[i], temp_solution[(j+1)%n]] + distance_matrix_2[temp_solution[j], temp_solution[(i+1)%n]]\n\n    # Calculate the combined cost improvement\n    delta_total = (new_cost1 - current_cost1) * 0.6 + (new_cost2 - current_cost2) * 0.4\n\n    # Accept the swap if it improves the combined cost or with a small probability\n    if (delta_total < 0) or (random.random() < 0.1):\n        new_solution = temp_solution\n\n    return new_solution\n\n",
        "score": [
            -0.9080737660130738,
            0.39899635314941406
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [(obj[0] * 0.6 + obj[1] * 0.4) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment to create a new configuration\n    inverted_segment = segment[::-1]\n\n    # Calculate segment cost in both objectives before and after inversion\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the change in total cost\n    delta_cost1 = inverted_cost1 - original_cost1\n    delta_cost2 = inverted_cost2 - original_cost2\n\n    # Probabilistically accept the inversion if it improves at least one objective\n    if (delta_cost1 < 0) or (delta_cost2 < 0) or (random.random() < 0.2):\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Perform edge rebalancing between two random edges\n    i, j = random.sample(range(n), 2)\n    if i > j:\n        i, j = j, i\n\n    # Calculate the current and potential new costs for the edges\n    current_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n\n    # Try swapping the edges\n    temp_solution = new_solution.copy()\n    temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n    new_cost1 = distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] + distance_matrix_1[temp_solution[j], temp_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[temp_solution[i], temp_solution[(j+1)%n]] + distance_matrix_2[temp_solution[j], temp_solution[(i+1)%n]]\n\n    # Calculate the combined cost improvement\n    delta_total = (new_cost1 - current_cost1) * 0.6 + (new_cost2 - current_cost2) * 0.4\n\n    # Accept the swap if it improves the combined cost or with a small probability\n    if (delta_total < 0) or (random.random() < 0.1):\n        new_solution = temp_solution\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 211,
        "algorithm": "{This novel algorithm employs a multi-objective edge selection strategy that dynamically evaluates and replaces edges based on their potential to improve both objectives, using a weighted combination of cost improvements with a probabilistic acceptance criterion to balance exploration and exploitation while maintaining feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Calculate current total costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a set of edges to evaluate\n    num_edges_to_evaluate = min(5, n // 2)\n    edges_to_evaluate = random.sample(range(n), num_edges_to_evaluate)\n\n    best_improvement = 0\n    best_edge = None\n    best_replacement = None\n\n    for edge in edges_to_evaluate:\n        i = edge\n        j = (edge + 1) % n\n\n        # Try replacing this edge with a random other edge\n        replacement = random.randint(0, n - 1)\n        if replacement == i or replacement == j or (replacement + 1) % n == i or (replacement + 1) % n == j:\n            continue\n\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[replacement], temp_solution[(replacement + 1) % n]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Calculate improvement score (weighted combination of both objectives)\n        improvement = (current_cost1 - new_cost1) * 0.6 + (current_cost2 - new_cost2) * 0.4\n\n        # Accept with probability based on improvement\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_edge = edge\n            best_replacement = replacement\n\n    if best_edge is not None:\n        # Apply the best improvement found\n        new_solution[best_edge], new_solution[(best_edge + 1) % n] = new_solution[best_replacement], new_solution[(best_replacement + 1) % n]\n    else:\n        # If no improvement found, perform a random 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6678404329840645,
            0.19615256786346436
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Calculate current total costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a set of edges to evaluate\n    num_edges_to_evaluate = min(5, n // 2)\n    edges_to_evaluate = random.sample(range(n), num_edges_to_evaluate)\n\n    best_improvement = 0\n    best_edge = None\n    best_replacement = None\n\n    for edge in edges_to_evaluate:\n        i = edge\n        j = (edge + 1) % n\n\n        # Try replacing this edge with a random other edge\n        replacement = random.randint(0, n - 1)\n        if replacement == i or replacement == j or (replacement + 1) % n == i or (replacement + 1) % n == j:\n            continue\n\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[replacement], temp_solution[(replacement + 1) % n]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Calculate improvement score (weighted combination of both objectives)\n        improvement = (current_cost1 - new_cost1) * 0.6 + (current_cost2 - new_cost2) * 0.4\n\n        # Accept with probability based on improvement\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_edge = edge\n            best_replacement = replacement\n\n    if best_edge is not None:\n        # Apply the best improvement found\n        new_solution[best_edge], new_solution[(best_edge + 1) % n] = new_solution[best_replacement], new_solution[(best_replacement + 1) % n]\n    else:\n        # If no improvement found, perform a random 2-opt move\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 212,
        "algorithm": "{This new algorithm uses a dynamic edge reversal strategy that evaluates edge contributions across both objectives, prioritizing edges with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, with a modified scoring function that emphasizes balanced improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    best_score = -float('inf')\n    best_reversal = None\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            improvement1 = original_cost1 - cost1\n            improvement2 = original_cost2 - cost2\n\n            score = (improvement1 * 0.4 + improvement2 * 0.6) * (1 + 0.1 * (improvement1 + improvement2))\n\n            if score > best_score:\n                best_score = score\n                best_reversal = (i, j)\n\n    if best_reversal is not None:\n        i, j = best_reversal\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.4801804714300716,
            6.0162259340286255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    best_score = -float('inf')\n    best_reversal = None\n\n    for i in range(n):\n        for j in range(i+1, min(i+5, n)):\n            temp_solution = new_solution.copy()\n            temp_solution[i:j+1] = temp_solution[i:j+1][::-1]\n\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n            original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n            improvement1 = original_cost1 - cost1\n            improvement2 = original_cost2 - cost2\n\n            score = (improvement1 * 0.4 + improvement2 * 0.6) * (1 + 0.1 * (improvement1 + improvement2))\n\n            if score > best_score:\n                best_score = score\n                best_reversal = (i, j)\n\n    if best_reversal is not None:\n        i, j = best_reversal\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 213,
        "algorithm": "{This new algorithm uses a hybrid approach that combines a probabilistic segment inversion with a multi-objective edge evaluation, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a dynamic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment with probability based on its potential\n    if random.random() < 0.5:  # 50% chance to invert\n        segment = segment[::-1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9200614505572171,
            0.36474287509918213
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment with probability based on its potential\n    if random.random() < 0.5:  # 50% chance to invert\n        segment = segment[::-1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 214,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.961733874130713,
            0.5165420174598694
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 215,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9186846303486711,
            0.4923001527786255
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 216,
        "algorithm": "{This new algorithm uses a hybrid segment relocation and edge reversal strategy that evaluates segment contributions across both objectives with a dynamic weighting scheme, prioritizing segments with high potential for cost reduction while probabilistically validating feasibility through a multi-criteria acceptance threshold.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Dynamic weighting based on segment length\n    weight1 = 0.6 if segment_length <= 3 else 0.4\n    weight2 = 1 - weight1\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: dynamic weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge reversal\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if random.random() < 0.4:  # 40% chance to reverse\n            new_solution = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8822323103953211,
            0.3835403323173523
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Dynamic weighting based on segment length\n    weight1 = 0.6 if segment_length <= 3 else 0.4\n    weight2 = 1 - weight1\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: dynamic weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge reversal\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        if random.random() < 0.4:  # 40% chance to reverse\n            new_solution = np.concatenate([new_solution[:i], new_solution[i:j][::-1], new_solution[j:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 217,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8052507399766645,
            0.5090634226799011
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 218,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective edge prioritization mechanism with a dynamic segment inversion operator to explore high-potential regions of the solution space while maintaining feasibility through a probabilistic validation framework.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points with dynamic inversion\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_inversion = False\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment normally\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inversion = False\n\n        # Try inserting the inverted segment\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inversion = True\n\n    if best_insert_pos != -1:\n        if best_inversion:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a random 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9153574056255476,
            0.6750250458717346
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points with dynamic inversion\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_inversion = False\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment normally\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inversion = False\n\n        # Try inserting the inverted segment\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inversion = True\n\n    if best_insert_pos != -1:\n        if best_inversion:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a random 3-opt operation\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j] = new_solution[i:j][::-1]\n        new_solution[j:k] = new_solution[j:k][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 219,
        "algorithm": "{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, with a modified score function that emphasizes balanced improvement across objectives and includes a dynamic weighting mechanism based on the relative costs.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate total costs for normalization\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Dynamic weighting based on relative costs\n    weight1 = 0.5 if total_cost1 == 0 else (total_cost1 / (total_cost1 + total_cost2)) ** 0.5\n    weight2 = 1 - weight1\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Modified score function with dynamic weights and balanced improvement\n        improvement1 = (segment_cost1 - (cost1 - segment_cost1)) / (total_cost1 + 1e-6)\n        improvement2 = (segment_cost2 - (cost2 - segment_cost2)) / (total_cost2 + 1e-6)\n        score = weight1 * improvement1 + weight2 * improvement2 - 0.2 * abs(improvement1 - improvement2)\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with dynamic probability\n        i, j = random.sample(range(n), 2)\n        swap_prob = 0.5 * (1 - min(total_cost1, total_cost2) / (max(total_cost1, total_cost2) + 1e-6))\n        if random.random() < swap_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9189286099225499,
            0.4218124747276306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate total costs for normalization\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Dynamic weighting based on relative costs\n    weight1 = 0.5 if total_cost1 == 0 else (total_cost1 / (total_cost1 + total_cost2)) ** 0.5\n    weight2 = 1 - weight1\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Modified score function with dynamic weights and balanced improvement\n        improvement1 = (segment_cost1 - (cost1 - segment_cost1)) / (total_cost1 + 1e-6)\n        improvement2 = (segment_cost2 - (cost2 - segment_cost2)) / (total_cost2 + 1e-6)\n        score = weight1 * improvement1 + weight2 * improvement2 - 0.2 * abs(improvement1 - improvement2)\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with dynamic probability\n        i, j = random.sample(range(n), 2)\n        swap_prob = 0.5 * (1 - min(total_cost1, total_cost2) / (max(total_cost1, total_cost2) + 1e-6))\n        if random.random() < swap_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 220,
        "algorithm": "{This novel algorithm employs a dynamic multi-segment inversion strategy that adaptively selects and inverts multiple non-overlapping segments of varying lengths, then evaluates their combined impact on both objectives using a Pareto-dominance-based scoring mechanism to ensure balanced improvement across both spaces while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple non-overlapping segments for inversion\n    num_segments = random.randint(1, min(3, n // 5))\n    segment_lengths = sorted(random.sample(range(2, min(5, n // 3)), num_segments))\n    segments = []\n    positions = []\n\n    current_pos = 0\n    for length in segment_lengths:\n        if current_pos + length > n:\n            break\n        start = random.randint(current_pos, n - length)\n        segments.append(new_solution[start:start+length])\n        positions.append(start)\n        current_pos = start + length\n\n    if not segments:\n        # Fallback to single segment if no valid segments found\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segments = [new_solution[start:start+segment_length]]\n        positions = [start]\n\n    # Create a temporary solution with inverted segments\n    temp_solution = new_solution.copy()\n    for seg, pos in zip(segments, positions):\n        temp_solution[pos:pos+len(seg)] = seg[::-1]\n\n    # Calculate original and new costs\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Check if the new solution dominates the original in either objective\n    if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different inversion pattern\n        for seg, pos in zip(segments, positions):\n            if len(seg) > 2:\n                # Try a partial inversion\n                split = random.randint(1, len(seg)-1)\n                new_solution[pos:pos+len(seg)] = np.concatenate([seg[:split][::-1], seg[split:]])\n\n    return new_solution\n\n",
        "score": [
            -0.8507608935313263,
            0.5509148836135864
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple non-overlapping segments for inversion\n    num_segments = random.randint(1, min(3, n // 5))\n    segment_lengths = sorted(random.sample(range(2, min(5, n // 3)), num_segments))\n    segments = []\n    positions = []\n\n    current_pos = 0\n    for length in segment_lengths:\n        if current_pos + length > n:\n            break\n        start = random.randint(current_pos, n - length)\n        segments.append(new_solution[start:start+length])\n        positions.append(start)\n        current_pos = start + length\n\n    if not segments:\n        # Fallback to single segment if no valid segments found\n        segment_length = random.randint(2, min(5, n // 2))\n        start = random.randint(0, n - segment_length)\n        segments = [new_solution[start:start+segment_length]]\n        positions = [start]\n\n    # Create a temporary solution with inverted segments\n    temp_solution = new_solution.copy()\n    for seg, pos in zip(segments, positions):\n        temp_solution[pos:pos+len(seg)] = seg[::-1]\n\n    # Calculate original and new costs\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Check if the new solution dominates the original in either objective\n    if (new_cost1 <= original_cost1 and new_cost2 < original_cost2) or (new_cost1 < original_cost1 and new_cost2 <= original_cost2):\n        new_solution = temp_solution\n    else:\n        # If no improvement, try a different inversion pattern\n        for seg, pos in zip(segments, positions):\n            if len(seg) > 2:\n                # Try a partial inversion\n                split = random.randint(1, len(seg)-1)\n                new_solution[pos:pos+len(seg)] = np.concatenate([seg[:split][::-1], seg[split:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 221,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random segments of the tour\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Extract the segments\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Swap the segments if it improves both objectives\n    if (cost1_seg1 + cost1_seg2) > (sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2))) +\n                                     sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))):\n        new_solution[a1:a2+1] = segment2\n        new_solution[b1:b2+1] = segment1\n\n    # Verify the solution is still a valid tour\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8027997829224152,
            2.488035798072815
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random segments of the tour\n    a1, a2 = sorted(random.sample(range(n), 2))\n    b1, b2 = sorted(random.sample(range(n), 2))\n\n    # Extract the segments\n    segment1 = new_solution[a1:a2+1]\n    segment2 = new_solution[b1:b2+1]\n\n    # Calculate the cost of the segments in both objectives\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2)))\n\n    # Swap the segments if it improves both objectives\n    if (cost1_seg1 + cost1_seg2) > (sum(distance_matrix_1[segment2[i], segment2[(i+1)%len(segment2)]] for i in range(len(segment2))) +\n                                     sum(distance_matrix_1[segment1[i], segment1[(i+1)%len(segment1)]] for i in range(len(segment1)))):\n        new_solution[a1:a2+1] = segment2\n        new_solution[b1:b2+1] = segment1\n\n    # Verify the solution is still a valid tour\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 222,
        "algorithm": "{This new algorithm employs a dynamic sub-sequence inversion strategy that evaluates edge contributions across both objectives, prioritizing inversions of high-potential segments while maintaining feasibility through a probabilistic validation step, and incorporates a multi-objective cost improvement criterion that balances improvements in both spaces.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential inversion of the segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate potential improvement\n    improvement1 = segment_cost1 - inverted_cost1\n    improvement2 = segment_cost2 - inverted_cost2\n\n    # Apply inversion if it improves at least one objective\n    if improvement1 > 0 or improvement2 > 0:\n        new_solution[a:a+segment_length] = inverted_segment\n\n        # Check if the inversion improves both objectives\n        if improvement1 > 0 and improvement2 > 0:\n            # If both improved, apply with higher probability\n            if random.random() < 0.7:\n                return new_solution\n\n        # If only one improved, apply with lower probability\n        if random.random() < 0.4:\n            return new_solution\n\n    # If inversion didn't help, perform a probabilistic edge swap\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7655686402964483,
            0.3204137086868286
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential inversion of the segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate potential improvement\n    improvement1 = segment_cost1 - inverted_cost1\n    improvement2 = segment_cost2 - inverted_cost2\n\n    # Apply inversion if it improves at least one objective\n    if improvement1 > 0 or improvement2 > 0:\n        new_solution[a:a+segment_length] = inverted_segment\n\n        # Check if the inversion improves both objectives\n        if improvement1 > 0 and improvement2 > 0:\n            # If both improved, apply with higher probability\n            if random.random() < 0.7:\n                return new_solution\n\n        # If only one improved, apply with lower probability\n        if random.random() < 0.4:\n            return new_solution\n\n    # If inversion didn't help, perform a probabilistic edge swap\n    if random.random() < 0.5:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 223,
        "algorithm": "{This new algorithm employs a dynamic edge filtering and adaptive segment inversion strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction while maintaining feasibility through a probabilistic validation step and adaptive segment inversion to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points with segment inversion\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_inverted = False\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inverted = False\n\n        # Try inverted segment\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n        # Calculate cost change for inverted segment\n        cost1_inv = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2_inv = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score_inv = (segment_cost1 - (cost1_inv - segment_cost1)) * 0.7 + (segment_cost2 - (cost2_inv - segment_cost2)) * 0.3\n\n        if score_inv > best_score:\n            best_score = score_inv\n            best_insert_pos = pos\n            best_inverted = True\n\n    if best_insert_pos != -1:\n        if best_inverted:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with adaptive probability\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9669931673968821,
            0.7371736764907837
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points with segment inversion\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_inverted = False\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inverted = False\n\n        # Try inverted segment\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n        # Calculate cost change for inverted segment\n        cost1_inv = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2_inv = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score_inv = (segment_cost1 - (cost1_inv - segment_cost1)) * 0.7 + (segment_cost2 - (cost2_inv - segment_cost2)) * 0.3\n\n        if score_inv > best_score:\n            best_score = score_inv\n            best_insert_pos = pos\n            best_inverted = True\n\n    if best_insert_pos != -1:\n        if best_inverted:\n            segment = segment[::-1]\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with adaptive probability\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 224,
        "algorithm": "{A novel adaptive multi-objective local search strategy that dynamically combines a probabilistic edge selection mechanism with a two-phase optimization process, first prioritizing high-potential edge exchanges in either objective space and then validating the move through a Pareto dominance check before committing to the change while maintaining tour feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Phase 1: Probabilistic edge selection\n    edge_scores = []\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate potential improvement for both objectives\n            old_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n            # Calculate improvement scores\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            # Combine improvements with different weights\n            combined_score = 0.6 * improvement1 + 0.4 * improvement2\n            edge_scores.append((combined_score, (i, j)))\n\n    if not edge_scores:\n        # If no edges found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select top 10% edges with highest scores\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n    top_edges = edge_scores[:max(1, len(edge_scores) // 10)]\n\n    # Phase 2: Pareto validation\n    for score, (i, j) in top_edges:\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Check Pareto dominance\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n           (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n",
        "score": [
            -0.5620530853790388,
            4.919195890426636
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(base_solution)\n\n    # Phase 1: Probabilistic edge selection\n    edge_scores = []\n    for i in range(n):\n        for j in range(i+1, n):\n            # Calculate potential improvement for both objectives\n            old_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n            # Calculate improvement scores\n            improvement1 = old_cost1 - new_cost1\n            improvement2 = old_cost2 - new_cost2\n\n            # Combine improvements with different weights\n            combined_score = 0.6 * improvement1 + 0.4 * improvement2\n            edge_scores.append((combined_score, (i, j)))\n\n    if not edge_scores:\n        # If no edges found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select top 10% edges with highest scores\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n    top_edges = edge_scores[:max(1, len(edge_scores) // 10)]\n\n    # Phase 2: Pareto validation\n    for score, (i, j) in top_edges:\n        # Create temporary solution\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[j] = temp_solution[j], temp_solution[i]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n        # Check Pareto dominance\n        original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n))\n\n        if (new_cost1 < original_cost1 and new_cost2 <= original_cost2) or \\\n           (new_cost1 <= original_cost1 and new_cost2 < original_cost2):\n            new_solution = temp_solution\n            break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 225,
        "algorithm": "{This new algorithm uses a multi-objective edge replacement strategy that evaluates edge contributions across both objectives, prioritizing edges with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, combined with a dynamic segment reversal to explore alternative tour configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with segment reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap and reverse segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9975602549149514,
            0.3695623278617859
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with segment reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap and reverse segment\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 226,
        "algorithm": "{This new algorithm employs a multi-objective edge reinforcement strategy that identifies critical edges in both objective spaces and probabilistically reinforces them while maintaining tour feasibility through a constraint-aware perturbation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    selected_idx = max(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges in both objectives\n    edge_scores = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_scores[i, j] = (distance_matrix_1[i, j] + distance_matrix_2[i, j]) / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    # Reinforce top 20% edges with probability\n    threshold = np.percentile(edge_scores, 80)\n    for i in range(n):\n        for j in range(n):\n            if edge_scores[i, j] >= threshold and random.random() < 0.4:\n                # Find positions of i and j in the tour\n                pos_i = np.where(new_solution == i)[0][0]\n                pos_j = np.where(new_solution == j)[0][0]\n\n                # Swap nodes if they are not adjacent\n                if abs(pos_i - pos_j) > 1:\n                    new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n\n    # Apply constraint-aware perturbation\n    if random.random() < 0.3:\n        # Select a random segment and reverse it\n        segment_start = random.randint(0, n - 3)\n        segment_end = random.randint(segment_start + 2, n - 1)\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8091806247205495,
            0.8281423449516296
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest combined objective score\n    selected_idx = max(range(len(archive)), key=lambda i: archive[i][1][0] + archive[i][1][1])\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges in both objectives\n    edge_scores = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                edge_scores[i, j] = (distance_matrix_1[i, j] + distance_matrix_2[i, j]) / (archive[selected_idx][1][0] + archive[selected_idx][1][1] + 1e-6)\n\n    # Reinforce top 20% edges with probability\n    threshold = np.percentile(edge_scores, 80)\n    for i in range(n):\n        for j in range(n):\n            if edge_scores[i, j] >= threshold and random.random() < 0.4:\n                # Find positions of i and j in the tour\n                pos_i = np.where(new_solution == i)[0][0]\n                pos_j = np.where(new_solution == j)[0][0]\n\n                # Swap nodes if they are not adjacent\n                if abs(pos_i - pos_j) > 1:\n                    new_solution[pos_i], new_solution[pos_j] = new_solution[pos_j], new_solution[pos_i]\n\n    # Apply constraint-aware perturbation\n    if random.random() < 0.3:\n        # Select a random segment and reverse it\n        segment_start = random.randint(0, n - 3)\n        segment_end = random.randint(segment_start + 2, n - 1)\n        new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 227,
        "algorithm": "{This new algorithm uses an adaptive segment relocation strategy that evaluates edge contributions across both objectives with a dynamic weighting scheme, prioritizing segments that show balanced improvement potential in either space while ensuring feasibility through a probabilistic acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Dynamic score function: adaptive weighting based on segment cost ratio\n        cost_ratio = (segment_cost1 + 1e-6) / (segment_cost2 + 1e-6)\n        weight1 = 0.5 * (1 + (1 / (1 + cost_ratio)))\n        weight2 = 0.5 * (1 + (1 / (1 + 1/cost_ratio)))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic 2-opt with objective-aware selection\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to perform 2-opt\n            # Calculate objective cost for current and reversed segment\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if either objective improves\n            if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.94855986639196,
            0.42030978202819824
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Dynamic score function: adaptive weighting based on segment cost ratio\n        cost_ratio = (segment_cost1 + 1e-6) / (segment_cost2 + 1e-6)\n        weight1 = 0.5 * (1 + (1 / (1 + cost_ratio)))\n        weight2 = 0.5 * (1 + (1 / (1 + 1/cost_ratio)))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic 2-opt with objective-aware selection\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to perform 2-opt\n            # Calculate objective cost for current and reversed segment\n            current_cost1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            reversed_cost1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[i], new_solution[(j+1)%n]]\n            current_cost2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            reversed_cost2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[(j+1)%n]]\n\n            # Accept if either objective improves\n            if (reversed_cost1 < current_cost1) or (reversed_cost2 < current_cost2):\n                new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 228,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while abs(a - b) <= 1:\n        b = random.randint(0, n - 1)\n\n    # Extract the edges to swap\n    edge1 = (new_solution[a], new_solution[(a + 1) % n])\n    edge2 = (new_solution[b], new_solution[(b + 1) % n])\n\n    # Calculate the cost of the edges in both objectives\n    cost1 = distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]]\n    cost2 = distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]]\n\n    # Try swapping the edges\n    new_solution[(a + 1) % n], new_solution[(b + 1) % n] = new_solution[(b + 1) % n], new_solution[(a + 1) % n]\n\n    # Calculate the new cost\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[(a + 1) % n]] + distance_matrix_1[new_solution[b], new_solution[(b + 1) % n]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[(a + 1) % n]] + distance_matrix_2[new_solution[b], new_solution[(b + 1) % n]]\n\n    # If the swap does not improve both objectives, revert\n    if not (new_cost1 <= cost1 and new_cost2 <= cost2):\n        new_solution[(a + 1) % n], new_solution[(b + 1) % n] = new_solution[(b + 1) % n], new_solution[(a + 1) % n]\n\n    return new_solution\n\n",
        "score": [
            -0.652074393619057,
            1.8515957593917847
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    while abs(a - b) <= 1:\n        b = random.randint(0, n - 1)\n\n    # Extract the edges to swap\n    edge1 = (new_solution[a], new_solution[(a + 1) % n])\n    edge2 = (new_solution[b], new_solution[(b + 1) % n])\n\n    # Calculate the cost of the edges in both objectives\n    cost1 = distance_matrix_1[edge1[0], edge1[1]] + distance_matrix_1[edge2[0], edge2[1]]\n    cost2 = distance_matrix_2[edge1[0], edge1[1]] + distance_matrix_2[edge2[0], edge2[1]]\n\n    # Try swapping the edges\n    new_solution[(a + 1) % n], new_solution[(b + 1) % n] = new_solution[(b + 1) % n], new_solution[(a + 1) % n]\n\n    # Calculate the new cost\n    new_cost1 = distance_matrix_1[new_solution[a], new_solution[(a + 1) % n]] + distance_matrix_1[new_solution[b], new_solution[(b + 1) % n]]\n    new_cost2 = distance_matrix_2[new_solution[a], new_solution[(a + 1) % n]] + distance_matrix_2[new_solution[b], new_solution[(b + 1) % n]]\n\n    # If the swap does not improve both objectives, revert\n    if not (new_cost1 <= cost1 and new_cost2 <= cost2):\n        new_solution[(a + 1) % n], new_solution[(b + 1) % n] = new_solution[(b + 1) % n], new_solution[(a + 1) % n]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 229,
        "algorithm": "{A novel multi-objective local search strategy combines a Pareto-based selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the cost of removing this node\n    prev_node = new_solution[(node_idx - 1) % n]\n    next_node = new_solution[(node_idx + 1) % n]\n    removed_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    removed_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current node and its immediate neighbors\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], [node], new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.988514131702233,
            0.43348175287246704
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the cost of removing this node\n    prev_node = new_solution[(node_idx - 1) % n]\n    next_node = new_solution[(node_idx + 1) % n]\n    removed_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    removed_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current node and its immediate neighbors\n\n        # Try inserting the node at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], [node], temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], [node], new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 230,
        "algorithm": "{This new algorithm employs a dynamic node clustering and reinsertion strategy that groups nodes based on their proximity in both objective spaces, then reinserts clusters at optimal positions to balance cost improvements across both objectives while ensuring feasibility through a multi-criteria validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = 1 / (normalized.sum(axis=1) + 1e-6)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Cluster nodes based on proximity in both objective spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        prev_node = base_solution[i-1]\n        current_node = base_solution[i]\n        # Check if nodes are close in both spaces\n        dist1 = distance_matrix_1[prev_node, current_node]\n        dist2 = distance_matrix_2[prev_node, current_node]\n        if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n            current_cluster.append(current_node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [current_node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    if not clusters:\n        # If no clusters found, perform a random segment swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        return new_solution\n\n    # Select a cluster to relocate\n    cluster = random.choice(clusters)\n    cluster_indices = [i for i, node in enumerate(base_solution) if node in cluster]\n    start, end = min(cluster_indices), max(cluster_indices)\n    cluster_nodes = base_solution[start:end+1]\n\n    # Find best insertion point for the cluster\n    best_score = -float('inf')\n    best_pos = -1\n\n    for pos in range(n - len(cluster_nodes) + 1):\n        if pos >= start and pos <= end:\n            continue\n\n        # Try inserting the cluster at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], cluster_nodes, new_solution[pos:]])\n\n        # Calculate cost change\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: harmonic mean of normalized improvements\n        improvement1 = (original_cost1 - new_cost1) / (original_cost1 + 1e-6)\n        improvement2 = (original_cost2 - new_cost2) / (original_cost2 + 1e-6)\n        score = 2 * improvement1 * improvement2 / (improvement1 + improvement2 + 1e-6) if (improvement1 + improvement2) > 0 else -1\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove the cluster and insert at best position\n        temp_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([temp_solution[:best_pos], cluster_nodes, temp_solution[best_pos:]])\n    else:\n        # If no improvement found, perform a random cluster inversion\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7652290942914458,
            3.380270779132843
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = objectives / (np.max(objectives, axis=0) + 1e-6)\n    weights = 1 / (normalized.sum(axis=1) + 1e-6)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Cluster nodes based on proximity in both objective spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        prev_node = base_solution[i-1]\n        current_node = base_solution[i]\n        # Check if nodes are close in both spaces\n        dist1 = distance_matrix_1[prev_node, current_node]\n        dist2 = distance_matrix_2[prev_node, current_node]\n        if dist1 < 1.5 * np.mean(distance_matrix_1) and dist2 < 1.5 * np.mean(distance_matrix_2):\n            current_cluster.append(current_node)\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [current_node]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    if not clusters:\n        # If no clusters found, perform a random segment swap\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n        return new_solution\n\n    # Select a cluster to relocate\n    cluster = random.choice(clusters)\n    cluster_indices = [i for i, node in enumerate(base_solution) if node in cluster]\n    start, end = min(cluster_indices), max(cluster_indices)\n    cluster_nodes = base_solution[start:end+1]\n\n    # Find best insertion point for the cluster\n    best_score = -float('inf')\n    best_pos = -1\n\n    for pos in range(n - len(cluster_nodes) + 1):\n        if pos >= start and pos <= end:\n            continue\n\n        # Try inserting the cluster at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], cluster_nodes, new_solution[pos:]])\n\n        # Calculate cost change\n        original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: harmonic mean of normalized improvements\n        improvement1 = (original_cost1 - new_cost1) / (original_cost1 + 1e-6)\n        improvement2 = (original_cost2 - new_cost2) / (original_cost2 + 1e-6)\n        score = 2 * improvement1 * improvement2 / (improvement1 + improvement2 + 1e-6) if (improvement1 + improvement2) > 0 else -1\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove the cluster and insert at best position\n        temp_solution = np.concatenate([new_solution[:start], new_solution[end+1:]])\n        new_solution = np.concatenate([temp_solution[:best_pos], cluster_nodes, temp_solution[best_pos:]])\n    else:\n        # If no improvement found, perform a random cluster inversion\n        new_solution[start:end+1] = new_solution[start:end+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 231,
        "algorithm": "{This new algorithm uses a multi-objective segment inversion strategy that dynamically evaluates and inverts high-cost segments while maintaining feasibility through a probabilistic acceptance criterion, balancing improvements in both objective spaces through a weighted evaluation scheme.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse cost)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to evaluate for inversion\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate original connection costs\n    prev_node = new_solution[a-1] if a > 0 else new_solution[-1]\n    next_node = new_solution[a+segment_length-1] if a+segment_length < n else new_solution[0]\n    original_conn_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    original_conn_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_conn_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n\n    # Evaluate improvement potential\n    delta_cost1 = (inverted_cost1 + inverted_conn_cost1) - (original_cost1 + original_conn_cost1)\n\n    # For the second objective, we'll use a different strategy\n    # Calculate the average edge cost in the second objective\n    avg_original_cost2 = original_cost2 / segment_length\n    avg_inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length)) / segment_length\n\n    # Determine if inversion is beneficial\n    accept_prob = 0.5  # Base probability\n    if delta_cost1 < 0:  # Improvement in first objective\n        accept_prob = 0.8\n    elif avg_inverted_cost2 < avg_original_cost2:  # Improvement in second objective\n        accept_prob = 0.7\n\n    # Apply inversion with probability\n    if random.random() < accept_prob:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional perturbation: probabilistic edge swap\n    if random.random() < 0.2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9323621760648412,
            0.32651394605636597
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse cost)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to evaluate for inversion\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate original segment cost\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate original connection costs\n    prev_node = new_solution[a-1] if a > 0 else new_solution[-1]\n    next_node = new_solution[a+segment_length-1] if a+segment_length < n else new_solution[0]\n    original_conn_cost1 = distance_matrix_1[prev_node, segment[0]] + distance_matrix_1[segment[-1], next_node]\n    original_conn_cost2 = distance_matrix_2[prev_node, segment[0]] + distance_matrix_2[segment[-1], next_node]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_conn_cost1 = distance_matrix_1[prev_node, inverted_segment[0]] + distance_matrix_1[inverted_segment[-1], next_node]\n\n    # Evaluate improvement potential\n    delta_cost1 = (inverted_cost1 + inverted_conn_cost1) - (original_cost1 + original_conn_cost1)\n\n    # For the second objective, we'll use a different strategy\n    # Calculate the average edge cost in the second objective\n    avg_original_cost2 = original_cost2 / segment_length\n    avg_inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length)) / segment_length\n\n    # Determine if inversion is beneficial\n    accept_prob = 0.5  # Base probability\n    if delta_cost1 < 0:  # Improvement in first objective\n        accept_prob = 0.8\n    elif avg_inverted_cost2 < avg_original_cost2:  # Improvement in second objective\n        accept_prob = 0.7\n\n    # Apply inversion with probability\n    if random.random() < accept_prob:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional perturbation: probabilistic edge swap\n    if random.random() < 0.2:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 232,
        "algorithm": "{This algorithm implements a novel multi-objective path reconstruction strategy that dynamically combines edge reordering based on both objective spaces with a probabilistic segment inversion operator to explore diverse neighborhood structures while maintaining feasibility through a comprehensive edge validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge reordering phase\n    for _ in range(3):  # Perform multiple passes\n        # Select a random edge to consider\n        edge_idx = random.randint(0, n-1)\n        i, j = edge_idx, (edge_idx + 1) % n\n\n        # Calculate current edge costs\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best alternative edge in both objective spaces\n        best_node = -1\n        best_gain = 0\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1) % n or k == (j+1) % n:\n                continue\n\n            # Calculate potential gains\n            gain1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                    distance_matrix_1[new_solution[k], new_solution[j]]) - cost1\n            gain2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_2[new_solution[k], new_solution[j]]) - cost2\n\n            # Weighted gain calculation\n            total_gain = 0.6 * (cost1 - gain1) + 0.4 * (cost2 - gain2)\n\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_node = k\n\n        if best_node != -1:\n            # Apply the best edge replacement\n            new_solution[j], new_solution[best_node] = new_solution[best_node], new_solution[j]\n\n    # Probabilistic segment inversion operator\n    if random.random() < 0.4:  # 40% chance to apply\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:\n            # Handle wrap-around case\n            part1 = new_solution[seg_start:][::-1]\n            part2 = new_solution[:seg_end][::-1]\n            new_solution = np.concatenate([part1, part2])\n\n    return new_solution\n\n",
        "score": [
            -0.8041377544504698,
            0.35915058851242065
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic edge reordering phase\n    for _ in range(3):  # Perform multiple passes\n        # Select a random edge to consider\n        edge_idx = random.randint(0, n-1)\n        i, j = edge_idx, (edge_idx + 1) % n\n\n        # Calculate current edge costs\n        cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best alternative edge in both objective spaces\n        best_node = -1\n        best_gain = 0\n\n        for k in range(n):\n            if k == i or k == j or k == (i-1) % n or k == (j+1) % n:\n                continue\n\n            # Calculate potential gains\n            gain1 = (distance_matrix_1[new_solution[i], new_solution[k]] +\n                    distance_matrix_1[new_solution[k], new_solution[j]]) - cost1\n            gain2 = (distance_matrix_2[new_solution[i], new_solution[k]] +\n                    distance_matrix_2[new_solution[k], new_solution[j]]) - cost2\n\n            # Weighted gain calculation\n            total_gain = 0.6 * (cost1 - gain1) + 0.4 * (cost2 - gain2)\n\n            if total_gain > best_gain:\n                best_gain = total_gain\n                best_node = k\n\n        if best_node != -1:\n            # Apply the best edge replacement\n            new_solution[j], new_solution[best_node] = new_solution[best_node], new_solution[j]\n\n    # Probabilistic segment inversion operator\n    if random.random() < 0.4:  # 40% chance to apply\n        seg_start = random.randint(0, n-1)\n        seg_length = random.randint(2, min(5, n//2))\n        seg_end = (seg_start + seg_length) % n\n\n        if seg_start < seg_end:\n            new_solution[seg_start:seg_end] = new_solution[seg_start:seg_end][::-1]\n        else:\n            # Handle wrap-around case\n            part1 = new_solution[seg_start:][::-1]\n            part2 = new_solution[:seg_end][::-1]\n            new_solution = np.concatenate([part1, part2])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 233,
        "algorithm": "{This new algorithm employs a hybrid approach combining probabilistic segment reversal with edge swapping, where segments are dynamically selected based on their potential to reduce costs in either objective space while using a weighted scoring mechanism to guide the search toward promising regions of the solution space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and reverse it\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length][::-1]  # Reverse the segment\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9281681796105288,
            0.3859752416610718
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and reverse it\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length][::-1]  # Reverse the segment\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 234,
        "algorithm": "{This new algorithm employs a dynamic edge inversion strategy that selectively reverses segments of the tour based on their potential to reduce costs in either objective space while maintaining feasibility through a probabilistic acceptance criterion.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(6, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential inversion of the segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate total cost change if segment is inverted\n    delta_cost1 = inverted_cost1 - segment_cost1\n    delta_cost2 = inverted_cost2 - segment_cost2\n\n    # Probabilistic acceptance based on cost improvement\n    if delta_cost1 < 0 or delta_cost2 < 0 or random.random() < 0.2:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional probabilistic edge swap\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8201761553204456,
            0.2922546863555908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(6, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential inversion of the segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate total cost change if segment is inverted\n    delta_cost1 = inverted_cost1 - segment_cost1\n    delta_cost2 = inverted_cost2 - segment_cost2\n\n    # Probabilistic acceptance based on cost improvement\n    if delta_cost1 < 0 or delta_cost2 < 0 or random.random() < 0.2:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    # Additional probabilistic edge swap\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 235,
        "algorithm": "{This novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and incorporates a novel segment-based perturbation that dynamically adjusts the segment size based on the current solution's quality.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamically determine segment size based on solution quality\n    segment_size = max(2, min(n // 4, random.randint(2, n // 2)))\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random reversal of the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.901954494220094,
            0.5725630521774292
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamically determine segment size based on solution quality\n    segment_size = max(2, min(n // 4, random.randint(2, n // 2)))\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - segment_size)\n    b = a + segment_size - 1\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random reversal of the segment\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 236,
        "algorithm": "{This new algorithm uses a hybrid edge-swap and segment-flip strategy that dynamically evaluates edge contributions across both objectives, prioritizing flips of promising segments while maintaining feasibility through a probabilistic validation step and incorporating a novel edge-swap mechanism to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential flip of the segment\n    flipped_segment = segment[::-1]\n    flipped_cost1 = sum(distance_matrix_1[flipped_segment[i], flipped_segment[(i+1)%segment_length]] for i in range(segment_length))\n    flipped_cost2 = sum(distance_matrix_2[flipped_segment[i], flipped_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate potential cost change\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Try flipping the segment\n    temp_solution = np.concatenate([new_solution[:a], flipped_segment, new_solution[a+segment_length:]])\n    flipped_total_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    flipped_total_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Score function: weighted sum of cost improvements\n    score = ((original_cost1 - flipped_total_cost1) * 0.6 + (original_cost2 - flipped_total_cost2) * 0.4)\n\n    if score > 0:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8957517059717408,
            0.5764559507369995
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential flip of the segment\n    flipped_segment = segment[::-1]\n    flipped_cost1 = sum(distance_matrix_1[flipped_segment[i], flipped_segment[(i+1)%segment_length]] for i in range(segment_length))\n    flipped_cost2 = sum(distance_matrix_2[flipped_segment[i], flipped_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate potential cost change\n    original_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Try flipping the segment\n    temp_solution = np.concatenate([new_solution[:a], flipped_segment, new_solution[a+segment_length:]])\n    flipped_total_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    flipped_total_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Score function: weighted sum of cost improvements\n    score = ((original_cost1 - flipped_total_cost1) * 0.6 + (original_cost2 - flipped_total_cost2) * 0.4)\n\n    if score > 0:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 237,
        "algorithm": "{This algorithm selects a solution from the archive based on a dynamic multi-objective improvement score, then applies a hybrid local search that combines segment relinking with a novel edge exchange mechanism prioritizing edges with high potential for cost reduction in both objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement scores for each solution\n    scores = []\n    for sol, obj in archive:\n        total_cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        improvement_score = (total_cost1 - obj[0]) + (total_cost2 - obj[1])\n        scores.append(improvement_score)\n\n    # Select solution with highest improvement score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relinking with edge exchange\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Calculate segment costs\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Create temporary solution\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate total costs\n        total_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n        # Calculate weighted score (prioritize better solutions in both objectives)\n        score = (total_cost1 - archive[selected_idx][1][0]) + (total_cost2 - archive[selected_idx][1][1])\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8895430547996726,
            2.412863552570343
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Calculate improvement scores for each solution\n    scores = []\n    for sol, obj in archive:\n        total_cost1 = sum(distance_matrix_1[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        total_cost2 = sum(distance_matrix_2[sol[i], sol[(i+1)%len(sol)]] for i in range(len(sol)))\n        improvement_score = (total_cost1 - obj[0]) + (total_cost2 - obj[1])\n        scores.append(improvement_score)\n\n    # Select solution with highest improvement score\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n\n    # Hybrid local search: segment relinking with edge exchange\n    n = len(base_solution)\n    a, b = sorted(random.sample(range(n), 2))\n    segment = base_solution[a:b+1]\n\n    # Calculate segment costs\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find best insertion point considering both objectives\n    best_pos = -1\n    best_score = float('inf')\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Create temporary solution\n        temp_sol = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate total costs\n        total_cost1 = sum(distance_matrix_1[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n        total_cost2 = sum(distance_matrix_2[temp_sol[i], temp_sol[(i+1)%n]] for i in range(n))\n\n        # Calculate weighted score (prioritize better solutions in both objectives)\n        score = (total_cost1 - archive[selected_idx][1][0]) + (total_cost2 - archive[selected_idx][1][1])\n\n        if score < best_score:\n            best_score = score\n            best_pos = pos\n\n    if best_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n    else:\n        # If no improvement found, perform edge exchange\n        i, j = random.sample(range(n), 2)\n        if i > j:\n            i, j = j, i\n        # Reverse the segment between i and j\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 238,
        "algorithm": "{This novel algorithm employs a multi-criteria edge prioritization strategy that dynamically selects and exchanges edges based on their potential to reduce costs in both objectives, while ensuring feasibility through a probabilistic validation mechanism that balances exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective scores)\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    weights = [obj[0] + obj[1] / total_cost for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges for potential exchange\n    a, b = random.sample(range(n), 2)\n    c, d = random.sample(range(n), 2)\n\n    # Ensure we're not trying to create invalid edges\n    if (a == b or c == d or\n        a == c or a == d or b == c or b == d or\n        (a == d and b == c)):\n        return new_solution\n\n    # Calculate the cost difference for both objectives\n    def cost_diff(sol, i, j, k, l):\n        old_cost1 = (distance_matrix_1[sol[i], sol[j]] + distance_matrix_1[sol[k], sol[l]])\n        new_cost1 = (distance_matrix_1[sol[i], sol[k]] + distance_matrix_1[sol[j], sol[l]])\n        old_cost2 = (distance_matrix_2[sol[i], sol[j]] + distance_matrix_2[sol[k], sol[l]])\n        new_cost2 = (distance_matrix_2[sol[i], sol[k]] + distance_matrix_2[sol[j], sol[l]])\n        return (new_cost1 - old_cost1, new_cost2 - old_cost2)\n\n    diff1, diff2 = cost_diff(new_solution, a, b, c, d)\n\n    # Apply the exchange if it improves both objectives or with a certain probability\n    if (diff1 < 0 and diff2 < 0) or (diff1 < 0 and random.random() < 0.3) or (diff2 < 0 and random.random() < 0.3):\n        # Perform the edge exchange\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n    else:\n        # Fallback to a random swap if exchange doesn't help\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9160504368328029,
            0.23626166582107544
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective scores)\n    total_cost = sum(obj[0] + obj[1] for _, obj in archive)\n    weights = [obj[0] + obj[1] / total_cost for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Select two random edges for potential exchange\n    a, b = random.sample(range(n), 2)\n    c, d = random.sample(range(n), 2)\n\n    # Ensure we're not trying to create invalid edges\n    if (a == b or c == d or\n        a == c or a == d or b == c or b == d or\n        (a == d and b == c)):\n        return new_solution\n\n    # Calculate the cost difference for both objectives\n    def cost_diff(sol, i, j, k, l):\n        old_cost1 = (distance_matrix_1[sol[i], sol[j]] + distance_matrix_1[sol[k], sol[l]])\n        new_cost1 = (distance_matrix_1[sol[i], sol[k]] + distance_matrix_1[sol[j], sol[l]])\n        old_cost2 = (distance_matrix_2[sol[i], sol[j]] + distance_matrix_2[sol[k], sol[l]])\n        new_cost2 = (distance_matrix_2[sol[i], sol[k]] + distance_matrix_2[sol[j], sol[l]])\n        return (new_cost1 - old_cost1, new_cost2 - old_cost2)\n\n    diff1, diff2 = cost_diff(new_solution, a, b, c, d)\n\n    # Apply the exchange if it improves both objectives or with a certain probability\n    if (diff1 < 0 and diff2 < 0) or (diff1 < 0 and random.random() < 0.3) or (diff2 < 0 and random.random() < 0.3):\n        # Perform the edge exchange\n        new_solution[b], new_solution[c] = new_solution[c], new_solution[b]\n    else:\n        # Fallback to a random swap if exchange doesn't help\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 239,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism, and employs a probabilistic acceptance criterion to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    temp_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution_inserted = np.insert(temp_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution_inserted[i], temp_solution_inserted[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution_inserted[i], temp_solution_inserted[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        new_solution = np.insert(temp_solution, random.randint(0, n-1), node)\n\n    return new_solution\n\n",
        "score": [
            -0.861369263289878,
            0.7727053761482239
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Remove the node from its current position\n    temp_solution = np.delete(new_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n    current_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%(n-1)]] for i in range(n-1))\n\n    # Find the best insertion point for the node\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n-1):\n        # Try inserting the node at position 'pos'\n        temp_solution_inserted = np.insert(temp_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution_inserted[i], temp_solution_inserted[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution_inserted[i], temp_solution_inserted[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(temp_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        new_solution = np.insert(temp_solution, random.randint(0, n-1), node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 240,
        "algorithm": "{This new algorithm employs a dynamic edge clustering and reinsertion strategy that analyzes edge contributions across both objectives, forming clusters of edges with complementary cost reductions while maintaining feasibility through a probabilistic validation mechanism that ensures solution quality is preserved.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 / (normalized.sum(axis=1) + 1e-6)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Cluster edges based on their contribution to both objectives\n    edges = [(base_solution[i], base_solution[(i+1)%n]) for i in range(n)]\n    edge_scores = []\n    for u, v in edges:\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        score = (cost1 + cost2) / (cost1 * cost2 + 1e-6)  # Harmonic mean of normalized costs\n        edge_scores.append(score)\n\n    # Select top k edges with highest scores\n    k = min(5, n // 2)\n    top_edges = sorted(zip(edges, edge_scores), key=lambda x: -x[1])[:k]\n    selected_edges = [edge for edge, _ in top_edges]\n\n    # Remove selected edges and their nodes\n    nodes_to_remove = set()\n    for u, v in selected_edges:\n        nodes_to_remove.update([u, v])\n\n    remaining_nodes = [node for node in base_solution if node not in nodes_to_remove]\n    if len(remaining_nodes) < 2:\n        # Fallback to random swap if too few nodes remain\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Reconstruct solution by reinserting edges in a different order\n    new_solution = remaining_nodes.copy()\n    for u, v in selected_edges:\n        if random.random() < 0.5:\n            # Insert edge at random position\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, u)\n            new_solution.insert(pos + 1, v)\n        else:\n            # Insert edge at end\n            new_solution.extend([u, v])\n\n    # Ensure no duplicates and all nodes are present\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = [node for node in base_solution if node not in unique_nodes]\n    if missing_nodes:\n        # Add missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    return np.array(new_solution)\n\n",
        "score": [
            -0.6385842816297691,
            0.15040117502212524
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by normalized objective values)\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 / (normalized.sum(axis=1) + 1e-6)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Cluster edges based on their contribution to both objectives\n    edges = [(base_solution[i], base_solution[(i+1)%n]) for i in range(n)]\n    edge_scores = []\n    for u, v in edges:\n        cost1 = distance_matrix_1[u, v]\n        cost2 = distance_matrix_2[u, v]\n        score = (cost1 + cost2) / (cost1 * cost2 + 1e-6)  # Harmonic mean of normalized costs\n        edge_scores.append(score)\n\n    # Select top k edges with highest scores\n    k = min(5, n // 2)\n    top_edges = sorted(zip(edges, edge_scores), key=lambda x: -x[1])[:k]\n    selected_edges = [edge for edge, _ in top_edges]\n\n    # Remove selected edges and their nodes\n    nodes_to_remove = set()\n    for u, v in selected_edges:\n        nodes_to_remove.update([u, v])\n\n    remaining_nodes = [node for node in base_solution if node not in nodes_to_remove]\n    if len(remaining_nodes) < 2:\n        # Fallback to random swap if too few nodes remain\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Reconstruct solution by reinserting edges in a different order\n    new_solution = remaining_nodes.copy()\n    for u, v in selected_edges:\n        if random.random() < 0.5:\n            # Insert edge at random position\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, u)\n            new_solution.insert(pos + 1, v)\n        else:\n            # Insert edge at end\n            new_solution.extend([u, v])\n\n    # Ensure no duplicates and all nodes are present\n    unique_nodes = np.unique(new_solution)\n    missing_nodes = [node for node in base_solution if node not in unique_nodes]\n    if missing_nodes:\n        # Add missing nodes at random positions\n        for node in missing_nodes:\n            pos = random.randint(0, len(new_solution))\n            new_solution.insert(pos, node)\n\n    return np.array(new_solution)\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 241,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective ranking criterion, then applies a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Use Pareto dominance to select the most promising solution\n    selected_idx = 0\n    for i in range(1, len(archive_objectives)):\n        if (archive_objectives[i][0] < archive_objectives[selected_idx][0] and archive_objectives[i][1] <= archive_objectives[selected_idx][1]) or \\\n           (archive_objectives[i][0] <= archive_objectives[selected_idx][0] and archive_objectives[i][1] < archive_objectives[selected_idx][1]):\n            selected_idx = i\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a dynamic edge exchange operator\n    n = len(base_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Ensure i and j are distinct\n    while j == i:\n        j = random.randint(0, n - 1)\n\n    # Calculate potential cost reduction\n    old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n    old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n\n    new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n    new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n    # Apply the exchange if it improves both objectives\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.2:  # Add randomness to escape local optima\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8885647103769236,
            0.48957765102386475
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best trade-off between objectives\n    archive_solutions = [sol for sol, _ in archive]\n    archive_objectives = [obj for _, obj in archive]\n\n    # Use Pareto dominance to select the most promising solution\n    selected_idx = 0\n    for i in range(1, len(archive_objectives)):\n        if (archive_objectives[i][0] < archive_objectives[selected_idx][0] and archive_objectives[i][1] <= archive_objectives[selected_idx][1]) or \\\n           (archive_objectives[i][0] <= archive_objectives[selected_idx][0] and archive_objectives[i][1] < archive_objectives[selected_idx][1]):\n            selected_idx = i\n\n    base_solution = archive_solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n\n    # Apply a dynamic edge exchange operator\n    n = len(base_solution)\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n\n    # Ensure i and j are distinct\n    while j == i:\n        j = random.randint(0, n - 1)\n\n    # Calculate potential cost reduction\n    old_cost1 = distance_matrix_1[base_solution[i-1], base_solution[i]] + distance_matrix_1[base_solution[j-1], base_solution[j]]\n    old_cost2 = distance_matrix_2[base_solution[i-1], base_solution[i]] + distance_matrix_2[base_solution[j-1], base_solution[j]]\n\n    new_cost1 = distance_matrix_1[base_solution[i-1], base_solution[j]] + distance_matrix_1[base_solution[j-1], base_solution[i]]\n    new_cost2 = distance_matrix_2[base_solution[i-1], base_solution[j]] + distance_matrix_2[base_solution[j-1], base_solution[i]]\n\n    # Apply the exchange if it improves both objectives\n    if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or random.random() < 0.2:  # Add randomness to escape local optima\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 242,
        "algorithm": "{This new algorithm employs a multi-objective edge exchange strategy that dynamically evaluates and swaps entire sub-tours between two randomly selected segments, while using a hybrid cost function to prioritize improvements in both objectives and maintaining feasibility through a probabilistic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    objectives = [obj for _, obj in archive]\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    segment1_length = random.randint(2, min(5, n // 3))\n    segment2_length = random.randint(2, min(5, n // 3))\n\n    a1 = random.randint(0, n - segment1_length)\n    a2 = random.randint(0, n - segment2_length)\n\n    # Ensure segments don't overlap\n    while max(a1, a2) - min(a1 + segment1_length, a2 + segment2_length) < 0:\n        a2 = random.randint(0, n - segment2_length)\n\n    segment1 = new_solution[a1:a1+segment1_length]\n    segment2 = new_solution[a2:a2+segment2_length]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%segment1_length]] for i in range(segment1_length))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%segment1_length]] for i in range(segment1_length))\n\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%segment2_length]] for i in range(segment2_length))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%segment2_length]] for i in range(segment2_length))\n\n    # Calculate total cost before exchange\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Try exchanging the segments\n    if a1 < a2:\n        temp_solution = np.concatenate([\n            new_solution[:a1], segment2, new_solution[a1+segment1_length:a2], segment1, new_solution[a2+segment2_length:]\n        ])\n    else:\n        temp_solution = np.concatenate([\n            new_solution[:a2], segment1, new_solution[a2+segment2_length:a1], segment2, new_solution[a1+segment1_length:]\n        ])\n\n    # Calculate new costs\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Hybrid cost improvement calculation\n    improvement1 = (total_cost1 - new_cost1) / (cost1_seg1 + cost1_seg2 + 1e-6)\n    improvement2 = (total_cost2 - new_cost2) / (cost2_seg1 + cost2_seg2 + 1e-6)\n\n    # Accept with probability based on improvements\n    if (improvement1 > 0 and improvement2 > 0) or \\\n       (random.random() < 0.5 and (improvement1 > 0 or improvement2 > 0)):\n        new_solution = temp_solution\n    else:\n        # Fallback to random swap if no improvement\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.980118658633526,
            0.2480309009552002
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    objectives = [obj for _, obj in archive]\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for obj in objectives]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-overlapping segments\n    segment1_length = random.randint(2, min(5, n // 3))\n    segment2_length = random.randint(2, min(5, n // 3))\n\n    a1 = random.randint(0, n - segment1_length)\n    a2 = random.randint(0, n - segment2_length)\n\n    # Ensure segments don't overlap\n    while max(a1, a2) - min(a1 + segment1_length, a2 + segment2_length) < 0:\n        a2 = random.randint(0, n - segment2_length)\n\n    segment1 = new_solution[a1:a1+segment1_length]\n    segment2 = new_solution[a2:a2+segment2_length]\n\n    # Calculate segment costs\n    cost1_seg1 = sum(distance_matrix_1[segment1[i], segment1[(i+1)%segment1_length]] for i in range(segment1_length))\n    cost2_seg1 = sum(distance_matrix_2[segment1[i], segment1[(i+1)%segment1_length]] for i in range(segment1_length))\n\n    cost1_seg2 = sum(distance_matrix_1[segment2[i], segment2[(i+1)%segment2_length]] for i in range(segment2_length))\n    cost2_seg2 = sum(distance_matrix_2[segment2[i], segment2[(i+1)%segment2_length]] for i in range(segment2_length))\n\n    # Calculate total cost before exchange\n    total_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Try exchanging the segments\n    if a1 < a2:\n        temp_solution = np.concatenate([\n            new_solution[:a1], segment2, new_solution[a1+segment1_length:a2], segment1, new_solution[a2+segment2_length:]\n        ])\n    else:\n        temp_solution = np.concatenate([\n            new_solution[:a2], segment1, new_solution[a2+segment2_length:a1], segment2, new_solution[a1+segment1_length:]\n        ])\n\n    # Calculate new costs\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Hybrid cost improvement calculation\n    improvement1 = (total_cost1 - new_cost1) / (cost1_seg1 + cost1_seg2 + 1e-6)\n    improvement2 = (total_cost2 - new_cost2) / (cost2_seg1 + cost2_seg2 + 1e-6)\n\n    # Accept with probability based on improvements\n    if (improvement1 > 0 and improvement2 > 0) or \\\n       (random.random() < 0.5 and (improvement1 > 0 or improvement2 > 0)):\n        new_solution = temp_solution\n    else:\n        # Fallback to random swap if no improvement\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 243,
        "algorithm": "{This new algorithm uses an adaptive segment inversion strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a dynamic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(3, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points with inversion\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_inverted = False\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the original segment\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inverted = False\n\n        # Try inserting the inverted segment\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inverted = True\n\n    if best_insert_pos != -1:\n        segment_to_insert = segment[::-1] if best_inverted else segment\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment_to_insert, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with inversion\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            if random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8750540203713066,
            0.6187118291854858
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(3, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points with inversion\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_inverted = False\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the original segment\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inverted = False\n\n        # Try inserting the inverted segment\n        inverted_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n            best_inverted = True\n\n    if best_insert_pos != -1:\n        segment_to_insert = segment[::-1] if best_inverted else segment\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment_to_insert, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with inversion\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            if random.random() < 0.5:\n                new_solution[i:j] = new_solution[i:j][::-1]\n            else:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 244,
        "algorithm": "{This new algorithm employs a multi-objective edge-swapping strategy that dynamically evaluates and prioritizes edge replacements based on their potential to improve both objectives simultaneously, while maintaining feasibility through a biased random walk mechanism that explores promising regions of the search space.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 / (norm_obj.sum(axis=1) + 1e-6)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic edge selection: prioritize edges with high potential for improvement\n    edge_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        current_cost1 = distance_matrix_1[base_solution[i], base_solution[j]]\n        current_cost2 = distance_matrix_2[base_solution[i], base_solution[j]]\n\n        # Evaluate potential replacements\n        potential_improvements = []\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue  # Skip adjacent nodes to maintain feasibility\n            new_cost1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[k], base_solution[j]]\n            new_cost2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[k], base_solution[j]]\n            improvement1 = current_cost1 - new_cost1\n            improvement2 = current_cost2 - new_cost2\n            potential_improvements.append((improvement1 + improvement2, k))\n\n        if potential_improvements:\n            best_improvement, best_k = max(potential_improvements)\n            edge_scores.append((best_improvement, i, best_k))\n\n    if edge_scores:\n        # Select edges with highest potential improvements\n        edge_scores.sort(reverse=True)\n        top_edges = [edge for edge in edge_scores if edge[0] > 0][:3]  # Top 3 edges with positive improvements\n\n        if top_edges:\n            # Apply the best edge replacement\n            _, i, k = random.choice(top_edges)\n            j = (i + 1) % n\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n            # Perform a biased random walk to explore nearby solutions\n            for _ in range(2):  # Perform 2 random swaps biased toward improvements\n                candidates = []\n                for a in range(n):\n                    for b in range(a+2, n):\n                        if abs(a-b) > 1:  # Ensure non-adjacent nodes\n                            delta1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                                     distance_matrix_1[new_solution[(a-1)%n], new_solution[(b+1)%n]]) - \\\n                                    (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                                     distance_matrix_1[new_solution[b], new_solution[(b-1)%n]])\n                            delta2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                                     distance_matrix_2[new_solution[(a-1)%n], new_solution[(b+1)%n]]) - \\\n                                    (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                                     distance_matrix_2[new_solution[b], new_solution[(b-1)%n]])\n                            candidates.append((delta1 + delta2, a, b))\n\n                if candidates:\n                    candidates.sort(reverse=True)\n                    best_delta, a, b = candidates[0]\n                    if best_delta > 0:  # Only apply if positive improvement\n                        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            return new_solution\n\n    # Fallback: perform a random 2-opt if no improvements found\n    a, b = sorted(random.sample(range(n), 2))\n    if abs(a-b) > 1:  # Ensure non-adjacent nodes\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8863476019553279,
            0.9400138258934021
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by normalized objectives)\n    objectives = np.array([obj for _, obj in archive])\n    norm_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-6)\n    weights = 1 / (norm_obj.sum(axis=1) + 1e-6)\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Dynamic edge selection: prioritize edges with high potential for improvement\n    edge_scores = []\n    for i in range(n):\n        j = (i + 1) % n\n        current_cost1 = distance_matrix_1[base_solution[i], base_solution[j]]\n        current_cost2 = distance_matrix_2[base_solution[i], base_solution[j]]\n\n        # Evaluate potential replacements\n        potential_improvements = []\n        for k in range(n):\n            if k == i or k == j or k == (i-1)%n or k == (j+1)%n:\n                continue  # Skip adjacent nodes to maintain feasibility\n            new_cost1 = distance_matrix_1[base_solution[i], base_solution[k]] + distance_matrix_1[base_solution[k], base_solution[j]]\n            new_cost2 = distance_matrix_2[base_solution[i], base_solution[k]] + distance_matrix_2[base_solution[k], base_solution[j]]\n            improvement1 = current_cost1 - new_cost1\n            improvement2 = current_cost2 - new_cost2\n            potential_improvements.append((improvement1 + improvement2, k))\n\n        if potential_improvements:\n            best_improvement, best_k = max(potential_improvements)\n            edge_scores.append((best_improvement, i, best_k))\n\n    if edge_scores:\n        # Select edges with highest potential improvements\n        edge_scores.sort(reverse=True)\n        top_edges = [edge for edge in edge_scores if edge[0] > 0][:3]  # Top 3 edges with positive improvements\n\n        if top_edges:\n            # Apply the best edge replacement\n            _, i, k = random.choice(top_edges)\n            j = (i + 1) % n\n            new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n\n            # Perform a biased random walk to explore nearby solutions\n            for _ in range(2):  # Perform 2 random swaps biased toward improvements\n                candidates = []\n                for a in range(n):\n                    for b in range(a+2, n):\n                        if abs(a-b) > 1:  # Ensure non-adjacent nodes\n                            delta1 = (distance_matrix_1[new_solution[a], new_solution[b]] +\n                                     distance_matrix_1[new_solution[(a-1)%n], new_solution[(b+1)%n]]) - \\\n                                    (distance_matrix_1[new_solution[a], new_solution[(a+1)%n]] +\n                                     distance_matrix_1[new_solution[b], new_solution[(b-1)%n]])\n                            delta2 = (distance_matrix_2[new_solution[a], new_solution[b]] +\n                                     distance_matrix_2[new_solution[(a-1)%n], new_solution[(b+1)%n]]) - \\\n                                    (distance_matrix_2[new_solution[a], new_solution[(a+1)%n]] +\n                                     distance_matrix_2[new_solution[b], new_solution[(b-1)%n]])\n                            candidates.append((delta1 + delta2, a, b))\n\n                if candidates:\n                    candidates.sort(reverse=True)\n                    best_delta, a, b = candidates[0]\n                    if best_delta > 0:  # Only apply if positive improvement\n                        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n            return new_solution\n\n    # Fallback: perform a random 2-opt if no improvements found\n    a, b = sorted(random.sample(range(n), 2))\n    if abs(a-b) > 1:  # Ensure non-adjacent nodes\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 245,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8901973509891317,
            0.4887102246284485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a novel local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 246,
        "algorithm": "{This new algorithm employs a dynamic segment inversion strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction while maintaining feasibility through a probabilistic validation step, and uses a novel edge-swapping mechanism to further refine the solution.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the inverted segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], inverted_segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with inversion\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap and invert\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8771359302165034,
            0.36657750606536865
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment\n    inverted_segment = segment[::-1]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the inverted segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], inverted_segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with inversion\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap and invert\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 247,
        "algorithm": "{A novel adaptive local search strategy combines a multi-objective edge selection heuristic with a dynamic segment inversion operator, prioritizing edges with high potential for cost reduction in both objectives while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate original cost of the segment\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Invert the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new cost of the segment\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If inversion improves both objectives, keep it\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n\n    # Otherwise, try a different segment inversion\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(c, d+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(c, d+1))\n\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(c, d+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(c, d+1))\n\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n\n    # If no improvement, return original solution\n    return base_solution\n\n",
        "score": [
            -0.7184288252302415,
            0.9431301951408386
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest potential for improvement (randomly weighted by objective values)\n    weights = [1.0 / (1.0 + obj[0] + obj[1]) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Select a random segment and invert it\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Calculate original cost of the segment\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # Invert the segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate new cost of the segment\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If inversion improves both objectives, keep it\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n\n    # Otherwise, try a different segment inversion\n    c = random.randint(0, n - 1)\n    d = random.randint(0, n - 1)\n    if c > d:\n        c, d = d, c\n\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(c, d+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(c, d+1))\n\n    new_solution[c:d+1] = new_solution[c:d+1][::-1]\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(c, d+1))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(c, d+1))\n\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n\n    # If no improvement, return original solution\n    return base_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 248,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Calculate the current cost of the edges to be exchanged\n    current_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n\n    # Calculate the potential new cost if we exchange the edges\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    # Only perform the exchange if it improves both objectives\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Perform the edge exchange\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n    else:\n        # If the exchange doesn't improve both objectives, perform a random swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n",
        "score": [
            -0.8842098896025321,
            0.18806427717208862
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to exchange\n    i = random.randint(0, n - 1)\n    j = random.randint(0, n - 1)\n    while abs(i - j) <= 1 or i == j:\n        j = random.randint(0, n - 1)\n\n    # Calculate the current cost of the edges to be exchanged\n    current_cost1 = distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_1[base_solution[j], base_solution[(j+1)%n]]\n    current_cost2 = distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] + distance_matrix_2[base_solution[j], base_solution[(j+1)%n]]\n\n    # Calculate the potential new cost if we exchange the edges\n    new_cost1 = distance_matrix_1[base_solution[i], base_solution[j]] + distance_matrix_1[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n    new_cost2 = distance_matrix_2[base_solution[i], base_solution[j]] + distance_matrix_2[base_solution[(i+1)%n], base_solution[(j+1)%n]]\n\n    # Only perform the exchange if it improves both objectives\n    if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n        # Perform the edge exchange\n        if i > j:\n            i, j = j, i\n        new_solution[i+1:j+1] = np.flip(new_solution[i+1:j+1])\n    else:\n        # If the exchange doesn't improve both objectives, perform a random swap\n        a, b = random.sample(range(n), 2)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 249,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -1.0033561175670453,
            0.537498950958252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 250,
        "algorithm": "{This new algorithm uses a dynamic edge relocation strategy that evaluates edge contributions across both objectives with a weighted score function, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, and incorporates a novel segment inversion operator to explore different tour configurations.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Modified score function: weighted sum of cost improvements with different weights\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.4 + (segment_cost2 - (cost2 - segment_cost2)) * 0.6\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a segment inversion\n        if n >= 4:\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i >= 2:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.886376967471043,
            0.4230486750602722
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Modified score function: weighted sum of cost improvements with different weights\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.4 + (segment_cost2 - (cost2 - segment_cost2)) * 0.6\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a segment inversion\n        if n >= 4:\n            i, j = sorted(random.sample(range(n), 2))\n            if j - i >= 2:\n                new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 251,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.912102679824695,
            0.4987976551055908
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 252,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a novel segment inversion strategy to explore the search space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a novel hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment to create a new tour\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the inversion improves both objectives, keep it\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n    else:\n        # Otherwise, try a different approach: node reordering based on objective correlation\n        # Calculate the correlation between the two objectives for each node\n        node_correlation = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate the change in both objectives if we move this node\n            original_edge1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            original_edge2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Try moving the node to a different position\n            for j in range(n):\n                if j == i or j == i-1 or j == (i+1)%n:\n                    continue\n\n                new_prev = new_solution[j-1]\n                new_next = new_solution[j]\n\n                new_edge1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                new_edge2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n                # Calculate the correlation between the changes\n                delta1 = new_edge1 - original_edge1\n                delta2 = new_edge2 - original_edge2\n\n                if delta1 != 0 and delta2 != 0:\n                    correlation = delta1 / delta2\n                    node_correlation.append((correlation, i, j))\n\n        if node_correlation:\n            # Sort by correlation and select the most promising move\n            node_correlation.sort(key=lambda x: abs(x[0]))\n            _, best_i, best_j = node_correlation[0]\n\n            # Apply the move\n            node = new_solution[best_i]\n            new_solution = np.delete(new_solution, best_i)\n            new_solution = np.insert(new_solution, best_j, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8738290926335105,
            0.8620046973228455
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a novel hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment to create a new tour\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n    new_solution[a:b+1] = inverted_segment\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    new_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # If the inversion improves both objectives, keep it\n    if new_cost1 < original_cost1 and new_cost2 < original_cost2:\n        return new_solution\n    else:\n        # Otherwise, try a different approach: node reordering based on objective correlation\n        # Calculate the correlation between the two objectives for each node\n        node_correlation = []\n        for i in range(n):\n            node = new_solution[i]\n            prev_node = new_solution[i-1]\n            next_node = new_solution[(i+1)%n]\n\n            # Calculate the change in both objectives if we move this node\n            original_edge1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n            original_edge2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n            # Try moving the node to a different position\n            for j in range(n):\n                if j == i or j == i-1 or j == (i+1)%n:\n                    continue\n\n                new_prev = new_solution[j-1]\n                new_next = new_solution[j]\n\n                new_edge1 = distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next]\n                new_edge2 = distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next]\n\n                # Calculate the correlation between the changes\n                delta1 = new_edge1 - original_edge1\n                delta2 = new_edge2 - original_edge2\n\n                if delta1 != 0 and delta2 != 0:\n                    correlation = delta1 / delta2\n                    node_correlation.append((correlation, i, j))\n\n        if node_correlation:\n            # Sort by correlation and select the most promising move\n            node_correlation.sort(key=lambda x: abs(x[0]))\n            _, best_i, best_j = node_correlation[0]\n\n            # Apply the move\n            node = new_solution[best_i]\n            new_solution = np.delete(new_solution, best_i)\n            new_solution = np.insert(new_solution, best_j, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 253,
        "algorithm": "{This algorithm employs a multi-objective edge prioritization strategy that dynamically selects and exchanges edges based on their potential to reduce costs in both objective spaces while using a validation mechanism to ensure feasibility and diversity in the generated neighbor solutions.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify edges with potential for improvement\n    edge_scores = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        # Score based on potential cost reduction in both objectives\n        potential_cost1 = distance_matrix_1[u, v] - min(distance_matrix_1[u, :])\n        potential_cost2 = distance_matrix_2[u, v] - min(distance_matrix_2[u, :])\n        score = potential_cost1 + potential_cost2\n        edge_scores.append((score, i))\n\n    # Sort edges by score (highest potential first)\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n    top_edges = [i for _, i in edge_scores[:max(2, n//10)]]  # Select top edges\n\n    # Perform edge exchanges\n    for i in top_edges:\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        # Find best replacement edge\n        best_j = -1\n        best_improvement = 0\n        for j in range(n):\n            if j == i or j == (i+1)%n or j == (i-1)%n:\n                continue\n            w = new_solution[j]\n            # Calculate potential improvement\n            new_cost1 = distance_matrix_1[u, w] + distance_matrix_1[w, v] - distance_matrix_1[u, v]\n            new_cost2 = distance_matrix_2[u, w] + distance_matrix_2[w, v] - distance_matrix_2[u, v]\n            improvement = -new_cost1 - new_cost2  # Negative because we want to minimize\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_j = j\n\n        if best_j != -1:\n            # Perform the exchange\n            w = new_solution[best_j]\n            new_solution[(i+1)%n] = w\n            # Reconnect the tour\n            if (i+1)%n < best_j:\n                new_solution[(i+1)%n:best_j+1] = new_solution[(i+1)%n:best_j+1][::-1]\n            else:\n                new_solution[best_j:(i+1)%n] = new_solution[best_j:(i+1)%n][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.6053494242751911,
            2.680351734161377
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Identify edges with potential for improvement\n    edge_scores = []\n    for i in range(n):\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        # Score based on potential cost reduction in both objectives\n        potential_cost1 = distance_matrix_1[u, v] - min(distance_matrix_1[u, :])\n        potential_cost2 = distance_matrix_2[u, v] - min(distance_matrix_2[u, :])\n        score = potential_cost1 + potential_cost2\n        edge_scores.append((score, i))\n\n    # Sort edges by score (highest potential first)\n    edge_scores.sort(reverse=True, key=lambda x: x[0])\n    top_edges = [i for _, i in edge_scores[:max(2, n//10)]]  # Select top edges\n\n    # Perform edge exchanges\n    for i in top_edges:\n        u, v = new_solution[i], new_solution[(i+1)%n]\n        # Find best replacement edge\n        best_j = -1\n        best_improvement = 0\n        for j in range(n):\n            if j == i or j == (i+1)%n or j == (i-1)%n:\n                continue\n            w = new_solution[j]\n            # Calculate potential improvement\n            new_cost1 = distance_matrix_1[u, w] + distance_matrix_1[w, v] - distance_matrix_1[u, v]\n            new_cost2 = distance_matrix_2[u, w] + distance_matrix_2[w, v] - distance_matrix_2[u, v]\n            improvement = -new_cost1 - new_cost2  # Negative because we want to minimize\n            if improvement > best_improvement:\n                best_improvement = improvement\n                best_j = j\n\n        if best_j != -1:\n            # Perform the exchange\n            w = new_solution[best_j]\n            new_solution[(i+1)%n] = w\n            # Reconnect the tour\n            if (i+1)%n < best_j:\n                new_solution[(i+1)%n:best_j+1] = new_solution[(i+1)%n:best_j+1][::-1]\n            else:\n                new_solution[best_j:(i+1)%n] = new_solution[best_j:(i+1)%n][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 254,
        "algorithm": "{This new algorithm employs a multi-objective edge swapping strategy that dynamically evaluates edge contributions across both objective spaces, prioritizing swaps that improve at least one objective while maintaining feasibility through a constrained neighborhood exploration mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate current total costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a set of edges to consider for swapping\n    num_edges = min(5, n // 2)\n    edge_indices = random.sample(range(n), num_edges)\n\n    best_cost1, best_cost2 = current_cost1, current_cost2\n    best_swap = None\n\n    for i in edge_indices:\n        j = (i + 1) % n\n\n        # Consider swapping with a non-adjacent edge\n        k = random.randint(0, n - 1)\n        while k in [i, (i - 1) % n, (i + 1) % n, (i + 2) % n]:\n            k = random.randint(0, n - 1)\n\n        l = (k + 1) % n\n\n        # Try the swap\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[m], temp_solution[(m+1)%n]] for m in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[m], temp_solution[(m+1)%n]] for m in range(n))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < best_cost1) or (new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_swap = (i, k)\n\n    if best_swap is not None:\n        i, k = best_swap\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        # If no improvement found, perform a random 2-opt\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8726799561189201,
            0.3225861191749573
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by objective values)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate current total costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Randomly select a set of edges to consider for swapping\n    num_edges = min(5, n // 2)\n    edge_indices = random.sample(range(n), num_edges)\n\n    best_cost1, best_cost2 = current_cost1, current_cost2\n    best_swap = None\n\n    for i in edge_indices:\n        j = (i + 1) % n\n\n        # Consider swapping with a non-adjacent edge\n        k = random.randint(0, n - 1)\n        while k in [i, (i - 1) % n, (i + 1) % n, (i + 2) % n]:\n            k = random.randint(0, n - 1)\n\n        l = (k + 1) % n\n\n        # Try the swap\n        temp_solution = new_solution.copy()\n        temp_solution[i], temp_solution[k] = temp_solution[k], temp_solution[i]\n\n        # Calculate new costs\n        new_cost1 = sum(distance_matrix_1[temp_solution[m], temp_solution[(m+1)%n]] for m in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[m], temp_solution[(m+1)%n]] for m in range(n))\n\n        # Accept if at least one objective improves\n        if (new_cost1 < best_cost1) or (new_cost2 < best_cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_swap = (i, k)\n\n    if best_swap is not None:\n        i, k = best_swap\n        new_solution[i], new_solution[k] = new_solution[k], new_solution[i]\n    else:\n        # If no improvement found, perform a random 2-opt\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 255,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic partial tour reversal operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and reversed segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If the reversal improves both objectives, keep it; otherwise, revert\n    if not (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6680558573984366,
            0.7877118587493896
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the selected segment\n    new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and reversed segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    reversed_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n    reversed_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(a, b+1))\n\n    # If the reversal improves both objectives, keep it; otherwise, revert\n    if not (reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2):\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 256,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective score (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: x[0] + x[1])\n    selected_idx = objectives.index(max_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping\n    if b >= c:\n        c, d = b + 1, d + 1\n        if d >= n:\n            c, d = 0, 1\n\n    # Swap the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Validate the solution is a valid tour\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to random swap if validation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9271291784736835,
            0.12459492683410645
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective score (sum of normalized objectives)\n    objectives = [obj for _, obj in archive]\n    max_obj = max(objectives, key=lambda x: x[0] + x[1])\n    selected_idx = objectives.index(max_obj)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two segments to swap\n    a, b = sorted(random.sample(range(n), 2))\n    c, d = sorted(random.sample(range(n), 2))\n\n    # Ensure segments are non-overlapping\n    if b >= c:\n        c, d = b + 1, d + 1\n        if d >= n:\n            c, d = 0, 1\n\n    # Swap the segments\n    segment1 = new_solution[a:b+1]\n    segment2 = new_solution[c:d+1]\n    new_solution = np.concatenate([\n        new_solution[:a],\n        segment2,\n        new_solution[b+1:c],\n        segment1,\n        new_solution[d+1:]\n    ])\n\n    # Validate the solution is a valid tour\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n        # Fallback to random swap if validation fails\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 257,
        "algorithm": "{This novel algorithm employs a multi-objective aware edge inversion strategy that dynamically selects and inverts segments of the tour based on their potential to reduce costs in both objective spaces, while using a probabilistic acceptance criterion to escape local optima and maintain diversity.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the cost of the inverted segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the cost of the entire tour with the inverted segment\n    temp_solution = new_solution.copy()\n    temp_solution[a:a+segment_length] = inverted_segment\n    total_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate the improvement in both objectives\n    improvement1 = segment_cost1 - inverted_cost1\n    improvement2 = segment_cost2 - inverted_cost2\n\n    # Accept the inversion if it improves at least one objective\n    if improvement1 > 0 or improvement2 > 0:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a probabilistic acceptance\n        if random.random() < 0.1:  # 10% chance to accept anyway\n            new_solution = temp_solution\n        else:\n            # If not accepted, perform a random edge swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9800500546426043,
            0.21354395151138306
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to invert\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the cost of the inverted segment\n    inverted_segment = segment[::-1]\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate the cost of the entire tour with the inverted segment\n    temp_solution = new_solution.copy()\n    temp_solution[a:a+segment_length] = inverted_segment\n    total_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    total_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Calculate the improvement in both objectives\n    improvement1 = segment_cost1 - inverted_cost1\n    improvement2 = segment_cost2 - inverted_cost2\n\n    # Accept the inversion if it improves at least one objective\n    if improvement1 > 0 or improvement2 > 0:\n        new_solution = temp_solution\n    else:\n        # If no improvement, perform a probabilistic acceptance\n        if random.random() < 0.1:  # 10% chance to accept anyway\n            new_solution = temp_solution\n        else:\n            # If not accepted, perform a random edge swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 258,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and uses a probabilistic selection of segments based on their potential improvement in both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    # Probabilistically select candidate positions based on potential improvement\n    candidate_positions = random.sample(range(n), min(10, n))\n    for pos in candidate_positions:\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 or new_cost2 < cost2):\n            if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5 or (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]) < (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8491380484914111,
            0.4007159471511841
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    # Probabilistically select candidate positions based on potential improvement\n    candidate_positions = random.sample(range(n), min(10, n))\n    for pos in candidate_positions:\n        if pos >= a and pos <= b:\n            continue\n\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 or new_cost2 < cost2):\n            if (new_cost1 + new_cost2) < (best_cost1 + best_cost2):\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5 or (distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]) < (distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 259,
        "algorithm": "{A novel adaptive local search strategy combines a multi-objective edge replacement criterion with a dynamic segment reversal operator that selectively inverts segments based on their potential to improve both objectives, while ensuring feasibility through a comprehensive validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Only reverse if it improves both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If no improvement, perform a random edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9707744370134359,
            0.19571512937545776
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and reverse it\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    # Calculate the cost of the original and reversed segments in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # Only reverse if it improves both objectives\n    if reversed_cost1 < original_cost1 and reversed_cost2 < original_cost2:\n        new_solution[a:b+1] = reversed_segment\n    else:\n        # If no improvement, perform a random edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 260,
        "algorithm": "{This new algorithm uses a weighted segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, with a modified scoring function that emphasizes balanced improvements across objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9161986848346194,
            0.3562564253807068
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 261,
        "algorithm": "{This new algorithm uses a multi-objective edge selection criterion to identify critical edges in both objective spaces, then applies a dynamic segment relocation operator that prioritizes edges with high potential for cost reduction while ensuring feasibility through a comprehensive validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges based on both objectives\n    edge_scores = []\n    for i in range(n):\n        prev_node = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n        score1 = distance_matrix_1[prev_node, next_node]\n        score2 = distance_matrix_2[prev_node, next_node]\n        combined_score = score1 * 0.7 + score2 * 0.3  # Weighted combination\n        edge_scores.append((combined_score, i))\n\n    # Sort edges by score (ascending) to prioritize worst edges\n    edge_scores.sort(key=lambda x: x[0])\n    worst_edges = [idx for (score, idx) in edge_scores[:max(2, n//10)]]\n\n    # Apply dynamic segment relocation\n    for edge_idx in worst_edges:\n        i = edge_idx\n        j = (i + 1) % n\n\n        # Try removing the edge and reconnecting\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, j)\n\n        # Find best insertion point\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            if pos == i or pos == i+1:\n                continue\n\n            # Try inserting between pos and (pos+1)\n            candidate = np.insert(temp_solution, pos, new_solution[j])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Use weighted sum as selection criterion\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, new_solution[j])\n\n    return new_solution\n\n",
        "score": [
            -0.5085309649649024,
            2.2669217586517334
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    current_obj1, current_obj2 = archive[selected_idx][1]\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical edges based on both objectives\n    edge_scores = []\n    for i in range(n):\n        prev_node = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n        score1 = distance_matrix_1[prev_node, next_node]\n        score2 = distance_matrix_2[prev_node, next_node]\n        combined_score = score1 * 0.7 + score2 * 0.3  # Weighted combination\n        edge_scores.append((combined_score, i))\n\n    # Sort edges by score (ascending) to prioritize worst edges\n    edge_scores.sort(key=lambda x: x[0])\n    worst_edges = [idx for (score, idx) in edge_scores[:max(2, n//10)]]\n\n    # Apply dynamic segment relocation\n    for edge_idx in worst_edges:\n        i = edge_idx\n        j = (i + 1) % n\n\n        # Try removing the edge and reconnecting\n        temp_solution = new_solution.copy()\n        temp_solution = np.delete(temp_solution, j)\n\n        # Find best insertion point\n        best_pos = -1\n        best_cost = float('inf')\n\n        for pos in range(len(temp_solution)):\n            if pos == i or pos == i+1:\n                continue\n\n            # Try inserting between pos and (pos+1)\n            candidate = np.insert(temp_solution, pos, new_solution[j])\n\n            # Calculate new costs\n            cost1 = sum(distance_matrix_1[candidate[k], candidate[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[candidate[k], candidate[(k+1)%n]] for k in range(n))\n\n            # Use weighted sum as selection criterion\n            total_cost = cost1 * 0.7 + cost2 * 0.3\n\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_pos = pos\n\n        if best_pos != -1:\n            new_solution = np.insert(temp_solution, best_pos, new_solution[j])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 262,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reinsertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = base_solution[node_idx]\n\n    # Create a new solution by removing the selected node\n    new_solution = np.delete(base_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the node in the new solution\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(len(new_solution)):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n",
        "score": [
            -0.8629887556387951,
            0.7298611998558044
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Randomly select a node to reinsert\n    node_idx = random.randint(0, n - 1)\n    node = base_solution[node_idx]\n\n    # Create a new solution by removing the selected node\n    new_solution = np.delete(base_solution, node_idx)\n\n    # Calculate the cost of the current solution\n    current_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best insertion point for the node in the new solution\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(len(new_solution)):\n        # Try inserting the node at position 'pos'\n        temp_solution = np.insert(new_solution, pos, node)\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if (new_cost1 < current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 <= current_cost1 and new_cost2 < current_cost2) or \\\n           (new_cost1 < current_cost1 and new_cost2 <= current_cost2):\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.insert(new_solution, best_insert_pos, node)\n    else:\n        # If no better insertion found, perform a random insertion\n        pos = random.randint(0, len(new_solution))\n        new_solution = np.insert(new_solution, pos, node)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 263,
        "algorithm": "{This new algorithm uses a multi-objective segment inversion strategy that evaluates the impact of reversing segments on both objectives, prioritizing inversions that create high-quality edges while maintaining feasibility through a dynamic validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n    inverted_segment = segment[::-1]\n\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    if inverted_cost1 + inverted_cost2 < original_cost1 + original_cost2:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7645447017098508,
            0.5632570385932922
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n    inverted_segment = segment[::-1]\n\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    if inverted_cost1 + inverted_cost2 < original_cost1 + original_cost2:\n        new_solution[a:a+segment_length] = inverted_segment\n\n    if random.random() < 0.4:\n        i, j = random.sample(range(n), 2)\n        if distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] < \\\n           distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j-1], new_solution[j]]:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 264,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8697597570184686,
            0.45407670736312866
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n\n    # Generate a neighbor using a hybrid local search operator\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 265,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic path inversion operator that considers both objective spaces, prioritizing segments with high potential for cost reduction while maintaining feasibility through a validation mechanism and ensuring the solution remains a valid tour.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a path inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Check if inversion improves both objectives\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or random.random() < 0.3:\n        # Apply the inversion\n        new_solution[a:b+1] = segment\n\n        # Validate the solution\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If inversion didn't help, perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8658822274716764,
            0.20456773042678833
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a path inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1][::-1]\n\n    # Calculate the cost of the original and inverted segments in both objectives\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, b+1))\n\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Check if inversion improves both objectives\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or random.random() < 0.3:\n        # Apply the inversion\n        new_solution[a:b+1] = segment\n\n        # Validate the solution\n        if len(set(new_solution)) == n:\n            return new_solution\n\n    # If inversion didn't help, perform a random edge swap\n    i, j = random.sample(range(n), 2)\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 266,
        "algorithm": "{This novel algorithm employs a multi-objective edge refinement strategy that dynamically evaluates and replaces edges based on their contribution to both objectives, using a Pareto dominance-aware selection criterion to prioritize improvements while maintaining tour feasibility through a constrained neighborhood exploration.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify edges with potential for improvement\n    edge_improvements = []\n    for i in range(n):\n        current_node = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate current edge costs\n        current_cost1 = distance_matrix_1[current_node, next_node]\n        current_cost2 = distance_matrix_2[current_node, next_node]\n\n        # Find potential replacements (nodes not adjacent to current edge)\n        candidates = [j for j in range(n) if j not in {i, (i+1)%n, (i-1)%n}]\n\n        for candidate in candidates:\n            # Calculate new edge costs\n            new_cost1 = distance_matrix_1[current_node, candidate] + distance_matrix_1[candidate, next_node]\n            new_cost2 = distance_matrix_2[current_node, candidate] + distance_matrix_2[candidate, next_node]\n\n            # Check if replacement improves at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                # Calculate improvement score (weighted sum)\n                improvement_score = 0.6 * (current_cost1 - new_cost1) + 0.4 * (current_cost2 - new_cost2)\n                edge_improvements.append((improvement_score, i, candidate))\n\n    if edge_improvements:\n        # Select the edge with highest improvement score\n        edge_improvements.sort(reverse=True, key=lambda x: x[0])\n        _, edge_idx, candidate = edge_improvements[0]\n\n        # Apply the edge refinement\n        new_solution = base_solution.copy()\n        new_solution[edge_idx] = candidate\n    else:\n        # If no improvements found, perform a constrained random insertion\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            new_solution = np.concatenate([base_solution[:a], [base_solution[b]], base_solution[a+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.79289768625856,
            0.39252740144729614
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify edges with potential for improvement\n    edge_improvements = []\n    for i in range(n):\n        current_node = base_solution[i]\n        next_node = base_solution[(i+1)%n]\n\n        # Calculate current edge costs\n        current_cost1 = distance_matrix_1[current_node, next_node]\n        current_cost2 = distance_matrix_2[current_node, next_node]\n\n        # Find potential replacements (nodes not adjacent to current edge)\n        candidates = [j for j in range(n) if j not in {i, (i+1)%n, (i-1)%n}]\n\n        for candidate in candidates:\n            # Calculate new edge costs\n            new_cost1 = distance_matrix_1[current_node, candidate] + distance_matrix_1[candidate, next_node]\n            new_cost2 = distance_matrix_2[current_node, candidate] + distance_matrix_2[candidate, next_node]\n\n            # Check if replacement improves at least one objective\n            if (new_cost1 < current_cost1) or (new_cost2 < current_cost2):\n                # Calculate improvement score (weighted sum)\n                improvement_score = 0.6 * (current_cost1 - new_cost1) + 0.4 * (current_cost2 - new_cost2)\n                edge_improvements.append((improvement_score, i, candidate))\n\n    if edge_improvements:\n        # Select the edge with highest improvement score\n        edge_improvements.sort(reverse=True, key=lambda x: x[0])\n        _, edge_idx, candidate = edge_improvements[0]\n\n        # Apply the edge refinement\n        new_solution = base_solution.copy()\n        new_solution[edge_idx] = candidate\n    else:\n        # If no improvements found, perform a constrained random insertion\n        a = random.randint(0, n-1)\n        b = random.randint(0, n-1)\n        if a != b:\n            new_solution = np.concatenate([base_solution[:a], [base_solution[b]], base_solution[a+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 267,
        "algorithm": "{This new algorithm uses a hybrid segment relocation and edge inversion strategy that evaluates segment contributions across both objectives while incorporating probabilistic inversion of edges to escape local optima and maintain solution feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements with dynamic weights\n        weight1 = 0.6 if random.random() < 0.4 else 0.4\n        weight2 = 1 - weight1\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge inversion\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        if random.random() < 0.4:  # 40% chance to invert\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.960351706825773,
            0.4078095555305481
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements with dynamic weights\n        weight1 = 0.6 if random.random() < 0.4 else 0.4\n        weight2 = 1 - weight1\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge inversion\n        i = random.randint(0, n - 2)\n        j = random.randint(i + 1, n - 1)\n        if random.random() < 0.4:  # 40% chance to invert\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 268,
        "algorithm": "{This new algorithm employs a multi-objective edge-swapping strategy that dynamically selects and swaps edges based on their potential to reduce both objectives while maintaining feasibility through a probabilistic edge validation mechanism, combining both segment-based and edge-based improvements.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by dominance)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a set of edges to evaluate\n    num_edges = min(5, n // 2)\n    edge_indices = random.sample(range(n), num_edges)\n\n    # Evaluate each edge for potential improvement\n    for i in edge_indices:\n        j = (i + 1) % n\n        current_edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best alternative edge\n        best_improvement = 0\n        best_k = -1\n        best_l = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n                continue\n            l = (k + 1) % n\n\n            # Calculate potential new edge costs\n            new_edge1_cost1 = distance_matrix_1[new_solution[i], new_solution[l]]\n            new_edge2_cost1 = distance_matrix_1[new_solution[k], new_solution[j]]\n            improvement1 = (current_edge_cost1 - (new_edge1_cost1 + new_edge2_cost1)) * 0.6\n\n            new_edge1_cost2 = distance_matrix_2[new_solution[i], new_solution[l]]\n            new_edge2_cost2 = distance_matrix_2[new_solution[k], new_solution[j]]\n            improvement2 = (current_edge_cost2 - (new_edge1_cost2 + new_edge2_cost2)) * 0.4\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_k = k\n                best_l = l\n\n        # Apply the best edge swap if beneficial\n        if best_improvement > 0 and random.random() < 0.7:  # 70% chance to accept\n            new_solution[i], new_solution[best_l] = new_solution[best_l], new_solution[i]\n            new_solution[(best_k + 1) % n], new_solution[j] = new_solution[j], new_solution[(best_k + 1) % n]\n\n    # If no improvement, perform a random segment reversal\n    if new_solution.tolist() == base_solution.tolist():\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9173290242779671,
            0.3629959225654602
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by dominance)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a set of edges to evaluate\n    num_edges = min(5, n // 2)\n    edge_indices = random.sample(range(n), num_edges)\n\n    # Evaluate each edge for potential improvement\n    for i in edge_indices:\n        j = (i + 1) % n\n        current_edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n        current_edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n        # Find the best alternative edge\n        best_improvement = 0\n        best_k = -1\n        best_l = -1\n\n        for k in range(n):\n            if k == i or k == j or k == (i - 1) % n or k == (j + 1) % n:\n                continue\n            l = (k + 1) % n\n\n            # Calculate potential new edge costs\n            new_edge1_cost1 = distance_matrix_1[new_solution[i], new_solution[l]]\n            new_edge2_cost1 = distance_matrix_1[new_solution[k], new_solution[j]]\n            improvement1 = (current_edge_cost1 - (new_edge1_cost1 + new_edge2_cost1)) * 0.6\n\n            new_edge1_cost2 = distance_matrix_2[new_solution[i], new_solution[l]]\n            new_edge2_cost2 = distance_matrix_2[new_solution[k], new_solution[j]]\n            improvement2 = (current_edge_cost2 - (new_edge1_cost2 + new_edge2_cost2)) * 0.4\n\n            total_improvement = improvement1 + improvement2\n\n            if total_improvement > best_improvement:\n                best_improvement = total_improvement\n                best_k = k\n                best_l = l\n\n        # Apply the best edge swap if beneficial\n        if best_improvement > 0 and random.random() < 0.7:  # 70% chance to accept\n            new_solution[i], new_solution[best_l] = new_solution[best_l], new_solution[i]\n            new_solution[(best_k + 1) % n], new_solution[j] = new_solution[j], new_solution[(best_k + 1) % n]\n\n    # If no improvement, perform a random segment reversal\n    if new_solution.tolist() == base_solution.tolist():\n        a, b = sorted(random.sample(range(n), 2))\n        new_solution[a:b+1] = new_solution[a:b+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 269,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1) or (new_cost2 < cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8966893704978658,
            0.47953301668167114
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1) or (new_cost2 < cost2):\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 270,
        "algorithm": "{This algorithm implements a hybrid local search strategy that combines multi-objective edge prioritization with a dynamic segment relocation mechanism, where promising segments are identified based on their potential to reduce costs in both objective spaces while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a segment reversal\n        if len(segment) > 1:\n            new_solution[a:b+1] = segment[::-1]\n        else:\n            # If segment is single node, perform a random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9475789812657576,
            0.4624902606010437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a segment reversal\n        if len(segment) > 1:\n            new_solution[a:b+1] = segment[::-1]\n        else:\n            # If segment is single node, perform a random swap\n            i, j = random.sample(range(n), 2)\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 271,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node relocation operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (for diversification)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor using a dynamic node relocation operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's connections\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best position to insert the node\n    best_pos = -1\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and adjacent positions\n\n        # Calculate the new cost if we insert the node at position 'pos'\n        prev_node_new = new_solution[pos - 1]\n        next_node_new = new_solution[pos]\n        new_cost1 = distance_matrix_1[prev_node_new, node] + distance_matrix_1[node, next_node_new]\n        new_cost2 = distance_matrix_2[prev_node_new, node] + distance_matrix_2[node, next_node_new]\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1 = new_cost1\n            best_cost2 = new_cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # If no better position found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9248038363527494,
            0.24150556325912476
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (for diversification)\n    selected_solution, _ = max(archive, key=lambda x: sum(x[1]))\n    base_solution = selected_solution.copy()\n\n    # Generate a neighbor using a dynamic node relocation operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to relocate\n    node_idx = random.randint(0, n - 1)\n    node = new_solution[node_idx]\n\n    # Calculate the current cost of the node's connections\n    prev_node = new_solution[node_idx - 1]\n    next_node = new_solution[(node_idx + 1) % n]\n    current_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    current_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Find the best position to insert the node\n    best_pos = -1\n    best_cost1 = float('inf')\n    best_cost2 = float('inf')\n\n    for pos in range(n):\n        if pos == node_idx or pos == (node_idx - 1) % n:\n            continue  # Skip the current position and adjacent positions\n\n        # Calculate the new cost if we insert the node at position 'pos'\n        prev_node_new = new_solution[pos - 1]\n        next_node_new = new_solution[pos]\n        new_cost1 = distance_matrix_1[prev_node_new, node] + distance_matrix_1[node, next_node_new]\n        new_cost2 = distance_matrix_2[prev_node_new, node] + distance_matrix_2[node, next_node_new]\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1 = new_cost1\n            best_cost2 = new_cost2\n            best_pos = pos\n\n    if best_pos != -1:\n        # Remove the node from its current position\n        new_solution = np.delete(new_solution, node_idx)\n\n        # Insert the node at the best position\n        new_solution = np.insert(new_solution, best_pos, node)\n    else:\n        # If no better position found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 272,
        "algorithm": "{This algorithm employs a hybrid of adaptive segment inversion and dynamic edge insertion, where it first identifies critical segments based on their contribution to both objectives, then inverts them to explore new configurations, followed by a targeted edge insertion that considers the combined potential for improvement in both spaces while maintaining feasibility through a feasibility-preserving mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on edge contributions\n    segment_length = random.randint(3, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment to explore new configurations\n    inverted_segment = segment[::-1]\n    temp_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[a+segment_length:]])\n\n    # Calculate the cost change\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Accept the inversion if it improves at least one objective\n    if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n        new_solution = temp_solution.copy()\n    else:\n        # If inversion doesn't help, perform targeted edge insertion\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential insertion cost\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n], distance_matrix_1[new_solution[i], new_solution[(i+1)%n]], distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]),\n            (new_solution[j], new_solution[(j+1)%n], distance_matrix_1[new_solution[j], new_solution[(j+1)%n]], distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_edges = [\n            (new_solution[i], new_solution[j], distance_matrix_1[new_solution[i], new_solution[j]], distance_matrix_2[new_solution[i], new_solution[j]]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n], distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]], distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate cost difference\n        delta_cost1 = (new_edges[0][2] + new_edges[1][2]) - (old_edges[0][2] + old_edges[1][2])\n        delta_cost2 = (new_edges[0][3] + new_edges[1][3]) - (old_edges[1][3] + old_edges[1][3])\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0:\n            # Perform the insertion\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j+1], new_solution[i:j:-1], new_solution[i+1:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9151691952010306,
            0.4209325313568115
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Identify critical segments based on edge contributions\n    segment_length = random.randint(3, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Invert the segment to explore new configurations\n    inverted_segment = segment[::-1]\n    temp_solution = np.concatenate([new_solution[:a], inverted_segment, new_solution[a+segment_length:]])\n\n    # Calculate the cost change\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n    new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n    new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n    # Accept the inversion if it improves at least one objective\n    if new_cost1 < original_cost1 or new_cost2 < original_cost2:\n        new_solution = temp_solution.copy()\n    else:\n        # If inversion doesn't help, perform targeted edge insertion\n        i = random.randint(0, n - 1)\n        j = random.randint(0, n - 1)\n        while j == i or j == (i + 1) % n or j == (i - 1) % n:\n            j = random.randint(0, n - 1)\n\n        # Calculate potential insertion cost\n        old_edges = [\n            (new_solution[i], new_solution[(i+1)%n], distance_matrix_1[new_solution[i], new_solution[(i+1)%n]], distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]),\n            (new_solution[j], new_solution[(j+1)%n], distance_matrix_1[new_solution[j], new_solution[(j+1)%n]], distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n        ]\n\n        new_edges = [\n            (new_solution[i], new_solution[j], distance_matrix_1[new_solution[i], new_solution[j]], distance_matrix_2[new_solution[i], new_solution[j]]),\n            (new_solution[(i+1)%n], new_solution[(j+1)%n], distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]], distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]])\n        ]\n\n        # Calculate cost difference\n        delta_cost1 = (new_edges[0][2] + new_edges[1][2]) - (old_edges[0][2] + old_edges[1][2])\n        delta_cost2 = (new_edges[0][3] + new_edges[1][3]) - (old_edges[1][3] + old_edges[1][3])\n\n        # Accept if it improves at least one objective\n        if delta_cost1 < 0 or delta_cost2 < 0:\n            # Perform the insertion\n            if i < j:\n                new_solution = np.concatenate([new_solution[:i+1], new_solution[j:i:-1], new_solution[j+1:]])\n            else:\n                new_solution = np.concatenate([new_solution[:j+1], new_solution[i:j:-1], new_solution[i+1:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 273,
        "algorithm": "{This new algorithm uses a dynamic edge exchange strategy that evaluates node contributions across both objectives, prioritizing nodes with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, with a score function that dynamically adjusts weights based on the relative improvement in each objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to evaluate for exchange\n    node = random.randint(0, n - 1)\n    neighbors = [i for i in range(n) if i != node]\n\n    # Calculate node cost in both objectives\n    prev_node = base_solution[node - 1]\n    next_node = base_solution[(node + 1) % n]\n    node_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    node_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Evaluate potential exchange neighbors\n    best_score = -float('inf')\n    best_neighbor = -1\n\n    for neighbor in neighbors:\n        # Calculate cost change if node is exchanged with neighbor\n        new_prev = base_solution[neighbor - 1]\n        new_next = base_solution[(neighbor + 1) % n]\n\n        new_cost1 = (distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next] +\n                     distance_matrix_1[prev_node, neighbor] + distance_matrix_1[neighbor, next_node])\n        new_cost2 = (distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next] +\n                     distance_matrix_2[prev_node, neighbor] + distance_matrix_2[neighbor, next_node])\n\n        # Dynamic score function: weighted by relative improvement\n        improvement1 = node_cost1 - (new_cost1 - node_cost1)\n        improvement2 = node_cost2 - (new_cost2 - node_cost2)\n        total_improvement = improvement1 + improvement2\n\n        if total_improvement > 0:\n            weight1 = improvement1 / total_improvement if total_improvement > 0 else 0.5\n            weight2 = improvement2 / total_improvement if total_improvement > 0 else 0.5\n            score = weight1 * improvement1 + weight2 * improvement2\n        else:\n            score = -total_improvement  # Penalize negative improvements\n\n        if score > best_score:\n            best_score = score\n            best_neighbor = neighbor\n\n    if best_neighbor != -1:\n        # Perform the exchange\n        new_solution[node], new_solution[best_neighbor] = new_solution[best_neighbor], new_solution[node]\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8335052126257337,
            0.2649804949760437
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a node to evaluate for exchange\n    node = random.randint(0, n - 1)\n    neighbors = [i for i in range(n) if i != node]\n\n    # Calculate node cost in both objectives\n    prev_node = base_solution[node - 1]\n    next_node = base_solution[(node + 1) % n]\n    node_cost1 = distance_matrix_1[prev_node, node] + distance_matrix_1[node, next_node]\n    node_cost2 = distance_matrix_2[prev_node, node] + distance_matrix_2[node, next_node]\n\n    # Evaluate potential exchange neighbors\n    best_score = -float('inf')\n    best_neighbor = -1\n\n    for neighbor in neighbors:\n        # Calculate cost change if node is exchanged with neighbor\n        new_prev = base_solution[neighbor - 1]\n        new_next = base_solution[(neighbor + 1) % n]\n\n        new_cost1 = (distance_matrix_1[new_prev, node] + distance_matrix_1[node, new_next] +\n                     distance_matrix_1[prev_node, neighbor] + distance_matrix_1[neighbor, next_node])\n        new_cost2 = (distance_matrix_2[new_prev, node] + distance_matrix_2[node, new_next] +\n                     distance_matrix_2[prev_node, neighbor] + distance_matrix_2[neighbor, next_node])\n\n        # Dynamic score function: weighted by relative improvement\n        improvement1 = node_cost1 - (new_cost1 - node_cost1)\n        improvement2 = node_cost2 - (new_cost2 - node_cost2)\n        total_improvement = improvement1 + improvement2\n\n        if total_improvement > 0:\n            weight1 = improvement1 / total_improvement if total_improvement > 0 else 0.5\n            weight2 = improvement2 / total_improvement if total_improvement > 0 else 0.5\n            score = weight1 * improvement1 + weight2 * improvement2\n        else:\n            score = -total_improvement  # Penalize negative improvements\n\n        if score > best_score:\n            best_score = score\n            best_neighbor = neighbor\n\n    if best_neighbor != -1:\n        # Perform the exchange\n        new_solution[node], new_solution[best_neighbor] = new_solution[best_neighbor], new_solution[node]\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 274,
        "algorithm": "{This new algorithm employs a multi-objective segment inversion strategy that dynamically evaluates and inverts promising segments based on their potential for cost reduction in both objective spaces, while maintaining tour feasibility through a probabilistic feasibility check and a novel segment reinsertion mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse cost sum)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    segment_length = random.randint(2, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n    inverted_segment = segment[::-1]\n\n    # Calculate original and inverted segment costs\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Check if inversion improves both objectives\n    if inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2:\n        new_solution[a:a+segment_length] = inverted_segment\n        return new_solution\n\n    # If inversion doesn't help, try reinserting the segment after inversion\n    temp_solution = new_solution.copy()\n    temp_solution[a:a+segment_length] = inverted_segment\n\n    # Find best insertion point for the inverted segment\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the inverted segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (original_cost1 - (cost1 - original_cost1)) * 0.6 + (original_cost2 - (cost2 - original_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], inverted_segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.913851445116305,
            0.33872658014297485
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse cost sum)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment and invert it\n    segment_length = random.randint(2, min(6, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n    inverted_segment = segment[::-1]\n\n    # Calculate original and inverted segment costs\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Check if inversion improves both objectives\n    if inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2:\n        new_solution[a:a+segment_length] = inverted_segment\n        return new_solution\n\n    # If inversion doesn't help, try reinserting the segment after inversion\n    temp_solution = new_solution.copy()\n    temp_solution[a:a+segment_length] = inverted_segment\n\n    # Find best insertion point for the inverted segment\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the inverted segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], inverted_segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (original_cost1 - (cost1 - original_cost1)) * 0.6 + (original_cost2 - (cost2 - original_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], inverted_segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 275,
        "algorithm": "{A novel hybrid local search strategy uses a multi-objective edge prioritization mechanism that combines dominance-based selection with a dynamic path relinking operator, which selectively transfers promising sub-tours between solutions while maintaining feasibility through a validation mechanism that ensures all nodes remain visited exactly once.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct nodes to relink paths\n    a, b = random.sample(range(n), 2)\n\n    # Find the paths between these nodes in the current solution\n    idx_a = np.where(base_solution == a)[0][0]\n    idx_b = np.where(base_solution == b)[0][0]\n\n    if idx_a > idx_b:\n        idx_a, idx_b = idx_b, idx_a\n\n    # Extract the two paths between a and b\n    path1 = base_solution[idx_a:idx_b+1]\n    path2 = np.concatenate([base_solution[idx_b:], base_solution[:idx_a+1]])\n\n    # Calculate the cost of both paths in both objectives\n    cost1_path1 = sum(distance_matrix_1[path1[i], path1[(i+1)%len(path1)]] for i in range(len(path1)))\n    cost2_path1 = sum(distance_matrix_2[path1[i], path1[(i+1)%len(path1)]] for i in range(len(path1)))\n\n    cost1_path2 = sum(distance_matrix_1[path2[i], path2[(i+1)%len(path2)]] for i in range(len(path2)))\n    cost2_path2 = sum(distance_matrix_2[path2[i], path2[(i+1)%len(path2)]] for i in range(len(path2)))\n\n    # Determine which path is better in both objectives\n    if (cost1_path1 < cost1_path2 and cost2_path1 < cost2_path2) or random.random() < 0.3:\n        # Use path1 if it's better or with 30% probability\n        new_solution = np.concatenate([base_solution[:idx_a], path1, base_solution[idx_b+1:idx_a]])\n    else:\n        # Otherwise use path2\n        new_solution = np.concatenate([path2[:len(path2)-len(base_solution[:idx_a+1])],\n                                      base_solution[:idx_a+1],\n                                      path2[len(path2)-len(base_solution[:idx_a+1]):]])\n\n    # Ensure the solution is valid (all nodes are visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.6557376100874122,
            2.4483072757720947
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two distinct nodes to relink paths\n    a, b = random.sample(range(n), 2)\n\n    # Find the paths between these nodes in the current solution\n    idx_a = np.where(base_solution == a)[0][0]\n    idx_b = np.where(base_solution == b)[0][0]\n\n    if idx_a > idx_b:\n        idx_a, idx_b = idx_b, idx_a\n\n    # Extract the two paths between a and b\n    path1 = base_solution[idx_a:idx_b+1]\n    path2 = np.concatenate([base_solution[idx_b:], base_solution[:idx_a+1]])\n\n    # Calculate the cost of both paths in both objectives\n    cost1_path1 = sum(distance_matrix_1[path1[i], path1[(i+1)%len(path1)]] for i in range(len(path1)))\n    cost2_path1 = sum(distance_matrix_2[path1[i], path1[(i+1)%len(path1)]] for i in range(len(path1)))\n\n    cost1_path2 = sum(distance_matrix_1[path2[i], path2[(i+1)%len(path2)]] for i in range(len(path2)))\n    cost2_path2 = sum(distance_matrix_2[path2[i], path2[(i+1)%len(path2)]] for i in range(len(path2)))\n\n    # Determine which path is better in both objectives\n    if (cost1_path1 < cost1_path2 and cost2_path1 < cost2_path2) or random.random() < 0.3:\n        # Use path1 if it's better or with 30% probability\n        new_solution = np.concatenate([base_solution[:idx_a], path1, base_solution[idx_b+1:idx_a]])\n    else:\n        # Otherwise use path2\n        new_solution = np.concatenate([path2[:len(path2)-len(base_solution[:idx_a+1])],\n                                      base_solution[:idx_a+1],\n                                      path2[len(path2)-len(base_solution[:idx_a+1]):]])\n\n    # Ensure the solution is valid (all nodes are visited exactly once)\n    if len(np.unique(new_solution)) != n:\n        # If invalid, revert to the original solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 276,
        "algorithm": "{This new algorithm uses a hybrid segment inversion and edge flipping strategy that dynamically evaluates node contributions across both objectives, prioritizing inversions of high-cost segments while probabilistically flipping edges based on their combined objective improvement potential.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and invert it\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length][::-1]  # Invert the segment\n\n    # Calculate original and inverted segment costs\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, a+segment_length))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, a+segment_length))\n\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Apply inversion if it improves at least one objective\n    if (inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2):\n        new_solution[a:a+segment_length] = segment\n\n    # Probabilistic edge flipping based on combined objective improvement\n    for i in range(n):\n        j = (i + random.randint(1, n//2)) % n\n        if i != j:\n            original_edge_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            flipped_edge_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            if flipped_edge_cost < original_edge_cost and random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.6647409203088008,
            0.28425002098083496
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and invert it\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length][::-1]  # Invert the segment\n\n    # Calculate original and inverted segment costs\n    original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(a, a+segment_length))\n    original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(a, a+segment_length))\n\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Apply inversion if it improves at least one objective\n    if (inverted_cost1 < original_cost1 or inverted_cost2 < original_cost2):\n        new_solution[a:a+segment_length] = segment\n\n    # Probabilistic edge flipping based on combined objective improvement\n    for i in range(n):\n        j = (i + random.randint(1, n//2)) % n\n        if i != j:\n            original_edge_cost = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n            flipped_edge_cost = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[i], new_solution[j]]\n\n            if flipped_edge_cost < original_edge_cost and random.random() < 0.5:\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 277,
        "algorithm": "{This new algorithm employs a dynamic path fusion strategy that combines segments from multiple solutions in the archive, prioritizing edges with high potential for cost reduction in either objective space while ensuring feasibility through a multi-objective validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple solutions for fusion\n    selected_indices = random.sample(range(len(archive)), min(3, len(archive)))\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    n = len(selected_solutions[0])\n    new_solution = np.zeros(n, dtype=int)\n    used_nodes = set()\n\n    # Randomly select a starting node from one solution\n    start_node = random.choice(selected_solutions[0])\n    new_solution[0] = start_node\n    used_nodes.add(start_node)\n    current_node = start_node\n\n    for i in range(1, n):\n        # Evaluate potential next nodes from all selected solutions\n        candidates = []\n        for sol in selected_solutions:\n            # Find the position of current_node in this solution\n            pos = np.where(sol == current_node)[0][0]\n            next_node = sol[(pos + 1) % n]\n\n            if next_node not in used_nodes:\n                # Calculate edge costs\n                cost1 = distance_matrix_1[current_node, next_node]\n                cost2 = distance_matrix_2[current_node, next_node]\n                candidates.append((next_node, cost1, cost2))\n\n        if not candidates:\n            # Fallback: select any unused node\n            available_nodes = [node for node in range(n) if node not in used_nodes]\n            next_node = random.choice(available_nodes)\n        else:\n            # Select node with best combined cost\n            weights = [(1/(cost1 + 1e-6)) * 0.6 + (1/(cost2 + 1e-6)) * 0.4 for (_, cost1, cost2) in candidates]\n            next_node = random.choices([node for (node, _, _) in candidates], weights=weights, k=1)[0]\n\n        new_solution[i] = next_node\n        used_nodes.add(next_node)\n        current_node = next_node\n\n    # Validate the solution\n    if len(set(new_solution)) != n:\n        # Fallback: repair by removing duplicates and adding missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        for i in range(n):\n            if new_solution[i] in used_nodes:\n                continue\n            if missing:\n                new_solution[i] = missing.pop()\n            else:\n                # If no missing nodes, find a node not in current position\n                for node in range(n):\n                    if node not in new_solution:\n                        new_solution[i] = node\n                        break\n\n    return new_solution\n\n",
        "score": [
            -0.7163302519505595,
            0.38955867290496826
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select multiple solutions for fusion\n    selected_indices = random.sample(range(len(archive)), min(3, len(archive)))\n    selected_solutions = [archive[i][0] for i in selected_indices]\n\n    n = len(selected_solutions[0])\n    new_solution = np.zeros(n, dtype=int)\n    used_nodes = set()\n\n    # Randomly select a starting node from one solution\n    start_node = random.choice(selected_solutions[0])\n    new_solution[0] = start_node\n    used_nodes.add(start_node)\n    current_node = start_node\n\n    for i in range(1, n):\n        # Evaluate potential next nodes from all selected solutions\n        candidates = []\n        for sol in selected_solutions:\n            # Find the position of current_node in this solution\n            pos = np.where(sol == current_node)[0][0]\n            next_node = sol[(pos + 1) % n]\n\n            if next_node not in used_nodes:\n                # Calculate edge costs\n                cost1 = distance_matrix_1[current_node, next_node]\n                cost2 = distance_matrix_2[current_node, next_node]\n                candidates.append((next_node, cost1, cost2))\n\n        if not candidates:\n            # Fallback: select any unused node\n            available_nodes = [node for node in range(n) if node not in used_nodes]\n            next_node = random.choice(available_nodes)\n        else:\n            # Select node with best combined cost\n            weights = [(1/(cost1 + 1e-6)) * 0.6 + (1/(cost2 + 1e-6)) * 0.4 for (_, cost1, cost2) in candidates]\n            next_node = random.choices([node for (node, _, _) in candidates], weights=weights, k=1)[0]\n\n        new_solution[i] = next_node\n        used_nodes.add(next_node)\n        current_node = next_node\n\n    # Validate the solution\n    if len(set(new_solution)) != n:\n        # Fallback: repair by removing duplicates and adding missing nodes\n        missing = [node for node in range(n) if node not in new_solution]\n        for i in range(n):\n            if new_solution[i] in used_nodes:\n                continue\n            if missing:\n                new_solution[i] = missing.pop()\n            else:\n                # If no missing nodes, find a node not in current position\n                for node in range(n):\n                    if node not in new_solution:\n                        new_solution[i] = node\n                        break\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 278,
        "algorithm": "{A novel hybrid local search strategy that combines a multi-objective selection criterion with a dynamic edge exchange operator, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism, and incorporating a novel segment-based perturbation strategy to escape local optima.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and its cost\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost1 <= cost1 and new_cost2 < cost2):\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.8210652483126772,
            0.45656394958496094
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    total_weight = sum(weights)\n    probabilities = [w / total_weight for w in weights]\n    selected_idx = random.choices(range(len(archive)), weights=probabilities, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment and its cost\n    segment = new_solution[a:b+1]\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in at least one objective\n        if (new_cost1 < cost1 and new_cost2 <= cost2) or (new_cost1 <= cost1 and new_cost2 < cost2):\n            if new_cost1 + new_cost2 < best_cost1 + best_cost2:\n                best_cost1, best_cost2 = new_cost1, new_cost2\n                best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random 3-opt move\n        i, j, k = sorted(random.sample(range(n), 3))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n        new_solution[j:k+1] = new_solution[j:k+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 279,
        "algorithm": "{This new algorithm uses a dynamic node clustering and reinsertion strategy that groups nodes based on their spatial proximity in both objective spaces, then selectively reinserts entire clusters into the tour to exploit both objectives' structure while maintaining feasibility through a multi-criteria validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by combined inverse cost)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Cluster nodes based on their positions in both spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        # Calculate distance between consecutive nodes in both spaces\n        dist1 = distance_matrix_1[base_solution[i-1], base_solution[i]]\n        dist2 = distance_matrix_2[base_solution[i-1], base_solution[i]]\n\n        # If both distances are below thresholds, add to current cluster\n        if dist1 < 0.3 * np.mean(distance_matrix_1) and dist2 < 0.3 * np.mean(distance_matrix_2):\n            current_cluster.append(base_solution[i])\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [base_solution[i]]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # If no clusters found, perform a simple swap and return\n    if not clusters:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a random cluster to reinsert\n    selected_cluster = random.choice(clusters)\n    cluster_indices = [np.where(base_solution == node)[0][0] for node in selected_cluster]\n\n    # Remove the cluster from the solution\n    mask = np.ones(n, dtype=bool)\n    mask[cluster_indices] = False\n    temp_solution = base_solution[mask]\n\n    # Find best insertion point for the cluster\n    best_score = -float('inf')\n    best_pos = 0\n\n    for pos in range(len(temp_solution) + 1):\n        # Try inserting the cluster at position 'pos'\n        candidate = np.concatenate([temp_solution[:pos], selected_cluster, temp_solution[pos:]])\n\n        # Calculate cost for the candidate solution\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of normalized improvements\n        original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        score = ((original_cost1 - cost1) / (original_cost1 + 1e-6)) * 0.6 + ((original_cost2 - cost2) / (original_cost2 + 1e-6)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([temp_solution[:best_pos], selected_cluster, temp_solution[best_pos:]])\n\n    return new_solution\n\n",
        "score": [
            -0.9681100420885613,
            0.2967994213104248
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by combined inverse cost)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Cluster nodes based on their positions in both spaces\n    clusters = []\n    current_cluster = [base_solution[0]]\n    for i in range(1, n):\n        # Calculate distance between consecutive nodes in both spaces\n        dist1 = distance_matrix_1[base_solution[i-1], base_solution[i]]\n        dist2 = distance_matrix_2[base_solution[i-1], base_solution[i]]\n\n        # If both distances are below thresholds, add to current cluster\n        if dist1 < 0.3 * np.mean(distance_matrix_1) and dist2 < 0.3 * np.mean(distance_matrix_2):\n            current_cluster.append(base_solution[i])\n        else:\n            if len(current_cluster) > 1:\n                clusters.append(current_cluster)\n            current_cluster = [base_solution[i]]\n    if len(current_cluster) > 1:\n        clusters.append(current_cluster)\n\n    # If no clusters found, perform a simple swap and return\n    if not clusters:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n        return new_solution\n\n    # Select a random cluster to reinsert\n    selected_cluster = random.choice(clusters)\n    cluster_indices = [np.where(base_solution == node)[0][0] for node in selected_cluster]\n\n    # Remove the cluster from the solution\n    mask = np.ones(n, dtype=bool)\n    mask[cluster_indices] = False\n    temp_solution = base_solution[mask]\n\n    # Find best insertion point for the cluster\n    best_score = -float('inf')\n    best_pos = 0\n\n    for pos in range(len(temp_solution) + 1):\n        # Try inserting the cluster at position 'pos'\n        candidate = np.concatenate([temp_solution[:pos], selected_cluster, temp_solution[pos:]])\n\n        # Calculate cost for the candidate solution\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of normalized improvements\n        original_cost1 = sum(distance_matrix_1[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n        original_cost2 = sum(distance_matrix_2[base_solution[i], base_solution[(i+1)%n]] for i in range(n))\n\n        score = ((original_cost1 - cost1) / (original_cost1 + 1e-6)) * 0.6 + ((original_cost2 - cost2) / (original_cost2 + 1e-6)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_pos = pos\n\n    # Apply the best insertion\n    new_solution = np.concatenate([temp_solution[:best_pos], selected_cluster, temp_solution[best_pos:]])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 280,
        "algorithm": "{This new algorithm uses an adaptive segment relocation strategy that evaluates edge contributions across both objectives with a dynamic weighting scheme, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Dynamic weighting based on segment cost ratio\n    cost_ratio = segment_cost1 / (segment_cost2 + 1e-6)\n    weight1 = min(0.9, max(0.1, 1 / (1 + cost_ratio)))\n    weight2 = 1 - weight1\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: dynamic weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with dynamic probability\n        i, j = random.sample(range(n), 2)\n        swap_prob = min(0.5, max(0.1, 0.3 * (segment_cost1 + segment_cost2) / (distance_matrix_1[i,j] + distance_matrix_2[i,j])))\n        if random.random() < swap_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.8260491094711471,
            0.38536107540130615
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Dynamic weighting based on segment cost ratio\n    cost_ratio = segment_cost1 / (segment_cost2 + 1e-6)\n    weight1 = min(0.9, max(0.1, 1 / (1 + cost_ratio)))\n    weight2 = 1 - weight1\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: dynamic weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * weight1 + (segment_cost2 - (cost2 - segment_cost2)) * weight2\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap with dynamic probability\n        i, j = random.sample(range(n), 2)\n        swap_prob = min(0.5, max(0.1, 0.3 * (segment_cost1 + segment_cost2) / (distance_matrix_1[i,j] + distance_matrix_2[i,j])))\n        if random.random() < swap_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 281,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node insertion operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism and using a novel segment reversal mechanism to explore the solution space more effectively.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the selected segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the reversed segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # If the reversed segment is better in both objectives, keep it\n    if reversed_cost1 <= cost1 and reversed_cost2 <= cost2:\n        return new_solution\n\n    # Otherwise, try to find a better insertion point for the reversed segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], reversed_segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], reversed_segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9530123483228421,
            0.25803011655807495
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to reverse\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Reverse the selected segment\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n    new_solution[a:b+1] = reversed_segment\n\n    # Calculate the cost of the reversed segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    # If the reversed segment is better in both objectives, keep it\n    if reversed_cost1 <= cost1 and reversed_cost2 <= cost2:\n        return new_solution\n\n    # Otherwise, try to find a better insertion point for the reversed segment\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the reversed segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], reversed_segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < best_cost1 and new_cost2 < best_cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], reversed_segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 282,
        "algorithm": "{This new algorithm uses a dynamic multi-segment relocation strategy that evaluates and combines multiple non-adjacent segments in a solution, prioritizing those with high potential for cost reduction in either objective while maintaining feasibility through a probabilistic validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple non-adjacent segments\n    num_segments = random.randint(2, min(3, n // 4))\n    segment_indices = sorted(random.sample(range(n - 1), num_segments))\n    segments = []\n    current_pos = 0\n\n    for idx in segment_indices:\n        segment_length = random.randint(2, min(3, (n - current_pos) // 2))\n        segments.append(new_solution[current_pos:current_pos+segment_length])\n        current_pos += segment_length + 1\n\n    # Calculate combined segment cost\n    total_cost1 = 0\n    total_cost2 = 0\n    for seg in segments:\n        seg_len = len(seg)\n        total_cost1 += sum(distance_matrix_1[seg[i], seg[(i+1)%seg_len]] for i in range(seg_len))\n        total_cost2 += sum(distance_matrix_2[seg[i], seg[(i+1)%seg_len]] for i in range(seg_len))\n\n    # Evaluate potential insertion points for combined segments\n    best_score = -float('inf')\n    best_insert_pos = -1\n    combined_segments = np.concatenate(segments)\n\n    for pos in range(n - len(combined_segments) + 1):\n        # Check if insertion point would overlap with any segment\n        overlap = False\n        for seg in segments:\n            seg_start = np.where(new_solution == seg[0])[0][0]\n            seg_end = seg_start + len(seg)\n            if not (pos >= seg_end or pos + len(combined_segments) <= seg_start):\n                overlap = True\n                break\n        if overlap:\n            continue\n\n        # Try inserting the combined segments at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], combined_segments, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (total_cost1 - (cost1 - total_cost1)) * 0.6 + (total_cost2 - (cost2 - total_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], combined_segments, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic multi-swap\n        swap_points = random.sample(range(n), min(4, n))\n        if random.random() < 0.4:  # 40% chance to perform multi-swap\n            new_solution[swap_points] = new_solution[swap_points[::-1]]\n\n    return new_solution\n\n",
        "score": [
            -0.8735329495877582,
            0.31969690322875977
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select multiple non-adjacent segments\n    num_segments = random.randint(2, min(3, n // 4))\n    segment_indices = sorted(random.sample(range(n - 1), num_segments))\n    segments = []\n    current_pos = 0\n\n    for idx in segment_indices:\n        segment_length = random.randint(2, min(3, (n - current_pos) // 2))\n        segments.append(new_solution[current_pos:current_pos+segment_length])\n        current_pos += segment_length + 1\n\n    # Calculate combined segment cost\n    total_cost1 = 0\n    total_cost2 = 0\n    for seg in segments:\n        seg_len = len(seg)\n        total_cost1 += sum(distance_matrix_1[seg[i], seg[(i+1)%seg_len]] for i in range(seg_len))\n        total_cost2 += sum(distance_matrix_2[seg[i], seg[(i+1)%seg_len]] for i in range(seg_len))\n\n    # Evaluate potential insertion points for combined segments\n    best_score = -float('inf')\n    best_insert_pos = -1\n    combined_segments = np.concatenate(segments)\n\n    for pos in range(n - len(combined_segments) + 1):\n        # Check if insertion point would overlap with any segment\n        overlap = False\n        for seg in segments:\n            seg_start = np.where(new_solution == seg[0])[0][0]\n            seg_end = seg_start + len(seg)\n            if not (pos >= seg_end or pos + len(combined_segments) <= seg_start):\n                overlap = True\n                break\n        if overlap:\n            continue\n\n        # Try inserting the combined segments at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], combined_segments, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (total_cost1 - (cost1 - total_cost1)) * 0.6 + (total_cost2 - (cost2 - total_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], combined_segments, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic multi-swap\n        swap_points = random.sample(range(n), min(4, n))\n        if random.random() < 0.4:  # 40% chance to perform multi-swap\n            new_solution[swap_points] = new_solution[swap_points[::-1]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 283,
        "algorithm": "{A novel adaptive local search strategy integrates a dynamic edge evaluation metric with a multi-objective selection criterion, combining segment relocation and edge swapping to explore high-potential regions in the solution space while maintaining feasibility through a constraint-aware validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_score = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate a combined score (weighted sum of normalized improvements)\n        score = (new_cost1 - cost1) / (distance_matrix_1.max() + 1e-6) + (new_cost2 - cost2) / (distance_matrix_2.max() + 1e-6)\n\n        if score < best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9685219709817929,
            0.46139341592788696
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly weighted by objective values)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_score = float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate a combined score (weighted sum of normalized improvements)\n        score = (new_cost1 - cost1) / (distance_matrix_1.max() + 1e-6) + (new_cost2 - cost2) / (distance_matrix_2.max() + 1e-6)\n\n        if score < best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random edge swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 284,
        "algorithm": "{This new algorithm employs a multi-objective edge aggregation strategy that dynamically combines edges from the best solutions in each objective space, followed by a probabilistic edge refinement step to ensure feasibility and potentially improve both objectives simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from each objective\n    best_sol1 = min(archive, key=lambda x: x[1][0])[0]\n    best_sol2 = min(archive, key=lambda x: x[1][1])[0]\n\n    # Create a combined edge set from both solutions\n    edges1 = set(zip(best_sol1, np.roll(best_sol1, -1)))\n    edges2 = set(zip(best_sol2, np.roll(best_sol2, -1)))\n\n    # Initialize a new solution with random start\n    n = len(best_sol1)\n    new_solution = np.zeros(n, dtype=int)\n    start_node = random.randint(0, n-1)\n    new_solution[0] = start_node\n    visited = {start_node}\n\n    # Build the solution by alternating between edge sets\n    for i in range(1, n):\n        current_node = new_solution[i-1]\n        candidates = []\n\n        # Check edges from first objective\n        for u, v in edges1:\n            if u == current_node and v not in visited:\n                candidates.append(v)\n            elif v == current_node and u not in visited:\n                candidates.append(u)\n\n        # Check edges from second objective\n        for u, v in edges2:\n            if u == current_node and v not in visited:\n                candidates.append(v)\n            elif v == current_node and u not in visited:\n                candidates.append(u)\n\n        # Select next node with probability based on edge quality\n        if candidates:\n            # Calculate edge quality scores\n            scores = []\n            for node in candidates:\n                score = 0\n                if (current_node, node) in edges1:\n                    score += 1 / distance_matrix_1[current_node, node]\n                if (current_node, node) in edges2:\n                    score += 1 / distance_matrix_2[current_node, node]\n                scores.append(score)\n\n            # Normalize scores\n            total = sum(scores)\n            if total > 0:\n                probs = [s/total for s in scores]\n                next_node = random.choices(candidates, weights=probs, k=1)[0]\n            else:\n                next_node = random.choice(candidates)\n        else:\n            # Fallback to unvisited nodes\n            next_node = random.choice([i for i in range(n) if i not in visited])\n\n        new_solution[i] = next_node\n        visited.add(next_node)\n\n    # Ensure all nodes are visited (fallback to random permutation if needed)\n    if len(visited) != n:\n        unvisited = [i for i in range(n) if i not in visited]\n        remaining_pos = [i for i in range(n) if new_solution[i] == 0]\n        for pos, node in zip(remaining_pos, unvisited):\n            new_solution[pos] = node\n\n    # Apply probabilistic edge refinement\n    for _ in range(3):  # Number of refinement steps\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9515377592302533,
            0.36719751358032227
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the best solution from each objective\n    best_sol1 = min(archive, key=lambda x: x[1][0])[0]\n    best_sol2 = min(archive, key=lambda x: x[1][1])[0]\n\n    # Create a combined edge set from both solutions\n    edges1 = set(zip(best_sol1, np.roll(best_sol1, -1)))\n    edges2 = set(zip(best_sol2, np.roll(best_sol2, -1)))\n\n    # Initialize a new solution with random start\n    n = len(best_sol1)\n    new_solution = np.zeros(n, dtype=int)\n    start_node = random.randint(0, n-1)\n    new_solution[0] = start_node\n    visited = {start_node}\n\n    # Build the solution by alternating between edge sets\n    for i in range(1, n):\n        current_node = new_solution[i-1]\n        candidates = []\n\n        # Check edges from first objective\n        for u, v in edges1:\n            if u == current_node and v not in visited:\n                candidates.append(v)\n            elif v == current_node and u not in visited:\n                candidates.append(u)\n\n        # Check edges from second objective\n        for u, v in edges2:\n            if u == current_node and v not in visited:\n                candidates.append(v)\n            elif v == current_node and u not in visited:\n                candidates.append(u)\n\n        # Select next node with probability based on edge quality\n        if candidates:\n            # Calculate edge quality scores\n            scores = []\n            for node in candidates:\n                score = 0\n                if (current_node, node) in edges1:\n                    score += 1 / distance_matrix_1[current_node, node]\n                if (current_node, node) in edges2:\n                    score += 1 / distance_matrix_2[current_node, node]\n                scores.append(score)\n\n            # Normalize scores\n            total = sum(scores)\n            if total > 0:\n                probs = [s/total for s in scores]\n                next_node = random.choices(candidates, weights=probs, k=1)[0]\n            else:\n                next_node = random.choice(candidates)\n        else:\n            # Fallback to unvisited nodes\n            next_node = random.choice([i for i in range(n) if i not in visited])\n\n        new_solution[i] = next_node\n        visited.add(next_node)\n\n    # Ensure all nodes are visited (fallback to random permutation if needed)\n    if len(visited) != n:\n        unvisited = [i for i in range(n) if i not in visited]\n        remaining_pos = [i for i in range(n) if new_solution[i] == 0]\n        for pos, node in zip(remaining_pos, unvisited):\n            new_solution[pos] = node\n\n    # Apply probabilistic edge refinement\n    for _ in range(3):  # Number of refinement steps\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 285,
        "algorithm": "{This algorithm employs a hybrid approach combining adaptive segment reversal and objective-biased edge insertion, where segments are dynamically selected based on their potential to improve either objective while maintaining feasibility through probabilistic validation and a novel edge insertion strategy that considers both objectives' contributions simultaneously.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and reverse it\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length][::-1]\n    new_solution[a:a+segment_length] = segment\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential edge insertions\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_edge = None\n\n    for i in range(n):\n        for j in range(i+1, min(i+4, n)):\n            # Calculate edge cost in both objectives\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Score function: weighted sum of edge costs\n            score = edge_cost1 * 0.6 + edge_cost2 * 0.4\n\n            if score > best_score:\n                best_score = score\n                best_insert_pos = i\n                best_edge = j\n\n    if best_insert_pos is not None and best_edge is not None:\n        # Insert the best edge at the best position\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos+1],\n            [new_solution[best_edge]],\n            new_solution[best_insert_pos+1:best_edge],\n            new_solution[best_edge+1:]\n        ])\n\n    return new_solution\n\n",
        "score": [
            -0.7606171615723016,
            0.24874413013458252
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length and reverse it\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length][::-1]\n    new_solution[a:a+segment_length] = segment\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential edge insertions\n    best_score = -float('inf')\n    best_insert_pos = -1\n    best_edge = None\n\n    for i in range(n):\n        for j in range(i+1, min(i+4, n)):\n            # Calculate edge cost in both objectives\n            edge_cost1 = distance_matrix_1[new_solution[i], new_solution[j]]\n            edge_cost2 = distance_matrix_2[new_solution[i], new_solution[j]]\n\n            # Score function: weighted sum of edge costs\n            score = edge_cost1 * 0.6 + edge_cost2 * 0.4\n\n            if score > best_score:\n                best_score = score\n                best_insert_pos = i\n                best_edge = j\n\n    if best_insert_pos is not None and best_edge is not None:\n        # Insert the best edge at the best position\n        new_solution = np.concatenate([\n            new_solution[:best_insert_pos+1],\n            [new_solution[best_edge]],\n            new_solution[best_insert_pos+1:best_edge],\n            new_solution[best_edge+1:]\n        ])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 286,
        "algorithm": "{This novel algorithm combines a multi-objective selection criterion with a dynamic sub-tour reversal operator that prioritizes segments with high potential for cost reduction in both objective spaces, while ensuring feasibility through a validation mechanism that maintains the tour's continuity and node uniqueness.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    if (reversed_cost1 < cost1 and reversed_cost2 < cost2):\n        new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.7552002914597232,
            0.405540406703949
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    segment = new_solution[a:b+1]\n    reversed_segment = segment[::-1]\n\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    reversed_cost1 = sum(distance_matrix_1[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n    reversed_cost2 = sum(distance_matrix_2[reversed_segment[i], reversed_segment[(i+1)%len(reversed_segment)]] for i in range(len(reversed_segment)))\n\n    if (reversed_cost1 < cost1 and reversed_cost2 < cost2):\n        new_solution[a:b+1] = reversed_segment\n\n    if random.random() < 0.3:\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 287,
        "algorithm": "{This new algorithm uses a dynamic edge reversal strategy that evaluates node contributions across both objectives, prioritizing edges with high potential for cost reduction while maintaining feasibility through a probabilistic validation step, with a different parameterization of the score function to balance exploration and exploitation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential reversal points\n    best_score = -float('inf')\n    best_reversal_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try reversing the segment at position 'pos'\n        temp_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], temp_segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements with different parameters\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_reversal_pos = pos\n\n    if best_reversal_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_reversal_pos], segment[::-1], new_solution[best_reversal_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to reverse\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9265172055482714,
            0.40533727407455444
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(4, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential reversal points\n    best_score = -float('inf')\n    best_reversal_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try reversing the segment at position 'pos'\n        temp_segment = segment[::-1]\n        temp_solution = np.concatenate([new_solution[:pos], temp_segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements with different parameters\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.5 + (segment_cost2 - (cost2 - segment_cost2)) * 0.5\n\n        if score > best_score:\n            best_score = score\n            best_reversal_pos = pos\n\n    if best_reversal_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_reversal_pos], segment[::-1], new_solution[best_reversal_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.5:  # 50% chance to reverse\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 288,
        "algorithm": "{A novel adaptive segment exchange strategy that dynamically combines multi-objective edge evaluation with a probabilistic segment inversion mechanism to explore diverse solution regions while prioritizing segments with balanced improvement potential across both objectives.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse combined cost)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment with adaptive length\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Evaluate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate segment's potential improvement score\n    improvement_score = (segment_cost1 * 0.6 + segment_cost2 * 0.4) / segment_length\n\n    # With probability based on improvement potential, either:\n    # 1. Exchange the segment with another random segment\n    # 2. Invert the segment (reverse its order)\n    if random.random() < improvement_score / (improvement_score + 10):\n        # Segment exchange\n        b = random.randint(0, n - segment_length)\n        if abs(a - b) > segment_length:\n            temp_segment = new_solution[b:b+segment_length]\n            new_solution[a:a+segment_length] = temp_segment\n            new_solution[b:b+segment_length] = segment\n    else:\n        # Segment inversion\n        if random.random() < 0.5:\n            new_solution[a:a+segment_length] = segment[::-1]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.9016539704091382,
            0.4028765559196472
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted by inverse combined cost)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment with adaptive length\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Evaluate segment's contribution to both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Calculate segment's potential improvement score\n    improvement_score = (segment_cost1 * 0.6 + segment_cost2 * 0.4) / segment_length\n\n    # With probability based on improvement potential, either:\n    # 1. Exchange the segment with another random segment\n    # 2. Invert the segment (reverse its order)\n    if random.random() < improvement_score / (improvement_score + 10):\n        # Segment exchange\n        b = random.randint(0, n - segment_length)\n        if abs(a - b) > segment_length:\n            temp_segment = new_solution[b:b+segment_length]\n            new_solution[a:a+segment_length] = temp_segment\n            new_solution[b:b+segment_length] = segment\n    else:\n        # Segment inversion\n        if random.random() < 0.5:\n            new_solution[a:a+segment_length] = segment[::-1]\n\n    # Validate the solution remains feasible\n    if len(set(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 289,
        "algorithm": "{This algorithm selects a solution from the archive based on a multi-objective improvement potential score, then applies a novel dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential (simplified)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n\n    # Novel dynamic edge exchange operator\n    new_solution = selected_solution.copy()\n    for _ in range(3):  # Perform multiple exchanges\n        # Select two random edges to exchange\n        i, j = random.sample(range(n), 2)\n        a, b = (i, (i+1)%n) if random.random() < 0.5 else ((i+1)%n, i)\n        c, d = (j, (j+1)%n) if random.random() < 0.5 else ((j+1)%n, j)\n\n        # Calculate cost difference for both objectives\n        cost1_diff = (distance_matrix_1[a, d] + distance_matrix_1[b, c] -\n                      distance_matrix_1[a, b] - distance_matrix_1[c, d])\n        cost2_diff = (distance_matrix_2[a, d] + distance_matrix_2[b, c] -\n                      distance_matrix_2[a, b] - distance_matrix_2[c, d])\n\n        # Accept exchange if it improves at least one objective\n        if cost1_diff < 0 or cost2_diff < 0:\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n                new_solution[d], new_solution[c], new_solution[b], new_solution[a])\n\n    return new_solution\n\n",
        "score": [
            -0.7522722200331069,
            0.2020837664604187
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest improvement potential (simplified)\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n    n = len(selected_solution)\n\n    # Novel dynamic edge exchange operator\n    new_solution = selected_solution.copy()\n    for _ in range(3):  # Perform multiple exchanges\n        # Select two random edges to exchange\n        i, j = random.sample(range(n), 2)\n        a, b = (i, (i+1)%n) if random.random() < 0.5 else ((i+1)%n, i)\n        c, d = (j, (j+1)%n) if random.random() < 0.5 else ((j+1)%n, j)\n\n        # Calculate cost difference for both objectives\n        cost1_diff = (distance_matrix_1[a, d] + distance_matrix_1[b, c] -\n                      distance_matrix_1[a, b] - distance_matrix_1[c, d])\n        cost2_diff = (distance_matrix_2[a, d] + distance_matrix_2[b, c] -\n                      distance_matrix_2[a, b] - distance_matrix_2[c, d])\n\n        # Accept exchange if it improves at least one objective\n        if cost1_diff < 0 or cost2_diff < 0:\n            new_solution[a], new_solution[b], new_solution[c], new_solution[d] = (\n                new_solution[d], new_solution[c], new_solution[b], new_solution[a])\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 290,
        "algorithm": "{This new algorithm uses a dynamic subpath inversion strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, and combines it with a biased random walk to explore diverse neighborhoods.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a subpath of variable length and invert it\n    subpath_length = random.randint(2, min(7, n // 2))\n    a = random.randint(0, n - subpath_length)\n    subpath = new_solution[a:a+subpath_length]\n    inverted_subpath = subpath[::-1]\n\n    # Calculate subpath cost in both objectives\n    subpath_cost1 = sum(distance_matrix_1[subpath[i], subpath[(i+1)%subpath_length]] for i in range(subpath_length))\n    subpath_cost2 = sum(distance_matrix_2[subpath[i], subpath[(i+1)%subpath_length]] for i in range(subpath_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - subpath_length + 1):\n        if pos >= a and pos < a + subpath_length:\n            continue\n\n        # Try inserting the inverted subpath at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], inverted_subpath, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (subpath_cost1 - (cost1 - subpath_cost1)) * 0.6 + (subpath_cost2 - (cost2 - subpath_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], inverted_subpath, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a biased random walk\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(2, min(5, n // 2))) % n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9031552498637444,
            0.39394938945770264
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a subpath of variable length and invert it\n    subpath_length = random.randint(2, min(7, n // 2))\n    a = random.randint(0, n - subpath_length)\n    subpath = new_solution[a:a+subpath_length]\n    inverted_subpath = subpath[::-1]\n\n    # Calculate subpath cost in both objectives\n    subpath_cost1 = sum(distance_matrix_1[subpath[i], subpath[(i+1)%subpath_length]] for i in range(subpath_length))\n    subpath_cost2 = sum(distance_matrix_2[subpath[i], subpath[(i+1)%subpath_length]] for i in range(subpath_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - subpath_length + 1):\n        if pos >= a and pos < a + subpath_length:\n            continue\n\n        # Try inserting the inverted subpath at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], inverted_subpath, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (subpath_cost1 - (cost1 - subpath_cost1)) * 0.6 + (subpath_cost2 - (cost2 - subpath_cost2)) * 0.4\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], inverted_subpath, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a biased random walk\n        i = random.randint(0, n - 1)\n        j = (i + random.randint(2, min(5, n // 2))) % n\n        new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 291,
        "algorithm": "{A novel hybrid local search strategy combines multi-objective edge selection with a dynamic segment inversion operator that prioritizes edges with high potential for cost improvement in both objective spaces while ensuring feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply inversion if it improves both objectives\n    if inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If inversion doesn't help, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9271068338143624,
            0.20823979377746582
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Invert the segment\n    segment = new_solution[a:b+1]\n    inverted_segment = segment[::-1]\n\n    # Calculate the cost of the original and inverted segments\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    inverted_cost1 = sum(distance_matrix_1[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n    inverted_cost2 = sum(distance_matrix_2[inverted_segment[i], inverted_segment[(i+1)%len(inverted_segment)]] for i in range(len(inverted_segment)))\n\n    # Apply inversion if it improves both objectives\n    if inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2:\n        new_solution[a:b+1] = inverted_segment\n    else:\n        # If inversion doesn't help, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 292,
        "algorithm": "{A novel adaptive segment exchange strategy dynamically selects and improves solution segments based on their potential cost reduction in both objectives, using a weighted combination of objective improvements to guide the search while maintaining feasibility through constrained segment manipulation.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective improvement potential\n    selected_solution, (cost1, cost2) = max(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Select a segment to exchange\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate the current cost of the segment in both objectives\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Try to find a better insertion point for the segment\n    best_improvement = -float('inf')\n    best_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < start + segment_length:\n            continue  # Skip the current position\n\n        # Create a temporary solution with the segment moved to this position\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n        temp_solution = np.concatenate([temp_solution[:pos+segment_length], temp_solution[pos+segment_length:start], temp_solution[start+segment_length:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate the weighted improvement\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Apply the best improvement\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n        new_solution = np.concatenate([new_solution[:best_pos+segment_length], new_solution[best_pos+segment_length:start], new_solution[start+segment_length:]])\n    else:\n        # If no improvement found, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9368282819628022,
            0.5623357892036438
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective improvement potential\n    selected_solution, (cost1, cost2) = max(archive, key=lambda x: x[1][0] + x[1][1])\n    base_solution = selected_solution.copy()\n    new_solution = base_solution.copy()\n\n    n = len(base_solution)\n    if n < 3:\n        return new_solution  # No meaningful operation possible\n\n    # Select a segment to exchange\n    segment_length = random.randint(2, min(5, n // 2))\n    start = random.randint(0, n - segment_length)\n    segment = new_solution[start:start+segment_length]\n\n    # Calculate the current cost of the segment in both objectives\n    current_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    current_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Try to find a better insertion point for the segment\n    best_improvement = -float('inf')\n    best_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= start and pos < start + segment_length:\n            continue  # Skip the current position\n\n        # Create a temporary solution with the segment moved to this position\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n        temp_solution = np.concatenate([temp_solution[:pos+segment_length], temp_solution[pos+segment_length:start], temp_solution[start+segment_length:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Calculate the weighted improvement\n        improvement = (current_cost1 - new_cost1) + (current_cost2 - new_cost2)\n\n        if improvement > best_improvement:\n            best_improvement = improvement\n            best_pos = pos\n\n    if best_pos != -1 and best_improvement > 0:\n        # Apply the best improvement\n        new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n        new_solution = np.concatenate([new_solution[:best_pos+segment_length], new_solution[best_pos+segment_length:start], new_solution[start+segment_length:]])\n    else:\n        # If no improvement found, perform a random 2-opt move\n        i, j = sorted(random.sample(range(n), 2))\n        new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 293,
        "algorithm": "{A novel adaptive local search strategy combines a multi-objective edge prioritization mechanism with a dynamic segment inversion operator that selectively inverts node segments based on their potential for cost improvement in both objective spaces, while ensuring feasibility through a segment validation check.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (for diversity)\n    combined_costs = [sum(obj) for _, obj in archive]\n    selected_idx = combined_costs.index(max(combined_costs))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract and potentially invert the segment\n    segment = new_solution[a:b+1]\n    if random.random() < 0.5:  # 50% chance to invert the segment\n        segment = segment[::-1]\n\n    # Calculate the original cost of the segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate the cost of the inverted segment\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n\n    # Determine if inversion improves both objectives\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n       (random.random() < 0.2):  # 20% chance to accept even if not strictly better\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Apply a random edge swap if no improvement was made\n    if np.array_equal(new_solution, base_solution):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9213829570267162,
            0.23291128873825073
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value (for diversity)\n    combined_costs = [sum(obj) for _, obj in archive]\n    selected_idx = combined_costs.index(max(combined_costs))\n    base_solution = archive_solutions[selected_idx].copy()\n\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to potentially invert\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract and potentially invert the segment\n    segment = new_solution[a:b+1]\n    if random.random() < 0.5:  # 50% chance to invert the segment\n        segment = segment[::-1]\n\n    # Calculate the original cost of the segment in both objectives\n    original_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    original_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate the cost of the inverted segment\n    inverted_cost1 = sum(distance_matrix_1[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n    inverted_cost2 = sum(distance_matrix_2[segment[i], segment[(i-1)%len(segment)]] for i in range(len(segment)))\n\n    # Determine if inversion improves both objectives\n    if (inverted_cost1 < original_cost1 and inverted_cost2 < original_cost2) or \\\n       (random.random() < 0.2):  # 20% chance to accept even if not strictly better\n        new_solution = np.concatenate([new_solution[:a], segment, new_solution[b+1:]])\n\n    # Apply a random edge swap if no improvement was made\n    if np.array_equal(new_solution, base_solution):\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 294,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic node reordering operator that considers both objective spaces, prioritizing nodes with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best node to move\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_node, best_pos = -1, -1\n\n    for node in range(n):\n        for pos in range(n):\n            if pos == node or (pos + 1) % n == node:\n                continue  # Skip adjacent positions to avoid trivial moves\n\n            # Try moving the node to the new position\n            temp_solution = new_solution.copy()\n            temp_solution = np.roll(temp_solution, -pos)  # Rotate to make pos=0\n            temp_solution[0] = temp_solution[node]\n            temp_solution[node] = new_solution[pos]\n            temp_solution = np.roll(temp_solution, pos)  # Rotate back\n\n            # Calculate new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Check if improvement in both objectives\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                if (current_cost1 - new_cost1) + (current_cost2 - new_cost2) > (current_cost1 - best_cost1) + (current_cost2 - best_cost2):\n                    best_cost1, best_cost2 = new_cost1, new_cost2\n                    best_node, best_pos = node, pos\n\n    if best_node != -1:\n        # Apply the best move\n        new_solution = new_solution.copy()\n        new_solution = np.roll(new_solution, -best_pos)\n        new_solution[0] = new_solution[best_node]\n        new_solution[best_node] = base_solution[best_pos]\n        new_solution = np.roll(new_solution, best_pos)\n    else:\n        # If no improvement found, perform a random 3-opt\n        i, j, k = random.sample(range(n), 3)\n        new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    return new_solution\n\n",
        "score": [
            -0.7776404383825906,
            12.910227179527283
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive) - 1)\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Calculate current costs\n    current_cost1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_cost2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n\n    # Find the best node to move\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_node, best_pos = -1, -1\n\n    for node in range(n):\n        for pos in range(n):\n            if pos == node or (pos + 1) % n == node:\n                continue  # Skip adjacent positions to avoid trivial moves\n\n            # Try moving the node to the new position\n            temp_solution = new_solution.copy()\n            temp_solution = np.roll(temp_solution, -pos)  # Rotate to make pos=0\n            temp_solution[0] = temp_solution[node]\n            temp_solution[node] = new_solution[pos]\n            temp_solution = np.roll(temp_solution, pos)  # Rotate back\n\n            # Calculate new cost\n            new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n            new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n            # Check if improvement in both objectives\n            if new_cost1 < current_cost1 and new_cost2 < current_cost2:\n                if (current_cost1 - new_cost1) + (current_cost2 - new_cost2) > (current_cost1 - best_cost1) + (current_cost2 - best_cost2):\n                    best_cost1, best_cost2 = new_cost1, new_cost2\n                    best_node, best_pos = node, pos\n\n    if best_node != -1:\n        # Apply the best move\n        new_solution = new_solution.copy()\n        new_solution = np.roll(new_solution, -best_pos)\n        new_solution[0] = new_solution[best_node]\n        new_solution[best_node] = base_solution[best_pos]\n        new_solution = np.roll(new_solution, best_pos)\n    else:\n        # If no improvement found, perform a random 3-opt\n        i, j, k = random.sample(range(n), 3)\n        new_solution[[i, j, k]] = new_solution[[j, k, i]]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 295,
        "algorithm": "{This new algorithm uses a dynamic edge reversal strategy that evaluates edge contributions across both objectives, prioritizing edges with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step, using a modified score function that emphasizes the most improved objective.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Modified score function: emphasize the most improved objective\n        improvement1 = segment_cost1 - (cost1 - segment_cost1)\n        improvement2 = segment_cost2 - (cost2 - segment_cost2)\n\n        if improvement1 > improvement2:\n            score = improvement1 * 0.8 + improvement2 * 0.2\n        else:\n            score = improvement1 * 0.2 + improvement2 * 0.8\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to reverse\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.9378726657815116,
            0.35908591747283936
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Modified score function: emphasize the most improved objective\n        improvement1 = segment_cost1 - (cost1 - segment_cost1)\n        improvement2 = segment_cost2 - (cost2 - segment_cost2)\n\n        if improvement1 > improvement2:\n            score = improvement1 * 0.8 + improvement2 * 0.2\n        else:\n            score = improvement1 * 0.2 + improvement2 * 0.8\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge reversal\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:  # 40% chance to reverse\n            new_solution[i:j] = new_solution[i:j][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 296,
        "algorithm": "{This algorithm uses a multi-objective edge swapping strategy that evaluates edge contributions across both objectives, probabilistically selecting edges with high potential for cost reduction while maintaining feasibility through a dynamic validation process.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a set of edges to consider for swapping\n    num_edges = min(5, n // 2)\n    edges = random.sample(range(n), num_edges)\n\n    # Evaluate potential edge swaps\n    best_score = -float('inf')\n    best_swap = None\n\n    for i in edges:\n        for j in edges:\n            if i == j:\n                continue\n\n            # Try swapping edges (i, i+1) and (j, j+1)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[(i+1)%n] = temp_solution[(i+1)%n], temp_solution[i]\n            temp_solution[j], temp_solution[(j+1)%n] = temp_solution[(j+1)%n], temp_solution[j]\n\n            # Calculate cost change\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Score function: weighted sum of cost improvements\n            score = (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) - cost1) * 0.6 + \\\n                    (sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) - cost2) * 0.4\n\n            if score > best_score:\n                best_score = score\n                best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n        new_solution[j], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[j]\n    else:\n        # If no improvement found, perform a probabilistic node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and random.random() < 0.4:  # 40% chance to insert\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n            new_solution = np.delete(new_solution, i if i > j else i+1)\n\n    return new_solution\n\n",
        "score": [
            -0.8314606088810769,
            1.1101192235946655
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] * obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a set of edges to consider for swapping\n    num_edges = min(5, n // 2)\n    edges = random.sample(range(n), num_edges)\n\n    # Evaluate potential edge swaps\n    best_score = -float('inf')\n    best_swap = None\n\n    for i in edges:\n        for j in edges:\n            if i == j:\n                continue\n\n            # Try swapping edges (i, i+1) and (j, j+1)\n            temp_solution = new_solution.copy()\n            temp_solution[i], temp_solution[(i+1)%n] = temp_solution[(i+1)%n], temp_solution[i]\n            temp_solution[j], temp_solution[(j+1)%n] = temp_solution[(j+1)%n], temp_solution[j]\n\n            # Calculate cost change\n            cost1 = sum(distance_matrix_1[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n            cost2 = sum(distance_matrix_2[temp_solution[k], temp_solution[(k+1)%n]] for k in range(n))\n\n            # Score function: weighted sum of cost improvements\n            score = (sum(distance_matrix_1[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) - cost1) * 0.6 + \\\n                    (sum(distance_matrix_2[new_solution[k], new_solution[(k+1)%n]] for k in range(n)) - cost2) * 0.4\n\n            if score > best_score:\n                best_score = score\n                best_swap = (i, j)\n\n    if best_swap is not None:\n        i, j = best_swap\n        new_solution[i], new_solution[(i+1)%n] = new_solution[(i+1)%n], new_solution[i]\n        new_solution[j], new_solution[(j+1)%n] = new_solution[(j+1)%n], new_solution[j]\n    else:\n        # If no improvement found, perform a probabilistic node insertion\n        i = random.randint(0, n-1)\n        j = random.randint(0, n-1)\n        if i != j and random.random() < 0.4:  # 40% chance to insert\n            node = new_solution[i]\n            new_solution = np.concatenate([new_solution[:j], [node], new_solution[j:]])\n            new_solution = np.delete(new_solution, i if i > j else i+1)\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{This new algorithm uses a dynamic segment relocation strategy that evaluates edge contributions across both objectives, prioritizing segments with high potential for cost reduction in either space while maintaining feasibility through a probabilistic validation step.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (weighted random selection)\n    weights = [1 / (obj[0] + obj[1] + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment of variable length\n    segment_length = random.randint(2, min(5, n // 2))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    # Calculate segment cost in both objectives\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    # Evaluate potential insertion points\n    best_score = -float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n - segment_length + 1):\n        if pos >= a and pos < a + segment_length:\n            continue\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate cost change\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Score function: weighted sum of cost improvements\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.7 + (segment_cost2 - (cost2 - segment_cost2)) * 0.3\n\n        if score > best_score:\n            best_score = score\n            best_insert_pos = pos\n\n    if best_insert_pos != -1:\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no improvement found, perform a probabilistic edge swap\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.3:  # 30% chance to swap\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 297,
        "algorithm": "{This new algorithm uses an adaptive segment inversion strategy that dynamically balances between local and global improvements by evaluating edge contributions in both objectives, applying probabilistic segment inversions to escape local optima while maintaining feasibility through a multi-criteria validation step.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_inversion = None\n\n    for _ in range(3):\n        temp_segment = segment.copy()\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(segment_length), 2))\n            temp_segment[i:j+1] = temp_segment[i:j+1][::-1]\n\n        temp_solution = np.concatenate([new_solution[:a], temp_segment, new_solution[a+segment_length:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n        if score > best_score:\n            best_score = score\n            best_inversion = temp_segment\n\n    if best_inversion is not None:\n        new_solution = np.concatenate([new_solution[:a], best_inversion, new_solution[a+segment_length:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n",
        "score": [
            -0.7396995096610731,
            1.172921061515808
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    weights = [1 / (obj[0] * 0.6 + obj[1] * 0.4 + 1e-6) for _, obj in archive]\n    selected_idx = random.choices(range(len(archive)), weights=weights, k=1)[0]\n    base_solution = archive[selected_idx][0].copy()\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    segment_length = random.randint(3, min(7, n // 3))\n    a = random.randint(0, n - segment_length)\n    segment = new_solution[a:a+segment_length]\n\n    segment_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n    segment_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%segment_length]] for i in range(segment_length))\n\n    best_score = -float('inf')\n    best_inversion = None\n\n    for _ in range(3):\n        temp_segment = segment.copy()\n        if random.random() < 0.7:\n            i, j = sorted(random.sample(range(segment_length), 2))\n            temp_segment[i:j+1] = temp_segment[i:j+1][::-1]\n\n        temp_solution = np.concatenate([new_solution[:a], temp_segment, new_solution[a+segment_length:]])\n        cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        score = (segment_cost1 - (cost1 - segment_cost1)) * 0.6 + (segment_cost2 - (cost2 - segment_cost2)) * 0.4\n        if score > best_score:\n            best_score = score\n            best_inversion = temp_segment\n\n    if best_inversion is not None:\n        new_solution = np.concatenate([new_solution[:a], best_inversion, new_solution[a+segment_length:]])\n    else:\n        i, j = random.sample(range(n), 2)\n        if random.random() < 0.4:\n            new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 298,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
        "score": [
            -0.9211532339392035,
            0.45859771966934204
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    archive_solutions = [sol for sol, _ in archive]\n    if not archive_solutions:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a solution with high potential for improvement (randomly for simplicity)\n    selected_idx = random.randint(0, len(archive_solutions) - 1)\n    base_solution = archive_solutions[selected_idx].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select a segment to perturb\n    a = random.randint(0, n - 1)\n    b = random.randint(0, n - 1)\n    if a > b:\n        a, b = b, a\n\n    # Extract the segment\n    segment = new_solution[a:b+1]\n\n    # Calculate the cost of the segment in both objectives\n    cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Find the best insertion point for the segment in the rest of the tour\n    best_cost1, best_cost2 = float('inf'), float('inf')\n    best_insert_pos = -1\n\n    for pos in range(n):\n        if pos >= a and pos <= b:\n            continue  # Skip the current segment\n\n        # Try inserting the segment at position 'pos'\n        temp_solution = new_solution.copy()\n        temp_solution = np.concatenate([temp_solution[:pos], segment, temp_solution[pos:]])\n\n        # Calculate the new cost\n        new_cost1 = sum(distance_matrix_1[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n        new_cost2 = sum(distance_matrix_2[temp_solution[i], temp_solution[(i+1)%n]] for i in range(n))\n\n        # Check if this is better in both objectives\n        if new_cost1 < cost1 and new_cost2 < cost2:\n            best_cost1, best_cost2 = new_cost1, new_cost2\n            best_insert_pos = pos\n            break  # Early exit if found a clearly better solution\n\n    if best_insert_pos != -1:\n        # Apply the best insertion\n        new_solution = np.concatenate([new_solution[:best_insert_pos], segment, new_solution[best_insert_pos:]])\n    else:\n        # If no better insertion found, perform a random swap\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n\nPlease identify the main algorithm parameters and assist me in creating a new algorithm that has a different parameter settings of the score function provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 299,
        "algorithm": "{A novel hybrid local search strategy combines a multi-objective selection criterion with a dynamic edge exchange operator that considers both objective spaces, prioritizing edges with high potential for cost reduction while maintaining feasibility through a validation mechanism.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined score (normalized sum of objectives)\n    scores = [-(obj1 + obj2) for _, (obj1, obj2) in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Apply the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.8266477294070143,
            0.18770736455917358
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the best combined score (normalized sum of objectives)\n    scores = [-(obj1 + obj2) for _, (obj1, obj2) in archive]\n    selected_idx = np.argmax(scores)\n    base_solution = archive[selected_idx][0].copy()\n\n    # Generate a neighbor using a hybrid local search operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Randomly select two non-adjacent edges to swap\n    i = random.randint(0, n - 1)\n    j = (i + random.randint(2, n - 2)) % n\n\n    # Apply the swap\n    new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Validate the solution remains feasible\n    if len(np.unique(new_solution)) != n:\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n"
    }
]