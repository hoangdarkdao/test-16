[
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: sum(x[1]))\n    selected_idx = np.random.choice(min(5, len(archive_sorted)))  # Select from top 5 or all if fewer\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid operator: Combine 3-opt with a novel segment reversal strategy\n    # First, perform a random 3-opt move\n    i, j, k = sorted(np.random.choice(n, 3, replace=False))\n    if i == 0 and k == n-1:  # Avoid full reversal which is equivalent to a swap\n        i, j, k = 0, 1, 2\n\n    # Create three segments and reverse the middle one\n    segment1 = new_solution[:i]\n    segment2 = new_solution[i:j+1][::-1]\n    segment3 = new_solution[j+1:k+1][::-1]\n    segment4 = new_solution[k+1:]\n\n    # Combine segments with a novel crossover pattern\n    new_solution = np.concatenate([segment1, segment3, segment2, segment4])\n\n    # Step 3: Ensure the solution remains feasible\n    # Verify all nodes are present and unique\n    if len(set(new_solution)) != n or len(new_solution) != n:\n        # If invalid, revert to the base solution\n        new_solution = base_solution.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.5515284065342554,
               0.4913042187690735
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Identify non-dominated solutions in the archive\n    non_dominated = []\n    for sol, obj in archive:\n        is_dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            non_dominated.append((sol, obj))\n\n    if not non_dominated:\n        non_dominated = archive  # Fallback to all solutions if none are non-dominated\n\n    # Step 2: Select a solution with high diversity (sum of distances in both objectives)\n    selected_idx = np.argmax([obj[0] + obj[1] for _, obj in non_dominated])\n    base_solution = non_dominated[selected_idx][0].copy()\n\n    # Step 3: Segmented inversion operator\n    n = len(base_solution)\n    new_solution = base_solution.copy()\n\n    # Determine segment lengths dynamically based on instance size\n    segment_length = max(2, n // 10)  # At least 2 nodes per segment\n\n    for i in range(0, n, segment_length):\n        segment_start = i\n        segment_end = min(i + segment_length, n)\n\n        # Calculate segment cost in both objectives\n        segment_cost_1 = 0\n        segment_cost_2 = 0\n        for j in range(segment_start, segment_end - 1):\n            node_a = base_solution[j]\n            node_b = base_solution[j + 1]\n            segment_cost_1 += distance_matrix_1[node_a, node_b]\n            segment_cost_2 += distance_matrix_2[node_a, node_b]\n\n        # Probability of inversion is inversely proportional to segment cost\n        total_cost = segment_cost_1 + segment_cost_2\n        if total_cost > 0:\n            inversion_prob = 1.0 / (1.0 + total_cost / (distance_matrix_1.sum() + distance_matrix_2.sum()))\n        else:\n            inversion_prob = 0.5\n\n        if np.random.rand() < inversion_prob:\n            # Invert the segment\n            new_solution[segment_start:segment_end] = new_solution[segment_start:segment_end][::-1]\n\n    # Ensure the solution remains feasible (all nodes visited exactly once)\n    assert len(set(new_solution)) == len(base_solution), \"Generated solution is not feasible\"\n\n    return new_solution\n\n",
          "score": [
               -0.9562401881074726,
               0.8160168528556824
          ]
     },
     {
          "algorithm": "{The proposed local search strategy, named \"Adaptive Multi-Objective Edge Insertion with Dynamic Neighborhood Exploration,\" combines adaptive edge selection based on Pareto dominance and objective-specific distance matrices with dynamic neighborhood exploration to balance exploration and exploitation. It first identifies promising edges by analyzing the Pareto front of the archive, then adaptively selects edges with high potential for improvement by considering both objective-specific distances and their contribution to the overall solution quality. The dynamic neighborhood exploration phase employs a hybrid approach that alternates between edge-based and segment-based operations, guided by the current solution's performance in each objective space. The method ensures feasibility by maintaining a valid tour structure and includes a novel \"objective-aware edge insertion\" operator that selectively inserts edges based on their impact on both objectives, while a \"segment reordering\" heuristic reorders segments of the tour to optimize both spaces simultaneously. The adaptive selection of operations and the dynamic adjustment of neighborhood size based on the solution's convergence properties enhance the method's ability to escape local optima and explore diverse regions of the search space.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if len(archive) > 1:\n        # Sort solutions by non-dominated rank and crowding distance\n        sorted_archive = sorted(archive, key=lambda x: (sum(x[1]), -len(x[0])))\n        # Select a solution with probability proportional to its rank\n        selected_idx = random.choices(range(len(sorted_archive)), weights=[1/(i+1) for i in range(len(sorted_archive))])[0]\n        base_solution = sorted_archive[selected_idx][0].copy()\n    else:\n        base_solution = archive[0][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search operator\n    if random.random() < 0.7:  # 70% chance for edge-based operation\n        # Objective-aware edge insertion\n        i, j = sorted(random.sample(range(n), 2))\n        # Calculate potential improvement in both objectives\n        obj1_improvement = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]) - \\\n                          (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_1[new_solution[i], new_solution[(i+1)%n]])\n        obj2_improvement = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                           distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]) - \\\n                          (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                           distance_matrix_2[new_solution[i], new_solution[(i+1)%n]])\n\n        # Accept if both objectives improve or one improves significantly\n        if obj1_improvement < 0 and obj2_improvement < 0:\n            # Insert edge (i,j) between i and j\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n        elif (obj1_improvement < 0 and obj2_improvement < 10) or (obj2_improvement < 0 and obj1_improvement < 10):\n            # Insert edge (i,j) between i and j\n            new_solution = np.concatenate([new_solution[:i+1], new_solution[j:j+1], new_solution[i+1:j], new_solution[j+1:]])\n    else:\n        # Segment reordering operation\n        if n > 3:\n            # Select two random segments and reverse one of them\n            k1, k2 = sorted(random.sample(range(1, n-1), 2))\n            if random.random() < 0.5:\n                # Reverse segment between k1 and k2\n                new_solution[k1:k2+1] = new_solution[k1:k2+1][::-1]\n            else:\n                # Swap segments\n                segment1 = new_solution[k1:k2+1]\n                k3 = random.randint(0, n-1)\n                new_solution = np.concatenate([new_solution[:k3], segment1, new_solution[k3:k1], new_solution[k2+1:]])\n\n    return new_solution\n\n",
          "score": [
               -0.8044547072753083,
               0.5334844589233398
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' begins by evaluating the archive of solutions to identify those with the highest potential for improvement, prioritizing solutions with lower objective values and higher diversity in their tour structures. It then intelligently selects a base solution using a tournament selection mechanism that balances exploration and exploitation, favoring solutions that are not only Pareto-optimal but also exhibit structural diversity. The selected base solution undergoes a novel hybrid local search operator that combines a multi-segment inversion strategy with a guided edge insertion mechanism. This operator first partitions the tour into multiple segments, inverts a randomly selected segment to disrupt the current structure, and then intelligently reinserts edges from the inverted segment back into the tour using a guided approach that minimizes the increase in both objective costs. The operator ensures feasibility by maintaining a valid TSP tour throughout the process, and it employs a dynamic acceptance criterion to accept non-improving solutions with a small probability, preventing premature convergence. The generated neighbor solution is then returned, representing a high-quality candidate for further exploration in the optimization process.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a base solution based on objective values and diversity\n    def select_base(archive):\n        # Rank solutions based on objective values (lower is better)\n        objectives = np.array([obj for _, obj in archive])\n        ranks = np.lexsort((objectives[:, 1], objectives[:, 0]))\n\n        # Select top 10% of solutions for tournament\n        tournament_size = max(1, len(archive) // 10)\n        candidates = [archive[i] for i in ranks[:tournament_size]]\n\n        # Select the solution with the highest diversity (most different from others)\n        def diversity(sol):\n            total_dist = 0\n            for other_sol, _ in candidates:\n                if not np.array_equal(sol, other_sol):\n                    total_dist += np.sum(sol != other_sol)\n            return total_dist\n\n        base_sol, _ = max(candidates, key=lambda x: diversity(x[0]))\n        return base_sol.copy()\n\n    base_solution = select_base(archive)\n\n    # Hybrid local search operator\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Multi-segment inversion\n    if n > 3:\n        # Randomly select a segment to invert\n        start = np.random.randint(0, n - 2)\n        end = np.random.randint(start + 1, n)\n        new_solution[start:end] = new_solution[start:end][::-1]\n\n    # Guided edge insertion\n    def calculate_cost(sol, distance_matrix_1, distance_matrix_2):\n        cost1 = sum(distance_matrix_1[sol[i], sol[(i + 1) % n]] for i in range(n))\n        cost2 = sum(distance_matrix_2[sol[i], sol[(i + 1) % n]] for i in range(n))\n        return cost1, cost2\n\n    current_cost1, current_cost2 = calculate_cost(new_solution, distance_matrix_1, distance_matrix_2)\n\n    for _ in range(10):  # Limit the number of insertion attempts\n        # Randomly select two edges to reconnect\n        i, j = np.random.choice(n, size=2, replace=False)\n        if i > j:\n            i, j = j, i\n\n        # Create a new candidate solution by reconnecting edges\n        candidate = np.concatenate([\n            new_solution[:i+1],\n            new_solution[j+1:],\n            new_solution[i+1:j+1]\n        ])\n\n        # Ensure the candidate is a valid tour\n        if len(np.unique(candidate)) == n:\n            candidate_cost1, candidate_cost2 = calculate_cost(candidate, distance_matrix_1, distance_matrix_2)\n\n            # Accept the candidate if it improves both objectives\n            if (candidate_cost1 <= current_cost1 and candidate_cost2 <= current_cost2) or \\\n               (np.random.rand() < 0.1):  # Small probability to accept non-improving solutions\n                new_solution = candidate\n                current_cost1, current_cost2 = candidate_cost1, candidate_cost2\n\n    return new_solution\n\n",
          "score": [
               -0.9394132083738742,
               1.2528079152107239
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    archive_sorted = sorted(archive, key=lambda x: x[1][0] + x[1][1])\n    selected_idx = min(len(archive_sorted) // 2, len(archive_sorted) - 1)\n    base_solution = archive_sorted[selected_idx][0].copy()\n\n    # Step 2: Apply a hybrid local search operator\n    # Hybrid of 3-opt and path relinking with objective-aware selection\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select 3 segments to modify (3-opt style)\n    a, b, c = sorted(random.sample(range(1, n), 3))\n    segment1 = new_solution[:a]\n    segment2 = new_solution[a:b]\n    segment3 = new_solution[b:c]\n    segment4 = new_solution[c:]\n\n    # Recombine segments in a new order\n    new_order = [segment1, segment3, segment2, segment4]\n    new_solution = np.concatenate(new_order)\n\n    # Path relinking: blend with another solution from archive\n    if len(archive) > 1:\n        other_solution = random.choice([s for s, _ in archive if not np.array_equal(s, base_solution)])\n        # Find common nodes and align segments\n        common_nodes = set(base_solution).intersection(set(other_solution))\n        if common_nodes:\n            # Create a new solution by combining segments from both solutions\n            # This is a simplified version of path relinking\n            new_solution = np.concatenate([base_solution[:len(base_solution)//2], other_solution[len(other_solution)//2:]])\n\n    # Ensure the solution is valid (no duplicates, all nodes present)\n    unique_nodes = np.unique(new_solution)\n    if len(unique_nodes) != n or len(new_solution) != n:\n        # If invalid, revert to base solution with a small random modification\n        new_solution = base_solution.copy()\n        i, j = random.sample(range(n), 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.7122305368764223,
               1.100231647491455
          ]
     },
     {
          "algorithm": "{The new algorithm, named \"Multi-Objective Hybrid Segment Recombination with Adaptive Perturbation,\" intelligently selects a solution from the archive by prioritizing those with high crowding distance in the Pareto front or low dominance counts, then applies a hybrid local search operator that combines a variable-length segment exchange mechanism with adaptive perturbation. This operator selectively recombines non-overlapping segments from the selected solution with segments from other archive solutions, while dynamically adjusting the segment length based on the solution's quality and the diversity of the archive. Additionally, it incorporates a controlled perturbation step that introduces small, localized changes to the tour to escape local optima, with the perturbation intensity proportional to the solution's current objective values and the diversity of the archive. The algorithm ensures feasibility by validating all generated solutions for valid TSP tours and reverting to the original solution if any infeasibility is detected.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty.\")\n\n    # Step 1: Select a promising solution from the archive\n    # Prioritize solutions with high crowding distance or low dominance count\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate crowding distance for each solution\n    crowding_distances = np.zeros(len(archive))\n    for i in range(len(archive)):\n        # Find neighbors in the objective space\n        left = None\n        right = None\n        for j in range(len(archive)):\n            if i == j:\n                continue\n            if (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and not (objectives[j][0] == objectives[i][0] and objectives[j][1] == objectives[i][1]):\n                # Dominated by j\n                if left is None or (objectives[j][0] >= objectives[left][0] and objectives[j][1] >= objectives[left][1]):\n                    left = j\n            elif (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and not (objectives[i][0] == objectives[j][0] and objectives[i][1] == objectives[j][1]):\n                # Dominates j\n                if right is None or (objectives[j][0] <= objectives[right][0] and objectives[j][1] <= objectives[right][1]):\n                    right = j\n        if left is not None and right is not None:\n            crowding_distances[i] = (objectives[right][0] - objectives[left][0]) + (objectives[right][1] - objectives[left][1])\n\n    # Select the solution with the highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Apply hybrid segment recombination with adaptive perturbation\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Determine segment length adaptively\n    segment_length = max(2, int(np.random.uniform(0.1, 0.3) * n))\n\n    # Select two non-overlapping segments\n    a_start = np.random.randint(0, n - segment_length)\n    a_end = a_start + segment_length\n    b_start = np.random.randint(0, n - segment_length)\n    b_end = b_start + segment_length\n\n    # Ensure segments are non-overlapping\n    while not (a_end <= b_start or b_end <= a_start):\n        b_start = np.random.randint(0, n - segment_length)\n        b_end = b_start + segment_length\n\n    # Extract segments\n    segment_a = base_solution[a_start:a_end]\n    segment_b = base_solution[b_start:b_end]\n\n    # Create a new solution by swapping segments\n    new_solution[a_start:a_end] = segment_b\n    new_solution[b_start:b_end] = segment_a\n\n    # Ensure the new solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Revert to base solution if invalid\n        new_solution = base_solution.copy()\n\n    # Step 3: Apply adaptive perturbation\n    perturbation_intensity = 0.1 * (1 - crowding_distances[selected_idx] / np.max(crowding_distances + 1e-6))\n    if np.random.rand() < perturbation_intensity:\n        # Randomly select two positions and swap them\n        i, j = np.random.choice(n, 2, replace=False)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.9221275616184177,
               1.2943867444992065
          ]
     },
     {
          "algorithm": null,
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the most promising solution based on objective values and crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = np.array([obj for _, obj in archive])\n\n    # Normalize objectives for crowding distance calculation\n    if len(objectives) > 1:\n        normalized_obj = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-10)\n        crowding = np.zeros(len(normalized_obj))\n        for i in range(2):\n            sorted_idx = np.argsort(normalized_obj[:, i])\n            crowding[sorted_idx[0]] = np.inf\n            crowding[sorted_idx[-1]] = np.inf\n            for j in range(1, len(normalized_obj) - 1):\n                crowding[sorted_idx[j]] += normalized_obj[sorted_idx[j+1], i] - normalized_obj[sorted_idx[j-1], i]\n        # Select solution with lowest objective sum and high crowding distance\n        scores = objectives.sum(axis=1) - crowding\n        selected_idx = np.argmin(scores)\n    else:\n        selected_idx = 0\n\n    base_solution = solutions[selected_idx].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Adaptive segment inversion with objective-specific edge swaps\n    # Step 1: Identify critical segments\n    segment_length = max(3, n // 10)\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Step 2: Dual-objective segment inversion\n    segment = new_solution[start:end]\n    # Calculate segment cost in both objectives\n    seg_cost1 = sum(distance_matrix_1[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n    seg_cost2 = sum(distance_matrix_2[segment[i], segment[(i+1)%len(segment)]] for i in range(len(segment)))\n\n    # Calculate inverted segment cost\n    inv_segment = segment[::-1]\n    inv_cost1 = sum(distance_matrix_1[inv_segment[i], inv_segment[(i+1)%len(inv_segment)]] for i in range(len(inv_segment)))\n    inv_cost2 = sum(distance_matrix_2[inv_segment[i], inv_segment[(i+1)%len(inv_segment)]] for i in range(len(inv_segment)))\n\n    # Accept inversion if it improves at least one objective\n    if inv_cost1 < seg_cost1 or inv_cost2 < seg_cost2:\n        new_solution[start:end] = inv_segment\n\n    # Step 3: Objective-specific edge swaps\n    # Identify which objective is weaker\n    current_obj1 = sum(distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    current_obj2 = sum(distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] for i in range(n))\n    if current_obj1 < current_obj2:\n        # Improve objective 2\n        for i in range(n):\n            for j in range(i+2, min(i+10, n)):\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                # Calculate change in objective 2\n                delta = (distance_matrix_2[c, a] + distance_matrix_2[b, d]) - (distance_matrix_2[a, b] + distance_matrix_2[c, d])\n                if delta < 0:\n                    # Perform the swap\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                    break\n    else:\n        # Improve objective 1\n        for i in range(n):\n            for j in range(i+2, min(i+10, n)):\n                a, b = new_solution[i], new_solution[(i+1)%n]\n                c, d = new_solution[j], new_solution[(j+1)%n]\n                # Calculate change in objective 1\n                delta = (distance_matrix_1[c, a] + distance_matrix_1[b, d]) - (distance_matrix_1[a, b] + distance_matrix_1[c, d])\n                if delta < 0:\n                    # Perform the swap\n                    new_solution[i+1:j+1] = new_solution[i+1:j+1][::-1]\n                    break\n\n    return new_solution\n\n",
          "score": [
               -0.6366845880707233,
               2.2048791646957397
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    normalized_objectives = []\n    for sol, (obj1, obj2) in archive:\n        normalized_obj1 = obj1 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        normalized_obj2 = obj2 / (obj1 + obj2) if (obj1 + obj2) > 0 else 0\n        normalized_objectives.append((normalized_obj1 + normalized_obj2, sol))\n\n    normalized_objectives.sort(key=lambda x: -x[0])\n    selected_solution = normalized_objectives[0][1].copy()\n\n    # Step 2: Hybrid local search strategy\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective space dominance\n    # Calculate segment dominance in both objective spaces\n    def calculate_segment_dominance(solution, start, end):\n        segment = solution[start:end]\n        cost1 = sum(distance_matrix_1[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost1 += distance_matrix_1[segment[-1], segment[0]] if len(segment) > 1 else 0\n        cost2 = sum(distance_matrix_2[segment[i], segment[i+1]] for i in range(len(segment)-1))\n        cost2 += distance_matrix_2[segment[-1], segment[0]] if len(segment) > 1 else 0\n        return cost1, cost2\n\n    # Find the most dominated segment (where one objective improves significantly)\n    best_improvement = 0\n    best_segment = None\n    for i in range(n):\n        for j in range(i+2, min(i+10, n)):  # Limit segment size for efficiency\n            cost1, cost2 = calculate_segment_dominance(new_solution, i, j)\n            original_cost1 = sum(distance_matrix_1[new_solution[k], new_solution[k+1]] for k in range(i, j-1))\n            original_cost2 = sum(distance_matrix_2[new_solution[k], new_solution[k+1]] for k in range(i, j-1))\n            improvement1 = original_cost1 - cost1\n            improvement2 = original_cost2 - cost2\n\n            # Adaptive selection based on which objective shows more improvement\n            if improvement1 > improvement2 and improvement1 > best_improvement:\n                best_improvement = improvement1\n                best_segment = (i, j)\n            elif improvement2 > improvement1 and improvement2 > best_improvement:\n                best_improvement = improvement2\n                best_segment = (i, j)\n\n    if best_segment:\n        i, j = best_segment\n        # Apply segment reversal with adaptive step size\n        step = random.randint(1, min(3, j-i))  # Adaptive step size\n        new_solution[i:j] = np.roll(new_solution[i:j], step)\n\n    # Step 3: 3-opt refinement for fine-tuning\n    for _ in range(10):  # Limited iterations for efficiency\n        a, b, c = sorted(random.sample(range(n), 3))\n        # Try all possible 3-opt moves\n        candidates = [\n            np.concatenate([new_solution[:a+1], new_solution[b:c+1][::-1], new_solution[a+1:b][::-1], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a+1], new_solution[b:c+1], new_solution[a+1:b][::-1], new_solution[c+1:]]),\n            np.concatenate([new_solution[:a+1], new_solution[b:c+1][::-1], new_solution[a+1:b], new_solution[c+1:]])\n        ]\n        # Evaluate all candidates and select the best\n        best_candidate = new_solution.copy()\n        best_cost = float('inf')\n        for candidate in candidates:\n            cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_1[candidate[-1], candidate[0]]\n            cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n-1)) + distance_matrix_2[candidate[-1], candidate[0]]\n            total_cost = cost1 + cost2\n            if total_cost < best_cost:\n                best_cost = total_cost\n                best_candidate = candidate.copy()\n        new_solution = best_candidate.copy()\n\n    return new_solution\n\n",
          "score": [
               -0.75565824908132,
               6.271875858306885
          ]
     },
     {
          "algorithm": "{The heuristic function 'select_neighbor' employs a multi-objective selection criterion to prioritize solutions with high Pareto dominance (fewer non-dominated solutions in the archive) and low crowding distance (indicating solutions in sparse regions of the Pareto front). It then applies a hybrid local search operator combining a novel 'guided segment reversal' (which reverses a segment of the tour while respecting both objective spaces' constraints) with a probabilistic edge exchange mechanism that selectively swaps edges based on their relative improvement in both objectives. The function ensures feasibility by validating the generated neighbor solution before returning it, guaranteeing a valid TSP tour where each node is visited exactly once.}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Step 1: Select a promising solution from the archive\n    # Select solutions with high Pareto dominance and low crowding distance\n    solutions = [sol for sol, _ in archive]\n    objectives = [obj for _, obj in archive]\n\n    # Calculate Pareto dominance counts\n    dominance_counts = np.zeros(len(archive))\n    for i in range(len(archive)):\n        for j in range(len(archive)):\n            if i != j:\n                if (objectives[i][0] <= objectives[j][0] and objectives[i][1] <= objectives[j][1]) and \\\n                   (objectives[i][0] < objectives[j][0] or objectives[i][1] < objectives[j][1]):\n                    dominance_counts[i] += 1\n\n    # Calculate crowding distances\n    crowding_distances = np.zeros(len(archive))\n    sorted_indices = np.argsort(objectives, axis=0)\n    for m in range(2):  # For each objective\n        sorted_obj = np.array(objectives)[sorted_indices[:, m]]\n        crowding_distances[sorted_indices[0, m]] = np.inf\n        crowding_distances[sorted_indices[-1, m]] = np.inf\n        for i in range(1, len(archive)-1):\n            crowding_distances[sorted_indices[i, m]] += (sorted_obj[i+1, m] - sorted_obj[i-1, m])\n\n    # Normalize and combine selection criteria\n    norm_dominance = (dominance_counts - np.min(dominance_counts)) / (np.max(dominance_counts) - np.min(dominance_counts) + 1e-10)\n    norm_crowding = (crowding_distances - np.min(crowding_distances)) / (np.max(crowding_distances) - np.min(crowding_distances) + 1e-10)\n    scores = norm_dominance + norm_crowding\n\n    selected_idx = np.argmin(scores)  # Lower score is better\n    base_solution = solutions[selected_idx].copy()\n\n    # Step 2: Generate neighbor solution using hybrid local search\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Hybrid local search: Guided segment reversal + probabilistic edge exchange\n    if n > 3:\n        # Guided segment reversal\n        i, j = np.random.randint(0, n, 2)\n        if i > j:\n            i, j = j, i\n        segment = new_solution[i:j+1]\n        reversed_segment = segment[::-1]\n\n        # Evaluate segment reversal in both objectives\n        original_cost = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]] + \\\n                        distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost = distance_matrix_1[new_solution[i-1], reversed_segment[0]] + distance_matrix_1[reversed_segment[-1], new_solution[(j+1)%n]] + \\\n                   distance_matrix_2[new_solution[i-1], reversed_segment[0]] + distance_matrix_2[reversed_segment[-1], new_solution[(j+1)%n]]\n\n        if new_cost < original_cost:\n            new_solution[i:j+1] = reversed_segment\n\n        # Probabilistic edge exchange\n        for _ in range(min(3, n//2)):\n            a, b = np.random.randint(0, n, 2)\n            if a == b:\n                continue\n\n            # Swap edges a->b and a+1->b+1\n            temp = new_solution.copy()\n            temp[a], temp[b] = temp[b], temp[a]\n            temp[(a+1)%n], temp[(b+1)%n] = temp[(b+1)%n], temp[(a+1)%n]\n\n            # Calculate cost difference\n            delta_cost1 = (distance_matrix_1[temp[a-1], temp[a]] + distance_matrix_1[temp[b], temp[(b+1)%n]] +\n                          distance_matrix_1[temp[b-1], temp[b]] + distance_matrix_1[temp[a], temp[(a+1)%n]]) - \\\n                         (distance_matrix_1[new_solution[a-1], new_solution[a]] + distance_matrix_1[new_solution[b], new_solution[(b+1)%n]] +\n                          distance_matrix_1[new_solution[b-1], new_solution[b]] + distance_matrix_1[new_solution[a], new_solution[(a+1)%n]])\n\n            delta_cost2 = (distance_matrix_2[temp[a-1], temp[a]] + distance_matrix_2[temp[b], temp[(b+1)%n]] +\n                          distance_matrix_2[temp[b-1], temp[b]] + distance_matrix_2[temp[a], temp[(a+1)%n]]) - \\\n                         (distance_matrix_2[new_solution[a-1], new_solution[a]] + distance_matrix_2[new_solution[b], new_solution[(b+1)%n]] +\n                          distance_matrix_2[new_solution[b-1], new_solution[b]] + distance_matrix_2[new_solution[a], new_solution[(a+1)%n]])\n\n            # Accept if both objectives improve or with small probability\n            if (delta_cost1 < 0 and delta_cost2 < 0) or (np.random.random() < 0.1):\n                new_solution = temp\n\n    # Ensure the solution is a valid tour\n    if len(np.unique(new_solution)) != n:\n        # Fallback to a simple swap if invalid\n        i, j = np.random.randint(0, n, 2)\n        new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    return new_solution\n\n",
          "score": [
               -0.578910617749113,
               2.7978187203407288
          ]
     },
     {
          "algorithm": "{}",
          "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    non_dominated = []\n    for sol, obj in archive:\n        dominated = False\n        for _, other_obj in archive:\n            if (other_obj[0] <= obj[0] and other_obj[1] < obj[1]) or (other_obj[0] < obj[0] and other_obj[1] <= obj[1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated.append(sol)\n\n    if not non_dominated:\n        non_dominated = [sol for sol, _ in archive]\n\n    # Randomly select a base solution from non-dominated ones\n    base_solution = random.choice(non_dominated).copy()\n    new_solution = base_solution.copy()\n\n    # Determine segment length for perturbation (dynamic based on solution quality)\n    n = len(base_solution)\n    segment_length = min(3, max(1, n // 10))  # Adjust based on problem size\n\n    # Randomly select a segment to remove\n    start_idx = random.randint(0, n - segment_length)\n    segment = new_solution[start_idx:start_idx + segment_length]\n\n    # Remove the segment\n    new_solution = np.concatenate([new_solution[:start_idx], new_solution[start_idx + segment_length:]])\n\n    # Find the best insertion position for the segment\n    best_pos = 0\n    best_cost = float('inf')\n\n    for pos in range(len(new_solution) - segment_length + 1):\n        # Try inserting the segment at this position\n        candidate = np.concatenate([new_solution[:pos], segment, new_solution[pos:]])\n\n        # Calculate total cost for both objectives\n        cost1 = sum(distance_matrix_1[candidate[i], candidate[i+1]] for i in range(n - segment_length))\n        cost2 = sum(distance_matrix_2[candidate[i], candidate[i+1]] for i in range(n - segment_length))\n\n        # Use a weighted sum to balance both objectives\n        total_cost = 0.5 * cost1 + 0.5 * cost2\n\n        if total_cost < best_cost:\n            best_cost = total_cost\n            best_pos = pos\n\n    # Insert the segment at the best found position\n    new_solution = np.concatenate([new_solution[:best_pos], segment, new_solution[best_pos:]])\n\n    return new_solution\n\n",
          "score": [
               -0.7214052028514468,
               9.164614021778107
          ]
     }
]