[
    {
        "algorithm": "The algorithm selects the best solution from the archive (based on the lowest combined objective value) and applies a novel 4-opt-inspired local search by randomly selecting four edges and reconnecting them in a non-standard way to explore higher-quality neighborhoods, ensuring feasibility by reversing segments and maintaining a circular tour. The key design idea is to prioritize the most promising solution while introducing diversity through a creative edge-reconnection strategy.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    i, j, k, l = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[l:j+1][::-1],\n        new_solution[k:l+1][::-1],\n        new_solution[j+1:k+1],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9964296678185147,
            0.10547882318496704
        ]
    },
    {
        "algorithm": "The algorithm selects the best solution from the archive (lowest combined objective) and applies a novel 4-opt-inspired local search by randomly selecting four edges, reversing segments between them, and reconnecting them to explore a larger neighborhood while ensuring feasibility. It prioritizes solutions with lower total cost and dynamically modifies the tour by segment reversal and concatenation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the lowest combined objective value\n    selected_solution = min(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 4-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select four distinct edges to reconnect\n    a, b, c, d = sorted(random.sample(range(n), 4))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:a+1],\n        new_solution[b:c+1][::-1],\n        new_solution[d:],\n        new_solution[a+1:b+1][::-1],\n        new_solution[c+1:d+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9715020941909596,
            0.14212608337402344
        ]
    },
    {
        "algorithm": "The algorithm selects a base solution from the archive based on objective diversity, then applies a hybrid local search combining adaptive segment relocations and node exchanges, ensuring feasibility through circular tour maintenance and evaluating improvements using an objective-weighted acceptance criterion. It prioritizes solutions with diverse objectives and uses probabilistic acceptance to balance improvements across both spaces, while maintaining valid TSP tours through segment manipulation and exchange operations.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solution with highest objective diversity\n    objectives = np.array([obj for _, obj in archive])\n    diversity = np.std(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment relocation\n    segment_size = max(2, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Node exchange with objective-weighted acceptance\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        # Calculate cost changes\n        old_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost1 = (distance_matrix_1[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_1[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_1[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_1[new_solution[i], new_solution[(j+1)%n]])\n\n        old_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(j+1)%n]])\n\n        new_cost2 = (distance_matrix_2[new_solution[i-1], new_solution[j]] +\n                     distance_matrix_2[new_solution[j], new_solution[(i+1)%n]] +\n                     distance_matrix_2[new_solution[j-1], new_solution[i]] +\n                     distance_matrix_2[new_solution[i], new_solution[(j+1)%n]])\n\n        # Objective-weighted improvement criterion\n        delta1 = new_cost1 - old_cost1\n        delta2 = new_cost2 - old_cost2\n        acceptance_prob = 1.0 / (1.0 + np.exp(0.5 * (delta1 + delta2)))\n\n        if np.random.rand() < acceptance_prob:\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9739385286197475,
            0.7466378808021545
        ]
    },
    {
        "algorithm": "The heuristic selects the solution with the highest combined objective value from the archive, then applies a novel 3-opt-inspired local search by randomly selecting three edges and reconnecting them in a way that maintains feasibility while exploring higher-quality neighborhoods. The algorithm prioritizes solutions with worse combined objectives (sum of both costs) to focus on less explored regions, and ensures the generated neighbor remains a valid TSP tour by reversing segments of the path and reconnecting them.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select the solution with the highest combined objective value\n    selected_solution = max(archive, key=lambda x: sum(x[1]))[0].copy()\n\n    # Apply a novel 3-opt-inspired local search\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select three distinct edges to reconnect\n    i, j, k = sorted(random.sample(range(n), 3))\n\n    # Create a new tour by reconnecting the edges in a different order\n    # This ensures feasibility while exploring a new neighborhood\n    new_solution = np.concatenate([\n        new_solution[:i+1],\n        new_solution[j:k+1][::-1],\n        new_solution[k+1:],\n        new_solution[i+1:j+1][::-1]\n    ])\n\n    # Ensure the tour is circular (return to start)\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.8796892138585624,
            0.27913469076156616
        ]
    },
    {
        "algorithm": "This algorithm selects extreme solutions from the archive (prioritizing those with highest combined objective values) and applies a hybrid local search combining dynamic segment rotations and node swaps, focusing on balanced improvements in both objectives while ensuring tour validity through circularity checks. The method uses probabilistic segment rotation and selective node swaps based on objective improvements, with a bias toward solutions that show potential for further optimization.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with extreme objective values\n    objectives = np.array([obj for _, obj in archive])\n    extreme_idx = np.argmax(np.sum(objectives, axis=1))\n    base_solution = archive[extreme_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment rotation\n    segment_size = max(3, int(np.ceil(n * 0.2 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    if np.random.rand() < 0.7:\n        # Rotate segment\n        segment = new_solution[start:end]\n        rotated = np.roll(segment, np.random.randint(1, segment_size))\n        new_solution[start:end] = rotated\n    else:\n        # Swap nodes with probability based on objective improvement\n        for _ in range(5):\n            i, j = np.random.choice(n, 2, replace=False)\n            if i == j:\n                continue\n\n            old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n            new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n            new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n            if (new_cost1 < old_cost1 and new_cost2 < old_cost2) or (new_cost1 <= 0.95 * old_cost1 and new_cost2 <= 0.95 * old_cost2):\n                new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n                break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9648589443513792,
            0.49024927616119385
        ]
    },
    {
        "algorithm": "The algorithm prioritizes nondominated solutions from the archive, dynamically selects segments based on objective diversity, and employs a hybrid local search combining adaptive segment reversals and edge swaps to generate improved neighbor solutions while ensuring feasibility. It focuses on regions of the Pareto front with high improvement potential by evaluating edge swaps in both objective spaces and dynamically adjusting segment sizes. The selection of segments and edges is guided by a diversity metric, and the algorithm maintains a circular tour by ensuring the neighbor solution remains a valid TSP tour.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a solution based on objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective diversity\n    segment_size = max(2, int(np.ceil(n * 0.1 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Hybrid local search: adaptive segment reversal and edge swaps\n    if np.random.rand() < 0.5:\n        # Reverse segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Swap edges\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Edge selection based on objective improvement\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9470726877155471,
            1.2816454768180847
        ]
    },
    {
        "algorithm": "The algorithm selects a nondominated solution from the archive based on objective diversity, then applies a hybrid local search combining segment reversal/swapping with objective-aware edge selection to generate a neighbor solution, ensuring feasibility by maintaining a valid TSP tour structure. The search dynamically adapts segment sizes and prioritizes improvements in both objectives, with a focus on balancing exploration and exploitation through randomness and objective-aware edge swaps.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    nondominated = []\n    for i, (sol_i, obj_i) in enumerate(archive):\n        is_dominated = False\n        for j, (sol_j, obj_j) in enumerate(archive):\n            if i != j and obj_j[0] <= obj_i[0] and obj_j[1] <= obj_i[1] and (obj_j[0] < obj_i[0] or obj_j[1] < obj_i[1]):\n                is_dominated = True\n                break\n        if not is_dominated:\n            nondominated.append((sol_i, obj_i))\n\n    if not nondominated:\n        nondominated = archive\n\n    # Select a solution based on objective diversity\n    objectives = np.array([obj for _, obj in nondominated])\n    diversity = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(diversity)\n    base_solution = nondominated[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on objective diversity\n    segment_size = max(2, int(np.ceil(n * 0.1 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Hybrid local search: adaptive segment reversal and edge selection\n    if np.random.rand() < 0.5:\n        # Reverse segment\n        new_solution[start:end] = new_solution[start:end][::-1]\n    else:\n        # Swap edges\n        a, b = np.random.choice(n, 2, replace=False)\n        new_solution[a], new_solution[b] = new_solution[b], new_solution[a]\n\n    # Objective-aware edge selection\n    for _ in range(5):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2) or (new_cost1 <= old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.944893980285704,
            1.2415058612823486
        ]
    },
    {
        "algorithm": "The algorithm prioritizes solutions with high improvement potential by dynamically selecting segments based on objective diversity, employing a hybrid local search that combines adaptive segment insertions and node relocations, while ensuring feasibility through circular tour maintenance and evaluating improvements in both objective spaces. It selects the base solution from the archive by identifying the one with the highest improvement potential across the objectives, then applies a segment-based or node-based local search to generate a neighbor solution, with edge swaps evaluated for improvements in both objectives. The algorithm ensures the tour remains valid by maintaining circularity and enforcing feasibility constraints.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select solutions with high improvement potential\n    objectives = np.array([obj for _, obj in archive])\n    improvement_potential = np.max(objectives, axis=0) - np.min(objectives, axis=0)\n    selected_idx = np.argmax(improvement_potential)\n    base_solution = archive[selected_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Dynamic segment selection based on improvement potential\n    segment_size = max(2, int(np.ceil(n * 0.15 * (1 + np.random.rand()))))\n    start = np.random.randint(0, n - segment_size + 1)\n    end = start + segment_size\n\n    # Hybrid local search: adaptive segment insertion and node relocation\n    if np.random.rand() < 0.6:\n        # Insert segment at a new position\n        segment = new_solution[start:end]\n        new_solution = np.delete(new_solution, np.arange(start, end))\n        insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n        new_solution = np.insert(new_solution, insert_pos, segment)\n    else:\n        # Relocate nodes between segments\n        a, b = np.random.choice(n, 2, replace=False)\n        node = new_solution[a]\n        new_solution = np.delete(new_solution, a)\n        new_solution = np.insert(new_solution, b, node)\n\n    # Edge selection based on improvement in both objectives\n    for _ in range(7):\n        i, j = np.random.choice(n, 2, replace=False)\n        if i == j:\n            continue\n\n        old_cost1 = distance_matrix_1[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_1[new_solution[j], new_solution[(j+1)%n]]\n        new_cost1 = distance_matrix_1[new_solution[i], new_solution[j]] + distance_matrix_1[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        old_cost2 = distance_matrix_2[new_solution[i], new_solution[(i+1)%n]] + distance_matrix_2[new_solution[j], new_solution[(j+1)%n]]\n        new_cost2 = distance_matrix_2[new_solution[i], new_solution[j]] + distance_matrix_2[new_solution[(i+1)%n], new_solution[(j+1)%n]]\n\n        if (new_cost1 < old_cost1 and new_cost2 <= old_cost2 + 0.1 * old_cost2) or (new_cost1 <= old_cost1 + 0.1 * old_cost1 and new_cost2 < old_cost2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n            break\n\n    # Ensure the tour is circular\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9023205661251933,
            0.8618206977844238
        ]
    },
    {
        "algorithm": "The algorithm selects a promising solution from the archive (prioritizing those with lower combined objective values) and applies a hybrid local search: first reversing a random segment of the tour (like 2-opt) and then rotating the segment to explore a more diverse neighborhood while ensuring feasibility. The selection strategy focuses on high-quality solutions, while the novel local search combines segment reversal and rotation to escape local optima effectively.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select a promising solution (lower combined objective)\n    archive.sort(key=lambda x: sum(x[1]))\n    selected_solution = archive[0][0].copy()\n\n    new_solution = selected_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to modify\n    i, j = sorted(np.random.choice(range(n), 2, replace=False))\n\n    # Segment reversal (similar to 2-opt)\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n\n    # Segment rotation: rotate the segment by a random amount\n    k = np.random.randint(1, j-i+1)\n    segment = new_solution[i:j+1]\n    new_solution[i:j+1] = np.concatenate([segment[k:], segment[:k]])\n\n    # Ensure the solution remains a valid tour\n    if len(np.unique(new_solution)) != n:\n        new_solution = selected_solution.copy()\n\n    return new_solution\n\n",
        "score": [
            -0.7527095184899617,
            0.7415230870246887
        ]
    },
    {
        "algorithm": "The algorithm combines nondominated solution selection with an adaptive segment-based local search, dynamically adjusting segment sizes based on objective diversity to explore high-quality neighborhoods while ensuring feasibility through careful edge reconnection. It prioritizes nondominated solutions but falls back to random selection if none exist, then uses diversity metrics to determine segment size for perturbation, flipping segments with probability based on diversity, and reconnecting edges to maintain tour validity. The overall structure balances exploration of diverse segments with exploitation of nondominated solutions, ensuring feasible tours through systematic edge manipulation.",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    if not archive:\n        raise ValueError(\"Archive is empty\")\n\n    # Select nondominated solutions\n    objectives = np.array([obj for _, obj in archive])\n    nondominated_indices = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and all(objectives[j] <= objectives[i]) and any(objectives[j] < objectives[i]):\n                dominated = True\n                break\n        if not dominated:\n            nondominated_indices.append(i)\n\n    if not nondominated_indices:\n        selected_idx = np.random.choice(len(archive))\n    else:\n        selected_idx = np.random.choice(nondominated_indices)\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on objective diversity\n    diversity = np.std(objectives, axis=0)\n    segment_size = max(2, int(np.ceil(n * 0.1 * (1 + np.random.rand() * (1 + diversity[0] + diversity[1])))))\n\n    # Randomly select a segment and reconnect\n    start = np.random.randint(0, n - segment_size + 1)\n    segment = new_solution[start:start+segment_size]\n\n    # Remove segment and insert at new position with edge reconnection\n    new_solution = np.concatenate([new_solution[:start], new_solution[start+segment_size:]])\n    insert_pos = np.random.randint(0, len(new_solution) - segment_size + 1)\n\n    # Reconnect edges with a novel strategy\n    if insert_pos > 0 and insert_pos < len(new_solution) - segment_size:\n        new_solution = np.concatenate([\n            new_solution[:insert_pos],\n            segment[::-1],\n            new_solution[insert_pos:]\n        ])\n    else:\n        new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Ensure circular tour\n    if new_solution[0] != new_solution[-1]:\n        new_solution = np.append(new_solution, new_solution[0])\n\n    return new_solution\n\n",
        "score": [
            -0.9153954387121037,
            8.404856204986572
        ]
    }
]