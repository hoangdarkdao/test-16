[
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Novel edge-swap: reverse the segment between i and j, then swap two random nodes in the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if j - i > 1:\n        k, l = np.random.choice(range(i, j+1), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection, then applies a novel node insertion and edge reversal strategy to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated_indices = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated_indices.append(i)\n\n    if non_dominated_indices:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel node insertion and edge reversal strategy\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node_to_insert = new_solution[j]\n\n    # Remove node j and insert it between i and i+1\n    new_solution = np.concatenate((new_solution[:j], new_solution[j+1:]))\n    insert_pos = np.random.randint(1, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Reverse a random segment to create diversity\n    k, l = sorted(np.random.choice(n-1, 2, replace=False))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 300,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-inspired selection, then applies a novel segment relocation and edge reversal strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for selection\n        crowding_distance = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distance[sorted_idx[0]] = np.inf\n            crowding_distance[sorted_idx[-1]] = np.inf\n            for i in range(1, len(objectives)-1):\n                crowding_distance[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        selected_idx = np.argmax(crowding_distance)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation and edge reversal strategy\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate((new_solution[:i], new_solution[j+1:]))\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Reverse a random segment to create diversity\n    k, l = sorted(np.random.choice(n-2, 2, replace=False))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.6818144509756099,
            0.49981606006622314
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    if len(objectives) > 1:\n        # Calculate crowding distance for selection\n        crowding_distance = np.zeros(len(objectives))\n        for m in range(2):\n            sorted_idx = np.argsort(objectives[:, m])\n            crowding_distance[sorted_idx[0]] = np.inf\n            crowding_distance[sorted_idx[-1]] = np.inf\n            for i in range(1, len(objectives)-1):\n                crowding_distance[sorted_idx[i]] += (objectives[sorted_idx[i+1], m] - objectives[sorted_idx[i-1], m]) / (objectives[sorted_idx[-1], m] - objectives[sorted_idx[0], m] + 1e-10)\n\n        selected_idx = np.argmax(crowding_distance)\n    else:\n        selected_idx = 0\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment relocation and edge reversal strategy\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Remove the segment and insert it at a random position\n    new_solution = np.concatenate((new_solution[:i], new_solution[j+1:]))\n    insert_pos = np.random.randint(0, len(new_solution)+1)\n    new_solution = np.insert(new_solution, insert_pos, segment)\n\n    # Reverse a random segment to create diversity\n    k, l = sorted(np.random.choice(n-2, 2, replace=False))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have one algorithm with its code as follows. Algorithm description:\n{}\nCode:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Novel edge-swap: reverse the segment between i and j, then swap two random nodes in the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if j - i > 1:\n        k, l = np.random.choice(range(i, j+1), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n\nPlease assist me in creating a new algorithm that has a different form but can be a modified version of the algorithm provided.\n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 301,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse and a node to reinsert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Reverse the segment and reinsert the selected node elsewhere\n    segment = new_solution[i:j+1][::-1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Ensure the solution remains feasible by reinserting the node if needed\n    if k not in new_solution:\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, k)\n        new_solution = new_solution[:n]  # Trim to original length\n\n    # Ensure the solution is valid\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.7322599131800291,
            0.2617053985595703
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select a segment to reverse and a node to reinsert\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    k = np.random.choice(range(n))\n\n    # Reverse the segment and reinsert the selected node elsewhere\n    segment = new_solution[i:j+1][::-1]\n    new_solution = np.concatenate([new_solution[:i], segment, new_solution[j+1:]])\n\n    # Ensure the solution remains feasible by reinserting the node if needed\n    if k not in new_solution:\n        pos = np.random.randint(0, n)\n        new_solution = np.insert(new_solution, pos, k)\n        new_solution = new_solution[:n]  # Trim to original length\n\n    # Ensure the solution is valid\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Novel edge-swap: reverse the segment between i and j, then swap two random nodes in the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if j - i > 1:\n        k, l = np.random.choice(range(i, j+1), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Novel edge-swap: reverse the segment between i and j, then swap two random nodes in the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if j - i > 1:\n        k, l = np.random.choice(range(i, j+1), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones. \n1. First, describe your new algorithm and main steps in one sentence. The description must be inside within boxed {}.\n2. Next, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    base_solution = archive[0][0].copy()\n    new_solution = base_solution.copy()\n    new_solution[0], new_solution[1] = new_solution[1], new_solution[0]\n\n    return new_solution\n\n\nDo not give additional explanations.",
        "sample_order": 302,
        "algorithm": "{}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n    base_solution = archive[np.argmax(scores)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on both objectives\n    segment_length = max(3, min(n // 4, 10))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Novel multi-objective-aware edge swap\n    segment = new_solution[start:end]\n    segment_obj1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    segment_obj2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n    # Reverse the segment if it improves at least one objective\n    reversed_segment = segment[::-1]\n    reversed_obj1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n    reversed_obj2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n    if (reversed_obj1 < segment_obj1) or (reversed_obj2 < segment_obj2):\n        new_solution[start:end] = reversed_segment\n\n    # Additional adaptive swaps based on objective improvement\n    if np.random.random() < 0.3:  # 30% chance of additional swap\n        i, j = np.random.choice(range(start, end), 2, replace=False)\n        swap_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        swap_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        original_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        if (swap_obj1 < original_obj1) or (swap_obj2 < original_obj2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.8655898988695199,
            0.26708120107650757
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    normalized = (objectives - objectives.min(axis=0)) / (objectives.max(axis=0) - objectives.min(axis=0) + 1e-8)\n    scores = normalized[:, 0] * normalized[:, 1]  # Product of normalized objectives\n    base_solution = archive[np.argmax(scores)][0].copy()\n\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Adaptive segment selection based on both objectives\n    segment_length = max(3, min(n // 4, 10))\n    start = np.random.randint(0, n - segment_length)\n    end = start + segment_length\n\n    # Novel multi-objective-aware edge swap\n    segment = new_solution[start:end]\n    segment_obj1 = sum(distance_matrix_1[segment[i-1], segment[i]] for i in range(len(segment)))\n    segment_obj2 = sum(distance_matrix_2[segment[i-1], segment[i]] for i in range(len(segment)))\n\n    # Reverse the segment if it improves at least one objective\n    reversed_segment = segment[::-1]\n    reversed_obj1 = sum(distance_matrix_1[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n    reversed_obj2 = sum(distance_matrix_2[reversed_segment[i-1], reversed_segment[i]] for i in range(len(reversed_segment)))\n\n    if (reversed_obj1 < segment_obj1) or (reversed_obj2 < segment_obj2):\n        new_solution[start:end] = reversed_segment\n\n    # Additional adaptive swaps based on objective improvement\n    if np.random.random() < 0.3:  # 30% chance of additional swap\n        i, j = np.random.choice(range(start, end), 2, replace=False)\n        swap_obj1 = distance_matrix_1[new_solution[i-1], new_solution[j]] + distance_matrix_1[new_solution[j], new_solution[(i+1)%n]]\n        swap_obj2 = distance_matrix_2[new_solution[i-1], new_solution[j]] + distance_matrix_2[new_solution[j], new_solution[(i+1)%n]]\n        original_obj1 = distance_matrix_1[new_solution[i-1], new_solution[i]] + distance_matrix_1[new_solution[i], new_solution[(i+1)%n]]\n        original_obj2 = distance_matrix_2[new_solution[i-1], new_solution[i]] + distance_matrix_2[new_solution[i], new_solution[(i+1)%n]]\n\n        if (swap_obj1 < original_obj1) or (swap_obj2 < original_obj2):\n            new_solution[i], new_solution[j] = new_solution[j], new_solution[i]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    },
    {
        "prompt": "You are solving a Bi-objective Travelling Salesman Problem (bi-TSP), where each node has two different 2D coordinates: (x1, y1) and (x2, y2), representing its position in two objective spaces. The goal is to find a tour visiting each node exactly once and returning to the starting node, while minimizing two objectives simultaneously: the total tour length in each coordinate space. Given an archive of solutions, where each solution is a numpy array representing a TSP tour, and its corresponding objective is a tuple of two values (cost in each space), design a heuristic function named 'select_neighbor' that selects one solution from the archive and apply a novel or hybrid local search operator to generate a neighbor solution from it.  Must always ensure that the generated neighbor solution remains feasible, i.e., the solution must represent a valid TSP tour: it visits each node exactly once, ensuring no node is skipped or revisited.Please perform an intelligent random selection from among the solutions that show promising potential for further local improvement. Using a creative local search strategy that you design yourself, avoid 2-opt, go beyond standard approaches to design a method that yields higher-quality solutions across multiple objectives. The function should return the new neighbor solution.\nI have 2 existing algorithms with their codes as follows:\nNo. 1 algorithm and the corresponding code are:\n{This new algorithm selects a solution from the archive based on a Pareto-dominance-inspired selection, then applies a novel node insertion and edge reversal strategy to generate a neighbor solution while ensuring feasibility.}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    objectives = np.array([obj for _, obj in archive])\n    non_dominated_indices = []\n    for i in range(len(objectives)):\n        dominated = False\n        for j in range(len(objectives)):\n            if i != j and (objectives[j][0] <= objectives[i][0] and objectives[j][1] <= objectives[i][1]) and (objectives[j][0] < objectives[i][0] or objectives[j][1] < objectives[i][1]):\n                dominated = True\n                break\n        if not dominated:\n            non_dominated_indices.append(i)\n\n    if non_dominated_indices:\n        selected_idx = np.random.choice(non_dominated_indices)\n    else:\n        selected_idx = np.random.choice(len(archive))\n\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel node insertion and edge reversal strategy\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    node_to_insert = new_solution[j]\n\n    # Remove node j and insert it between i and i+1\n    new_solution = np.concatenate((new_solution[:j], new_solution[j+1:]))\n    insert_pos = np.random.randint(1, len(new_solution))\n    new_solution = np.insert(new_solution, insert_pos, node_to_insert)\n\n    # Reverse a random segment to create diversity\n    k, l = sorted(np.random.choice(n-1, 2, replace=False))\n    new_solution[k:l+1] = new_solution[k:l+1][::-1]\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\nNo. 2 algorithm and the corresponding code are:\n{}\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    best_idx = np.argmin([obj[0] + obj[1] for _, obj in archive])\n    base_solution = archive[best_idx][0].copy()\n\n    # Hybrid local search: combine 2-opt with a novel edge-swap strategy\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Randomly select two edges to break\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n\n    # Novel edge-swap: reverse the segment between i and j, then swap two random nodes in the segment\n    new_solution[i:j+1] = new_solution[i:j+1][::-1]\n    if j - i > 1:\n        k, l = np.random.choice(range(i, j+1), 2, replace=False)\n        new_solution[k], new_solution[l] = new_solution[l], new_solution[k]\n\n    # Ensure the solution remains feasible (no duplicates or missing nodes)\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n\nPlease help me create a new algorithm that has a totally different form from the given ones but can be motivated from them.\n1. Firstly, identify the common backbone idea in the provided algorithms. \n2. Secondly, based on the backbone idea describe your new algorithm in one sentence. The description must be inside within boxed {}.\n3. Thirdly, implement the following Python function:\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n\n\nDo not give additional explanations.",
        "sample_order": 303,
        "algorithm": "{This new algorithm selects a solution from the archive based on a crowding-distance-inspired selection, then applies a novel segment rotation and node swapping strategy to generate a neighbor solution while ensuring feasibility.}",
        "function": "def select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n\n    # Calculate crowding distances\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        if len(sorted_indices) > 2:\n            for i in range(1, len(sorted_indices)-1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment rotation and node swapping strategy\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Rotate segment by random amount\n    rotation = np.random.randint(1, len(segment))\n    segment = np.roll(segment, rotation)\n\n    # Swap two random nodes in the rotated segment\n    if len(segment) > 1:\n        k, l = np.random.choice(len(segment), 2, replace=False)\n        segment[k], segment[l] = segment[l], segment[k]\n\n    new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n",
        "score": [
            -0.639318733582005,
            0.4482552409172058
        ],
        "program": "\nimport numpy as np\nfrom typing import List, Tuple\nimport random \n\ndef select_neighbor(archive: List[Tuple[np.ndarray, Tuple[float, float]]], instance: np.ndarray, distance_matrix_1: np.ndarray, distance_matrix_2: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Select a promising solution from the archive and generate a neighbor solution from it.\n\n    Args:\n    archive: List of (solution, objective) pairs. Each solution is a numpy array of node IDs.\n             Each objective is a tuple of two float values (cost in each space).\n    instance: Numpy array of shape (N, 4). Each row corresponds to a node and contains its coordinates in two 2D spaces: (x1, y1, x2, y2).\n    distance_matrix_1: Distance matrix in the first objective space.\n    distance_matrix_2: Distance matrix in the second objective space.\n\n    Returns:\n    A new neighbor solution (numpy array).\n    \"\"\"\n    objectives = np.array([obj for _, obj in archive])\n    crowding_distances = np.zeros(len(objectives))\n\n    # Calculate crowding distances\n    for m in range(2):  # For each objective\n        sorted_indices = np.argsort(objectives[:, m])\n        crowding_distances[sorted_indices[0]] = np.inf\n        crowding_distances[sorted_indices[-1]] = np.inf\n        if len(sorted_indices) > 2:\n            for i in range(1, len(sorted_indices)-1):\n                crowding_distances[sorted_indices[i]] += (objectives[sorted_indices[i+1], m] - objectives[sorted_indices[i-1], m]) / (objectives[sorted_indices[-1], m] - objectives[sorted_indices[0], m])\n\n    # Select solution with highest crowding distance\n    selected_idx = np.argmax(crowding_distances)\n    base_solution = archive[selected_idx][0].copy()\n    new_solution = base_solution.copy()\n    n = len(new_solution)\n\n    # Novel segment rotation and node swapping strategy\n    i, j = sorted(np.random.choice(n, 2, replace=False))\n    segment = new_solution[i:j+1]\n\n    # Rotate segment by random amount\n    rotation = np.random.randint(1, len(segment))\n    segment = np.roll(segment, rotation)\n\n    # Swap two random nodes in the rotated segment\n    if len(segment) > 1:\n        k, l = np.random.choice(len(segment), 2, replace=False)\n        segment[k], segment[l] = segment[l], segment[k]\n\n    new_solution[i:j+1] = segment\n\n    # Ensure feasibility\n    assert len(np.unique(new_solution)) == n, \"Invalid tour generated\"\n\n    return new_solution\n\n"
    }
]